var I2 = Object.defineProperty;
var fA = (e) => {
  throw TypeError(e);
};
var S2 = (e, n, s) => n in e ? I2(e, n, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[n] = s;
var je = (e, n, s) => S2(e, typeof n != "symbol" ? n + "" : n, s), pA = (e, n, s) => n.has(e) || fA("Cannot " + s);
var Ot = (e, n, s) => (pA(e, n, "read from private field"), s ? s.call(e) : n.get(e)), yo = (e, n, s) => n.has(e) ? fA("Cannot add the same private member more than once") : n instanceof WeakSet ? n.add(e) : n.set(e, s), ll = (e, n, s, i) => (pA(e, n, "write to private field"), i ? i.call(e, s) : n.set(e, s), s);
var y2 = Object.defineProperty, C2 = (e, n, s) => n in e ? y2(e, n, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[n] = s, Mt = (e, n, s) => C2(e, typeof n != "symbol" ? n + "" : n, s);
function N2(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var y1 = { exports: {} };
(function(e) {
  var n = Object.prototype.hasOwnProperty, s = "~";
  function i() {
  }
  Object.create && (i.prototype = /* @__PURE__ */ Object.create(null), new i().__proto__ || (s = !1));
  function r(l, h, d) {
    this.fn = l, this.context = h, this.once = d || !1;
  }
  function o(l, h, d, p, E) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var g = new r(d, p || l, E), T = s ? s + h : h;
    return l._events[T] ? l._events[T].fn ? l._events[T] = [l._events[T], g] : l._events[T].push(g) : (l._events[T] = g, l._eventsCount++), l;
  }
  function a(l, h) {
    --l._eventsCount === 0 ? l._events = new i() : delete l._events[h];
  }
  function c() {
    this._events = new i(), this._eventsCount = 0;
  }
  c.prototype.eventNames = function() {
    var l = [], h, d;
    if (this._eventsCount === 0) return l;
    for (d in h = this._events)
      n.call(h, d) && l.push(s ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(h)) : l;
  }, c.prototype.listeners = function(l) {
    var h = s ? s + l : l, d = this._events[h];
    if (!d) return [];
    if (d.fn) return [d.fn];
    for (var p = 0, E = d.length, g = new Array(E); p < E; p++)
      g[p] = d[p].fn;
    return g;
  }, c.prototype.listenerCount = function(l) {
    var h = s ? s + l : l, d = this._events[h];
    return d ? d.fn ? 1 : d.length : 0;
  }, c.prototype.emit = function(l, h, d, p, E, g) {
    var T = s ? s + l : l;
    if (!this._events[T]) return !1;
    var A = this._events[T], m = arguments.length, O, S;
    if (A.fn) {
      switch (A.once && this.removeListener(l, A.fn, void 0, !0), m) {
        case 1:
          return A.fn.call(A.context), !0;
        case 2:
          return A.fn.call(A.context, h), !0;
        case 3:
          return A.fn.call(A.context, h, d), !0;
        case 4:
          return A.fn.call(A.context, h, d, p), !0;
        case 5:
          return A.fn.call(A.context, h, d, p, E), !0;
        case 6:
          return A.fn.call(A.context, h, d, p, E, g), !0;
      }
      for (S = 1, O = new Array(m - 1); S < m; S++)
        O[S - 1] = arguments[S];
      A.fn.apply(A.context, O);
    } else {
      var y = A.length, v;
      for (S = 0; S < y; S++)
        switch (A[S].once && this.removeListener(l, A[S].fn, void 0, !0), m) {
          case 1:
            A[S].fn.call(A[S].context);
            break;
          case 2:
            A[S].fn.call(A[S].context, h);
            break;
          case 3:
            A[S].fn.call(A[S].context, h, d);
            break;
          case 4:
            A[S].fn.call(A[S].context, h, d, p);
            break;
          default:
            if (!O) for (v = 1, O = new Array(m - 1); v < m; v++)
              O[v - 1] = arguments[v];
            A[S].fn.apply(A[S].context, O);
        }
    }
    return !0;
  }, c.prototype.on = function(l, h, d) {
    return o(this, l, h, d, !1);
  }, c.prototype.once = function(l, h, d) {
    return o(this, l, h, d, !0);
  }, c.prototype.removeListener = function(l, h, d, p) {
    var E = s ? s + l : l;
    if (!this._events[E]) return this;
    if (!h)
      return a(this, E), this;
    var g = this._events[E];
    if (g.fn)
      g.fn === h && (!p || g.once) && (!d || g.context === d) && a(this, E);
    else {
      for (var T = 0, A = [], m = g.length; T < m; T++)
        (g[T].fn !== h || p && !g[T].once || d && g[T].context !== d) && A.push(g[T]);
      A.length ? this._events[E] = A.length === 1 ? A[0] : A : a(this, E);
    }
    return this;
  }, c.prototype.removeAllListeners = function(l) {
    var h;
    return l ? (h = s ? s + l : l, this._events[h] && a(this, h)) : (this._events = new i(), this._eventsCount = 0), this;
  }, c.prototype.off = c.prototype.removeListener, c.prototype.addListener = c.prototype.on, c.prefixed = s, c.EventEmitter = c, e.exports = c;
})(y1);
var x2 = y1.exports;
class h7 extends x2.EventEmitter {
  constructor() {
    super(), Mt(this, "timeOrigin"), Mt(this, "elapsedTime"), Mt(this, "state"), Mt(this, "_rafId"), this.timeOrigin = performance.now(), this.elapsedTime = 0, this._rafId = 0, this.state = "idle";
  }
  start() {
    (this.state === "idle" || this.state === "paused") && (this.state = "running", this.timeOrigin = performance.now(), this.tick());
  }
  seek(n) {
    this.pause(), this.elapsedTime = n, this.emitTick();
  }
  pause() {
    this.state === "running" && (this.state = "paused", window.cancelAnimationFrame(this._rafId));
  }
  reset() {
    this.elapsedTime = 0, this.timeOrigin = performance.now(), this.state = "idle";
  }
  tick() {
    this._rafId = window.requestAnimationFrame(() => {
      this.elapsedTime = performance.now() - this.timeOrigin, this.emitTick(), this.tick();
    });
  }
  emitTick() {
    this.emit("tick", this.elapsedTime);
  }
}
var v2 = 4, R2 = 1e-3, w2 = 1e-7, D2 = 10, wl = 11, Ou = 1 / (wl - 1), L2 = typeof Float32Array == "function";
function C1(e, n) {
  return 1 - 3 * n + 3 * e;
}
function N1(e, n) {
  return 3 * n - 6 * e;
}
function x1(e) {
  return 3 * e;
}
function ld(e, n, s) {
  return ((C1(n, s) * e + N1(n, s)) * e + x1(n)) * e;
}
function v1(e, n, s) {
  return 3 * C1(n, s) * e * e + 2 * N1(n, s) * e + x1(n);
}
function M2(e, n, s, i, r) {
  var o, a, c = 0;
  do
    a = n + (s - n) / 2, o = ld(a, i, r) - e, o > 0 ? s = a : n = a;
  while (Math.abs(o) > w2 && ++c < D2);
  return a;
}
function P2(e, n, s, i) {
  for (var r = 0; r < v2; ++r) {
    var o = v1(n, s, i);
    if (o === 0)
      return n;
    var a = ld(n, s, i) - e;
    n -= a / o;
  }
  return n;
}
function b2(e) {
  return e;
}
var U2 = function(e, n, s, i) {
  if (!(0 <= e && e <= 1 && 0 <= s && s <= 1))
    throw new Error("bezier x values must be in [0, 1] range");
  if (e === n && s === i)
    return b2;
  for (var r = L2 ? new Float32Array(wl) : new Array(wl), o = 0; o < wl; ++o)
    r[o] = ld(o * Ou, e, s);
  function a(c) {
    for (var l = 0, h = 1, d = wl - 1; h !== d && r[h] <= c; ++h)
      l += Ou;
    --h;
    var p = (c - r[h]) / (r[h + 1] - r[h]), E = l + p * Ou, g = v1(E, e, s);
    return g >= R2 ? P2(c, E, e, s) : g === 0 ? E : M2(c, l, l + Ou, e, s);
  }
  return function(c) {
    return c === 0 ? 0 : c === 1 ? 1 : ld(a(c), n, i);
  };
};
const G2 = /* @__PURE__ */ N2(U2), F2 = [0, 0, 1, 1], EA = (e, n) => {
  if (n <= e[0].time)
    return {
      startFrame: e[0],
      endFrame: e[0],
      progress: 0
    };
  if (n >= e[e.length - 1].time) {
    const a = e[e.length - 1];
    return {
      startFrame: a,
      endFrame: a,
      progress: 1
    };
  }
  const s = e.findIndex((a, c) => {
    const l = e[c + 1];
    return l ? n >= a.time && n <= l.time : !1;
  }), i = e[s], r = e[s + 1], o = (n - i.time) / (r.time - i.time);
  return { startFrame: i, endFrame: r, progress: o };
}, k2 = (e, n, s) => {
  switch (n) {
    case 0:
      return Math.min(1, Math.ceil(s * e) / e);
    case 1:
      return Math.min(1, Math.floor(s * e) / e);
    case 2: {
      if (s <= 0)
        return 0;
      if (s >= 1)
        return 1;
      const i = Math.floor(s * e), r = s * e - i;
      return Math.min(
        1,
        (r >= 0.5 ? i + 1 : i) / e
      );
    }
  }
}, B2 = (e, n) => {
  switch (e.length) {
    case 2:
      return k2(...e, n);
    case 4:
      return G2(...e)(n);
  }
};
class V2 {
  constructor(n, s, i, r, o) {
    Mt(this, "sortedKeyframes"), Mt(this, "duration"), this.interpolator = s, this.middlewares = i, this.registry = r, this.sortedKeyframes = n, this.duration = o === void 0 ? n[n.length - 1].time : o;
  }
  interpolate(n) {
    const s = Math.max(0, Math.min(1, n)) * this.duration, {
      startFrame: i,
      endFrame: r,
      progress: o
    } = EA(this.sortedKeyframes, s), a = r.easing ? B2(r.easing, o) : o, c = {
      keyframes: this.sortedKeyframes,
      rawProgress: o,
      easedProgress: a,
      startFrame: i,
      endFrame: r,
      value: this.interpolator(
        a,
        i.value,
        r.value,
        r.easing || F2,
        this.registry
      )
    };
    return this.middlewares.reduce(
      (l, h) => h(l),
      c
    ).value;
  }
  /**
   * TODO: check if it is the right place to do this
   *
   * Insert a keyframe into the sorted keyframes array.
   * If the keyframe with that time already exists, the value will be replaced by the new value.
   *
   * @param {Keyframe<T>} kf - The keyframe to insert.
   * @returns {ComposedInterpolator<T>} The composed interpolator.
   */
  insertKF(n) {
    const s = this.sortedKeyframes.findIndex((o) => o.time === n.time);
    if (s !== -1)
      return this.sortedKeyframes[s].value = n.value, this;
    const { progress: i } = EA(this.sortedKeyframes, n.time), r = this.sortedKeyframes.findIndex((o) => o.time > n.time);
    if (r !== 0 && r !== -1) {
      const o = this.sortedKeyframes[r];
      if (o.easing)
        if (o.easing.length === 4) {
          const a = o.easing, c = i, l = 0, h = 0, d = a[0], p = a[1], E = a[2], g = a[3], T = 1, A = 1, m = 1 - c, O = m * l + c * d, S = m * h + c * p, y = m * d + c * E, v = m * p + c * g, R = m * E + c * T, M = m * g + c * A, L = m * O + c * y, P = m * S + c * v, k = m * y + c * R, Q = m * v + c * M, b = m * L + c * k, X = m * P + c * Q, K = [l, h, O, S, L, P, b, X], V = [b, X, k, Q, R, M, T, A], J = K[6] - K[0], ge = K[7] - K[1], ne = [
            K[2] / J,
            K[3] / ge,
            K[4] / J,
            K[5] / ge
          ], ue = V[6] - V[0], te = V[7] - V[1], ie = [
            (V[2] - V[0]) / ue,
            (V[3] - V[1]) / te,
            (V[4] - V[0]) / ue,
            (V[5] - V[1]) / te
          ];
          n.easing = ne, o.easing = ie;
        } else o.easing.length;
    }
    return r === -1 ? this.sortedKeyframes.push(n) : this.sortedKeyframes.splice(r, 0, n), this;
  }
}
class H2 {
  constructor({ registry: n, middlewares: s = [] }) {
    Mt(this, "middlewares", []), Mt(this, "registry"), this.registry = n, this.middlewares = s;
  }
  compose(n, s, i) {
    if (s.length === 0)
      throw new Error("At least one keyframe is required");
    const r = this.registry.get(n), o = [...s].sort((a, c) => a.time - c.time);
    if (o[0].time < 0)
      throw new Error("First keyframe time must be greater than 0");
    return new V2(
      o,
      r.interpolate,
      this.middlewares,
      this.registry,
      i
    );
  }
}
const R1 = (e) => e;
class W2 {
  constructor() {
    Mt(this, "interpolators", /* @__PURE__ */ new Map());
    const n = R1({
      name: "number",
      interpolate: this.lerp
    });
    this.register(n);
  }
  register(n) {
    this.interpolators.set(n.name, n);
  }
  lerp(n, s, i) {
    return s + (i - s) * n;
  }
  interpolate(n, s, i, r, o) {
    return this.get(n).interpolate(s, r, o, i, this);
  }
  get(n) {
    const s = this.interpolators.get(n);
    if (!s)
      throw new Error(`Interpolator '${n}' not found`);
    return s;
  }
  has(n) {
    return this.interpolators.has(n);
  }
}
class Y2 {
  constructor(n, s) {
    Mt(this, "animationId"), Mt(this, "trackData"), Mt(this, "state"), Mt(this, "playbackRate"), Mt(this, "currentTime"), Mt(this, "startTime"), Mt(this, "_baseTime"), Mt(this, "createdAt"), this.animationId = n, this.trackData = s, this.state = Ms.IDLE, this.playbackRate = 1, this.currentTime = 0, this.startTime = 0, this._baseTime = 0, this.createdAt = performance.now();
  }
  getPropTrack(n) {
    const s = this.trackData.tracks.get(n);
    if (!s)
      throw new Error(`Property track not found for key: ${n}`);
    return JSON.parse(JSON.stringify(s));
  }
  /**
   * Forward playback
   * Will play forward from the current provided time
   */
  forward() {
    this._baseTime = this.currentTime, this.state = Ms.RUNNING, this.playbackRate = Math.abs(this.playbackRate), this.startTime = performance.now();
  }
  pause() {
    this.state = Ms.PAUSED;
  }
  /**
   * Backward playback
   * Will play backward from the current provided time
   *
   * If the current time is 0 at the time of calling this method, it will
   * conviniently seek to the end of the animation and play backward
   */
  backward() {
    this.currentTime === 0 && this.seekToEnd(), this._baseTime = this.currentTime, this.state = Ms.RUNNING, this.playbackRate = -Math.abs(this.playbackRate), this.startTime = performance.now();
  }
  // leave() {
  //   // console.log('leave', this.animationId)
  //   this._baseTime = this.currentTime
  //   this.state = AnimationState.LEAVING
  //   this.playbackRate = 1
  //   this.startTime = performance.now()
  // }
  // occupy() {
  //   this.state = AnimationState.OCCUPIED
  // }
  /**
   * Seek to a specific time in the animation
   * @param {number} time - The time to seek to, 0 <= time <= duration
   */
  seek(n) {
    this.currentTime = Math.max(0, Math.min(this.trackData.duration, n));
  }
  /**
   * Seek to the end of the animation
   */
  seekToEnd() {
    this.currentTime = this.trackData.duration;
  }
  isForward() {
    return this.state === Ms.RUNNING && this.playbackRate > 0;
  }
  isBackward() {
    return this.state === Ms.RUNNING && this.playbackRate < 0;
  }
  isPaused() {
    return this.state === Ms.PAUSED;
  }
  // isLeaving() {
  //   return this.state === AnimationState.LEAVING
  // }
  isEnded() {
    return this.state === Ms.PAUSED && this.currentTime === 0;
  }
  isCompleted() {
    return this.state === Ms.PAUSED && this.currentTime === this.trackData.duration;
  }
  // /**
  //  * experimenting
  //  * @returns {boolean}
  //  */
  // isOccupied() {
  //   return this.state === AnimationState.OCCUPIED
  // }
  /**
   * Based on current situation (state, currentTime, playbackRate, startTime) to
   * estimate new state and time with a global time
   * @param {number} globalTime
   * @returns {{ state: string, time: number }}
   */
  getStatus(n) {
    const s = n - this.startTime;
    if (this.isForward()) {
      const i = this._baseTime + s;
      return i >= this.trackData.duration ? {
        state: Ms.PAUSED,
        time: this.trackData.duration
      } : { state: Ms.RUNNING, time: i };
    } else if (this.isBackward()) {
      const i = this._baseTime - s;
      return i <= 0 ? { state: Ms.PAUSED, time: 0 } : { state: Ms.RUNNING, time: i };
    } else {
      const i = this._baseTime + s;
      return {
        state: this.state,
        time: Math.max(0, Math.min(this.trackData.duration, i))
      };
    }
  }
}
class X2 {
  constructor(n, s) {
    Mt(this, "AC"), Mt(this, "key"), Mt(this, "animations"), Mt(this, "interpolator"), this.AC = n, this.key = s, this.animations = [], this.interpolator = null;
  }
  addAnimation(n, s) {
    this.animations.some(
      (i) => i.animationId === s.animationId
    ) || this.animations.push(s), this.sortAnimations(), this.interpolator = this.resolve(n, this.animations.length > 1);
  }
  deleteAnimation(n, s) {
    const i = this.animations.indexOf(s);
    i !== -1 && this.animations.splice(i, 1), this.animations.length !== 0 && (this.interpolator = this.resolve(n, !0));
  }
  animationStateUpdated(n) {
    this.interpolator = this.resolve(n, this.animations.length > 1);
  }
  /**
   * Sort animations by priority and startTime
   */
  sortAnimations() {
    this.animations.sort((n, s) => s.createdAt - n.createdAt);
  }
  isPaused() {
    return this.getHighestAnimation().isPaused();
  }
  /**
   * There is an implicit assumption that propertyEffect will always
   * have same progress with the highest priority animation
   *
   * @returns {number}
   */
  getProgress() {
    const n = this.animations[0];
    return n.currentTime / n.trackData.duration;
  }
  getHighestAnimation() {
    return this.animations[0];
  }
  resolve(n, s = !1) {
    return this._resolve(
      n,
      s
    );
  }
  /**
   * Based on current active animations of this property, resolve the interpolator
   * Will always use highest priority animation as the base animation and
   * insert extra keyframes like:
   * - base value at 0
   * - computed value at currentTime
   * to make the interpolator smooth and continuous
   *
   * @param {number} currentTime
   * @param {boolean} needInsertCurrentComputedData
   * @returns {ComposedInterpolator<Value>}
   */
  _resolve(n, s = !1) {
    if (this.animations.length === 0)
      throw new Error(`No animations found for this PropEffect: ${this.key}`);
    const i = this.animations[0], { duration: r } = i.trackData, o = i.getPropTrack(this.key), { type: a, kfs: c } = o, l = c.some((E) => E.time === 0), h = c.some((E) => E.time === i.currentTime), d = this.AC.getBaseValue(this.key), p = this.AC.getComputedData(this.key);
    if (this.animations.length === 1) {
      const E = l ? c : [{ time: 0, value: d }, ...c], g = this.AC.keyframeComposer.compose(
        a,
        E,
        r
      );
      return s && !h && g.insertKF({
        time: i.currentTime,
        value: p
      }), g;
    }
    if (this.animations.length > 1) {
      if (i.isForward()) {
        const E = l ? c : [{ time: 0, value: d }, ...c], g = this.AC.keyframeComposer.compose(
          a,
          E,
          r
        );
        return h || g.insertKF({
          time: i.currentTime,
          value: p
        }), g;
      } else if (i.isBackward()) {
        const E = n + i.currentTime, g = GE(
          this.AC,
          E,
          this.key,
          this.animations,
          1
        ), T = l ? c : [{ time: 0, value: g }, ...c], A = this.AC.keyframeComposer.compose(
          a,
          T,
          r
        );
        return h || A.insertKF({
          time: i.currentTime,
          value: p
        }), A;
      } else if (i.isPaused()) {
        const E = l ? c : [{ time: 0, value: d }, ...c], g = this.AC.keyframeComposer.compose(
          a,
          E,
          r
        );
        return h || g.insertKF({
          time: i.currentTime,
          value: p
        }), g;
      }
    }
    throw new Error("unsupported state");
  }
}
const GE = (e, n, s, i, r) => {
  const o = e.getBaseValue(s);
  if (r >= i.length)
    return o;
  const a = i[r], { duration: c } = a.trackData, { time: l, state: h } = a.getStatus(n), d = a.getPropTrack(s), { type: p, kfs: E } = d, g = E.some((T) => T.time === 0);
  if (a.isForward())
    return e.keyframeComposer.compose(
      p,
      g ? E : [{ time: 0, value: o }, ...E],
      c
    ).interpolate(l / c);
  if (a.isBackward()) {
    if (l === 0 && h === Ms.PAUSED)
      return GE(e, n, s, i, r + 1);
    {
      const T = n + l, A = GE(
        e,
        T,
        s,
        i,
        r + 1
      );
      return e.keyframeComposer.compose(
        p,
        g ? E : [{ time: 0, value: A }, ...E],
        c
      ).interpolate(l / c);
    }
  } else {
    if (a.isPaused())
      return e.keyframeComposer.compose(
        p,
        g ? E : [{ time: 0, value: o }, ...E],
        c
      ).interpolate(l / c);
    throw new Error("unsupported state");
  }
}, Ms = {
  IDLE: "idle",
  // not started
  RUNNING: "running",
  // playing (forward or backward based on playbackRate)
  PAUSED: "paused"
};
class z2 {
  // FIXME: use plugin pattern
  // _debugger: TimelineDebugger<PropTrackKey, Value> | null = null
  constructor(n) {
    Mt(this, "baseValueCache"), Mt(this, "computedValueCache"), Mt(this, "sourceAnimationTracks"), Mt(this, "animations"), Mt(this, "propertyEffects"), Mt(this, "isPlaying"), Mt(this, "startTime"), Mt(this, "previousTime"), Mt(this, "currentTime"), Mt(this, "_rafId", null), Mt(this, "keyframeComposer"), this.sourceAnimationTracks = /* @__PURE__ */ new Map(), this.animations = /* @__PURE__ */ new Map(), this.propertyEffects = /* @__PURE__ */ new Map(), this.isPlaying = !1, this.startTime = 0, this.previousTime = 0, this.currentTime = 0, this.baseValueCache = /* @__PURE__ */ new Map(), this.computedValueCache = /* @__PURE__ */ new Map(), this.keyframeComposer = new H2({ registry: n });
  }
  deinit() {
    this.pause(), this.sourceAnimationTracks.clear(), this.animations.clear(), this.propertyEffects.clear(), this.baseValueCache.clear(), this.computedValueCache.clear();
  }
  setComputedData(n, s) {
    if (s === void 0) {
      console.warn(`Trying to set undefined value for key: ${n}`);
      return;
    }
    this.computedValueCache.set(n, s);
  }
  deleteComputedData(n) {
    this.computedValueCache.delete(n);
  }
  cacheBaseValue(n, s) {
    this.baseValueCache.set(n, s);
  }
  getPropertyEffect(n) {
    return this.propertyEffects.get(n) || (console.warn(`Property effect not found: ${n}`), null);
  }
  tick() {
    if (!this.isPlaying)
      return null;
    this.previousTime = this.currentTime, this.currentTime = performance.now();
    const n = /* @__PURE__ */ new Map();
    for (const [s, i] of this.animations) {
      if (i.isEnded() && this.deleteAnimation(s), i.isPaused())
        continue;
      const { time: r, state: o } = i.getStatus(this.currentTime);
      i.seek(r), n.set(s, o);
    }
    for (const [, s] of this.propertyEffects)
      if (s.interpolator) {
        const i = s.getProgress();
        if (!s.isPaused()) {
          const r = s.interpolator.interpolate(i);
          this.setComputedData(s.key, r);
        }
      } else
        console.warn("interpolator not found");
    for (const [s, i] of this.animations) {
      const r = n.get(s);
      r === Ms.PAUSED && r !== i.state && this.pauseAnimation(s);
    }
  }
  start() {
    if (this.isPlaying)
      return;
    this.isPlaying = !0, this.startTime = performance.now();
    const n = () => {
      this.tick(), this._rafId = window.requestAnimationFrame(n);
    };
    this._rafId = window.requestAnimationFrame(n);
  }
  pause() {
    this.isPlaying = !1, this._rafId !== null && (window.cancelAnimationFrame(this._rafId), this._rafId = null);
  }
  getComputedData(n) {
    return this.computedValueCache.has(n) ? this.computedValueCache.get(n) : this.getBaseValue(n);
  }
  getBaseValue(n) {
    return this.baseValueCache.get(n);
  }
  loadAnimationTrack(n, s) {
    if (s.duration <= 0) {
      console.warn(
        "Failed to load animation track: duration must be greater than 0",
        n
      );
      return;
    }
    this.sourceAnimationTracks.has(n) && console.warn("track already exists or id conflict", n);
    for (const [i, r] of s.tracks)
      this.cacheBaseValue(i, r.baseValue);
    this.sourceAnimationTracks.set(n, s);
  }
  hasAnimation(n) {
    return this.animations.has(n);
  }
  getAnimation(n) {
    return this.animations.get(n) || (console.warn(`Animation not found: ${n}`), null);
  }
  playAnimation(n, s) {
    let i = this.animations.get(n);
    if (i && !s.backward && (i.isForward() || i.isCompleted()) && this.deleteAnimation(n), i = this.animations.get(n), !i) {
      const r = this.sourceAnimationTracks.get(n);
      if (!r) {
        console.warn(`Animation track data not found for ${n}`);
        return;
      }
      i = new Y2(n, r), this.animations.set(n, i);
    }
    s.backward ? i.backward() : i.forward();
    for (const [r] of i.trackData.tracks) {
      if (!this.propertyEffects.has(r)) {
        const a = new X2(
          this,
          r
        );
        this.propertyEffects.set(r, a);
      }
      const o = this.getPropertyEffect(r);
      o && o.addAnimation(this.currentTime, i);
    }
  }
  pauseAnimation(n) {
    const s = this.getAnimation(n);
    if (s) {
      s.pause();
      for (const [i] of s.trackData.tracks) {
        const r = this.getPropertyEffect(i);
        if (!r)
          continue;
        const o = r.getHighestAnimation();
        o !== s && o.isBackward() && r.animationStateUpdated(this.currentTime);
      }
    }
  }
  deleteAnimation(n) {
    const s = this.getAnimation(n);
    if (s) {
      this.animations.delete(n);
      for (const [i] of s.trackData.tracks) {
        const r = this.getPropertyEffect(i);
        r && (r.deleteAnimation(this.currentTime, s), r.animations.length === 0 && (this.setComputedData(i, this.getBaseValue(i)), this.propertyEffects.delete(i)));
      }
    }
  }
  // transfer version 1
  // @experimental
  // public transferAnimation(
  //   animationId: string,
  //   { clientX, clientY }: { clientX: number; clientY: number }
  // ) {
  //   console.log('transferAnimation', animationId, { clientX, clientY })
  //   // let animation = this.animations.get(animationId)
  //   // if (!animation) {
  //   //     animation = new Animation(this, animationId)
  //   //     this.animations.set(animationId, animation)
  //   // }
  //   // const { trackData } = animation
  //   // const { functions } = trackData
  //   // for (const [_, propFunctionTrack] of functions) {
  //   //     const { key, function: func } = propFunctionTrack
  //   //     const callable = eval(func)
  //   //     const value = callable(clientX, clientY)
  //   //     this.setComputedData(key, value)
  //   // }
  // }
  // // transfer version 2
  // // @experimental
  // public transferAnimation2Start(
  //   animationId: string,
  //   context: AnimationContext
  // ) {
  //   console.log('transferAnimation2Start', animationId, context)
  //   // let animation = this.animations.get(animationId)
  //   // if (animation) {
  //   //     animation.occupy()
  //   //     animation._baseTime = animation.currentTime
  //   // } else {
  //   //     animation = new Animation(this, animationId)
  //   //     this.animations.set(animationId, animation)
  //   //     animation.occupy()
  //   //     for (const [trackKey,] of animation.trackData.tracks) {
  //   //         if (!this.propertyEffects.has(trackKey)) {
  //   //             const propEffect = new PropertyEffect<PropTrackKey, Value>(this, trackKey)
  //   //             this.propertyEffects.set(trackKey, propEffect)
  //   //         }
  //   //         const propEffect = this.getPropertyEffect(trackKey)
  //   //         propEffect.addAnimation(animation)
  //   //         propEffect.generateInterpolator(this.currentTime)
  //   //     }
  //   // }
  // }
  // // @experimental
  // public transferAnimation2Update(
  //   animationId: string,
  //   context: AnimationContext
  // ) {
  //   console.log('transferAnimation2Update', animationId, context)
  //   // const animation = this.getAnimation(animationId)
  //   // const propKey = animation.trackData.tracks.keys().next().value as PropTrackKey
  //   // const propTrack = animation.getPropTrack(propKey)
  //   // const { type, kfs } = propTrack
  //   // _insertKF(kfs, { time: 0, value: this.getBaseValue(propKey) })
  //   // const interpolator = this.keyframeComposer.compose(
  //   //     type,
  //   //     kfs,
  //   //     animation.trackData.duration
  //   // )
  //   // const startValue = interpolator.interpolate(0)
  //   // const finalValue = interpolator.interpolate(1)
  //   // const totalDelta = finalValue.pos[0] - startValue.pos[0]
  //   // const currentDelta = (context.delta?.x || 0)
  //   // const progress = currentDelta / totalDelta
  //   // const localTime = progress * animation.trackData.duration
  //   // animation.currentTime = localTime + animation._baseTime
  // }
  // // @experimental
  // public transferAnimation2Stop(
  //   animationId: string,
  //   context: AnimationContext
  // ) {
  //   console.log('transferAnimation2Stop', animationId, context)
  //   // const animation = this.getAnimation(animationId)
  //   // const propKey = animation.trackData.tracks.keys().next().value as PropTrackKey
  //   // const propTrack = animation.getPropTrack(propKey)
  //   // const { type, kfs } = propTrack
  //   // const newKFs = kfs
  //   // _insertKF(newKFs, { time: 0, value: this.getBaseValue(propKey) })
  //   // const interpolator = this.keyframeComposer.compose(
  //   //     type,
  //   //     newKFs,
  //   //     animation.trackData.duration
  //   // )
  //   // const startValue = interpolator.interpolate(0)
  //   // const finalValue = interpolator.interpolate(1)
  //   // const totalDelta = finalValue.pos[0] - startValue.pos[0]
  //   // const currentDelta = (context.delta?.x || 0)
  //   // const progress = currentDelta / totalDelta
  //   // if (progress >= 0.5) {
  //   //     animation.forward()
  //   // } else {
  //   //     animation.backward()
  //   // }
  // }
}
var gA = 1e-6, Mc = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var e = 0, n = arguments.length; n--; )
    e += arguments[n] * arguments[n];
  return Math.sqrt(e);
});
function K2() {
  var e = new Mc(6);
  return Mc != Float32Array && (e[1] = 0, e[2] = 0, e[4] = 0, e[5] = 0), e[0] = 1, e[3] = 1, e;
}
function _A(e, n, s, i, r, o, a) {
  return e[0] = n, e[1] = s, e[2] = i, e[3] = r, e[4] = o, e[5] = a, e;
}
function Q2() {
  var e = new Mc(4);
  return Mc != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0), e;
}
function TA(e, n, s, i, r) {
  return e[0] = n, e[1] = s, e[2] = i, e[3] = r, e;
}
(function() {
  var e = Q2();
  return function(n, s, i, r, o, a) {
    var c, l;
    for (s || (s = 4), i || (i = 0), r ? l = Math.min(r * s + i, n.length) : l = n.length, c = i; c < l; c += s)
      e[0] = n[c], e[1] = n[c + 1], e[2] = n[c + 2], e[3] = n[c + 3], o(e, e, a), n[c] = e[0], n[c + 1] = e[1], n[c + 2] = e[2], n[c + 3] = e[3];
    return n;
  };
})();
function w1() {
  var e = new Mc(2);
  return Mc != Float32Array && (e[0] = 0, e[1] = 0), e;
}
function Fo(e, n, s) {
  return e[0] = n, e[1] = s, e;
}
function Fi(e, n, s) {
  return e[0] = n[0] + s[0], e[1] = n[1] + s[1], e;
}
function ts(e, n, s) {
  return e[0] = n[0] - s[0], e[1] = n[1] - s[1], e;
}
function Pp(e, n, s) {
  return e[0] = Math.min(n[0], s[0]), e[1] = Math.min(n[1], s[1]), e;
}
function bp(e, n, s) {
  return e[0] = Math.max(n[0], s[0]), e[1] = Math.max(n[1], s[1]), e;
}
function Hr(e, n, s) {
  return e[0] = n[0] * s, e[1] = n[1] * s, e;
}
function FE(e) {
  var n = e[0], s = e[1];
  return Math.hypot(n, s);
}
function Dl(e, n) {
  var s = n[0], i = n[1], r = s * s + i * i;
  return r > 0 && (r = 1 / Math.sqrt(r)), e[0] = n[0] * r, e[1] = n[1] * r, e;
}
function Z2(e, n, s, i) {
  var r = n[0], o = n[1];
  return e[0] = r + i * (s[0] - r), e[1] = o + i * (s[1] - o), e;
}
function Vl(e, n, s) {
  var i = n[0], r = n[1];
  return e[0] = s[0] * i + s[2] * r + s[4], e[1] = s[1] * i + s[3] * r + s[5], e;
}
function q2(e, n) {
  var s = e[0], i = e[1], r = n[0], o = n[1];
  return Math.abs(s - r) <= gA * Math.max(1, Math.abs(s), Math.abs(r)) && Math.abs(i - o) <= gA * Math.max(1, Math.abs(i), Math.abs(o));
}
var Wr = FE, ba = ts;
(function() {
  var e = w1();
  return function(n, s, i, r, o, a) {
    var c, l;
    for (s || (s = 2), i || (i = 0), r ? l = Math.min(r * s + i, n.length) : l = n.length, c = i; c < l; c += s)
      e[0] = n[c], e[1] = n[c + 1], o(e, e, a), n[c] = e[0], n[c + 1] = e[1];
    return n;
  };
})();
const wn = 1e-4;
K2();
function j2(e, n) {
  return (e % n + n) % n;
}
function AA(e, n, s) {
  const i = s - n;
  return ((e - n) % i + i) % i + n;
}
function Ge(e) {
  return e == null;
}
function ee(e) {
  return !Ge(e);
}
function be(e) {
  return typeof e == "number";
}
function _c(e) {
  return e && e.length === 2 && typeof e[0] == "number" && typeof e[1] == "number";
}
function rr(e) {
  return e && e.constructor === String;
}
function hd(e) {
  return Array.isArray(e);
}
function J2(e) {
  return e && e.constructor === Map;
}
function mA(e) {
  return e && e.constructor === Function;
}
function $2(e, n, s = (i, r) => i === r) {
  if (e === n)
    return !0;
  if (Ge(e) || Ge(n) || e.length !== n.length)
    return !1;
  for (let i = 0; i < e.length; ++i)
    if (!s(e[i], n[i]))
      return !1;
  return !0;
}
function OA(e, n) {
  const s = /* @__PURE__ */ new Map();
  for (const [i, r] of e)
    s.set(...n(i, r, e));
  return s;
}
function eP(e, n) {
  for (const s of e)
    if (n(s, e))
      return s;
}
function ka(e, n, s = wn) {
  const i = e[0], r = e[1], o = n[0], a = n[1];
  return Math.abs(i - o) <= s * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(r - a) <= s * Math.max(1, Math.abs(r), Math.abs(a));
}
function IA(e, n, s) {
  return e[0] = n[0] + s, e[1] = n[1] + s, e;
}
function tP(e, n, s) {
  const i = e[0];
  return (s[0] - i) / (n[0] - i);
}
function nP(e, n, s = wn) {
  const i = e[0], r = e[1], o = e[2], a = e[3], c = n[0], l = n[1], h = n[2], d = n[3];
  return Math.abs(i - c) <= s * Math.max(1, Math.abs(i), Math.abs(c)) && Math.abs(r - l) <= s * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(o - h) <= s * Math.max(1, Math.abs(o), Math.abs(h)) && Math.abs(a - d) <= s * Math.max(1, Math.abs(a), Math.abs(d));
}
function sP(e, n, s = wn) {
  const i = e[0], r = e[1], o = e[2], a = e[3], c = e[4], l = e[5], h = n[0], d = n[1], p = n[2], E = n[3], g = n[4], T = n[5];
  return Math.abs(i - h) <= s * Math.max(1, Math.abs(i), Math.abs(h)) && Math.abs(r - d) <= s * Math.max(1, Math.abs(r), Math.abs(d)) && Math.abs(o - p) <= s * Math.max(1, Math.abs(o), Math.abs(p)) && Math.abs(a - E) <= s * Math.max(1, Math.abs(a), Math.abs(E)) && Math.abs(c - g) <= s * Math.max(1, Math.abs(c), Math.abs(g)) && Math.abs(l - T) <= s * Math.max(1, Math.abs(l), Math.abs(T));
}
function iP(e, n) {
  return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = 0, e[5] = 0, e;
}
const rP = (e, n = Number.MIN_SAFE_INTEGER, s = Number.MAX_SAFE_INTEGER) => Math.max(Math.min(e, s), n), Ra = (e, n, s) => e + (n - e) * s;
class se extends Float32Array {
  /**
   * Creates new Vector2 from 2 number components or copies values from a single vec2-like object
   * @param  {number | _Vector2 | vec2 | object} x  x component or vec2-like object
   * @param  {number} y   y component
   */
  constructor(n, s) {
    super(2), typeof n == "number" && typeof s == "number" ? Fo(this, n, s) : this.copy(n);
  }
  /**
   * Copies values from the vec2-like object
   * @param  {_Vector2 | vec2 | object} val
   * @returns {_Vector2} self
   */
  copy(n) {
    if (Ge(n))
      return;
    let s = ee(n[0]) ? n[0] : n.x;
    Ge(s) && (s = n.width);
    let i = ee(n[1]) ? n[1] : n.y;
    if (Ge(i) && (i = n.height), be(s) && be(i))
      Fo(this, s, i);
    else
      throw new Error("Trying to copy NaN to Vector2");
    return this;
  }
  /**
   * Checks if this Vector2 is equal (has same corresponding component values) to another vec2-like object
   * @param {_Vector2 | vec2 | object} val     vec2-like object
   * @param {number} [epsilon]                precision, default is 0.0001
   * @returns {boolean}                        true if vectors are equal; false othewise
   */
  eq(n, s = wn) {
    if (Ge(n))
      return !1;
    let i = ee(n[0]) ? n[0] : n.x;
    Ge(i) && (i = n.width);
    let r = ee(n[1]) ? n[1] : n.y;
    return Ge(r) && (r = n.height), ka(this, [i, r], s);
  }
  get x() {
    return this[0];
  }
  set x(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to x component of Vector2");
    this[0] = n;
  }
  get y() {
    return this[1];
  }
  set y(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to y component of Vector2");
    this[1] = n;
  }
  get width() {
    return this[0];
  }
  set width(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to width component of Vector2");
    this[0] = n;
  }
  get height() {
    return this[1];
  }
  set height(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to height component of Vector2");
    this[1] = n;
  }
}
se.ZERO = new se(0, 0);
se.ONE = new se(1, 1);
const D1 = (e, n, s, i, r) => [
  e * (i - n) + n,
  e * (r - s) + s
], oP = (e, n, s, i, r, o, a) => {
  const c = 1 - e, l = c ** 2, h = 2 * e * c, d = e ** 2;
  return [
    l * n + h * i + d * o,
    l * s + h * r + d * a
  ];
}, aP = (e, n, s, i, r, o, a, c, l) => {
  const h = 1 - e, d = h ** 3, p = 3 * e * h ** 2, E = 3 * h * e ** 2, g = e ** 3;
  return [
    d * n + p * i + E * o + g * c,
    d * s + p * r + E * a + g * l
  ];
}, L1 = (e, n, s, i, r) => {
  let o;
  if (s && i)
    o = aP(e, n.x, n.y, s.x, s.y, i.x, i.y, r.x, r.y);
  else if (s || i) {
    const a = s || i;
    o = oP(e, n.x, n.y, a.x, a.y, r.x, r.y);
  } else
    o = D1(e, n.x, n.y, r.x, r.y);
  return new se(o[0], o[1]);
};
var SA;
(function(e) {
  e.PERSONAL = "u", e.TEAM = "t";
})(SA || (SA = {}));
var gi;
(function(e) {
  e.BASE = "bs", e.ELEMENT = "el", e.PROPERTY_COMPONENT = "pc", e.INTERACTION_MANAGER_COMPONENT = "im", e.LAYER = "ly", e.MESH = "ms", e.TRANSITION_MANAGER_COMPONENT = "tm", e.ELEMENT_INTERACTION = "ei";
})(gi || (gi = {}));
var yA;
(function(e) {
  e[e.PIXEL = 0] = "PIXEL", e[e.PERCENT = 1] = "PERCENT";
})(yA || (yA = {}));
var Jt;
(function(e) {
  e[e.PIXEL = 0] = "PIXEL", e[e.PERCENT = 1] = "PERCENT";
})(Jt || (Jt = {}));
var Oc;
(function(e) {
  e[e.PIXEL = 0] = "PIXEL", e[e.PERCENT = 1] = "PERCENT", e[e.INCH = 2] = "INCH", e[e.CM = 3] = "CM", e[e.MM = 4] = "MM";
})(Oc || (Oc = {}));
var Rr;
(function(e) {
  e[e.PROPERTY = 0] = "PROPERTY", e[e.ENTITY = 1] = "ENTITY";
})(Rr || (Rr = {}));
var Oe;
(function(e) {
  e.BASE_CHANGES = "BASE_CHANGES", e.DEFAULT_CHANGES = "CHANGES", e.EDITOR_CHANGES = "EDITOR_CHANGES", e.EFFECT_LIST_CHANGES = "EFFECT_LIST_CHANGES", e.ELEMENT_INTERACTION_CHANGES = "ELEMENT_INTERACTION_CHANGES", e.GROUP_ADD_CHILDREN = "GROUP_ADD_CHILDREN", e.GROUP_REMOVE_CHILDREN = "GROUP_REMOVE_CHILDREN", e.GUIDELINES_CHANGES = "GUIDELINES_CHANGES", e.IMAGE_CHANGES = "IMAGE_CHANGES", e.INTERACTION_CHANGES = "INTERACTION_CHANGES", e.KFINFO_CHANGES = "KFINFO_CHANGES", e.LAYER_LIST_CHANGES = "LAYER_LIST_CHANGES", e.LIBRARY_CHANGES = "LIBRARY_CHANGES", e.LOAD = "LOAD", e.LOAD_START = "LOAD_START", e.MESH_CHANGES = "MESH_CHANGES", e.MODIFIER_KEY_CHANGES = "MODIFIER_KEY_CHANGES", e.PRESET_LIST_CHANGES = "PRESET_LIST_CHANGES", e.PROPERTY_PANEL_UPDATE_NEEDED = "PROPERTY_PANEL_UPDATE_NEEDED", e.SCENE_TREE_CHANGES = "SCENE_TREE_CHANGES", e.SELECT = "SELECT", e.SELECT_CELL = "SELECT_CELL", e.TRANSACTION = "TRANSACTION", e.TRIGGER_VECTOR_FORCE_UPDATE = "TRIGGER_VECTOR_FORCE_UPDATE", e.UI_STATE_CHANGES = "UI_STATE_CHANGES", e.WORKSPACE_CHANGE = "WORKSPACE_CHANGE", e.WORKSPACE_CHANGE_WATCH = "WORKSPACE_CHANGE_WATCH", e.WORKSPACE_LIST_CHANGES = "WORKSPACE_LIST_CHANGES", e.SELECT_TEXT_RANGE = "SELECT_TEXT_RANGE", e.DATA_STORE_CLEAR = "DATA_STORE_CLEAR", e.VIEWPORT_ZOOM_CHANGE = "VIEWPORT_ZOOM_CHANGE", e.UNDO_CHECKPOINT_CROSSED = "UNDO_CHECKPOINT_CROSSED", e.VIEWPORT_RESIZE = "VIEWPORT_RESIZE";
})(Oe || (Oe = {}));
var ud;
(function(e) {
  e[e.SOLID = 0] = "SOLID", e[e.LINEAR = 1] = "LINEAR", e[e.RADIAL = 2] = "RADIAL", e[e.ANGULAR = 3] = "ANGULAR", e[e.DIAMOND = 4] = "DIAMOND", e[e.SHAPE = 5] = "SHAPE", e[e.ACROSS = 6] = "ACROSS", e[e.ALONG = 7] = "ALONG";
})(ud || (ud = {}));
var Fs;
(function(e) {
  e[e.TOP = 0] = "TOP", e[e.BOTTOM = 1] = "BOTTOM", e[e.MIDDLE = 2] = "MIDDLE";
})(Fs || (Fs = {}));
var Yi;
(function(e) {
  e[e.LEFT = 0] = "LEFT", e[e.RIGHT = 1] = "RIGHT", e[e.CENTER = 2] = "CENTER", e[e.JUSTIFIED = 3] = "JUSTIFIED";
})(Yi || (Yi = {}));
var CA;
(function(e) {
  e[e.NORMAL = 0] = "NORMAL", e[e.UPPER = 1] = "UPPER", e[e.LOWER = 2] = "LOWER", e[e.TITLE = 3] = "TITLE";
})(CA || (CA = {}));
var NA;
(function(e) {
  e[e.NORMAL = 0] = "NORMAL", e[e.SUPERSCRIPT = 1] = "SUPERSCRIPT", e[e.SUBSCRIPT = 2] = "SUBSCRIPT";
})(NA || (NA = {}));
var dd;
(function(e) {
  e[e.LTR = 0] = "LTR", e[e.RTL = 1] = "RTL";
})(dd || (dd = {}));
var Ht;
(function(e) {
  e[e.AUTO_WIDTH = 0] = "AUTO_WIDTH", e[e.AUTO_HEIGHT = 1] = "AUTO_HEIGHT", e[e.FIXED = 2] = "FIXED";
})(Ht || (Ht = {}));
var Ie;
(function(e) {
  e[e.SOLID = 0] = "SOLID", e[e.IMAGE = 1] = "IMAGE", e[e.GRADIENT_LINEAR = 2] = "GRADIENT_LINEAR", e[e.GRADIENT_RADIAL = 3] = "GRADIENT_RADIAL", e[e.GRADIENT_ANGULAR = 4] = "GRADIENT_ANGULAR", e[e.GRADIENT_DIAMOND = 5] = "GRADIENT_DIAMOND";
})(Ie || (Ie = {}));
var Ut;
(function(e) {
  e[e.PASS_THROUGH = 0] = "PASS_THROUGH", e[e.NORMAL = 1] = "NORMAL", e[e.DARKEN = 2] = "DARKEN", e[e.MULTIPLY = 3] = "MULTIPLY", e[e.COLOR_BURN = 4] = "COLOR_BURN", e[e.LIGHTEN = 5] = "LIGHTEN", e[e.SCREEN = 6] = "SCREEN", e[e.COLOR_DODGE = 7] = "COLOR_DODGE", e[e.OVERLAY = 8] = "OVERLAY", e[e.SOFT_LIGHT = 9] = "SOFT_LIGHT", e[e.HARD_LIGHT = 10] = "HARD_LIGHT", e[e.DIFFERENCE = 11] = "DIFFERENCE", e[e.EXCLUSION = 12] = "EXCLUSION", e[e.HUE = 13] = "HUE", e[e.SATURATION = 14] = "SATURATION", e[e.COLOR = 15] = "COLOR", e[e.LUMINOSITY = 16] = "LUMINOSITY", e[e.DIVIDE = 17] = "DIVIDE", e[e.ADD = 18] = "ADD", e[e.SUBTRACT = 19] = "SUBTRACT", e[e.DISSOLVE = 20] = "DISSOLVE";
})(Ut || (Ut = {}));
var yr;
(function(e) {
  e[e.FILL = 0] = "FILL", e[e.STRETCH = 1] = "STRETCH", e[e.FIT = 2] = "FIT";
})(yr || (yr = {}));
var xA;
(function(e) {
  e[e.TOP_LEFT = 0] = "TOP_LEFT", e[e.TOP = 1] = "TOP", e[e.TOP_RIGHT = 2] = "TOP_RIGHT", e[e.LEFT = 3] = "LEFT", e[e.CENTER = 4] = "CENTER", e[e.RIGHT = 5] = "RIGHT", e[e.BOTTOM_LEFT = 6] = "BOTTOM_LEFT", e[e.BOTTOM = 7] = "BOTTOM", e[e.BOTTOM_RIGHT = 8] = "BOTTOM_RIGHT";
})(xA || (xA = {}));
var vA;
(function(e) {
  e[e.NORMAL = 0] = "NORMAL", e[e.SPACE = 1] = "SPACE";
})(vA || (vA = {}));
var RA;
(function(e) {
  e[e.ZERO = 0] = "ZERO", e[e.NINETY = 1] = "NINETY", e[e.ONE_EIGHTY = 2] = "ONE_EIGHTY", e[e.TWO_SEVENTY = 3] = "TWO_SEVENTY";
})(RA || (RA = {}));
var Ic;
(function(e) {
  e[e.INSIDE = 0] = "INSIDE", e[e.CENTER = 1] = "CENTER", e[e.OUTSIDE = 2] = "OUTSIDE";
})(Ic || (Ic = {}));
var cn;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.ROUND = 1] = "ROUND", e[e.LINE_ARROW = 2] = "LINE_ARROW", e[e.TRIANGLE_ARROW_SOLID = 3] = "TRIANGLE_ARROW_SOLID", e[e.TRIANGLE_ARROW_OUTLINE = 4] = "TRIANGLE_ARROW_OUTLINE", e[e.CIRCLE_SOLID = 5] = "CIRCLE_SOLID", e[e.CIRCLE_OUTLINE = 6] = "CIRCLE_OUTLINE", e[e.SQUARE_SOLID = 7] = "SQUARE_SOLID", e[e.SQUARE_OUTLINE = 8] = "SQUARE_OUTLINE";
})(cn || (cn = {}));
var Us;
(function(e) {
  e[e.MITER = 0] = "MITER", e[e.CONCAVE = 1] = "CONCAVE", e[e.ROUND = 2] = "ROUND", e[e.BEVEL = 3] = "BEVEL", e[e.NONE = 4] = "NONE";
})(Us || (Us = {}));
var Ba;
(function(e) {
  e[e.STRAIGHT = 0] = "STRAIGHT", e[e.ROUND = 1] = "ROUND";
})(Ba || (Ba = {}));
var wA;
(function(e) {
  e[e.HORIZONTAL = 0] = "HORIZONTAL", e[e.VERTICAL = 1] = "VERTICAL";
})(wA || (wA = {}));
var ln;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.UNION = 1] = "UNION", e[e.SUBTRACT = 2] = "SUBTRACT", e[e.INTERSECT = 3] = "INTERSECT", e[e.DIFFERENCE = 4] = "DIFFERENCE";
})(ln || (ln = {}));
var ks;
(function(e) {
  e[e.DOCUMENT = 0] = "DOCUMENT", e[e.DATA_STORE = 1] = "DATA_STORE", e[e.SELECTION = 2] = "SELECTION", e[e.WATCHER = 3] = "WATCHER", e[e.WORKSPACE = 4] = "WORKSPACE", e[e.ELEMENT = 5] = "ELEMENT", e[e.GEOMETRY = 6] = "GEOMETRY", e[e.ELEMENT_COMPONENT = 7] = "ELEMENT_COMPONENT", e[e.PROP_COMPONENT = 8] = "PROP_COMPONENT", e[e.LAYER = 9] = "LAYER", e[e.BASE = 10] = "BASE", e[e.COMPUTED_STYLE = 11] = "COMPUTED_STYLE", e[e.COMPUTED_LAYER = 12] = "COMPUTED_LAYER", e[e.IMAGE_RESOURCE = 13] = "IMAGE_RESOURCE", e[e.IMAGE_EXPORT = 14] = "IMAGE_EXPORT", e[e.IMAGE_PRESET = 15] = "IMAGE_PRESET", e[e.EFFECT = 16] = "EFFECT", e[e.COMPUTED_EFFECT = 17] = "COMPUTED_EFFECT";
})(ks || (ks = {}));
var Me;
(function(e) {
  e[e.TEXT = 0] = "TEXT", e[e.PATH = 1] = "PATH", e[e.GROUP = 2] = "GROUP", e[e.CONTAINER = 3] = "CONTAINER", e[e.GEOMETRY_GROUP = 4] = "GEOMETRY_GROUP", e[e.SCREEN = 5] = "SCREEN", e[e.BOOLEAN_CONTAINER = 6] = "BOOLEAN_CONTAINER", e[e.MASK_CONTAINER = 7] = "MASK_CONTAINER", e[e.NORMAL_GROUP = 8] = "NORMAL_GROUP";
})(Me || (Me = {}));
var DA;
(function(e) {
  e[e.ELEMENT = 0] = "ELEMENT", e[e.COMPONENT = 1] = "COMPONENT";
})(DA || (DA = {}));
var kE;
(function(e) {
  e[e.CONTAINER = 3] = "CONTAINER", e[e.MASK_CONTAINER = 7] = "MASK_CONTAINER", e[e.BOOLEAN_CONTAINER = 6] = "BOOLEAN_CONTAINER", e[e.NORMAL_GROUP = 8] = "NORMAL_GROUP";
})(kE || (kE = {}));
var mn;
(function(e) {
  e[e.RECTANGLE = 0] = "RECTANGLE", e[e.ELLIPSE = 1] = "ELLIPSE", e[e.POLYGON = 2] = "POLYGON", e[e.REGULAR_POLYGON = 3] = "REGULAR_POLYGON", e[e.STAR = 4] = "STAR", e[e.LINE = 5] = "LINE", e[e.TEXT = 6] = "TEXT";
})(mn || (mn = {}));
var we;
(function(e) {
  e[e.TRANSLATE = 0] = "TRANSLATE", e[e.DIMENSIONS = 1] = "DIMENSIONS", e[e.ROTATION = 2] = "ROTATION", e[e.OPACITY = 3] = "OPACITY", e[e.FILL = 4] = "FILL", e[e.STROKE = 5] = "STROKE", e[e.SHADOW = 6] = "SHADOW", e[e.INNER_SHADOW = 7] = "INNER_SHADOW", e[e.FONT = 8] = "FONT", e[e.TEXT_ALIGNMENT = 9] = "TEXT_ALIGNMENT", e[e.TEXT_DECORATION = 10] = "TEXT_DECORATION", e[e.TEXT_DIRECTION = 11] = "TEXT_DIRECTION", e[e.TEXT_SPACING = 12] = "TEXT_SPACING", e[e.SCALE = 13] = "SCALE", e[e.SKEW = 14] = "SKEW", e[e.ORIGIN = 15] = "ORIGIN", e[e.OVERFLOW = 16] = "OVERFLOW", e[e.BLUR_GAUSSIAN = 17] = "BLUR_GAUSSIAN", e[e.PAINT = 18] = "PAINT", e[e.IMAGE = 19] = "IMAGE", e[e.CORNER_RADIUS = 20] = "CORNER_RADIUS", e[e.CONTENT_ANCHOR = 21] = "CONTENT_ANCHOR", e[e.EFFECT = 22] = "EFFECT", e[e.REFERENCE_POINT = 23] = "REFERENCE_POINT";
})(we || (we = {}));
var Or;
(function(e) {
  e[e.FILL = 4] = "FILL", e[e.STROKE = 5] = "STROKE", e[e.SHADOW = 6] = "SHADOW", e[e.INNER_SHADOW = 7] = "INNER_SHADOW";
})(Or || (Or = {}));
var LA;
(function(e) {
  e[e.FONT = 8] = "FONT", e[e.TEXT_ALIGNMENT = 9] = "TEXT_ALIGNMENT", e[e.TEXT_DECORATION = 10] = "TEXT_DECORATION", e[e.TEXT_DIRECTION = 11] = "TEXT_DIRECTION";
})(LA || (LA = {}));
var MA;
(function(e) {
  e[e.SCALE = 13] = "SCALE", e[e.SKEW = 14] = "SKEW", e[e.BLUR_GAUSSIAN = 17] = "BLUR_GAUSSIAN";
})(MA || (MA = {}));
var ze;
(function(e) {
  e[e.FILL = 4] = "FILL", e[e.STROKE = 5] = "STROKE", e[e.SHADOW = 6] = "SHADOW", e[e.INNER_SHADOW = 7] = "INNER_SHADOW";
})(ze || (ze = {}));
var PA;
(function(e) {
  e[e.VERTEX = 0] = "VERTEX", e[e.EDGE = 1] = "EDGE", e[e.CONTOUR = 2] = "CONTOUR";
})(PA || (PA = {}));
var pe;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.ANGLE = 1] = "ANGLE", e[e.ANGLE_AND_LENGTH = 2] = "ANGLE_AND_LENGTH", e[e.INDEPENDENT = 3] = "INDEPENDENT";
})(pe || (pe = {}));
var zi;
(function(e) {
  e[e.TRIM_PATH = 0] = "TRIM_PATH";
})(zi || (zi = {}));
var ar;
(function(e) {
  e[e.SIMULTANEOUSLY = 0] = "SIMULTANEOUSLY", e[e.INDIVIDUALLY = 1] = "INDIVIDUALLY";
})(ar || (ar = {}));
var bA;
(function(e) {
  e[e.ACTION = 0] = "ACTION", e[e.RESPONSE = 1] = "RESPONSE", e[e.TRIGGER = 2] = "TRIGGER", e[e.CONDITION = 3] = "CONDITION", e[e.ELEMENT_TRACK = 4] = "ELEMENT_TRACK", e[e.PROPERTY_TRACK = 5] = "PROPERTY_TRACK", e[e.KEY_FRAME = 6] = "KEY_FRAME", e[e.ANIMATION_PRESET = 7] = "ANIMATION_PRESET", e[e.TRANSFER = 8] = "TRANSFER";
})(bA || (bA = {}));
var UA;
(function(e) {
  e[e.START = 0] = "START", e[e.DURING = 1] = "DURING", e[e.END = 2] = "END", e[e.START_AND_END = 3] = "START_AND_END";
})(UA || (UA = {}));
var GA;
(function(e) {
  e[e.LEFT = 0] = "LEFT", e[e.RIGHT = 1] = "RIGHT", e[e.MULTI = 2] = "MULTI";
})(GA || (GA = {}));
var FA;
(function(e) {
  e.A = "A", e.B = "B", e.C = "C", e.D = "D", e.E = "E", e.F = "F", e.G = "G", e.H = "H", e.I = "I", e.J = "J", e.K = "K", e.L = "L", e.M = "M", e.N = "N", e.O = "O", e.P = "P", e.Q = "Q", e.R = "R", e.S = "S", e.T = "T", e.U = "U", e.V = "V", e.W = "W", e.X = "X", e.Y = "Y", e.Z = "Z", e.NUM_0 = "0", e.NUM_1 = "1", e.NUM_2 = "2", e.NUM_3 = "3", e.NUM_4 = "4", e.NUM_5 = "5", e.NUM_6 = "6", e.NUM_7 = "7", e.NUM_8 = "8", e.NUM_9 = "9";
})(FA || (FA = {}));
var di;
(function(e) {
  e[e.CLICK = 0] = "CLICK", e[e.DOUBLE_CLICK = 1] = "DOUBLE_CLICK", e[e.DRAG = 2] = "DRAG", e[e.EDGE_SWIPE = 3] = "EDGE_SWIPE", e[e.FORCE_TAP = 4] = "FORCE_TAP", e[e.HOVER = 5] = "HOVER", e[e.MOUSE_ENTER = 6] = "MOUSE_ENTER", e[e.MOUSE_LEAVE = 7] = "MOUSE_LEAVE", e[e.MOUSE_UP = 8] = "MOUSE_UP", e[e.MOUSE_DOWN = 9] = "MOUSE_DOWN", e[e.KEY_PRESS = 10] = "KEY_PRESS", e[e.LOAD = 11] = "LOAD", e[e.LONG_PRESS = 12] = "LONG_PRESS", e[e.MANY_CLICK = 13] = "MANY_CLICK", e[e.MOUSE_MOVE = 14] = "MOUSE_MOVE", e[e.PINCH = 15] = "PINCH", e[e.PRESS = 16] = "PRESS", e[e.ROTATE = 17] = "ROTATE", e[e.SCROLL = 18] = "SCROLL", e[e.SWIPE = 19] = "SWIPE";
})(di || (di = {}));
var kA;
(function(e) {
  e[e.AND = 0] = "AND", e[e.OR = 1] = "OR";
})(kA || (kA = {}));
var BA;
(function(e) {
  e[e.NONE = 0] = "NONE";
})(BA || (BA = {}));
var BE;
(function(e) {
  e[e.EXPLICIT = 0] = "EXPLICIT", e[e.INITIAL = 1] = "INITIAL";
})(BE || (BE = {}));
var VE;
(function(e) {
  e.EXPLICIT = "EXPLICIT", e.INITIAL = "INITIAL", e.TWEEN = "TWEEN", e.NON_EDITABLE = "NON_EDITABLE";
})(VE || (VE = {}));
var dt;
(function(e) {
  e[e.ANY = 0] = "ANY", e[e.CLOCKWISE = 1] = "CLOCKWISE", e[e.COUNTERCLOCKWISE = 2] = "COUNTERCLOCKWISE", e[e.INWARD = 3] = "INWARD", e[e.OUTWARD = 4] = "OUTWARD", e[e.HORIZONTAL = 5] = "HORIZONTAL", e[e.VERTICAL = 6] = "VERTICAL", e[e.LEFT = 7] = "LEFT", e[e.RIGHT = 8] = "RIGHT", e[e.UP = 9] = "UP", e[e.DOWN = 10] = "DOWN", e[e.START = 11] = "START", e[e.END = 12] = "END";
})(dt || (dt = {}));
var Te;
(function(e) {
  e[e.LINEAR = 0] = "LINEAR", e[e.EASE = 1] = "EASE", e[e.EASE_IN = 2] = "EASE_IN", e[e.EASE_OUT = 3] = "EASE_OUT", e[e.EASE_IN_OUT = 4] = "EASE_IN_OUT", e[e.EASE_IN_SIN = 5] = "EASE_IN_SIN", e[e.EASE_OUT_SINE = 6] = "EASE_OUT_SINE", e[e.EASE_IN_OUT_SINE = 7] = "EASE_IN_OUT_SINE", e[e.EASE_IN_QUAD = 8] = "EASE_IN_QUAD", e[e.EASE_OUT_QUAD = 9] = "EASE_OUT_QUAD", e[e.EASE_IN_OUT_QUAD = 10] = "EASE_IN_OUT_QUAD", e[e.EASE_IN_CUBIC = 11] = "EASE_IN_CUBIC", e[e.EASE_OUT_CUBIC = 12] = "EASE_OUT_CUBIC", e[e.EASE_IN_OUT_CUBIC = 13] = "EASE_IN_OUT_CUBIC", e[e.EASE_IN_QUART = 14] = "EASE_IN_QUART", e[e.EASE_OUT_QUART = 15] = "EASE_OUT_QUART", e[e.EASE_IN_OUT_QUART = 16] = "EASE_IN_OUT_QUART", e[e.EASE_IN_QUINT = 17] = "EASE_IN_QUINT", e[e.EASE_OUT_QUINT = 18] = "EASE_OUT_QUINT", e[e.EASE_IN_OUT_QUINT = 19] = "EASE_IN_OUT_QUINT", e[e.EASE_IN_EXPO = 20] = "EASE_IN_EXPO", e[e.EASE_OUT_EXPO = 21] = "EASE_OUT_EXPO", e[e.EASE_IN_OUT_EXPO = 22] = "EASE_IN_OUT_EXPO", e[e.EASE_IN_CIRC = 23] = "EASE_IN_CIRC", e[e.EASE_OUT_CIRC = 24] = "EASE_OUT_CIRC", e[e.EASE_IN_OUT_CIRC = 25] = "EASE_IN_OUT_CIRC", e[e.EASE_IN_BACK = 26] = "EASE_IN_BACK", e[e.EASE_OUT_BACK = 27] = "EASE_OUT_BACK", e[e.EASE_IN_OUT_BACK = 28] = "EASE_IN_OUT_BACK", e[e.CUSTOM = 29] = "CUSTOM", e[e.STEP = 30] = "STEP", e[e.STEP_START = 31] = "STEP_START", e[e.STEP_MIDDLE = 32] = "STEP_MIDDLE", e[e.STEP_END = 33] = "STEP_END", e[e.STEP_CUSTOM = 34] = "STEP_CUSTOM", e[e.HOP_IN = 35] = "HOP_IN", e[e.HOP_OUT = 36] = "HOP_OUT", e[e.HOP_IN_OUT = 37] = "HOP_IN_OUT";
})(Te || (Te = {}));
var VA;
(function(e) {
  e[e.START = 0] = "START", e[e.END = 1] = "END";
})(VA || (VA = {}));
var xn;
(function(e) {
  e[e.FADE_IN = 0] = "FADE_IN", e[e.FADE_OUT = 1] = "FADE_OUT", e[e.MOVE_IN = 2] = "MOVE_IN", e[e.MOVE_OUT = 3] = "MOVE_OUT", e[e.SCALE_IN = 4] = "SCALE_IN", e[e.SCALE_OUT = 5] = "SCALE_OUT", e[e.SPIN_IN = 6] = "SPIN_IN", e[e.SPIN_OUT = 7] = "SPIN_OUT", e[e.TRIM_IN = 8] = "TRIM_IN", e[e.TRIM_OUT = 9] = "TRIM_OUT";
})(xn || (xn = {}));
var HA;
(function(e) {
  e.ELEMENT_LIST = "element_list", e.ACTION_LIST = "action_list";
})(HA || (HA = {}));
var si;
(function(e) {
  e.EDITING = "EDITING", e.VIEWING = "VIEWING", e.INSPECTING = "INSPECTING", e.VERSIONING = "VERSIONING", e.PROTOTYPING = "PROTOTYPING";
})(si || (si = {}));
var fd;
(function(e) {
  e[e.SINGLE = 0] = "SINGLE", e[e.TABLE = 1] = "TABLE", e[e.SITEMAP = 2] = "SITEMAP";
})(fd || (fd = {}));
var Dn;
(function(e) {
  e[e.ELEMENT = 0] = "ELEMENT", e[e.SHAPE = 1] = "SHAPE", e[e.TEXT = 2] = "TEXT", e[e.MOTION_PATH = 3] = "MOTION_PATH";
})(Dn || (Dn = {}));
var Rn;
(function(e) {
  e[e.DESIGN = 0] = "DESIGN", e[e.ACTION = 1] = "ACTION";
})(Rn || (Rn = {}));
var WA;
(function(e) {
  e.DESIGN_MODE = "DESIGN_MODE", e.ACTION_MODE = "ACTION_MODE", e.PROTOTYPE_MODE = "PROTOTYPE_MODE", e.INSPECT_MODE = "INSPECT_MODE", e.VERSION_MODE = "VERSION_MODE", e.VIEW_MODE = "VIEW_MODE", e.SELECTOR_MODE = "SELECTOR_MODE";
})(WA || (WA = {}));
var YA;
(function(e) {
  e.EDITING_STATE = "EDITING_STATE", e.VERSIONING_STATE = "VERSIONING_STATE";
})(YA || (YA = {}));
var st;
(function(e) {
  e[e.SELECT = 0] = "SELECT", e[e.SCALE = 1] = "SCALE", e[e.HAND = 2] = "HAND", e[e.RECTANGLE = 3] = "RECTANGLE", e[e.ELLIPSE = 4] = "ELLIPSE", e[e.POLYGON = 5] = "POLYGON", e[e.STAR = 6] = "STAR", e[e.LINE = 7] = "LINE", e[e.ARROW = 8] = "ARROW", e[e.CONTAINER = 9] = "CONTAINER", e[e.PEN = 10] = "PEN", e[e.EYE_DROPPER = 11] = "EYE_DROPPER", e[e.COMMENT = 12] = "COMMENT", e[e.INSERT = 13] = "INSERT", e[e.PROTOTYPE = 14] = "PROTOTYPE", e[e.ADD_ACTION = 15] = "ADD_ACTION", e[e.TEXT = 16] = "TEXT";
})(st || (st = {}));
var XA;
(function(e) {
  e[e.SELECT = 0] = "SELECT", e[e.SCALE = 1] = "SCALE";
})(XA || (XA = {}));
var zA;
(function(e) {
  e[e.RECTANGLE = 3] = "RECTANGLE", e[e.ELLIPSE = 4] = "ELLIPSE", e[e.POLYGON = 5] = "POLYGON", e[e.STAR = 6] = "STAR", e[e.LINE = 7] = "LINE", e[e.ARROW = 8] = "ARROW", e[e.CONTAINER = 9] = "CONTAINER", e[e.PEN = 10] = "PEN", e[e.TEXT = 16] = "TEXT";
})(zA || (zA = {}));
var Zt;
(function(e) {
  e[e.TOP = 0] = "TOP", e[e.MIDDLE = 1] = "MIDDLE", e[e.BOTTOM = 2] = "BOTTOM", e[e.LEFT = 3] = "LEFT", e[e.CENTER = 4] = "CENTER", e[e.RIGHT = 5] = "RIGHT";
})(Zt || (Zt = {}));
var Pc;
(function(e) {
  e[e.HORIZONTAL = 0] = "HORIZONTAL", e[e.VERTICAL = 1] = "VERTICAL";
})(Pc || (Pc = {}));
var KA;
(function(e) {
  e[e.IN_PROGRESS = 0] = "IN_PROGRESS", e[e.COMPLETED = 1] = "COMPLETED", e[e.SKIPPED = 2] = "SKIPPED";
})(KA || (KA = {}));
var QA;
(function(e) {
  e[e.INITIAL = 0] = "INITIAL", e[e.WAITING = 1] = "WAITING", e[e.FINISHED = 2] = "FINISHED";
})(QA || (QA = {}));
var Vo;
(function(e) {
  e[e.GIF = 0] = "GIF", e[e.MP4 = 1] = "MP4", e[e.LOTTIE = 2] = "LOTTIE", e[e.DOTLOTTIE = 3] = "DOTLOTTIE";
})(Vo || (Vo = {}));
var wa;
(function(e) {
  e[e.ULTRA = 0] = "ULTRA", e[e.HIGH = 1] = "HIGH", e[e.MEDIUM = 2] = "MEDIUM", e[e.LOW = 3] = "LOW";
})(wa || (wa = {}));
var ZA;
(function(e) {
  e[e.IMPORT_LOTTIE_REMINDER_DIALOG_IN_ACTION = 0] = "IMPORT_LOTTIE_REMINDER_DIALOG_IN_ACTION", e[e.IMPORT_DOTLOTTIE_MULTIPLE_ANIMATIONS_DIALOG_IN_ACTION = 1] = "IMPORT_DOTLOTTIE_MULTIPLE_ANIMATIONS_DIALOG_IN_ACTION";
})(ZA || (ZA = {}));
var pd;
(function(e) {
  e[e.CONTENT = 0] = "CONTENT", e[e.POSITION = 1] = "POSITION";
})(pd || (pd = {}));
var kn;
(function(e) {
  e[e.STOP = 0] = "STOP", e[e.GRADIENT = 1] = "GRADIENT", e[e.HANDLE = 2] = "HANDLE", e[e.ASPECT_RATIO = 3] = "ASPECT_RATIO", e[e.REFERENCE = 4] = "REFERENCE";
})(kn || (kn = {}));
var qA;
(function(e) {
  e[e.BOTH = 0] = "BOTH", e[e.HORIZONTAL = 1] = "HORIZONTAL", e[e.VERTICAL = 2] = "VERTICAL";
})(qA || (qA = {}));
var jA;
(function(e) {
  e.GUEST = "GUEST", e.MEMBER = "MEMBER", e.ADMIN = "ADMIN", e.OWNER = "OWNER";
})(jA || (jA = {}));
var or;
(function(e) {
  e.FROM_MESH_CHANGE = "FROM_MESH_CHANGE", e.FROM_PARENT_EDIT = "FROM_PARENT_EDIT", e.FROM_CHILDREN_CHANGE = "FROM_CHILDREN_CHANGE", e.FROM_ANIMATION = "FROM_ANIMATION", e.FROM_CHANGE_CONTAINER_TYPE = "FROM_CHANGE_CONTAINER_TYPE", e.FROM_DRAG_DUPLICATE = "FROM_DRAG_DUPLICATE", e.FROM_DATA_SYNC = "FROM_DATA_SYNC", e.FROM_INTERACTION_CONTINUOUSLY_CHANGE = "FROM_INTERACTION_CONTINUOUSLY_CHANGE", e.FROM_ELEMENT_CREATE = "FROM_ELEMENT_CREATE", e.SHOW_SCOPE_CHANGE_MODAL = "SHOW_SCOPE_CHANGE_MODAL", e.FROM_SYSTEM = "FROM_SYSTEM", e.FROM_TEXT_EDIT = "FROM_TEXT_EDIT";
})(or || (or = {}));
var Gs;
(function(e) {
  e.USER_EDITING = "USER_EDITING", e.UNDO_REDO = "UNDO_REDO", e.ANIMATING = "ANIMATING", e.OTHER = "OTHER";
})(Gs || (Gs = {}));
var Is;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.UPDATE = 1] = "UPDATE", e[e.UPDATE_ALL = 2] = "UPDATE_ALL", e[e.UPDATE_NEED_BBOX_RECALC = 3] = "UPDATE_NEED_BBOX_RECALC", e[e.UPDATE_ALL_NEED_BBOX_RECALC = 4] = "UPDATE_ALL_NEED_BBOX_RECALC";
})(Is || (Is = {}));
var Gt;
(function(e) {
  e.NONE = "NONE", e.ELEMENT = "ELEMENT", e.RESIZE_HANDLE = "RESIZE_HANDLE", e.ROTATE_HANDLE = "ROTATE_HANDLE", e.GRADIENT_STOP_HANDLE = "GRADIENT_STOP_HANDLE", e.GRADIENT_TRANSFORM_START_HANDLE = "GRADIENT_TRANSFORM_START_HANDLE", e.GRADIENT_TRANSFORM_END_HANDLE = "GRADIENT_TRANSFORM_END_HANDLE", e.GRADIENT_TRANSFORM_SHAPE_HANDLE = "GRADIENT_TRANSFORM_SHAPE_HANDLE", e.GRADIENT_TRANSFORM_REFERENCE_LINE = "GRADIENT_TRANSFORM_REFERENCE_LINE", e.SCROLLBAR = "SCROLLBAR", e.CURVE_CONTROL = "CURVE_CONTROL", e.VERTEX = "VERTEX", e.ENDPOINT = "ENDPOINT", e.EDGE = "EDGE", e.ORIGIN = "ORIGIN", e.MULTIPLE_SELECTION_BOUND = "MULTIPLE_SELECTION_BOUND", e.MOTION_POINT = "MOTION_POINT", e.MOTION_SEGMENT = "MOTION_SEGMENT", e.RULER = "RULER", e.GUIDELINE = "GUIDELINE";
})(Gt || (Gt = {}));
var Y;
(function(e) {
  e.ACTIVATE_ARROW_TOOL = "ACTIVATE_ARROW_TOOL", e.ACTIVATE_COMMENT_TOOL = "ACTIVATE_COMMENT_TOOL", e.ACTIVATE_CONTAINER_TOOL = "ACTIVATE_CONTAINER_TOOL", e.ACTIVATE_EDIT_GRADIENT = "ACTIVATE_EDIT_GRADIENT", e.ACTIVATE_ELLIPSE_TOOL = "ACTIVATE_ELLIPSE_TOOL", e.ACTIVATE_EXCLUDE_TOOL = "ACTIVATE_EXCLUDE_TOOL", e.ACTIVATE_EYE_DROPPER_TOOL = "ACTIVATE_EYE_DROPPER_TOOL", e.ACTIVATE_GRADIENT_HANDLES_MODE = "ACTIVATE_GRADIENT_HANDLES_MODE", e.ACTIVATE_HAND_TOOL = "ACTIVATE_HAND_TOOL", e.ACTIVATE_INTERSECT_TOOL = "ACTIVATE_INTERSECT_TOOL", e.ACTIVATE_LINE_TOOL = "ACTIVATE_LINE_TOOL", e.ACTIVATE_PAN = "ACTIVATE_PAN", e.ACTIVATE_PEN_TOOL = "ACTIVATE_PEN_TOOL", e.ACTIVATE_POLYGON_TOOL = "ACTIVATE_POLYGON_TOOL", e.ACTIVATE_RECTANGLE_TOOL = "ACTIVATE_RECTANGLE_TOOL", e.ACTIVATE_SCALE_TOOL = "ACTIVATE_SCALE_TOOL", e.ACTIVATE_SELECTOR_MODE = "ACTIVATE_SELECTOR_MODE", e.ACTIVATE_SELECT_TOOL = "ACTIVATE_SELECT_TOOL", e.ACTIVATE_SHAPE_MODE = "ACTIVATE_SHAPE_MODE", e.ACTIVATE_STAR_TOOL = "ACTIVATE_STAR_TOOL", e.ACTIVATE_SUBTRACT_TOOL = "ACTIVATE_SUBTRACT_TOOL", e.ACTIVATE_TEXT_EDIT_MODE = "ACTIVATE_TEXT_EDIT_MODE", e.ACTIVATE_TEXT_MODE = "ACTIVATE_TEXT_MODE", e.ACTIVATE_TEXT_TOOL = "ACTIVATE_TEXT_TOOL", e.ACTIVATE_UNION_TOOL = "ACTIVATE_UNION_TOOL", e.ADD_ACTION = "ADD_ACTION", e.ADD_LAYER = "ADD_LAYER", e.ADD_NEW_GRADIENT_STOP = "ADD_NEW_GRADIENT_STOP", e.ALIGN = "ALIGN", e.ALL = "*", e.APPEND_ELEMENT = "APPEND_ELEMENT", e.BOOLEAN_GROUP_ELEMENTS = "BOOLEAN_GROUP_ELEMENTS", e.BRING_TO_FRONT = "BRING_TO_FRONT", e.CANCEL_EXPORT_MEDIA = "CANCEL_EXPORT_MEDIA", e.CANCEL_SELECTOR_MODE = "CANCEL_SELECTOR_MODE", e.CHANGE_TEXT_CARET = "CHANGE_TEXT_CARET", e.CLOSE_MODAL = "CLOSE_MODAL", e.COMMENT_DEACTIVATE_PAN = "COMMENT_DEACTIVATE_PAN", e.CONFIRM_SELECTOR_MODE = "CONFIRM_SELECTOR_MODE", e.CONVERT_ELEMENT_TO_CONTAINER = "CONVERT_ELEMENT_TO_CONTAINER", e.CONVERT_ELEMENT_TO_GROUP = "CONVERT_ELEMENT_TO_GROUP", e.CONVERT_ELEMENT_TO_PATH = "CONVERT_ELEMENT_TO_PATH", e.CONVERT_SHAPE_TO_PATH = "CONVERT_SHAPE_TO_PATH", e.COPY = "COPY", e.CREATE_ELEMENT_W_DEFAULT_SIZE = "CREATE_ELEMENT_W_DEFAULT_SIZE", e.CUT = "CUT", e.DEACTIVATE_GRADIENT_HANDLES_MODE = "DEACTIVATE_GRADIENT_HANDLES_MODE", e.DEACTIVATE_PAN = "DEACTIVATE_PAN", e.DEACTIVATE_SELECTOR_MODE = "DEACTIVATE_SELECTOR_MODE", e.DEACTIVATE_SHAPE_MODE = "DEACTIVATE_SHAPE_MODE", e.DEACTIVATE_TEXT_EDIT_MODE = "DEACTIVATE_TEXT_EDIT_MODE", e.DEACTIVATE_TEXT_MODE = "DEACTIVATE_TEXT_MODE", e.DEACTIVATE_MOTION_PATH_MODE = "DEACTIVATE_MOTION_PATH_MODE", e.DECREASE_CORNER_RADIUS = "DECREASE_CORNER_RADIUS", e.DELETE_CELL = "DELETE_CELL", e.DELETE_ELEMENT = "DELETE_ELEMENT", e.DELETE_GRADIENT_STOP = "DELETE_GRADIENT_STOP", e.DELETE_GUIDELINES = "DELETE_GUIDELINES", e.DELETE_KEYFRAME = "DELETE_KEYFRAME", e.DELETE_LAYER = "DELETE_LAYER", e.DELETE_MOTION_POINT = "DELETE_MOTION_POINT", e.DELETE_TEXT = "DELETE_TEXT", e.DERECTLY_SELECT_GUIDE = "DERECTLY_SELECT_GUIDE", e.DESELECT_CELL = "DESELECT_CELL", e.DESELECT_ELEMENT = "DESELECT_ELEMENT", e.DESELECT_KEYFRAME = "DESELECT_KEYFRAME", e.DESELECT_MOTION_POINT = "DESELECT_MOTION_POINT", e.DIRECTLY_SELECT_GUIDE = "DIRECTLY_SELECT_GUIDE", e.DISTRIBUTE = "DISTRIBUTE", e.DOUBLE_LEFT_CLICK = "DOUBLE_LEFT_CLICK", e.DOWNLOAD_FILE = "DOWNLOAD_FILE", e.DRAG_END = "DRAG_END", e.DRAG_OVER = "DRAG_OVER", e.DROP_WITH_FILES = "DROP_WITH_FILES", e.DUPLICATE_CELL = "DUPLICATE_CELL", e.DUPLICATE_ELEMENT = "DUPLICATE_ELEMENT", e.DUPLICATE_KEYFRAME = "DUPLICATE_KEYFRAME", e.EDIT_NEXT_TEXT_ELEMENT = "EDIT_NEXT_TEXT_ELEMENT", e.EDIT_ORIGIN = "EDIT_ORIGIN", e.EDIT_PREVIOUS_TEXT_ELEMENT = "EDIT_PREVIOUS_TEXT_ELEMENT", e.EDIT_SELECTOR = "EDIT_SELECTOR", e.END_AREA_SELECT_CELL = "END_AREA_SELECT_CELL", e.END_AREA_SELECT_ELEMENT = "END_AREA_SELECT_ELEMENT", e.END_CREATE_ELEMENT = "END_CREATE_ELEMENT", e.END_CREATE_GUIDE = "END_CREATE_GUIDE", e.END_DRAG_CELL = "END_DRAG_CELL", e.END_DRAG_ELEMENT = "END_DRAG_ELEMENT", e.END_DRAG_GRADIENT_HANDLE = "END_DRAG_GRADIENT_HANDLE", e.END_DRAG_MOTION_POINT = "END_DRAG_MOTION_POINT", e.END_DRAG_MOTION_SEGMENT = "END_DRAG_MOTION_SEGMENT", e.END_DRAG_MULTI_ELEMENTS = "END_DRAG_MULTI_ELEMENTS", e.END_DRAG_ORIGIN = "END_DRAG_ORIGIN", e.END_DRAG_SCROLLBAR = "END_DRAG_SCROLLBAR", e.END_DRAW_PATH = "END_DRAW_PATH", e.END_DRAW_PATH_ON_EDGE = "END_DRAW_PATH_ON_EDGE", e.END_DRAW_PATH_ON_VERTEX = "END_DRAW_PATH_ON_VERTEX", e.END_EXPAND_TEXT_SELECTION = "END_EXPAND_TEXT_SELECTION", e.END_LEFT_CLICK_MOVE = "END_LEFT_CLICK_MOVE", e.END_MOVE_GUIDE = "END_MOVE_GUIDE", e.END_MOVE_GUIDE_WO_SELECT = "END_MOVE_GUIDE_WO_SELECT", e.END_MOVE_SCROLLBAR = "END_MOVE_SCROLLBAR", e.END_MOVE_TEXT_CARET = "END_MOVE_TEXT_CARET", e.END_PANNING = "END_PANNING", e.END_RESIZE_ELEMENT = "END_RESIZE_ELEMENT", e.END_RIGHT_CLICK_MOVE = "END_RIGHT_CLICK_MOVE", e.END_ROTATE_ELEMENT = "END_ROTATE_ELEMENT", e.END_SCALE_ELEMENT = "END_SCALE_ELEMENT", e.END_ZOOM_TO_SELECTION = "END_ZOOM_TO_SELECTION", e.ENTER_PROTOTYPE_MODE = "ENTER_PROTOTYPE_MODE", e.ENTER_PROTOTYPE_MODE_FULL_SCREEN = "ENTER_PROTOTYPE_MODE_FULL_SCREEN", e.EXIT_EDITOR = "EXIT_EDITOR", e.EXIT_PROTOTYPE_MODE = "EXIT_PROTOTYPE_MODE", e.EXPAND_TEXT_SELECTION = "EXPAND_TEXT_SELECTION", e.EXPAND_TEXT_SELECTION_KEY = "EXPAND_TEXT_SELECTION_KEY", e.EXPAND_TEXT_SELECTION_TO_LINE_START = "EXPAND_TEXT_SELECTION_TO_LINE_START", e.EXPAND_TEXT_SELECTION_TO_NEXT_WORD_KEY = "EXPAND_TEXT_SELECTION_TO_NEXT_WORD_KEY", e.EXPAND_TEXT_SELECTION_TO_TEXT_START = "EXPAND_TEXT_SELECTION_TO_TEXT_START", e.EXPORT_FINISH = "EXPORT_FINISH", e.EXPORT_MEDIA = "EXPORT_MEDIA", e.EXPORT_PROGRESS = "EXPORT_PROGRESS", e.GROUP_ELEMENTS = "GROUP_ELEMENTS", e.HOVER_BOX_HANDLE = "HOVER_BOX_HANDLE", e.HOVER_CELL = "HOVER_CELL", e.HOVER_CELL_WITH_SELECTION = "HOVER_CELL_WITH_SELECTION", e.HOVER_CREATE_PATH = "HOVER_CREATE_PATH", e.HOVER_DEEP_ELEMENT = "HOVER_DEEP_ELEMENT", e.HOVER_ELEMENT = "HOVER_ELEMENT", e.HOVER_GRADIENT_HANDLE = "HOVER_GRADIENT_HANDLE", e.HOVER_GUIDELINE = "HOVER_GUIDELINE", e.HOVER_MOTION_POINT = "HOVER_MOTION_POINT", e.HOVER_MOTION_SEGMENT = "HOVER_MOTION_SEGMENT", e.HOVER_ORIGIN = "HOVER_ORIGIN", e.HOVER_RULER = "HOVER_RULER", e.HOVER_SCROLLBAR = "HOVER_SCROLLBAR", e.INCREASE_CORNER_RADIUS = "INCREASE_CORNER_RADIUS", e.INSERT_ELEMENT = "INSERT_ELEMENT", e.INSERT_IMAGE = "INSERT_IMAGE", e.INSERT_SVG = "INSERT_SVG", e.LEAVE_VERSION_PREVIEW = "LEAVE_VERSION_PREVIEW", e.MAC_ZOOM_TO_POINTER = "MAC_ZOOM_TO_POINTER", e.MASK_GROUP_ELEMENTS = "MASK_GROUP_ELEMENTS", e.MOBILE_PINCH_ZOOM_TO_POINTER = "MOBILE_PINCH_ZOOM_TO_POINTER", e.MOBILE_TOUCH_PAN = "MOBILE_TOUCH_PAN", e.MOVE_BACKWARD = "MOVE_BACKWARD", e.MOVE_CELL_SELECTION_KEY = "MOVE_CELL_SELECTION_KEY", e.MOVE_ELEMENT_SELECTION_KEY = "MOVE_ELEMENT_SELECTION_KEY", e.MOVE_FORWARD = "MOVE_FORWARD", e.MOVE_GRADIENT_HANDLE_KEY = "MOVE_GRADIENT_HANDLE_KEY", e.MOVE_MOTION_POINTS_SELECTION_KEY = "MOVE_MOTION_POINTS_SELECTION_KEY", e.MOVE_TEXT_CARET_KEY = "MOVE_TEXT_CARET_KEY", e.MOVE_TEXT_CARET_TO_LINE_START = "MOVE_TEXT_CARET_TO_LINE_START", e.MOVE_TEXT_CARET_TO_NEXT_WORD_KEY = "MOVE_TEXT_CARET_TO_NEXT_WORD_KEY", e.MOVE_TEXT_CARET_TO_TEXT_START = "MOVE_TEXT_CARET_TO_TEXT_START", e.MOVE_VIEWPORT_KEY = "MOVE_VIEWPORT_KEY", e.MOVE_VIEWPORT_WHEEL = "MOVE_VIEWPORT_WHEEL", e.OPEN_CANVAS_CONTEXT_MENU = "OPEN_CANVAS_CONTEXT_MENU", e.OPEN_ELEMENT_CONTEXT_MENU = "OPEN_ELEMENT_CONTEXT_MENU", e.PASTE = "PASTE", e.PASTE_WITH_FILES = "PASTE_WITH_FILES", e.PAUSE_ANIMATION = "PAUSE_ANIMATION", e.PLAY_ANIMATION = "PLAY_ANIMATION", e.REDO = "REDO", e.RENAME_ELEMENT = "RENAME_ELEMENT", e.RESET_ANIMATION = "RESET_ANIMATION", e.RESET_GRADIENT_STOP_ACTIVE_INDEX = "RESET_GRADIENT_STOP_ACTIVE_INDEX", e.RESTART_PROTOTYPE = "RESTART_PROTOTYPE", e.RESUME_TEXT_EDIT_MODE = "RESUME_TEXT_EDIT_MODE", e.SELECT_ALL_CELLS = "SELECT_ALL_CELLS", e.SELECT_ALL_ELEMENTS = "SELECT_ALL_ELEMENTS", e.SELECT_ALL_MOTION_POINTS = "SELECT_ALL_MOTION_POINTS", e.SELECT_ALL_TEXT = "SELECT_ALL_TEXT", e.SELECT_CELL = "SELECT_CELL", e.SELECT_CHILD_ELEMENT = "SELECT_CHILD_ELEMENT", e.SELECT_ELEMENT = "SELECT_ELEMENT", e.SELECT_FIRST_ELEMENT = "SELECT_FIRST_ELEMENT", e.SELECT_GRADIENT_HANDLE = "SELECT_GRADIENT_HANDLE", e.SELECT_MOTION_POINT = "SELECT_MOTION_POINT", e.SELECT_NEXT_ELEMENT = "SELECT_NEXT_ELEMENT", e.SELECT_PARENT_ELEMENT = "SELECT_PARENT_ELEMENT", e.SELECT_PREVIOUS_ELEMENT = "SELECT_PREVIOUS_ELEMENT", e.SEND_TO_BACK = "SEND_TO_BACK", e.SET_CURSOR_OVERLAY = "SET_CURSOR_OVERLAY", e.SET_LOCK_GUIDES = "SET_LOCK_GUIDES", e.SHOW_CONFIRMATION = "SHOW_CONFIRMATION", e.SHOW_NOTIFICATION = "SHOW_NOTIFICATION", e.START_AREA_SELECT_CELL = "START_AREA_SELECT_CELL", e.START_AREA_SELECT_ELEMENT = "START_AREA_SELECT_ELEMENT", e.START_CREATE_ELEMENT = "START_CREATE_ELEMENT", e.START_CREATE_GUIDE = "START_CREATE_GUIDE", e.START_DRAG_CELL = "START_DRAG_CELL", e.START_DRAG_ELEMENT = "START_DRAG_ELEMENT", e.START_DRAG_GRADIENT_HANDLE = "START_DRAG_GRADIENT_HANDLE", e.START_DRAG_MOTION_POINT = "START_DRAG_MOTION_POINT", e.START_DRAG_MOTION_SEGMENT = "START_DRAG_MOTION_SEGMENT", e.START_DRAG_MULTI_ELEMENTS = "START_DRAG_MULTI_ELEMENTS", e.START_DRAG_ORIGIN = "START_DRAG_ORIGIN", e.START_DRAG_SCROLLBAR = "START_DRAG_SCROLLBAR", e.START_DRAW_PATH = "START_DRAW_PATH", e.START_DRAW_PATH_ON_EDGE = "START_DRAW_PATH_ON_EDGE", e.START_DRAW_PATH_ON_VERTEX = "START_DRAW_PATH_ON_VERTEX", e.START_EXPAND_TEXT_SELECTION = "START_EXPAND_TEXT_SELECTION", e.START_LEFT_CLICK_MOVE = "START_LEFT_CLICK_MOVE", e.START_MOVE_GUIDE = "START_MOVE_GUIDE", e.START_MOVE_GUIDE_WO_SELECT = "START_MOVE_GUIDE_WO_SELECT", e.START_MOVE_SCROLLBAR = "START_MOVE_SCROLLBAR", e.START_MOVE_TEXT_CARET = "START_MOVE_TEXT_CARET", e.START_PANNING = "START_PANNING", e.START_RESIZE_ELEMENT = "START_RESIZE_ELEMENT", e.START_RIGHT_CLICK_MOVE = "START_RIGHT_CLICK_MOVE", e.START_ROTATE_ELEMENT = "START_ROTATE_ELEMENT", e.START_SCALE_ELEMENT = "START_SCALE_ELEMENT", e.START_ZOOM_TO_SELECTION = "START_ZOOM_TO_SELECTION", e.STOP_ANIMATION = "STOP_ANIMATION", e.SWITCH_BEND_TOOL = "SWITCH_BEND_TOOL", e.SWITCH_DOCUMENT_MODE = "SWITCH_DOCUMENT_MODE", e.SWITCH_MODE = "SWITCH_MODE", e.SWITCH_TEXT_ELEMENT = "SWITCH_TEXT_ELEMENT", e.SWITCH_VIEW_MODE = "SWITCH_VIEW_MODE", e.TEXT_INSERT_NEW_LINE = "TEXT_INSERT_NEW_LINE", e.TOGGLE_ACTION_PANEL = "TOGGLE_ACTION_PANEL", e.TOGGLE_CELL_SELECTION = "TOGGLE_CELL_SELECTION", e.TOGGLE_COMMENT_VISIBILITY = "TOGGLE_COMMENT_VISIBILITY", e.TOGGLE_EXPAND = "TOGGLE_EXPAND", e.TOGGLE_INSPECTING = "TOGGLE_INSPECTING", e.TOGGLE_INTERFACE = "TOGGLE_INTERFACE", e.TOGGLE_LOCK = "TOGGLE_LOCK", e.TOGGLE_ORIGIN = "TOGGLE_ORIGIN", e.TOGGLE_PRESENCE = "TOGGLE_PRESENCE", e.TOGGLE_RULER = "TOGGLE_RULER", e.TOGGLE_SNAP_TO_OBJECT = "TOGGLE_SNAP_TO_OBJECT", e.TOGGLE_SNAP_TO_PIXEL_GRID = "TOGGLE_SNAP_TO_PIXEL_GRID", e.TOGGLE_VISIBLE = "TOGGLE_VISIBLE", e.TRACKPAD_ZOOM_TO_POINTER = "TRACKPAD_ZOOM_TO_POINTER", e.UNDO = "UNDO", e.UNGROUP_ELEMENTS = "UNGROUP_ELEMENTS", e.UPDATE_AREA_SELECT_CELL = "UPDATE_AREA_SELECT_CELL", e.UPDATE_AREA_SELECT_ELEMENT = "UPDATE_AREA_SELECT_ELEMENT", e.UPDATE_CREATE_ELEMENT = "UPDATE_CREATE_ELEMENT", e.UPDATE_CREATE_GUIDE = "UPDATE_CREATE_GUIDE", e.UPDATE_DRAG_CELL = "UPDATE_DRAG_CELL", e.UPDATE_DRAG_ELEMENT = "UPDATE_DRAG_ELEMENT", e.UPDATE_DRAG_GRADIENT_HANDLE = "UPDATE_DRAG_GRADIENT_HANDLE", e.UPDATE_DRAG_MOTION_POINT = "UPDATE_DRAG_MOTION_POINT", e.UPDATE_DRAG_MOTION_SEGMENT = "UPDATE_DRAG_MOTION_SEGMENT", e.UPDATE_DRAG_MULTI_ELEMENTS = "UPDATE_DRAG_MULTI_ELEMENTS", e.UPDATE_DRAG_ORIGIN = "UPDATE_DRAG_ORIGIN", e.UPDATE_DRAG_SCROLLBAR = "UPDATE_DRAG_SCROLLBAR", e.UPDATE_DRAW_PATH = "UPDATE_DRAW_PATH", e.UPDATE_DRAW_PATH_ON_EDGE = "UPDATE_DRAW_PATH_ON_EDGE", e.UPDATE_DRAW_PATH_ON_VERTEX = "UPDATE_DRAW_PATH_ON_VERTEX", e.UPDATE_EXPAND_TEXT_SELECTION = "UPDATE_EXPAND_TEXT_SELECTION", e.UPDATE_LEFT_CLICK_MOVE = "UPDATE_LEFT_CLICK_MOVE", e.UPDATE_MOVE_GUIDE = "UPDATE_MOVE_GUIDE", e.UPDATE_MOVE_GUIDE_WO_SELECT = "UPDATE_MOVE_GUIDE_WO_SELECT", e.UPDATE_MOVE_SCROLLBAR = "UPDATE_MOVE_SCROLLBAR", e.UPDATE_MOVE_TEXT_CARET = "UPDATE_MOVE_TEXT_CARET", e.UPDATE_PANNING = "UPDATE_PANNING", e.UPDATE_RESIZE_ELEMENT = "UPDATE_RESIZE_ELEMENT", e.UPDATE_RIGHT_CLICK_MOVE = "UPDATE_RIGHT_CLICK_MOVE", e.UPDATE_ROTATE_ELEMENT = "UPDATE_ROTATE_ELEMENT", e.UPDATE_SCALE_ELEMENT = "UPDATE_SCALE_ELEMENT", e.UPDATE_ZOOM_TO_SELECTION = "UPDATE_ZOOM_TO_SELECTION", e.WHEEL_PAN_VIEWPORT = "WHEEL_PAN_VIEWPORT", e.WHEEL_ZOOM_TO_POINTER = "WHEEL_ZOOM_TO_POINTER", e.ZOOM_CENTER_SELECTION = "ZOOM_CENTER_SELECTION", e.ZOOM_FIT_CONTENT = "ZOOM_FIT_CONTENT", e.ZOOM_FIT_HEIGHT = "ZOOM_FIT_HEIGHT", e.ZOOM_FIT_SELECTION = "ZOOM_FIT_SELECTION", e.ZOOM_FIT_WIDTH = "ZOOM_FIT_WIDTH", e.ZOOM_IN = "ZOOM_IN", e.ZOOM_OUT = "ZOOM_OUT", e.ZOOM_RESET = "ZOOM_RESET", e.ZOOM_TO_POINTER = "ZOOM_TO_POINTER", e.ZOOM_TO_VALUE = "ZOOM_TO_VALUE";
})(Y || (Y = {}));
var HE;
(function(e) {
  e.NONE = "NONE", e.SCREEN = "SCREEN", e.CONTAINER = "CONTAINER", e.TEXT = "TEXT", e.RECTANGLE = "RECTANGLE", e.ELLIPSE = "ELLIPSE", e.POLYGON = "POLYGON", e.REGULAR_POLYGON = "REGULAR_POLYGON", e.STAR = "STAR", e.LINE = "LINE", e.MULTIPLE = "MULTIPLE";
})(HE || (HE = {}));
const { abs: hl, cos: Yr, sin: oc, acos: cP, atan2: ul, sqrt: Co, pow: Gi } = Math;
function dl(e) {
  return e < 0 ? -Gi(-e, 1 / 3) : Gi(e, 1 / 3);
}
const M1 = Math.PI, Iu = 2 * M1, No = M1 / 2, lP = 1e-6, Up = Number.MAX_SAFE_INTEGER || 9007199254740991, Gp = Number.MIN_SAFE_INTEGER || -9007199254740991, hP = { x: 0, y: 0, z: 0 }, _e = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(e, n) {
    const s = n(e);
    let i = s.x * s.x + s.y * s.y;
    return typeof s.z < "u" && (i += s.z * s.z), Co(i);
  },
  compute: function(e, n, s) {
    if (e === 0)
      return n[0].t = 0, n[0];
    const i = n.length - 1;
    if (e === 1)
      return n[i].t = 1, n[i];
    const r = 1 - e;
    let o = n;
    if (i === 0)
      return n[0].t = e, n[0];
    if (i === 1) {
      const c = {
        x: r * o[0].x + e * o[1].x,
        y: r * o[0].y + e * o[1].y,
        t: e
      };
      return s && (c.z = r * o[0].z + e * o[1].z), c;
    }
    if (i < 4) {
      let c = r * r, l = e * e, h, d, p, E = 0;
      i === 2 ? (o = [o[0], o[1], o[2], hP], h = c, d = r * e * 2, p = l) : i === 3 && (h = c * r, d = c * e * 3, p = r * l * 3, E = e * l);
      const g = {
        x: h * o[0].x + d * o[1].x + p * o[2].x + E * o[3].x,
        y: h * o[0].y + d * o[1].y + p * o[2].y + E * o[3].y,
        t: e
      };
      return s && (g.z = h * o[0].z + d * o[1].z + p * o[2].z + E * o[3].z), g;
    }
    const a = JSON.parse(JSON.stringify(n));
    for (; a.length > 1; ) {
      for (let c = 0; c < a.length - 1; c++)
        a[c] = {
          x: a[c].x + (a[c + 1].x - a[c].x) * e,
          y: a[c].y + (a[c + 1].y - a[c].y) * e
        }, typeof a[c].z < "u" && (a[c].z = a[c].z + (a[c + 1].z - a[c].z) * e);
      a.splice(a.length - 1, 1);
    }
    return a[0].t = e, a[0];
  },
  computeWithRatios: function(e, n, s, i) {
    const r = 1 - e, o = s, a = n;
    let c = o[0], l = o[1], h = o[2], d = o[3], p;
    if (c *= r, l *= e, a.length === 2)
      return p = c + l, {
        x: (c * a[0].x + l * a[1].x) / p,
        y: (c * a[0].y + l * a[1].y) / p,
        z: i ? (c * a[0].z + l * a[1].z) / p : !1,
        t: e
      };
    if (c *= r, l *= 2 * r, h *= e * e, a.length === 3)
      return p = c + l + h, {
        x: (c * a[0].x + l * a[1].x + h * a[2].x) / p,
        y: (c * a[0].y + l * a[1].y + h * a[2].y) / p,
        z: i ? (c * a[0].z + l * a[1].z + h * a[2].z) / p : !1,
        t: e
      };
    if (c *= r, l *= 1.5 * r, h *= 3 * r, d *= e * e * e, a.length === 4)
      return p = c + l + h + d, {
        x: (c * a[0].x + l * a[1].x + h * a[2].x + d * a[3].x) / p,
        y: (c * a[0].y + l * a[1].y + h * a[2].y + d * a[3].y) / p,
        z: i ? (c * a[0].z + l * a[1].z + h * a[2].z + d * a[3].z) / p : !1,
        t: e
      };
  },
  derive: function(e, n) {
    const s = [];
    for (let i = e, r = i.length, o = r - 1; r > 1; r--, o--) {
      const a = [];
      for (let c = 0, l; c < o; c++)
        l = {
          x: o * (i[c + 1].x - i[c].x),
          y: o * (i[c + 1].y - i[c].y)
        }, n && (l.z = o * (i[c + 1].z - i[c].z)), a.push(l);
      s.push(a), i = a;
    }
    return s;
  },
  between: function(e, n, s) {
    return n <= e && e <= s || _e.approximately(e, n) || _e.approximately(e, s);
  },
  approximately: function(e, n, s) {
    return hl(e - n) <= (s || lP);
  },
  length: function(e) {
    const s = _e.Tvalues.length;
    let i = 0;
    for (let r = 0, o; r < s; r++)
      o = 0.5 * _e.Tvalues[r] + 0.5, i += _e.Cvalues[r] * _e.arcfn(o, e);
    return 0.5 * i;
  },
  map: function(e, n, s, i, r) {
    const o = s - n, a = r - i, c = e - n, l = c / o;
    return i + a * l;
  },
  lerp: function(e, n, s) {
    const i = {
      x: n.x + e * (s.x - n.x),
      y: n.y + e * (s.y - n.y)
    };
    return n.z !== void 0 && s.z !== void 0 && (i.z = n.z + e * (s.z - n.z)), i;
  },
  pointToString: function(e) {
    let n = e.x + "/" + e.y;
    return typeof e.z < "u" && (n += "/" + e.z), n;
  },
  pointsToString: function(e) {
    return "[" + e.map(_e.pointToString).join(", ") + "]";
  },
  copy: function(e) {
    return JSON.parse(JSON.stringify(e));
  },
  angle: function(e, n, s) {
    const i = n.x - e.x, r = n.y - e.y, o = s.x - e.x, a = s.y - e.y, c = i * a - r * o, l = i * o + r * a;
    return ul(c, l);
  },
  // round as string, to avoid rounding errors
  round: function(e, n) {
    const s = "" + e, i = s.indexOf(".");
    return parseFloat(s.substring(0, i + 1 + n));
  },
  dist: function(e, n) {
    const s = e.x - n.x, i = e.y - n.y;
    return Co(s * s + i * i);
  },
  closest: function(e, n) {
    let s = Gi(2, 63), i, r;
    return e.forEach(function(o, a) {
      r = _e.dist(n, o), r < s && (s = r, i = a);
    }), { mdist: s, mpos: i };
  },
  abcratio: function(e, n) {
    if (n !== 2 && n !== 3)
      return !1;
    if (typeof e > "u")
      e = 0.5;
    else if (e === 0 || e === 1)
      return e;
    const s = Gi(e, n) + Gi(1 - e, n), i = s - 1;
    return hl(i / s);
  },
  projectionratio: function(e, n) {
    if (n !== 2 && n !== 3)
      return !1;
    if (typeof e > "u")
      e = 0.5;
    else if (e === 0 || e === 1)
      return e;
    const s = Gi(1 - e, n), i = Gi(e, n) + s;
    return s / i;
  },
  lli8: function(e, n, s, i, r, o, a, c) {
    const l = (e * i - n * s) * (r - a) - (e - s) * (r * c - o * a), h = (e * i - n * s) * (o - c) - (n - i) * (r * c - o * a), d = (e - s) * (o - c) - (n - i) * (r - a);
    return d == 0 ? !1 : { x: l / d, y: h / d };
  },
  lli4: function(e, n, s, i) {
    const r = e.x, o = e.y, a = n.x, c = n.y, l = s.x, h = s.y, d = i.x, p = i.y;
    return _e.lli8(r, o, a, c, l, h, d, p);
  },
  lli: function(e, n) {
    return _e.lli4(e, e.c, n, n.c);
  },
  makeline: function(e, n) {
    return new Bt(
      e.x,
      e.y,
      (e.x + n.x) / 2,
      (e.y + n.y) / 2,
      n.x,
      n.y
    );
  },
  findbbox: function(e) {
    let n = Up, s = Up, i = Gp, r = Gp;
    return e.forEach(function(o) {
      const a = o.bbox();
      n > a.x.min && (n = a.x.min), s > a.y.min && (s = a.y.min), i < a.x.max && (i = a.x.max), r < a.y.max && (r = a.y.max);
    }), {
      x: { min: n, mid: (n + i) / 2, max: i, size: i - n },
      y: { min: s, mid: (s + r) / 2, max: r, size: r - s }
    };
  },
  shapeintersections: function(e, n, s, i, r) {
    if (!_e.bboxoverlap(n, i)) return [];
    const o = [], a = [e.startcap, e.forward, e.back, e.endcap], c = [s.startcap, s.forward, s.back, s.endcap];
    return a.forEach(function(l) {
      l.virtual || c.forEach(function(h) {
        if (h.virtual) return;
        const d = l.intersects(h, r);
        d.length > 0 && (d.c1 = l, d.c2 = h, d.s1 = e, d.s2 = s, o.push(d));
      });
    }), o;
  },
  makeshape: function(e, n, s) {
    const i = n.points.length, r = e.points.length, o = _e.makeline(n.points[i - 1], e.points[0]), a = _e.makeline(e.points[r - 1], n.points[0]), c = {
      startcap: o,
      forward: e,
      back: n,
      endcap: a,
      bbox: _e.findbbox([o, e, n, a])
    };
    return c.intersections = function(l) {
      return _e.shapeintersections(
        c,
        c.bbox,
        l,
        l.bbox,
        s
      );
    }, c;
  },
  getminmax: function(e, n, s) {
    if (!s) return { min: 0, max: 0 };
    let i = Up, r = Gp, o, a;
    s.indexOf(0) === -1 && (s = [0].concat(s)), s.indexOf(1) === -1 && s.push(1);
    for (let c = 0, l = s.length; c < l; c++)
      o = s[c], a = e.get(o), a[n] < i && (i = a[n]), a[n] > r && (r = a[n]);
    return { min: i, mid: (i + r) / 2, max: r, size: r - i };
  },
  align: function(e, n) {
    const s = n.p1.x, i = n.p1.y, r = -ul(n.p2.y - i, n.p2.x - s), o = function(a) {
      return {
        x: (a.x - s) * Yr(r) - (a.y - i) * oc(r),
        y: (a.x - s) * oc(r) + (a.y - i) * Yr(r)
      };
    };
    return e.map(o);
  },
  roots: function(e, n) {
    n = n || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const s = e.length - 1, i = _e.align(e, n), r = function(L) {
      return 0 <= L && L <= 1;
    };
    if (s === 2) {
      const L = i[0].y, P = i[1].y, k = i[2].y, Q = L - 2 * P + k;
      if (Q !== 0) {
        const b = -Co(P * P - L * k), X = -L + P, K = -(b + X) / Q, V = -(-b + X) / Q;
        return [K, V].filter(r);
      } else if (P !== k && Q === 0)
        return [(2 * P - k) / (2 * P - 2 * k)].filter(r);
      return [];
    }
    const o = i[0].y, a = i[1].y, c = i[2].y, l = i[3].y;
    let h = -o + 3 * a - 3 * c + l, d = 3 * o - 6 * a + 3 * c, p = -3 * o + 3 * a, E = o;
    if (_e.approximately(h, 0)) {
      if (_e.approximately(d, 0))
        return _e.approximately(p, 0) ? [] : [-E / p].filter(r);
      const L = Co(p * p - 4 * d * E), P = 2 * d;
      return [(L - p) / P, (-p - L) / P].filter(r);
    }
    d /= h, p /= h, E /= h;
    const g = (3 * p - d * d) / 3, T = g / 3, A = (2 * d * d * d - 9 * d * p + 27 * E) / 27, m = A / 2, O = m * m + T * T * T;
    let S, y, v, R, M;
    if (O < 0) {
      const L = -g / 3, P = L * L * L, k = Co(P), Q = -A / (2 * k), b = Q < -1 ? -1 : Q > 1 ? 1 : Q, X = cP(b), K = dl(k), V = 2 * K;
      return v = V * Yr(X / 3) - d / 3, R = V * Yr((X + Iu) / 3) - d / 3, M = V * Yr((X + 2 * Iu) / 3) - d / 3, [v, R, M].filter(r);
    } else {
      if (O === 0)
        return S = m < 0 ? dl(-m) : -dl(m), v = 2 * S - d / 3, R = -S - d / 3, [v, R].filter(r);
      {
        const L = Co(O);
        return S = dl(-m + L), y = dl(m + L), [S - y - d / 3].filter(r);
      }
    }
  },
  droots: function(e) {
    if (e.length === 3) {
      const n = e[0], s = e[1], i = e[2], r = n - 2 * s + i;
      if (r !== 0) {
        const o = -Co(s * s - n * i), a = -n + s, c = -(o + a) / r, l = -(-o + a) / r;
        return [c, l];
      } else if (s !== i && r === 0)
        return [(2 * s - i) / (2 * (s - i))];
      return [];
    }
    if (e.length === 2) {
      const n = e[0], s = e[1];
      return n !== s ? [n / (n - s)] : [];
    }
    return [];
  },
  curvature: function(e, n, s, i, r) {
    let o, a, c, l, h = 0, d = 0;
    const p = _e.compute(e, n), E = _e.compute(e, s), g = p.x * p.x + p.y * p.y;
    if (i ? (o = Co(
      Gi(p.y * E.z - E.y * p.z, 2) + Gi(p.z * E.x - E.z * p.x, 2) + Gi(p.x * E.y - E.x * p.y, 2)
    ), a = Gi(g + p.z * p.z, 3 / 2)) : (o = p.x * E.y - p.y * E.x, a = Gi(g, 3 / 2)), o === 0 || a === 0)
      return { k: 0, r: 0 };
    if (h = o / a, d = a / o, !r) {
      const T = _e.curvature(e - 1e-3, n, s, i, !0).k, A = _e.curvature(e + 1e-3, n, s, i, !0).k;
      l = (A - h + (h - T)) / 2, c = (hl(A - h) + hl(h - T)) / 2;
    }
    return { k: h, r: d, dk: l, adk: c };
  },
  inflections: function(e) {
    if (e.length < 4) return [];
    const n = _e.align(e, { p1: e[0], p2: e.slice(-1)[0] }), s = n[2].x * n[1].y, i = n[3].x * n[1].y, r = n[1].x * n[2].y, o = n[3].x * n[2].y, a = 18 * (-3 * s + 2 * i + 3 * r - o), c = 18 * (3 * s - i - 3 * r), l = 18 * (r - s);
    if (_e.approximately(a, 0)) {
      if (!_e.approximately(c, 0)) {
        let E = -l / c;
        if (0 <= E && E <= 1) return [E];
      }
      return [];
    }
    const h = 2 * a;
    if (_e.approximately(h, 0)) return [];
    const d = c * c - 4 * a * l;
    if (d < 0) return [];
    const p = Math.sqrt(d);
    return [(p - c) / h, -(c + p) / h].filter(function(E) {
      return 0 <= E && E <= 1;
    });
  },
  bboxoverlap: function(e, n) {
    const s = ["x", "y"], i = s.length;
    for (let r = 0, o, a, c, l; r < i; r++)
      if (o = s[r], a = e[o].mid, c = n[o].mid, l = (e[o].size + n[o].size) / 2, hl(a - c) >= l) return !1;
    return !0;
  },
  expandbox: function(e, n) {
    n.x.min < e.x.min && (e.x.min = n.x.min), n.y.min < e.y.min && (e.y.min = n.y.min), n.z && n.z.min < e.z.min && (e.z.min = n.z.min), n.x.max > e.x.max && (e.x.max = n.x.max), n.y.max > e.y.max && (e.y.max = n.y.max), n.z && n.z.max > e.z.max && (e.z.max = n.z.max), e.x.mid = (e.x.min + e.x.max) / 2, e.y.mid = (e.y.min + e.y.max) / 2, e.z && (e.z.mid = (e.z.min + e.z.max) / 2), e.x.size = e.x.max - e.x.min, e.y.size = e.y.max - e.y.min, e.z && (e.z.size = e.z.max - e.z.min);
  },
  pairiteration: function(e, n, s) {
    const i = e.bbox(), r = n.bbox(), o = 1e5, a = s || 0.5;
    if (i.x.size + i.y.size < a && r.x.size + r.y.size < a)
      return [
        (o * (e._t1 + e._t2) / 2 | 0) / o + "/" + (o * (n._t1 + n._t2) / 2 | 0) / o
      ];
    let c = e.split(0.5), l = n.split(0.5), h = [
      { left: c.left, right: l.left },
      { left: c.left, right: l.right },
      { left: c.right, right: l.right },
      { left: c.right, right: l.left }
    ];
    h = h.filter(function(p) {
      return _e.bboxoverlap(p.left.bbox(), p.right.bbox());
    });
    let d = [];
    return h.length === 0 || (h.forEach(function(p) {
      d = d.concat(
        _e.pairiteration(p.left, p.right, a)
      );
    }), d = d.filter(function(p, E) {
      return d.indexOf(p) === E;
    })), d;
  },
  getccenter: function(e, n, s) {
    const i = n.x - e.x, r = n.y - e.y, o = s.x - n.x, a = s.y - n.y, c = i * Yr(No) - r * oc(No), l = i * oc(No) + r * Yr(No), h = o * Yr(No) - a * oc(No), d = o * oc(No) + a * Yr(No), p = (e.x + n.x) / 2, E = (e.y + n.y) / 2, g = (n.x + s.x) / 2, T = (n.y + s.y) / 2, A = p + c, m = E + l, O = g + h, S = T + d, y = _e.lli8(p, E, A, m, g, T, O, S), v = _e.dist(y, e);
    let R = ul(e.y - y.y, e.x - y.x), M = ul(n.y - y.y, n.x - y.x), L = ul(s.y - y.y, s.x - y.x), P;
    return R < L ? ((R > M || M > L) && (R += Iu), R > L && (P = L, L = R, R = P)) : L < M && M < R ? (P = L, L = R, R = P) : L += Iu, y.s = R, y.e = L, y.r = v, y;
  },
  numberSort: function(e, n) {
    return e - n;
  }
};
class Hl {
  constructor(n) {
    this.curves = [], this._3d = !1, n && (this.curves = n, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(n) {
      return _e.pointsToString(n.points);
    }).join(", ") + "]";
  }
  addCurve(n) {
    this.curves.push(n), this._3d = this._3d || n._3d;
  }
  length() {
    return this.curves.map(function(n) {
      return n.length();
    }).reduce(function(n, s) {
      return n + s;
    });
  }
  curve(n) {
    return this.curves[n];
  }
  bbox() {
    const n = this.curves;
    for (var s = n[0].bbox(), i = 1; i < n.length; i++)
      _e.expandbox(s, n[i].bbox());
    return s;
  }
  offset(n) {
    const s = [];
    return this.curves.forEach(function(i) {
      s.push(...i.offset(n));
    }), new Hl(s);
  }
}
const { abs: fl, min: JA, max: $A, cos: uP, sin: dP, acos: fP, sqrt: pl } = Math, pP = Math.PI;
class Bt {
  constructor(n) {
    let s = n && n.forEach ? n : Array.from(arguments).slice(), i = !1;
    if (typeof s[0] == "object") {
      i = s.length;
      const g = [];
      s.forEach(function(T) {
        ["x", "y", "z"].forEach(function(A) {
          typeof T[A] < "u" && g.push(T[A]);
        });
      }), s = g;
    }
    let r = !1;
    const o = s.length;
    if (i) {
      if (i > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        r = !0;
      }
    } else if (o !== 6 && o !== 8 && o !== 9 && o !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const a = this._3d = !r && (o === 9 || o === 12) || n && n[0] && typeof n[0].z < "u", c = this.points = [];
    for (let g = 0, T = a ? 3 : 2; g < o; g += T) {
      var l = {
        x: s[g],
        y: s[g + 1]
      };
      a && (l.z = s[g + 2]), c.push(l);
    }
    const h = this.order = c.length - 1, d = this.dims = ["x", "y"];
    a && d.push("z"), this.dimlen = d.length;
    const p = _e.align(c, { p1: c[0], p2: c[h] }), E = _e.dist(c[0], c[h]);
    this._linear = p.reduce((g, T) => g + fl(T.y), 0) < E / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(n, s, i, r) {
    if (typeof r > "u" && (r = 0.5), r === 0)
      return new Bt(s, s, i);
    if (r === 1)
      return new Bt(n, s, s);
    const o = Bt.getABC(2, n, s, i, r);
    return new Bt(n, o.A, i);
  }
  static cubicFromPoints(n, s, i, r, o) {
    typeof r > "u" && (r = 0.5);
    const a = Bt.getABC(3, n, s, i, r);
    typeof o > "u" && (o = _e.dist(s, a.C));
    const c = o * (1 - r) / r, l = _e.dist(n, i), h = (i.x - n.x) / l, d = (i.y - n.y) / l, p = o * h, E = o * d, g = c * h, T = c * d, A = { x: s.x - p, y: s.y - E }, m = { x: s.x + g, y: s.y + T }, O = a.A, S = { x: O.x + (A.x - O.x) / (1 - r), y: O.y + (A.y - O.y) / (1 - r) }, y = { x: O.x + (m.x - O.x) / r, y: O.y + (m.y - O.y) / r }, v = { x: n.x + (S.x - n.x) / r, y: n.y + (S.y - n.y) / r }, R = {
      x: i.x + (y.x - i.x) / (1 - r),
      y: i.y + (y.y - i.y) / (1 - r)
    };
    return new Bt(n, v, R, i);
  }
  static getUtils() {
    return _e;
  }
  getUtils() {
    return Bt.getUtils();
  }
  static get PolyBezier() {
    return Hl;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return _e.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const n = this.points, s = n[0].x, i = n[0].y, r = ["M", s, i, this.order === 2 ? "Q" : "C"];
    for (let o = 1, a = n.length; o < a; o++)
      r.push(n[o].x), r.push(n[o].y);
    return r.join(" ");
  }
  setRatios(n) {
    if (n.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = n, this._lut = [];
  }
  verify() {
    const n = this.coordDigest();
    n !== this._print && (this._print = n, this.update());
  }
  coordDigest() {
    return this.points.map(function(n, s) {
      return "" + s + n.x + n.y + (n.z ? n.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = _e.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const n = this.points, s = _e.angle(n[0], n[this.order], n[1]);
    this.clockwise = s > 0;
  }
  length() {
    return _e.length(this.derivative.bind(this));
  }
  static getABC(n = 2, s, i, r, o = 0.5) {
    const a = _e.projectionratio(o, n), c = 1 - a, l = {
      x: a * s.x + c * r.x,
      y: a * s.y + c * r.y
    }, h = _e.abcratio(o, n);
    return { A: {
      x: i.x + (i.x - l.x) / h,
      y: i.y + (i.y - l.y) / h
    }, B: i, C: l, S: s, E: r };
  }
  getABC(n, s) {
    s = s || this.get(n);
    let i = this.points[0], r = this.points[this.order];
    return Bt.getABC(this.order, i, s, r, n);
  }
  getLUT(n) {
    if (this.verify(), n = n || 100, this._lut.length === n + 1)
      return this._lut;
    this._lut = [], n++, this._lut = [];
    for (let s = 0, i, r; s < n; s++)
      r = s / (n - 1), i = this.compute(r), i.t = r, this._lut.push(i);
    return this._lut;
  }
  on(n, s) {
    s = s || 5;
    const i = this.getLUT(), r = [];
    for (let o = 0, a, c = 0; o < i.length; o++)
      a = i[o], _e.dist(a, n) < s && (r.push(a), c += o / i.length);
    return r.length ? t /= r.length : !1;
  }
  project(n) {
    const s = this.getLUT(), i = s.length - 1, r = _e.closest(s, n), o = r.mpos, a = (o - 1) / i, c = (o + 1) / i, l = 0.1 / i;
    let h = r.mdist, d = a, p = d, E;
    h += 1;
    for (let g; d < c + l; d += l)
      E = this.compute(d), g = _e.dist(n, E), g < h && (h = g, p = d);
    return p = p < 0 ? 0 : p > 1 ? 1 : p, E = this.compute(p), E.t = p, E.d = h, E;
  }
  get(n) {
    return this.compute(n);
  }
  point(n) {
    return this.points[n];
  }
  compute(n) {
    return this.ratios ? _e.computeWithRatios(n, this.points, this.ratios, this._3d) : _e.compute(n, this.points, this._3d, this.ratios);
  }
  raise() {
    const n = this.points, s = [n[0]], i = n.length;
    for (let r = 1, o, a; r < i; r++)
      o = n[r], a = n[r - 1], s[r] = {
        x: (i - r) / i * o.x + r / i * a.x,
        y: (i - r) / i * o.y + r / i * a.y
      };
    return s[i] = n[i - 1], new Bt(s);
  }
  derivative(n) {
    return _e.compute(n, this.dpoints[0], this._3d);
  }
  dderivative(n) {
    return _e.compute(n, this.dpoints[1], this._3d);
  }
  align() {
    let n = this.points;
    return new Bt(_e.align(n, { p1: n[0], p2: n[n.length - 1] }));
  }
  curvature(n) {
    return _e.curvature(n, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return _e.inflections(this.points);
  }
  normal(n) {
    return this._3d ? this.__normal3(n) : this.__normal2(n);
  }
  __normal2(n) {
    const s = this.derivative(n), i = pl(s.x * s.x + s.y * s.y);
    return { t: n, x: -s.y / i, y: s.x / i };
  }
  __normal3(n) {
    const s = this.derivative(n), i = this.derivative(n + 0.01), r = pl(s.x * s.x + s.y * s.y + s.z * s.z), o = pl(i.x * i.x + i.y * i.y + i.z * i.z);
    s.x /= r, s.y /= r, s.z /= r, i.x /= o, i.y /= o, i.z /= o;
    const a = {
      x: i.y * s.z - i.z * s.y,
      y: i.z * s.x - i.x * s.z,
      z: i.x * s.y - i.y * s.x
    }, c = pl(a.x * a.x + a.y * a.y + a.z * a.z);
    a.x /= c, a.y /= c, a.z /= c;
    const l = [
      a.x * a.x,
      a.x * a.y - a.z,
      a.x * a.z + a.y,
      a.x * a.y + a.z,
      a.y * a.y,
      a.y * a.z - a.x,
      a.x * a.z - a.y,
      a.y * a.z + a.x,
      a.z * a.z
    ];
    return {
      t: n,
      x: l[0] * s.x + l[1] * s.y + l[2] * s.z,
      y: l[3] * s.x + l[4] * s.y + l[5] * s.z,
      z: l[6] * s.x + l[7] * s.y + l[8] * s.z
    };
  }
  hull(n) {
    let s = this.points, i = [], r = [], o = 0;
    for (r[o++] = s[0], r[o++] = s[1], r[o++] = s[2], this.order === 3 && (r[o++] = s[3]); s.length > 1; ) {
      i = [];
      for (let a = 0, c, l = s.length - 1; a < l; a++)
        c = _e.lerp(n, s[a], s[a + 1]), r[o++] = c, i.push(c);
      s = i;
    }
    return r;
  }
  split(n, s) {
    if (n === 0 && s)
      return this.split(s).left;
    if (s === 1)
      return this.split(n).right;
    const i = this.hull(n), r = {
      left: this.order === 2 ? new Bt([i[0], i[3], i[5]]) : new Bt([i[0], i[4], i[7], i[9]]),
      right: this.order === 2 ? new Bt([i[5], i[4], i[2]]) : new Bt([i[9], i[8], i[6], i[3]]),
      span: i
    };
    return r.left._t1 = _e.map(0, 0, 1, this._t1, this._t2), r.left._t2 = _e.map(n, 0, 1, this._t1, this._t2), r.right._t1 = _e.map(n, 0, 1, this._t1, this._t2), r.right._t2 = _e.map(1, 0, 1, this._t1, this._t2), s ? (s = _e.map(s, n, 1, 0, 1), r.right.split(s).left) : r;
  }
  extrema() {
    const n = {};
    let s = [];
    return this.dims.forEach(
      (function(i) {
        let r = function(a) {
          return a[i];
        }, o = this.dpoints[0].map(r);
        n[i] = _e.droots(o), this.order === 3 && (o = this.dpoints[1].map(r), n[i] = n[i].concat(_e.droots(o))), n[i] = n[i].filter(function(a) {
          return a >= 0 && a <= 1;
        }), s = s.concat(n[i].sort(_e.numberSort));
      }).bind(this)
    ), n.values = s.sort(_e.numberSort).filter(function(i, r) {
      return s.indexOf(i) === r;
    }), n;
  }
  bbox() {
    const n = this.extrema(), s = {};
    return this.dims.forEach(
      (function(i) {
        s[i] = _e.getminmax(this, i, n[i]);
      }).bind(this)
    ), s;
  }
  overlaps(n) {
    const s = this.bbox(), i = n.bbox();
    return _e.bboxoverlap(s, i);
  }
  offset(n, s) {
    if (typeof s < "u") {
      const i = this.get(n), r = this.normal(n), o = {
        c: i,
        n: r,
        x: i.x + r.x * s,
        y: i.y + r.y * s
      };
      return this._3d && (o.z = i.z + r.z * s), o;
    }
    if (this._linear) {
      const i = this.normal(0), r = this.points.map(function(o) {
        const a = {
          x: o.x + n * i.x,
          y: o.y + n * i.y
        };
        return o.z && i.z && (a.z = o.z + n * i.z), a;
      });
      return [new Bt(r)];
    }
    return this.reduce().map(function(i) {
      return i._linear ? i.offset(n)[0] : i.scale(n);
    });
  }
  simple() {
    if (this.order === 3) {
      const r = _e.angle(this.points[0], this.points[3], this.points[1]), o = _e.angle(this.points[0], this.points[3], this.points[2]);
      if (r > 0 && o < 0 || r < 0 && o > 0) return !1;
    }
    const n = this.normal(0), s = this.normal(1);
    let i = n.x * s.x + n.y * s.y;
    return this._3d && (i += n.z * s.z), fl(fP(i)) < pP / 3;
  }
  reduce() {
    let n, s = 0, i = 0, r = 0.01, o, a = [], c = [], l = this.extrema().values;
    for (l.indexOf(0) === -1 && (l = [0].concat(l)), l.indexOf(1) === -1 && l.push(1), s = l[0], n = 1; n < l.length; n++)
      i = l[n], o = this.split(s, i), o._t1 = s, o._t2 = i, a.push(o), s = i;
    return a.forEach(function(h) {
      for (s = 0, i = 0; i <= 1; )
        for (i = s + r; i <= 1 + r; i += r)
          if (o = h.split(s, i), !o.simple()) {
            if (i -= r, fl(s - i) < r)
              return [];
            o = h.split(s, i), o._t1 = _e.map(s, 0, 1, h._t1, h._t2), o._t2 = _e.map(i, 0, 1, h._t1, h._t2), c.push(o), s = i;
            break;
          }
      s < 1 && (o = h.split(s, 1), o._t1 = _e.map(s, 0, 1, h._t1, h._t2), o._t2 = h._t2, c.push(o));
    }), c;
  }
  translate(n, s, i) {
    i = typeof i == "number" ? i : s;
    const r = this.order;
    let o = this.points.map((a, c) => (1 - c / r) * s + c / r * i);
    return new Bt(
      this.points.map((a, c) => ({
        x: a.x + n.x * o[c],
        y: a.y + n.y * o[c]
      }))
    );
  }
  scale(n) {
    const s = this.order;
    let i = !1;
    if (typeof n == "function" && (i = n), i && s === 2)
      return this.raise().scale(i);
    const r = this.clockwise, o = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        i ? i(0) : n,
        i ? i(1) : n
      );
    const a = i ? i(0) : n, c = i ? i(1) : n, l = [this.offset(0, 10), this.offset(1, 10)], h = [], d = _e.lli4(l[0], l[0].c, l[1], l[1].c);
    if (!d)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(p) {
      const E = h[p * s] = _e.copy(o[p * s]);
      E.x += (p ? c : a) * l[p].n.x, E.y += (p ? c : a) * l[p].n.y;
    }), i ? ([0, 1].forEach(function(p) {
      if (!(s === 2 && p)) {
        var E = o[p + 1], g = {
          x: E.x - d.x,
          y: E.y - d.y
        }, T = i ? i((p + 1) / s) : n;
        i && !r && (T = -T);
        var A = pl(g.x * g.x + g.y * g.y);
        g.x /= A, g.y /= A, h[p + 1] = {
          x: E.x + T * g.x,
          y: E.y + T * g.y
        };
      }
    }), new Bt(h)) : ([0, 1].forEach((p) => {
      if (s === 2 && p) return;
      const E = h[p * s], g = this.derivative(p), T = { x: E.x + g.x, y: E.y + g.y };
      h[p + 1] = _e.lli4(E, T, d, o[p + 1]);
    }), new Bt(h));
  }
  outline(n, s, i, r) {
    if (s = s === void 0 ? n : s, this._linear) {
      const R = this.normal(0), M = this.points[0], L = this.points[this.points.length - 1];
      let P, k, Q;
      i === void 0 && (i = n, r = s), P = { x: M.x + R.x * n, y: M.y + R.y * n }, Q = { x: L.x + R.x * i, y: L.y + R.y * i }, k = { x: (P.x + Q.x) / 2, y: (P.y + Q.y) / 2 };
      const b = [P, k, Q];
      P = { x: M.x - R.x * s, y: M.y - R.y * s }, Q = { x: L.x - R.x * r, y: L.y - R.y * r }, k = { x: (P.x + Q.x) / 2, y: (P.y + Q.y) / 2 };
      const X = [Q, k, P], K = _e.makeline(X[2], b[0]), V = _e.makeline(b[2], X[0]), J = [K, new Bt(b), V, new Bt(X)];
      return new Hl(J);
    }
    const o = this.reduce(), a = o.length, c = [];
    let l = [], h, d = 0, p = this.length();
    const E = typeof i < "u" && typeof r < "u";
    function g(R, M, L, P, k) {
      return function(Q) {
        const b = P / L, X = (P + k) / L, K = M - R;
        return _e.map(Q, 0, 1, R + b * K, R + X * K);
      };
    }
    o.forEach(function(R) {
      const M = R.length();
      E ? (c.push(
        R.scale(g(n, i, p, d, M))
      ), l.push(
        R.scale(g(-s, -r, p, d, M))
      )) : (c.push(R.scale(n)), l.push(R.scale(-s))), d += M;
    }), l = l.map(function(R) {
      return h = R.points, h[3] ? R.points = [h[3], h[2], h[1], h[0]] : R.points = [h[2], h[1], h[0]], R;
    }).reverse();
    const T = c[0].points[0], A = c[a - 1].points[c[a - 1].points.length - 1], m = l[a - 1].points[l[a - 1].points.length - 1], O = l[0].points[0], S = _e.makeline(m, T), y = _e.makeline(A, O), v = [S].concat(c).concat([y]).concat(l);
    return new Hl(v);
  }
  outlineshapes(n, s, i) {
    s = s || n;
    const r = this.outline(n, s).curves, o = [];
    for (let a = 1, c = r.length; a < c / 2; a++) {
      const l = _e.makeshape(
        r[a],
        r[c - a],
        i
      );
      l.startcap.virtual = a > 1, l.endcap.virtual = a < c / 2 - 1, o.push(l);
    }
    return o;
  }
  intersects(n, s) {
    return n ? n.p1 && n.p2 ? this.lineIntersects(n) : (n instanceof Bt && (n = n.reduce()), this.curveintersects(
      this.reduce(),
      n,
      s
    )) : this.selfintersects(s);
  }
  lineIntersects(n) {
    const s = JA(n.p1.x, n.p2.x), i = JA(n.p1.y, n.p2.y), r = $A(n.p1.x, n.p2.x), o = $A(n.p1.y, n.p2.y);
    return _e.roots(this.points, n).filter((a) => {
      var c = this.get(a);
      return _e.between(c.x, s, r) && _e.between(c.y, i, o);
    });
  }
  selfintersects(n) {
    const s = this.reduce(), i = s.length - 2, r = [];
    for (let o = 0, a, c, l; o < i; o++)
      c = s.slice(o, o + 1), l = s.slice(o + 2), a = this.curveintersects(c, l, n), r.push(...a);
    return r;
  }
  curveintersects(n, s, i) {
    const r = [];
    n.forEach(function(a) {
      s.forEach(function(c) {
        a.overlaps(c) && r.push({ left: a, right: c });
      });
    });
    let o = [];
    return r.forEach(function(a) {
      const c = _e.pairiteration(
        a.left,
        a.right,
        i
      );
      c.length > 0 && (o = o.concat(c));
    }), o;
  }
  arcs(n) {
    return n = n || 0.5, this._iterate(n, []);
  }
  _error(n, s, i, r) {
    const o = (r - i) / 4, a = this.get(i + o), c = this.get(r - o), l = _e.dist(n, s), h = _e.dist(n, a), d = _e.dist(n, c);
    return fl(h - l) + fl(d - l);
  }
  _iterate(n, s) {
    let i = 0, r = 1, o;
    do {
      o = 0, r = 1;
      let a = this.get(i), c, l, h, d, p = !1, E = !1, g, T = r, A = 1;
      do
        if (E = p, d = h, T = (i + r) / 2, c = this.get(T), l = this.get(r), h = _e.getccenter(a, c, l), h.interval = {
          start: i,
          end: r
        }, p = this._error(h, a, i, r) <= n, g = E && !p, g || (A = r), p) {
          if (r >= 1) {
            if (h.interval.end = A = 1, d = h, r > 1) {
              let O = {
                x: h.x + h.r * uP(h.e),
                y: h.y + h.r * dP(h.e)
              };
              h.e += _e.angle({ x: h.x, y: h.y }, O, this.get(1));
            }
            break;
          }
          r = r + (r - i) / 2;
        } else
          r = T;
      while (!g && o++ < 100);
      if (o >= 100)
        break;
      d = d || h, s.push(d), i = A;
    } while (r < 1);
    return s;
  }
}
class as extends Float32Array {
  /**
   * Creates new Vector4 from 4 number components or copies values from a single vec4-like object
   * @param  {number | Vector4 | vec4 | object} x  x component or vec4-like object
   * @param  {number} [y]  y component
   * @param  {number} [z]  z component
   * @param  {number} [w]  w component
   */
  constructor(n, s, i, r) {
    super(4), typeof n == "number" && typeof s == "number" && typeof i == "number" && typeof r == "number" ? TA(this, n, s, i, r) : this.copy(n);
  }
  /**
   * Copies values from the vec4-like object
   * @param  {Vector4 | vec4 | object} val
   */
  copy(n) {
    if (Ge(n))
      return;
    let s = ee(n[0]) ? n[0] : n.x;
    Ge(s) && (s = n.r);
    let i = ee(n[1]) ? n[1] : n.y;
    Ge(i) && (i = n.g);
    let r = ee(n[2]) ? n[2] : n.z;
    Ge(r) && (r = ee(n.b) ? n.b : n.width);
    let o = ee(n[3]) ? n[3] : n.w;
    Ge(o) && (o = ee(n.a) ? n.a : n.height), be(s) && be(i) && be(r) && be(o) && TA(this, s, i, r, o);
  }
  /**
   * Checks if this Vector4 is equal (has same corresponding component values) to anothe vec4-like object
   * @param {Vector4 | vec4 | object} val     vec4-like object
   * @param {number} epsilon                  precision; default is 0.0001
   * @returns {boolean}                        true if vectors are equal; false othewise
   */
  eq(n, s = wn) {
    if (Ge(n))
      return !1;
    let i = ee(n[0]) ? n[0] : n.x;
    Ge(i) && (i = n.r);
    let r = ee(n[1]) ? n[1] : n.y;
    Ge(r) && (r = n.g);
    let o = ee(n[2]) ? n[2] : n.z;
    Ge(o) && (o = ee(n.b) ? n.b : n.width);
    let a = ee(n[3]) ? n[3] : n.w;
    return Ge(a) && (a = ee(n.a) ? n.a : n.height), nP(this, [i, r, o, a], s);
  }
  get x() {
    return this[0];
  }
  set x(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to x component of Vector4");
    this[0] = n;
  }
  get y() {
    return this[1];
  }
  set y(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to y component of Vector4");
    this[1] = n;
  }
  get z() {
    return this[2];
  }
  set z(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to z component of Vector4");
    this[2] = n;
  }
  get w() {
    return this[3];
  }
  set w(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to w component of Vector4");
    this[3] = n;
  }
  get r() {
    return this[0];
  }
  set r(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to r component of Vector4");
    this[0] = n;
  }
  get g() {
    return this[1];
  }
  set g(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to g component of Vector4");
    this[1] = n;
  }
  get b() {
    return this[2];
  }
  set b(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to b component of Vector4");
    this[2] = n;
  }
  get a() {
    return this[3];
  }
  set a(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to a component of Vector4");
    this[3] = n;
  }
  get width() {
    return this[2];
  }
  set width(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to width component of Vector4");
    this[2] = n;
  }
  get height() {
    return this[3];
  }
  set height(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to height component of Vector4");
    this[3] = n;
  }
}
as.ZERO = new as(0, 0, 0, 0);
as.ONE = new as(1, 1, 1, 1);
class Fn {
  /**
   * Creates new AABB in one of the following ways:
   *  - empty (if first parameter is not defined)
   *  - from another {@link AABB}
   *  - from {@link Rect} object
   *  - from two {@link _Vector2}-like objects representing min and max components
   *  - from x, y, width and height number components
   * @param  {number | AABB | Rect | _Vector2 } x    x component or {@link AABB}, or {@link Rect} object or {@link _Vector2}-like object
   * @param  {number | _Vector2 } [y]      y component or {@link _Vector2}-like object
   * @param  {number} [width]             width component
   * @param  {number} [height]            height component
   */
  constructor(n, s, i, r) {
    Ge(n) ? (this.min = new se(1 / 0, 1 / 0), this.max = new se(-1 / 0, -1 / 0)) : n.min ? (this.min = new se(n.min), this.max = new se(n.max)) : n.x && Ge(s) ? (this.min = new se(n.x, n.y), this.max = new se(n.x + n.width, n.y + n.height)) : !Ge(s) && Ge(i) ? (this.min = new se(n), this.max = new se(s)) : (this.min = new se(n, s), this.max = new se(n + i, s + r));
  }
  /**
   * Copies the passed AABB into `this` AABB.
   * @param  {AABB | Rect} val  other AABB or Rect object
   * @returns {AABB} self
   */
  copy(n) {
    if (Ge(n))
      return;
    const { min: s, max: i, x: r, y: o, width: a, height: c } = n;
    return _c(s) && _c(i) ? (this.min.copy(s), this.max.copy(i)) : be(r) && be(o) && be(a) && be(c) && (this.min.x = r, this.min.y = o, this.max.x = r + a, this.max.y = o + c), this;
  }
  /**
   * Checks if this AABB is equal (has same corresponding component values) to another AABB or Rect object
   * @param {AABB | Rect} val  - other AABB or Rect object
   * @param {number} [epsilon] - precision, default is 0.0001
   * @returns {boolean} true if vectors are equal; false othewise
   */
  eq(n, s = wn) {
    if (Ge(n))
      return !1;
    const i = _c(n.min) ? n.min : [n.x, n.y], r = _c(n.max) ? n.max : [n.x + n.width, n.y + n.height];
    return this.min.eq(i, s) && this.max.eq(r, s);
  }
  /**
   * Serializes AABB data
   * @returns {{min: [], max: []}}
   */
  save() {
    return { min: [...this.min], max: [...this.max] };
  }
  get isInfinite() {
    return this.min.x === 1 / 0 && this.min.y === 1 / 0 && this.max.x === -1 / 0 && this.max.y === -1 / 0;
  }
  get isZero() {
    return this.min.eq(se.ZERO) && this.max.eq(se.ZERO);
  }
  get size() {
    return ba(new se(), this.max, this.min);
  }
  get position() {
    return this.min;
  }
  get x() {
    return this.min.x;
  }
  get y() {
    return this.min.y;
  }
  get width() {
    return this.max.x - this.min.x;
  }
  get height() {
    return this.max.y - this.min.y;
  }
  get topLeft() {
    return this.min;
  }
  get bottomRight() {
    return this.max;
  }
  get topRight() {
    return new se(this.max.x, this.min.y);
  }
  get bottomLeft() {
    return new se(this.min.x, this.max.y);
  }
  get left() {
    return this.min.x;
  }
  get top() {
    return this.min.y;
  }
  get right() {
    return this.max.x;
  }
  get bottom() {
    return this.max.y;
  }
  get center() {
    return new se(this.x + this.width / 2, this.y + this.height / 2);
  }
  /**
   * Translates both min and max by delta
   * @param  {vec2}  delta          - translation vector
   * @param  {boolean} newInstance  - whether to create a new instance for output AABB
   * @returns {AABB} the output AABB
   */
  translate(n, s = !0) {
    const i = s ? new Fn() : this;
    return Fi(i.min, this.min, n), Fi(i.max, this.max, n), i;
  }
  /**
   * Moves bounds to specific position
   * @param  {vec2}  pos          -  position
   * @param  {boolean} newInstance  - whether to create a new instance for output AABB
   * @returns {AABB} the output AABB
   */
  moveTo(n, s = !0) {
    const i = s ? new Fn() : this, r = this.width, o = this.height;
    return Fo(i.min, n[0], n[1]), Fo(i.max, n[0] + r, n[1] + o), i;
  }
  /**
   * Transforms the rectangle form by this AABB and recalcultes AABB around the transformed rectangle
   * @param  {mat2d}  transform       transform matrix
   * @param  {boolean} newInstance    if true returns a new AABB instance, otherwise modifies this instance
   * @returns {AABB}                  new AABB, unless newInstance was set to false; otherwise returns new AABB instance
   */
  transform(n, s = !0) {
    const i = s ? new Fn() : this, r = this.rect().map((o) => Vl(o, o, n));
    return s || i.reset(), r.forEach((o) => i.minMax(o)), i;
  }
  /**
   * Resizes (expands or shrinks) the AABB by the vec2 delta
   * @param  {vec2} delta
   * @param  {boolean} newInstance    if true returns a new AABB instance, otherwise modifies this instance
   * @returns {AABB}                  new AABB, unless newInstance was set to false; otherwise returns new AABB instance
   */
  resizeBy(n, s = !0) {
    const i = s ? new Fn(this) : this;
    return ba(i.min, this.min, n), Fi(i.max, this.max, n), i;
  }
  /**
   * Resizes (expands or shrinks) the AABB by the scalar amount
   * @param  {number} scalar
   * @param  {boolean} newInstance    if true returns a new AABB instance, otherwise modifies this instance
   * @returns {AABB}                  new AABB, unless newInstance was set to false; otherwise returns new AABB instance
   */
  resizeByScalar(n, s = !0) {
    const i = s ? new Fn(this) : this;
    return IA(i.min, this.min, -n), IA(i.max, this.max, n), i;
  }
  /**
   * Transforms min and max points only (not rectangle). Recalculates min and max afterwards.
   * @param  {mat2d}  transform       transform matrix
   * @param  {boolean} newInstance    if true returnes a new AABB instance, otherwise modifies this instance
   * @returns {AABB}
   */
  transformMinMax(n, s = !0) {
    const i = s ? new Fn() : this;
    return Vl(i.min, this.min, n), Vl(i.max, this.max, n), i.minMax(), i;
  }
  /**
   * Finds whether this AABB intersects with the AABB represented by the arguments. This also includes
   * if one AABB lies fully inside the other.
   * @param {(number|AABB|{x:number, y:number, width:number, height: number})} x - x coord, AABB (or Vector4) or just object with x,y,width,height
   * @param {number} [y]
   * @param {number} [width]
   * @param {number} [height]
   * @returns {boolean} false if the two AABB don't overlap at all (no intersection); true otherwise (intersection)
   */
  intersects(n, s, i, r) {
    let o, a, c, l;
    return typeof n == "number" && typeof s == "number" && typeof i == "number" && typeof r == "number" ? (o = n, a = s, c = n + i, l = s + r) : (o = Ge(n.left) ? n.x : n.left, a = Ge(n.top) ? n.y : n.top, c = Ge(n.right) ? n.x + n.width : n.right, l = Ge(n.bottom) ? n.y + n.height : n.bottom), o < this.right && c > this.left && a < this.bottom && l > this.top;
  }
  /**
   * Calculates whether `this` AABB fully lies inside the passed AABB, i.e. whether the intersection
   * of these two AABBs is equal to `this`.
   * @param {(number|AABB|{x:number, y:number, width:number, height: number})} x - x coord, AABB (or Vector4) or just object with x,y,width,height
   * @param {number} [y]
   * @param {number} [width]
   * @param {number} [height]
   * @returns {boolean} true, if this AABB lies fully inside the passed AABB; false, otherwise
   */
  containedWithin(n, s, i, r) {
    let o, a, c, l;
    return typeof n == "number" && typeof s == "number" && typeof i == "number" && typeof r == "number" ? (o = n, a = s, c = n + i, l = s + r) : (o = Ge(n.left) ? n.x : n.left, a = Ge(n.top) ? n.y : n.top, c = Ge(n.right) ? n.x + n.width : n.right, l = Ge(n.bottom) ? n.y + n.height : n.bottom), this.left >= o && this.right <= c && this.top >= a && this.bottom <= l;
  }
  /**
   * Calculates whether this AABB contains the point `(x,y)` in the same coordinate space.
   * @param {(number|vec2)} x - x coordinate or whole point as vec2
   * @param {number} [y]      - y coordinate
   * @returns {boolean} true if point is inside (or on the boundary) of the AABB
   */
  containsPoint(n, s) {
    let i = n, r = s;
    return Ge(n.x) || (i = n.x, r = n.y), i >= this.left && i <= this.right && r >= this.top && r <= this.bottom;
  }
  /**
   * Returns the vertices of this rectangle in a clockwise fashion, starting from the top-left
   * vertex.
   * @returns {_Vector2[]} - vertices of this AABB rectangle
   */
  rect() {
    return [
      new se(this.min),
      new se(this.max[0], this.min[1]),
      new se(this.max),
      new se(this.min[0], this.max[1])
    ];
  }
  /**
   * Extends min max bounds (if necesary) by point, another AABB or OBB.
   * If argument is undefined, recalculates min max from its own min max values
   * (useful after manualy changing min or max)
   * @param {(vec2|AABB|OBB)} [p]  could be a single point, AABB or OBB, or undefined
   */
  minMax(n) {
    if (Ge(n)) {
      const s = Math.min(this.min[0], this.max[0]), i = Math.min(this.min[1], this.max[1]), r = Math.max(this.min[0], this.max[0]), o = Math.max(this.min[1], this.max[1]);
      Fo(this.min, s, i), Fo(this.max, r, o);
    } else
      !Ge(n.min) && !Ge(n.max) ? (Pp(this.min, this.min, n.min), bp(this.max, this.max, n.max)) : Ge(n.aabb) ? (Pp(this.min, this.min, n), bp(this.max, this.max, n)) : this.minMax(n.aabb);
  }
  /**
   * Intersects this and the given bounds.
   * @param {AABB} bounds            - bounds to intersect this with
   * @param {AABB}[newInstance=true] - whether to create a new instance for output bounds
   * @returns {AABB} the output AABB
   */
  intersectWith(n, s = !0) {
    const i = s ? new Fn() : this;
    return bp(i.min, this.min, n.min), Pp(i.max, this.max, n.max), i.max.y < i.min.y && (this.min.y = 0, this.max.y = 0), i.max.x < i.min.x && (this.min.x = 0, this.max.x = 0), i;
  }
  /**
   * Calculates the set-union of `this` and `other`.
   *
   * @param {AABB} other
   * @param {boolean}[newInstance=true] - whether to create new instance for output bounds
   * @returns {AABB} the output AABB
   */
  union(n, s = !0) {
    const i = s ? new Fn() : this;
    return i.min.x = Math.min(this.min.x, n.min.x), i.min.y = Math.min(this.min.y, n.min.y), i.max.x = Math.max(this.max.x, n.max.x), i.max.y = Math.max(this.max.y, n.max.y), i;
  }
  /**
   * Calculates the set-intersection of `this` and `other`.
   * @param {AABB} other
   * @param {boolean}[newInstance=true] - whether to create new instance for output bounds
   * @returns {AABB} the output AABB
   */
  intersect(n, s = !0) {
    const i = s ? new Fn() : this;
    return i.min.x = Math.max(this.min.x, n.min.x), i.min.y = Math.max(this.min.y, n.min.y), i.max.x = Math.min(this.max.x, n.max.x), i.max.y = Math.min(this.max.y, n.max.y), i;
  }
  // /**
  //  * Checks if this AABB is equal to other AABB or OBB
  //  * @param  {AABB | OBB}     other AABB or OBB
  //  * @returns {boolean}      true if equal; false otherwise
  //  */
  // isEqual(other) {
  //     const otherAABB = other.aabb || other
  //     return vec2.exactEquals(this.min, otherAABB.min) && vec2.exactEquals(this.max, otherAABB.max)
  // }
  /**
   * Resets this AABB so that:
   * + it has zero area
   * + min point is at positive infinity
   * + max point is at negative infinity
   *
   * @returns {AABB} this AABB
   */
  reset() {
    return Fo(this.min, 1 / 0, 1 / 0), Fo(this.max, -1 / 0, -1 / 0), this;
  }
}
var El = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function EP(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var P1 = { exports: {} };
(function(e) {
  var n = Object.prototype.hasOwnProperty, s = "~";
  function i() {
  }
  Object.create && (i.prototype = /* @__PURE__ */ Object.create(null), new i().__proto__ || (s = !1));
  function r(l, h, d) {
    this.fn = l, this.context = h, this.once = d || !1;
  }
  function o(l, h, d, p, E) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var g = new r(d, p || l, E), T = s ? s + h : h;
    return l._events[T] ? l._events[T].fn ? l._events[T] = [l._events[T], g] : l._events[T].push(g) : (l._events[T] = g, l._eventsCount++), l;
  }
  function a(l, h) {
    --l._eventsCount === 0 ? l._events = new i() : delete l._events[h];
  }
  function c() {
    this._events = new i(), this._eventsCount = 0;
  }
  c.prototype.eventNames = function() {
    var h = [], d, p;
    if (this._eventsCount === 0) return h;
    for (p in d = this._events)
      n.call(d, p) && h.push(s ? p.slice(1) : p);
    return Object.getOwnPropertySymbols ? h.concat(Object.getOwnPropertySymbols(d)) : h;
  }, c.prototype.listeners = function(h) {
    var d = s ? s + h : h, p = this._events[d];
    if (!p) return [];
    if (p.fn) return [p.fn];
    for (var E = 0, g = p.length, T = new Array(g); E < g; E++)
      T[E] = p[E].fn;
    return T;
  }, c.prototype.listenerCount = function(h) {
    var d = s ? s + h : h, p = this._events[d];
    return p ? p.fn ? 1 : p.length : 0;
  }, c.prototype.emit = function(h, d, p, E, g, T) {
    var A = s ? s + h : h;
    if (!this._events[A]) return !1;
    var m = this._events[A], O = arguments.length, S, y;
    if (m.fn) {
      switch (m.once && this.removeListener(h, m.fn, void 0, !0), O) {
        case 1:
          return m.fn.call(m.context), !0;
        case 2:
          return m.fn.call(m.context, d), !0;
        case 3:
          return m.fn.call(m.context, d, p), !0;
        case 4:
          return m.fn.call(m.context, d, p, E), !0;
        case 5:
          return m.fn.call(m.context, d, p, E, g), !0;
        case 6:
          return m.fn.call(m.context, d, p, E, g, T), !0;
      }
      for (y = 1, S = new Array(O - 1); y < O; y++)
        S[y - 1] = arguments[y];
      m.fn.apply(m.context, S);
    } else {
      var v = m.length, R;
      for (y = 0; y < v; y++)
        switch (m[y].once && this.removeListener(h, m[y].fn, void 0, !0), O) {
          case 1:
            m[y].fn.call(m[y].context);
            break;
          case 2:
            m[y].fn.call(m[y].context, d);
            break;
          case 3:
            m[y].fn.call(m[y].context, d, p);
            break;
          case 4:
            m[y].fn.call(m[y].context, d, p, E);
            break;
          default:
            if (!S) for (R = 1, S = new Array(O - 1); R < O; R++)
              S[R - 1] = arguments[R];
            m[y].fn.apply(m[y].context, S);
        }
    }
    return !0;
  }, c.prototype.on = function(h, d, p) {
    return o(this, h, d, p, !1);
  }, c.prototype.once = function(h, d, p) {
    return o(this, h, d, p, !0);
  }, c.prototype.removeListener = function(h, d, p, E) {
    var g = s ? s + h : h;
    if (!this._events[g]) return this;
    if (!d)
      return a(this, g), this;
    var T = this._events[g];
    if (T.fn)
      T.fn === d && (!E || T.once) && (!p || T.context === p) && a(this, g);
    else {
      for (var A = 0, m = [], O = T.length; A < O; A++)
        (T[A].fn !== d || E && !T[A].once || p && T[A].context !== p) && m.push(T[A]);
      m.length ? this._events[g] = m.length === 1 ? m[0] : m : a(this, g);
    }
    return this;
  }, c.prototype.removeAllListeners = function(h) {
    var d;
    return h ? (d = s ? s + h : h, this._events[d] && a(this, d)) : (this._events = new i(), this._eventsCount = 0), this;
  }, c.prototype.off = c.prototype.removeListener, c.prototype.addListener = c.prototype.on, c.prefixed = s, c.EventEmitter = c, e.exports = c;
})(P1);
var Oh = P1.exports;
const gP = /* @__PURE__ */ EP(Oh), _P = ["before", "after", "index", "toIndex", "fromIndex"];
let nn = class {
  constructor(n) {
    let s;
    for (s of _P)
      s in n && (this[s] = n[s]);
  }
};
class bc extends Map {
  constructor(n) {
    super(n), this.type = Rr.PROPERTY;
  }
  update(n, s) {
    if (!(s instanceof nn))
      throw Error("Expect class: Change");
    if (this.has(n)) {
      const i = this.get(n);
      s.before = i.before;
    }
    return this.set(n, s);
  }
  isEmpty() {
    return this.size === 0;
  }
}
class sh {
  constructor({ CREATE: n, UPDATE: s, DELETE: i } = {}) {
    this.type = Rr.ENTITY, this.CREATE = new Set(n), this.UPDATE = new Map(s), this.UPDATE.forEach((r, o) => {
      this.UPDATE.set(o, new bc(r));
    }), this.DELETE = new Set(i);
  }
  create(n) {
    for (const s of n)
      this.CREATE.add(s), this.DELETE.delete(s);
  }
  update(n, s, i) {
    this.DELETE.delete(n), this.UPDATE.has(n) || this.UPDATE.set(n, new bc()), this.UPDATE.get(n).update(s, i);
  }
  delete(n) {
    for (const s of n)
      this.CREATE.delete(s), this.DELETE.add(s);
  }
  removeFromCreate(n) {
    let s;
    for (s of n)
      this.CREATE.delete(s);
  }
  isEmpty() {
    return this.CREATE.size === 0 && this.DELETE.size === 0 && this.UPDATE.size === 0;
  }
  clear() {
    this.CREATE.clear(), this.UPDATE.clear(), this.DELETE.clear();
  }
}
function TP(e) {
  const { before: n, after: s, index: i, fromIndex: r, toIndex: o } = e;
  return new nn({
    before: s,
    after: n,
    index: i,
    fromIndex: o,
    toIndex: r
  });
}
function b1(e) {
  return new bc(
    [...e.entries()].map(([n, s]) => [
      n,
      TP(s)
    ])
  );
}
function U1(e) {
  const n = /* @__PURE__ */ new Map();
  return e.UPDATE.forEach((s, i) => {
    n.set(
      i,
      b1(s)
    );
  }), new sh({
    CREATE: new Set([...e.DELETE].reverse()),
    DELETE: new Set([...e.CREATE].reverse()),
    UPDATE: n
  });
}
function AP(e, n) {
  return e.after = n.after, n.toIndex && (e.toIndex = n.toIndex), !0;
}
function G1(e, n) {
  let s;
  for (s of n.keys())
    e.has(s) ? AP(e.get(s), n.get(s)) : e.set(s, n.get(s));
  return !0;
}
function mP(e, n) {
  let s;
  for (s of n.CREATE)
    e.CREATE.add(s), e.DELETE.delete(s);
  for (s of n.DELETE)
    e.CREATE.has(s) || e.DELETE.add(s), e.UPDATE.delete(s), e.CREATE.delete(s);
  for (s of n.UPDATE.keys())
    e.DELETE.delete(s), e.UPDATE.has(s) ? G1(e.UPDATE.get(s), n.UPDATE.get(s)) : e.UPDATE.set(s, n.UPDATE.get(s));
  return !0;
}
const Fp = {
  [Rr.PROPERTY]: bc,
  [Rr.ENTITY]: sh
};
class F1 extends gP {
  /**
   * @param {Undoer} undoer
   * @param {ChangeType} changeType
   * @param {string} eventName
   */
  constructor(n, s, i) {
    super(), this.undoer = n, this.changeType = s, this.eventName = i || Oe.DEFAULT_CHANGES, this.undoEvents = /* @__PURE__ */ new Set([this.eventName]), this.changes = new Fp[this.changeType]();
  }
  /**
   * Fire events with data changes
   * @param {Changes} changes
   * @param {object} options
   */
  emit(n, s) {
    super.emit(this.eventName, n, s);
  }
  /**
   * Fire changes event and add to undo
   * @param {boolean} [undoable=true]
   * @param {object} options
   */
  fire(n = !0, s) {
    this.changes.isEmpty() || (this.emit(this.changes, s), n && this.undoer && this.undoer.addUndo && this.undoer.addUndo(this, this.eventName, this.changes), this.changes = new Fp[this.changeType]());
  }
  /**
   * Renew changes without doing anything
   */
  renewChanges() {
    this.changes.isEmpty() || (this.changes = new Fp[this.changeType]());
  }
  /**
   * Undo changes
   * @param {Changes} changes
   */
  undo(n) {
    n instanceof bc && this.emit(b1(n)), n instanceof sh && this.emit(U1(n));
  }
  /**
   * Redo changes
   * @param {Changes} changes
   * @param {object} options
   */
  redo(n, s) {
    n instanceof bc && this.emit(n, s), n instanceof sh && this.emit(n, s);
  }
  /**
   *
   * @param {string} eventName event name
   * @param {PropChange | EntityChange} original   original changes object
   * @param {PropChange | EntityChange} current    new chnages object
   * @returns {bool}      true if handled; false otherwise
   */
  combineUndo(n, s, i) {
    if (s.type !== i.type)
      return !1;
    switch (s.type) {
      case Rr.ENTITY:
        return mP(s, i);
      case Rr.PROPERTY:
        return G1(s, i);
    }
  }
}
const OP = "isMix", Wo = 0.1, xo = Object.freeze(
  {
    CURVE_CONTROL: "__FAKE_IND_CURVE_CONTROL__"
  }
), ft = Object.freeze({
  spacingMultiple: 3,
  size: 20,
  dashSize: 4,
  color: 16777215,
  alpha: 0.6,
  borderColor: 2039586,
  background: 855052,
  fontSize: 10,
  originModeColour: 1863400,
  originModeBorderWidth: 2,
  guidelineColor: 14437212,
  overlapAlpha: [0.15, 0.3, 0.45, 0.6]
}), IP = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let SP = (e = 21) => {
  let n = "", s = crypto.getRandomValues(new Uint8Array(e |= 0));
  for (; e--; )
    n += IP[s[e] & 63];
  return n;
};
const Ia = "default", em = 0, WE = "-", yP = [
  "el",
  // Element
  "bs",
  // Base
  "pc",
  // Property Component
  "im",
  // Interaction Manager component
  "ly",
  // Layer Component
  "ms",
  // Mesh component
  "tm",
  // Transition Manager component
  "ei"
  // Element Interaction
], YE = (e, n, s) => {
  if (e === Ia)
    return `${n}`;
  const i = [];
  return e && i.push(e), i.push(n), s && i.push(s), i.join(WE);
}, CP = () => {
  const e = yP.reduce((n, s) => (n[s] = YE(s, em), n), {});
  return e[Ia] = `${em}`, e;
};
class NP {
  constructor() {
    this._counter = CP(), this.suffixKey = SP(4);
  }
  getCurrentCount(n) {
    const s = this._getPrefixKey(n);
    return this._getNumber(s);
  }
  getIdBy(n) {
    const s = this._getPrefixKey(n);
    return this._counter[s];
  }
  create(n) {
    const s = this._getPrefixKey(n), i = this._getNumber(s);
    return this._counter[s] = YE(s, i + 1, this.suffixKey), this._counter[s];
  }
  load(n, s) {
    const i = this._getPrefixKey(s), r = this._getNumber(i), o = this._getNumber(i, n), a = Math.max(r, o);
    this._counter[i] = YE(i, a);
  }
  _getPrefixKey(n) {
    return this._counter[n] ? n : Ia;
  }
  _getNumber(n, s) {
    if (s && !this.isInCounter(s, n))
      return parseInt(this._counter[Ia]);
    const i = this._getPrefixKey(n), r = s || this._counter[i], o = isNaN(Number(r)) ? this._counter[Ia] : r, a = i === Ia ? o : r.split(WE)[1];
    return parseInt(a);
  }
  isInCounter(n, s) {
    if (!n || typeof n != "string" && typeof n != "number")
      return !1;
    let i = n.toString();
    typeof n == "number" && (i = `${n}`);
    const r = this._getPrefixKey(s);
    let o = i;
    if (r !== Ia) {
      const a = i.split(WE);
      if (a.length < 2 || a[0] !== r)
        return !1;
      o = a[1];
    }
    return !isNaN(Number(o));
  }
}
const k1 = new NP();
function Zr(e = "") {
  return k1.create(e);
}
function B1(e, n = "") {
  k1.load(e, n);
}
const Be = Object.freeze(
  {
    SELECTED: 1,
    CURVE_VERT: 2,
    // Only for vertices
    CONNECT_SELECTED: 4
    // 
  }
);
class n0 {
  constructor(n = null) {
    this.id = n === null ? Zr(gi.MESH) : n, this.upperTierIDs = /* @__PURE__ */ new Set(), this.type = "undefined", this.flags = 0, this.index = 0;
  }
  static fromData({ id: n }) {
    B1(n, gi.MESH);
  }
  /**
   * Checks whether this cell has been turned the flags specified on
   * @param {FlagsEnum} flag
   * @returns {boolean} true if the flag is set, false otherwise
   */
  isFlagged(n) {
    return (this.flags & 1 << n) !== 0;
  }
  /**
   * Flag the given flag
   * @param {FlagsEnum} flag 
   */
  flag(n) {
    this.flags |= 1 << n;
  }
  /**
   * Remove the given flag
   * @param {FlagsEnum} flag 
   */
  removeFlag(n) {
    this.flags &= ~(1 << n);
  }
  /**
   * @abstract
   * @returns {VertexData|EdgeData|ContourData}
   */
  save() {
    throw new Error("must be implemented by subclass!");
  }
}
class Yo extends n0 {
  /**
   * Creates new Vertex instance
   * @param {boolean} [virtual=false]
   */
  constructor(n = !1) {
    super(), this.pos = new se(), this.cornerRadius = null, this.cap = null, this.end = null, this.join = null, this.mirror = pe.NONE, this.inHalves = /* @__PURE__ */ new Set(), this.outHalves = /* @__PURE__ */ new Set(), this.virtualInHalves = /* @__PURE__ */ new Set(), this.virtualOutHalves = /* @__PURE__ */ new Set(), this.isVirtual = n, this.type = "Vertex", this.unlinkedCurveControl = null, this.controllingEdge = null, this.adjacentMainVertex = null;
  }
  /**
   * Create Vertex instance from data
   * @param {VertexData} options
   * @returns {Vertex}
   */
  static fromData({
    id: n,
    pos: s,
    cornerRadius: i = null,
    cap: r = null,
    end: o = null,
    join: a = null,
    mirror: c = pe.NONE
  }) {
    super.fromData({ id: n });
    const l = new Yo();
    return l.id = n, l.pos = new se(s), l.cornerRadius = i, l.cap = r, l.end = o, l.join = a, l.mirror = c, l.type = "Vertex", l;
  }
  /**
   * @param {Partial<Omit<VertexData, 'id'>>} options
   */
  set({ pos: n, cornerRadius: s, cap: i, join: r, mirror: o, end: a }) {
    let c = !1;
    if (_c(n) && (this.pos = new se(n), c = !0), s === null ? this.cornerRadius = null : this.cornerRadius = s >= 0 ? s : this.cornerRadius, i === null ? this.cap = null : this.cap = i in cn ? i : this.cap, a === null ? this.end = null : this.end = a in Ba ? a : this.end, r === null ? this.join = null : this.join = r in Us ? r : this.join, this.mirror = o in pe ? o : this.mirror, c)
      for (const l of this.getEdges({ virtual: this.isVirtual }))
        l.updateBounds();
  }
  /**
   * Creates a copy of a Vertex
   * @returns {Vertex}
   */
  copy() {
    const n = new Yo();
    return n.pos.x = this.pos.x, n.pos.y = this.pos.y, n.cornerRadius = this.cornerRadius, n.cap = this.cap, n.end = this.end, n.join = this.join, n.mirror = this.mirror, n.adjacentMainVertex = this.adjacentMainVertex, n.unlinkedCurveControl = this.unlinkedCurveControl, n.flags = this.flags, n;
  }
  // TODO: do we need to consider id ?
  /**
   * Checks if this Vertex is equal to another Vertex
   * @param  {Vertex} v
   * @returns {boolean}      true if equal; false otherwise
   */
  eq(n) {
    return n && this.pos.eq(n);
  }
  /**
   * Serializes Vertex data
   * @returns {VertexData}
   */
  save() {
    var s;
    const n = {};
    return n.id = this.id, n.pos = [this.pos[0], this.pos[1]], n.cornerRadius = this.cornerRadius, n.cap = this.cap, n.end = this.end, n.join = this.join, n.mirror = this.mirror, n.adjMainId = (s = this.adjacentMainVertex) == null ? void 0 : s.id, n;
  }
  /**
   * Returns iterator over all halves starting at this Vertex
   * @param {object} [options]
   * @param {boolean} [options.virtual=false]         if true, only searches virtual HalfEdges
   * @param {boolean} [options.all=false]             if true, searches both real and virtual HalfEdges
   */
  *getOutHalves({ virtual: n = !1, all: s = !1 } = {}) {
    if (s || !n)
      for (const i of this.outHalves)
        yield i;
    if (s || n)
      for (const i of this.virtualOutHalves)
        yield i;
  }
  /**
   * Returns iterator over all halves ending at this Vertex
   * @param {object} [options]
   * @param {boolean} [options.virtual=false]         if true, only searches virtual HalfEdges
   * @param {boolean} [options.all=false]             if true, searches both real and virtual HalfEdges
   */
  *getInHalves({ virtual: n = !1, all: s = !1 } = {}) {
    if (s || !n)
      for (const i of this.inHalves)
        yield i;
    if (s || n)
      for (const i of this.virtualInHalves)
        yield i;
  }
  /**
   * Returns iterator over all ingress Edges of this Vertex
   * @param {object} [options]
   * @param {boolean} [options.virtual=false]         if true, only searches virtual HalfEdges
   * @param {boolean} [options.all=false]             if true, searches both real and virtual HalfEdges
   */
  *getEdges(n) {
    for (const s of this.getOutHalves(n))
      yield s.edge;
  }
  /**
   * Returns iterator over all neighbouring Vertices of this Vertex
   *  Internaly allocates a Set to check for repeating neighbours,
   *  because there could be more than one edge between same pair of Vertices
   * @param {object} [options]
   * @param {boolean} [options.virtual=false]         if true, only searches in virtual HalfEdges
   * @param {boolean} [options.all=false]             if true, searches in both real and virtual HalfEdges
   */
  *getNeighbours(n) {
    const s = /* @__PURE__ */ new Set();
    for (const i of this.getOutHalves(n))
      s.has(i.w) || (s.add(i.w), yield i.w);
  }
  /**
   * Iterator for all HalfEdges that start from this Vertex and end at specified Vertex `w`
   * @param {Vertex} w   ending Vertex
   * @param {object} [options]
   * @param {boolean} [options.virtual=false]         if true, only searches in virtual HalfEdges
   * @param {boolean} [options.all=false]             if true, searches in both real and virtual HalfEdges
   * @yields {HalfEdge} HalfEdges that start from this Vertex and end at Vertex `w`
   */
  *findOutHalves(n, s) {
    for (const i of this.getOutHalves(s))
      i.w === n && (yield i);
  }
  /**
   * Connects Edge to this vertex
   * @param {Edge} edge
   * @returns {boolean}      true if success; false if this Vertex does not belong to the specified Edge
   */
  connectEdge(n) {
    let s, i;
    return n.v === this ? (s = n.halves[0], i = n.halves[1]) : n.w === this && (s = n.halves[1], i = n.halves[0]), !s || !i ? !1 : (this.upperTierIDs.add(n.id), n.isVirtual ? (this.virtualOutHalves.add(s), this.virtualInHalves.add(i)) : (this.outHalves.add(s), this.inHalves.add(i)), !0);
  }
  /**
   * Disconnects edge from this vertex
   * @param  {Edge} edge
   */
  disconnectEdge(n) {
    this.upperTierIDs.delete(n.id), n.v === this ? n.isVirtual ? (this.virtualOutHalves.delete(n.halves[0]), this.virtualInHalves.delete(n.halves[1])) : (this.outHalves.delete(n.halves[0]), this.inHalves.delete(n.halves[1])) : n.w === this && (n.isVirtual ? (this.virtualOutHalves.delete(n.halves[1]), this.virtualInHalves.delete(n.halves[0])) : (this.outHalves.delete(n.halves[1]), this.inHalves.delete(n.halves[0])));
  }
}
class tm {
  /**
   * @param {Edge} edge           the parent Edge of this HalfEdge
   * @param {Vertex} v            starting Vertex of this HalfEdge
   */
  constructor(n, s) {
    if (Ge(n) || Ge(s))
      throw new Error("Trying to create HalfEdge with no parent edge or undefined origin");
    this.edge = n, this.v = s, this.contours = /* @__PURE__ */ new Set(), this.twin = void 0;
  }
  get isVirtual() {
    return this.edge.isVirtual;
  }
  /**
   * @returns {number} index of this HalfEdge in its parent Edge (0 or 1)
   */
  get index() {
    return this.edge.getHalfIndex(this);
  }
  /**
   * @returns {Vertex} end Vertex of this HalfEdge
   */
  get w() {
    return this.twin.v;
  }
  /**
   * @returns {HalfEdge[]} all HalfEdges going out of the end of this HalfEdge
   */
  get next() {
    return this.w.getOutHalves();
  }
  /**
   * @returns {HalfEdge[]} all HalfEdges going into the start of this HalfEdge
   */
  get prev() {
    return this.v.getInHalves();
  }
  /*
   * @returns {AABB}  bound of the Edge this HalfEdge belong too
   */
  get bounds() {
    return this.edge.bounds;
  }
  /**
   * Test if position `pos` is on this half edge (excluding the edge's endpoints)
   * @param  {_Vector2}  pos
   * @returns {boolean}       true if `pos` is on this edge;
   */
  has(n) {
    const s = this.v.pos, i = this.w.pos;
    return (i[0] - s[0]) * (n[1] - s[1]) === (n[0] - s[0]) * (i[1] - s[1]) && Math.abs(s[0] - i[0]) > wn ? s[0] < n[0] && n[0] < i[0] || i[0] < n[0] && n[0] < s[0] : s[1] < n[1] && n[1] < i[1] || i[1] < n[1] && n[1] < s[1];
  }
  /**
   * @param {Contour} contour
   */
  addContour(n) {
    this.contours.add(n);
  }
  /**
   * @param {Contour} contour
   */
  removeContour(n) {
    this.contours.delete(n);
  }
  /**
   * @param {[_Vector2, _Vector2]} curve
   * @param {number} [epsilon]
   * @returns {boolean}
   */
  hasMatchingCurve(n, s = wn) {
    if (!n || !this.edge.isCurve)
      return !1;
    const i = this.index, r = this.edge.curve;
    return ka(r[i === 0 ? 0 : 1].pos, n[0], s) && ka(r[i === 0 ? 1 : 0].pos, n[1], s);
  }
  hasVirtualEdges() {
    return this.edge.hasVirtualEdges();
  }
}
class Bi extends n0 {
  /**
   * Creates new Edge instance
   * @param {boolean} [virtual=false]
   */
  constructor(n = !1) {
    super(), this.halves = [], this.curve = [], this.virtualEdges = /* @__PURE__ */ new Set(), this.bounds = new Fn(), this.isVirtual = n, this._bezier = null, this.type = "Edge";
  }
  /**
   * Creates new Edge object from data
   * @param {EdgeDataIn} data
   * @param {boolean} [keepCurveControl]
   * @returns {Edge}
   */
  static fromData({ id: n, v: s, cpV: i, cpW: r, w: o }, a = !1) {
    super.fromData({ id: n });
    const c = new Bi();
    return c.id = n, c._createHalves(s, o), c.setCurve(i, r, a), c.updateBounds(), c.type = "Edge", c;
  }
  /**
   * @param {Omit<EdgeDataIn, 'id'>} options
   * @param {boolean} [keepCurveControl]
   */
  set({ v: n, cpV: s, cpW: i, w: r }, o = !1) {
    Ge(n) || Ge(r) || !n.pos || !r.pos || Ge(s) || Ge(i) || !s.pos || !i.pos || (this._createHalves(n, r), this.setCurve(s, i, o), this.updateBounds());
  }
  /**
   * @param {Vertex} cpV
   * @param {Vertex} cpW
   * @param {boolean} keepCurveControl
   */
  setCurve(n, s, i = !1) {
    this.curve = [n, s];
    for (let r = 0; r < 2; r++) {
      const o = this.halves[r].v;
      i || this.curve[r].set(o), this.curve[r].flag(Be.CURVE_VERT), this.curve[r].adjacentMainVertex = o, this.curve[r].cornerRadius = o.cornerRadius, this.curve[r].controllingEdge = this;
    }
    this.isCurve || (this._bezier = null);
  }
  /**
   * Create a copy of the edge provided
   * @param  {Vertex} v
   * @param {Vertex} cpV
   * @param {Vertex} cpW
   * @param  {Vertex} w
   * @returns {Edge}
   */
  copy(n, s, i, r) {
    const o = new Bi();
    return o.set({ v: n, cpV: s, cpW: i, w: r }, !0), o.bounds.copy(this.bounds), o;
  }
  /**
   * @returns {Vertex} start Vertex of this Edge
   */
  get v() {
    return this.halves[0].v;
  }
  /**
   * @returns {Vertex} end Vertex of this Edge
   */
  get w() {
    return this.halves[1].v;
  }
  /**
   * Serialize Edge data
   * @param {boolean} [figmaFormat]
   * @returns {EdgeData}
   */
  save(n = !1) {
    const s = {};
    return s.id = this.id, s.v = this.v.id, s.w = this.w.id, n ? s.curve = this.isCurve ? [[...this.curve[0].pos], [...this.curve[1].pos]] : null : (s.curveIds = [this.curve[0].id, this.curve[1].id], s.curve = this.isCurve ? [[this.curve[0].pos[0], this.curve[0].pos[1]], [this.curve[1].pos[0], this.curve[1].pos[1]]] : null), s;
  }
  /**
   * Get curve control point on the V side
   * @returns {Vertex}
   */
  get cpV() {
    return this.curve[0];
  }
  /**
   * Get curve control point on the W side
   * @returns {Vertex}
   */
  get cpW() {
    return this.curve[1];
  }
  get isStraight() {
    return Math.abs(this.cpV.pos[0] - this.v.pos[0]) < wn && Math.abs(this.cpV.pos[1] - this.v.pos[1]) < wn && Math.abs(this.cpW.pos[0] - this.w.pos[0]) < wn && Math.abs(this.cpW.pos[1] - this.w.pos[1]) < wn;
  }
  get isCurve() {
    return !this.isStraight;
  }
  *getContours() {
    for (const n of this.halves)
      for (const s of n.contours)
        yield s;
  }
  disconnect() {
    this.v.disconnectEdge(this), this.w.disconnectEdge(this);
    const n = [];
    for (const s of this.halves) {
      for (const i of s.contours)
        i.removeHalfEdge(s), n.push(i);
      s.contours = /* @__PURE__ */ new Set();
    }
    return n;
  }
  /**
   * Get index of the HalfEdge
   * @param  {HalfEdge} half
   * @returns {number}
   */
  getHalfIndex(n) {
    return this.halves[0] === n ? 0 : this.halves[1] === n ? 1 : -1;
  }
  /**
   * Returns the half directed from v to w
   * @param  {Vertex} v
   * @param  {Vertex} w
   * @returns {HalfEdge}
   */
  getHalf(n, s) {
    if (this.v === n && this.w === s)
      return this.halves[0];
    if (this.w === n && this.v === s)
      return this.halves[1];
  }
  /**
   * Returns the opposite end of the edge
   * @param  {Vertex} v
   * @returns {Vertex}
   */
  getOtherEnd(n) {
    if (this.v === n)
      return this.w;
    if (this.w === n)
      return this.v;
  }
  /**
   * Checks if point is on this edge
   * @param  {[number, number]}  point        vec2-like point coordinate
   * @returns {boolean}       true if point is on the Edge, false otherwise
   */
  hasPoint(n) {
    return ka(this.v.pos, n) || ka(this.w.pos, n) ? !0 : XE(this.v.pos, this.w.pos, n);
  }
  hasVirtualEdges() {
    return this.virtualEdges.size > 0;
  }
  /**
   * Checks if this Edge has intersection with another edge
   *  (excluding when both edges share one or both points)
   * @param  {Edge | [_Vector2, _Vector2]}  edge          Edge or an array of two points
   * @returns {boolean}       true if intersects, false otherwise
   */
  hasIntersectionWith(n) {
    if (!this.isCurve && !n.isCurve) {
      const r = n instanceof Bi ? n.v.pos : n[0], o = n instanceof Bi ? n.w.pos : n[1];
      return nm(this.v.pos, this.w.pos, r, o)[0].length > 0;
    }
    if (this.isCurve && n.isCurve)
      return this._bezier.intersects(n._bezier).length > 0;
    const s = this.isCurve ? {
      p1: n instanceof Bi ? n.v.pos : n[0],
      p2: n instanceof Bi ? n.w.pos : n[1]
    } : { p1: this.v.pos, p2: this.w.pos };
    return (this.isCurve ? this._bezier : n._bezier).intersects(s).length > 0;
  }
  /**
   * Returns list of intersection points
   * @param {Edge} [edge]
   * @returns {number[][]}    list of intersection points t-values [0, 1] along the
   *                          length of the edge, one for each of the two intersecting edges
   */
  intersect(n) {
    if (!n && this.isCurve)
      return this._bezier.intersects().slice(0, 1).map((a) => a.split("/").map((c) => parseFloat(c)));
    if (!this.isCurve && !n.isCurve)
      return nm(this.v.pos, this.w.pos, n.v.pos, n.w.pos);
    if (this.isCurve && n.isCurve)
      return this._bezier.intersects(n._bezier).map((a) => a.split("/").map((c) => parseFloat(c))).reduce((a, c, l) => ((l === 0 || Math.abs(a[0][a[0].length - 1] - c[0]) > 0.05 && Math.abs(a[1][a[1].length - 1] - c[1]) > 0.05) && (a[0].push(c[0]), a[1].push(c[1])), a), [[], []]);
    const s = this.isCurve ? { p1: n.v.pos, p2: n.w.pos } : { p1: this.v.pos, p2: this.w.pos }, i = n.isCurve ? n._bezier : this._bezier, r = i.intersects(s).sort(), o = r.map(
      (a) => tP(n.v.pos, n.w.pos, new se(i.get(a)))
    );
    return this.isCurve ? [r, o] : [o, r];
  }
  /**
   * Split the edge at particular interfals defined by t-values along the length of the edge.
   * @param  {number[]} ts  list of t-values [0, 1] along the length of the edge to split at
   * @returns {EdgeSplits}    split results
   */
  split(n) {
    let s, i;
    if (!n || n.length === 0)
      return { atPositions: [], newCurves: [] };
    if (this.isCurve) {
      const r = this._bezier;
      i = n.map((o) => new se(r.get(o))), s = xP(r, n);
    } else
      i = n.map((r) => Z2(new se(), this.v.pos, this.w.pos, r)), s = [];
    return { atPositions: i, newCurves: s };
  }
  /**
   * @param {Edge[]} edges
   */
  addVirtualEdges(n) {
    for (const s of n)
      s.isVirtual && this.virtualEdges.add(s);
  }
  removeVirtualEdges(n) {
    if (!n) {
      this.virtualEdges.clear();
      return;
    }
    for (const s of n)
      this.virtualEdges.delete(s);
  }
  /**
   * Update edge bounds
   */
  updateBounds() {
    if (this.bounds.reset(), this.isCurve) {
      this._updateBezier();
      const n = this._bezier.bbox();
      this.bounds.minMax({
        min: new se(n.x.min, n.y.min),
        max: new se(n.x.max, n.y.max)
      });
    } else
      this.bounds.minMax(this.v.pos), this.bounds.minMax(this.w.pos);
  }
  // ---------- private methods -------- //
  /**
   * @private
   * @param {Vertex} v
   * @param {Vertex} w
   */
  _createHalves(n, s) {
    const i = [
      new tm(this, n),
      new tm(this, s)
    ];
    i[0].twin = i[1], i[1].twin = i[0], this.halves = i, n.connectEdge(this), s.connectEdge(this);
  }
  /**
   * @private
   */
  _updateBezier() {
    this._bezier ? (this._bezier.points[0].x = this.v.pos[0], this._bezier.points[0].y = this.v.pos[1], this._bezier.points[1].x = this.cpV.pos[0], this._bezier.points[1].y = this.cpV.pos[1], this._bezier.points[2].x = this.cpW.pos[0], this._bezier.points[2].y = this.cpW.pos[1], this._bezier.points[3].x = this.w.pos[0], this._bezier.points[3].y = this.w.pos[1], this._bezier.update()) : this._bezier = new Bt(
      ...this.v.pos,
      ...this.cpV.pos,
      ...this.cpW.pos,
      ...this.w.pos
    );
  }
}
function xP(e, n) {
  const s = [];
  e.split(0, n[0]), s.push(kp(e.split(0, n[0])));
  for (let i = 0; i < n.length - 1; i++)
    s.push(kp(e.split(n[i], n[i + 1])));
  return s.push(kp(e.split(n[n.length - 1], 1))), s;
}
function kp(e) {
  return [
    new se(e.points[1]),
    new se(e.points[2])
  ];
}
const vP = 1e-6;
function nm(e, n, s, i) {
  const r = [[], []], o = n[0] - e[0], a = n[1] - e[1], c = i[0] - s[0], l = i[1] - s[1], h = o * l - c * a;
  if (Math.abs(h) < vP) return r;
  const d = e[0] - s[0], p = e[1] - s[1], E = o * p - a * d;
  if (E < 0 == h > 0) return r;
  const g = c * p - l * d;
  return g < 0 == h > 0 || E > h == h > 0 || g > h == h > 0 || (r[0].push(g / h), r[1].push(E / h)), r;
}
const RP = 10;
class Ua extends n0 {
  /**
   * Creates new empty Contour object
   * @param {boolean} [virtual=false]
   */
  constructor(n = !1) {
    super(), this.isClosed = !1, this.isFilled = !1, this.isHole = !1, this.isSimple = !0, this.halves = /* @__PURE__ */ new Set(), this.isVirtual = n, this.bounds = new Fn(), this._vertices = null, this.type = "Contour";
  }
  /**
   * Create Contour object from data
   * @param {ContourData} data
   * @returns {Contour}
   */
  static fromData({ id: n, isClosed: s = !1, isFilled: i = !1, isHole: r = !1 }) {
    super.fromData({ id: n });
    const o = new Ua();
    return o.id = n, o.isClosed = s, o.isFilled = i, o.isHole = r, o.type = "Contour", o;
  }
  /**
   * @param {object} options
   * @param {boolean} [options.isClosed]
   * @param {boolean} [options.isFilled]
   * @param {boolean} [options.isHole]
   * @param {Set<HalfEdge>|HalfEdge[]} [options.halves]
   */
  set({ isClosed: n, isFilled: s, isHole: i, halves: r }) {
    ee(n) && (this.isClosed = n), ee(s) && (this.isFilled = s), ee(i) && (this.isHole = i), ee(r) && (r instanceof Set ? (this.halves = r, this.halves.forEach((o) => {
      o.v.upperTierIDs.size > 2 && (this.isSimple = !1), o.addContour(this);
    }), this.updateBounds()) : hd(r) && (this.halves.clear(), this.bounds.reset(), this.addHalfEdgeList(r)));
  }
  /**
   * Creates a copy of the Contour
   * @returns  {Contour}
   */
  copy() {
    const n = new Ua();
    return n.isFilled = this.isFilled, n.isClosed = this.isClosed, n;
  }
  // TODO: do we need to consider id ?
  /**
   * Checks if this Contour is equal to another Contour
   * @param  {Contour} c
   * @returns {boolean}      true if equal; false otherwise
   */
  eq(n) {
    return n && this.isClosed === n.isClosed && this.isFilled === n.isFilled && this.isHole === n.isHole;
  }
  /**
   * Serialize Contour data
   * @returns {ContourData}
   */
  save() {
    const n = {};
    n.id = this.id, n.isClosed = this.isClosed, n.isFilled = this.isFilled, n.isHole = this.isHole;
    const s = [...this.halves];
    return n.halves = [
      s.map((i) => i.edge.id),
      s.map((i) => i.index)
    ], n;
  }
  disconnect() {
    for (const n of this.halves)
      n.removeContour(this), this.halves.delete(n);
  }
  /**
   * Adds HalfEdge to a contour, as well as connects this contour to added HalfEdge
   * @param {HalfEdge} half
   */
  addHalfEdge(n) {
    n.v.upperTierIDs.size > 2 && (this.isSimple = !1), this.halves.add(n), n.contours.add(this), this.bounds.minMax(n.bounds);
  }
  /**
   * @param {HalfEdge[]} halfList
   */
  addHalfEdgeList(n) {
    for (const s of n)
      this.addHalfEdge(s);
  }
  /**
   * Removes HalfEdge from this contour (if has one)
   * @param  {HalfEdge} half
   * @returns {boolean}      true if successfull; false if `half` is not part of this contour
   */
  removeHalfEdge(n) {
    const s = this.halves.delete(n);
    return s && this.isClosed && (this.isClosed = !1), s && this.updateBounds(), s;
  }
  get numEdges() {
    return this.halves.size;
  }
  get numPoints() {
    return this.isClosed ? this.halves.size : this.halves.size + 1;
  }
  /**
   * @returns {Set<Vertex>}
   */
  get vertices() {
    if (!this._vertices) {
      this._vertices = /* @__PURE__ */ new Set();
      for (const n of this.halves)
        this._vertices.add(n.v);
    }
    return this._vertices;
  }
  /** @returns {Vertex[]} */
  getVertexList() {
    const n = /* @__PURE__ */ new Map();
    for (const s of this.halves) {
      const i = n.get(s.v), r = n.get(s.w);
      if (i && r)
        i !== r && (i.push(...r), n.set(s.w, i), n.set(i[i.length - 1], i));
      else if (i)
        i.push(s.w), n.set(s.w, i);
      else if (r)
        r.unshift(s.v), n.set(s.v, r);
      else {
        const o = [s.v, s.w];
        n.set(s.v, o), n.set(s.w, o);
      }
    }
    return n.values().next().value;
  }
  /** @returns {HalfEdge[]} */
  getEdgeList() {
    const n = /* @__PURE__ */ new Map();
    for (const s of this.halves) {
      const i = n.get(s.v), r = n.get(s.w);
      if (i && r)
        i.push(s), i !== r && (i.push(...r), n.set(s.w, i), n.set(i[i.length - 1].w, i));
      else if (i)
        i.push(s), n.set(s.w, i);
      else if (r)
        r.unshift(s), n.set(s.v, r);
      else {
        const o = [s];
        n.set(s.v, o), n.set(s.w, o);
      }
    }
    return n.values().next().value;
  }
  /** @returns {_Vector2[]} */
  getPointList() {
    return this.getVertexList().map((n) => n.pos);
  }
  /**
   * @param {Vertex} v
   * @returns {boolean}
   */
  hasVertex(n) {
    for (const s of this.halves)
      if (s.v === n)
        return !0;
    return !1;
  }
  /**
   * Checks if a point is inside of this Contour
   * @param {[number, number]}  point  vec2-like point coordinates
   * @param {boolean} [isOnEdgeInside=false]  set to true to count point being inside
   *                                       if it lies on any of the Contour's HalfEdges
   * @returns {boolean}      true if point is inside the Contour
   */
  hasPoint(n, s = !1) {
    if (!_c(n) || !this.bounds.containsPoint(n))
      return !1;
    const i = [n, new se(this.bounds.max[0] + RP, n[1])];
    let r = 0;
    for (const o of this.halves) {
      if (s && o.edge.hasPoint(n))
        return !0;
      r += Number(o.edge.hasIntersectionWith(i));
    }
    return r % 2 === 1;
  }
  updateBounds() {
    this.bounds.reset();
    for (const n of this.halves)
      this.bounds.minMax(n.bounds);
  }
}
class wP {
  /**
   * @param {Mesh} mesh
   */
  constructor(n) {
    this.mesh = n;
  }
  /**
   * Returns Set of halves for each contour found.
   * @param {boolean} [virtual=false]        set to true to include Virtual vertices and virtual Edges in the search
   * @returns {Array<Set<HalfEdge>>}
   */
  findContours(n = !1) {
    return new DP(this.mesh).find(n);
  }
  /**
   * Resolve self intersections, by splitting intersected Edges into virtual Edges
   * and enumerating virtual Contours created as a result
   */
  selfIntersect() {
    const n = this._findIntersections();
    this._createVirtualStructures(n);
  }
  /**
   * @returns {Map<Edge, number[]>}
   */
  _findIntersections() {
    const n = this.mesh, s = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map(), r = (a, c, l) => {
      let h = i.get(a);
      h || (h = [], i.set(a, h)), h.push(...c[l]);
    };
    let o;
    for (const a of n.getEdges()) {
      o = a.intersect(), r(a, o, 0);
      for (const c of n.getEdges())
        a !== c && (s.has(`${a.id},${c.id}`) || (s.add(`${c.id},${a.id}`), o = a.intersect(c), o[0].length !== 0 && [a, c].forEach((l, h) => {
          r(l, o, h);
        })));
    }
    return i;
  }
  /**
   * @param {Map<Edge, number[]>} intersections
   */
  _createVirtualStructures(n) {
    const s = { virtual: !0 };
    for (const [i, r] of n)
      this.mesh.splitEdge(i, r, s);
    for (const i of this.findContours(!0))
      this.mesh.addContour(i, s);
  }
}
class DP {
  /**
   * @param {Mesh} mesh
   */
  constructor(n) {
    this.mesh = n, this.vertices = [], this.adjMap = /* @__PURE__ */ new Map(), this.realEdgesMap = /* @__PURE__ */ new Map(), this.loopHalfEdgeSets = [];
  }
  /**
   * @param {Mesh} mesh
   * @param {boolean} [virtual]
   */
  makeAdjacencyMap(n, s = !1) {
    for (const i of n.getVertices({ virtual: s })) {
      this.vertices.push(i);
      const r = [];
      for (const o of i.getOutHalves({ all: s }))
        o.w === i || o.hasVirtualEdges() || r.push(o.w);
      this.adjMap.set(i, r);
    }
    for (const i of n.getEdges()) {
      if (i.hasVirtualEdges())
        continue;
      if (i.v === i.w) {
        this.dealWithLoops(i);
        continue;
      }
      if (!i.isCurve)
        continue;
      const r = this.makeVirtualCurveSplit(i);
      this.vertices.push(r), this.adjMap.set(r, [i.v, i.w]);
      let o = this.adjMap.get(i.v);
      o.splice(o.indexOf(i.w), 1, r), o = this.adjMap.get(i.w), o = o.splice(o.indexOf(i.v), 1, r);
    }
  }
  /**
   * @param {Edge} edge
   */
  dealWithLoops(n) {
    this.loopHalfEdgeSets.push(/* @__PURE__ */ new Set([n.halves[0]]));
  }
  /**
   * @param {Edge} edge
   * @returns {Vertex}
   */
  makeVirtualCurveSplit(n) {
    const s = this.mesh, i = n.split([0.5]), r = { virtual: !0 }, o = s.addVertex(i.atPositions[0], r);
    return this.realEdgesMap.set(o, n), o;
  }
  /**
   * @param {Vertex[][]} cycles
   * @returns {Array<Set<HalfEdge>>}
   */
  convertToHalfEdgeSets(n) {
    const s = [];
    for (const i of n) {
      const r = /* @__PURE__ */ new Set();
      let o = this.realEdgesMap.get(i[0]);
      o && i.unshift(i.pop());
      for (let a = 0; a < i.length; a++) {
        const c = i[a], l = i[AA(a + 1, 0, i.length)];
        let h;
        if (o = this.realEdgesMap.get(l), o ? (h = o.getHalf(c, i[AA(a + 2, 0, i.length)]), a++) : h = eP(c.getOutHalves(), (d) => !d.edge.isCurve && d.w === l), !h)
          throw new Error("Failed to find matching HalfEdge. This should not happen.");
        r.add(h);
      }
      s.push(r);
    }
    for (const [i] of this.realEdgesMap)
      this.mesh.deleteVertex(i);
    for (const i of this.loopHalfEdgeSets)
      s.push(i);
    return s;
  }
  /**
   * @param {boolean} [virtual=false]   set to true to include virtual Vertices in the search
   * @returns {Array<Set<HalfEdge>>}
   */
  find(n = !1) {
    this.makeAdjacencyMap(this.mesh, n);
    const s = [];
    let i = this.vertices;
    for (; i.length > 0; ) {
      const r = this.leftBottomVertex(i), o = this.reduceWalk(this.closedWalkFrom(r));
      o.length > 2 && s.push(o), this.removeEdge(o[0], o[1]), i = this.removeFilamentAt(o[0], i), i = this.removeFilamentAt(o[1], i);
    }
    return this.convertToHalfEdgeSets(s);
  }
  /**
   * @param {Vertex[]} vertices
   * @returns {Vertex}
   */
  leftBottomVertex(n) {
    return n.reduce((s, i) => {
      const r = s.pos, o = i.pos, a = o[0] - r[0];
      return a < 0 ? i : a > 0 || o[1] - r[1] < 0 ? s : i;
    });
  }
  /**
   * @param {Vertex} v
   * @returns {Vertex[]}
   */
  closedWalkFrom(n) {
    const s = [];
    let i = n, r;
    do
      s.push(i), [i, r] = this.getNext(i, r);
    while (i && i !== n);
    return s;
  }
  /**
   * @param {Vertex[]} walk
   * @returns {Vertex[]}
   */
  reduceWalk(n) {
    for (let s = 1; s < n.length; s++) {
      const i = n.lastIndexOf(n[s]);
      i > s && n.splice(s + 1, i - s);
    }
    return n;
  }
  /**
   * @param {Vertex} v1
   * @param {Vertex} v2
   */
  removeEdge(n, s) {
    this.adjMap.set(n, this.withoutVertex(s, this.adjMap.get(n))), this.adjMap.set(s, this.withoutVertex(n, this.adjMap.get(s)));
  }
  /**
   * @param {Vertex} v
   * @param {Vertex[]} vertices
   * @returns {Vertex[]}
   */
  removeFilamentAt(n, s) {
    let i = n, r = s, o;
    for (; i && this.adjMap.get(i).length < 2; )
      r = this.withoutVertex(i, r), o = this.adjMap.get(i)[0], o && this.removeEdge(i, o), i = o;
    return r;
  }
  /**
   * @param {Vertex} v
   * @param {Vertex[]} adj
   * @returns {Vertex[]}
   */
  withoutVertex(n, s) {
    return !s || !s.length ? [] : s.filter((i) => i !== n);
  }
  /**
   * @param {Vertex} curr
   * @param {Vertex} prev
   * @returns {[Vertex, Vertex]}
   */
  getNext(n, s) {
    const i = this.adjMap.get(n);
    return !i || !i.length ? [] : [i.length === 1 ? i[0] : this.bestByKind(s, n, s ? "ccw" : "cw"), n];
  }
  /**
   * @param {Vertex} prev
   * @param {Vertex} curr
   * @param {string} kind
   * @returns {Vertex}
   */
  bestByKind(n, s, i) {
    let r, o = this.adjMap.get(s);
    return n ? (r = this.vsub(s, n), o = this.withoutVertex(n, o)) : r = new se(0, -1), o.reduce((a, c) => this.betterByKind(c, a, s, r, i), null);
  }
  /**
   * @param {Vertex} v
   * @param {Vertex} vSoFar
   * @param {Vertex} vCurr
   * @param {_Vector2} dCurr
   * @param {string} kind
   * @returns {Vertex}
   */
  betterByKind(n, s, i, r, o) {
    if (!s)
      return n;
    const a = this.vsub(n, i), c = this.vsub(s, i), l = this.dotPerp(c, r) > 0, h = this.dotPerp(r, a), d = this.dotPerp(c, a);
    let p;
    return o === "cw" ? p = l && (h >= 0 || d >= 0) || !l && h >= 0 && d >= 0 : p = !l && (h < 0 || d < 0) || l && h < 0 && d < 0, p ? n : s;
  }
  /**
   * @param {Vertex} v1
   * @param {Vertex} v2
   * @returns {_Vector2}
   */
  vsub(n, s) {
    return ba(new se(), n.pos, s.pos);
  }
  /**
   * @param {_Vector2} a
   * @param {_Vector2} b
   * @returns {number}
   */
  dotPerp(n, s) {
    return n.x * s.y - s.x * n.y;
  }
}
const ms = 1e-5, Qn = 1e-12, Bp = 112e-18, Bs = 1e-8, hr = 1e-7, LP = 1e-5, MP = 180 / Math.PI, PP = Math.PI / 180, bP = Math.PI / 2, V1 = Math.PI * 2, ss = {
  0: 0,
  15: Math.PI / 12,
  45: Math.PI / 4,
  90: Math.PI / 2,
  180: Math.PI
};
class ac {
  static processVertices(n, s, i = !1) {
    const r = /* @__PURE__ */ new Set();
    i && n.vertices.forEach((a) => r.add(a.id));
    const o = {};
    for (const a of s) {
      const c = Yo.fromData(a);
      if (i && r.has(a.id)) {
        const l = n.cellTable.get(a.id);
        n.vertices.delete(l);
      }
      n.vertices.add(c), n.cellTable.set(c.id, c), o[c.id] = c;
    }
    for (let a = 0; a < s.length; a++) {
      const c = s[a];
      if (!c.adjMainId)
        continue;
      const l = o[c.id];
      l.adjacentMainVertex = o[c.adjMainId], l.flag(Be.CURVE_VERT);
    }
    return o;
  }
  static processEdges(n, s, i, r = !1) {
    const o = r ? new Set([...n.edges.values()].map((l) => l.id)) : null, a = {}, c = new Set(Object.keys(i));
    for (const l of s) {
      let h, d;
      const p = i[l.v], E = i[l.w];
      if (l.curveIds && (h = i[l.curveIds[0]], d = i[l.curveIds[1]]), h || (h = n._createAndRecordVertex()), d || (d = n._createAndRecordVertex()), r) {
        if (o.has(l.id)) {
          const A = n.cellTable.get(l.id);
          n.edges.delete(A);
        }
      } else l.curve && (h.set({ pos: new se(l.curve[0]) }), d.set({ pos: new se(l.curve[1]) }));
      const g = l.curve != null, T = Bi.fromData({ ...l, v: p, cpV: h, cpW: d, w: E }, g);
      n.edges.add(T), a[T.id] = T, n.cellTable.set(T.id, T), c.delete(p.id), c.delete(h.id), c.delete(d.id), c.delete(E.id);
    }
    for (const l of c) {
      const h = n.cellTable.get(l);
      h.isFlagged(Be.CURVE_VERT) && (h.adjacentMainVertex.unlinkedCurveControl = h.id);
    }
    return a;
  }
  static processContours(n, s, i) {
    for (const r of s) {
      const o = Ua.fromData(r);
      for (let a = 0; a < r.halves[0].length; a++) {
        const c = i[r.halves[0][a]];
        if (!c) {
          console.warn(`Edge ${r.halves[0][a]} not found`);
          continue;
        }
        const l = c.halves[r.halves[1][a]];
        l.edge.upperTierIDs.add(o.id), o.addHalfEdge(l);
      }
      n.contours.add(o), n.cellTable.set(o.id, o);
    }
  }
}
function UP(e, n) {
  let s = e.pos[0];
  e.pos[0] = n.pos[0], n.pos[0] = s, s = e.pos[1], e.pos[1] = n.pos[1], n.pos[1] = s;
}
function sm(e, n) {
  for (const [s, i] of n)
    if (e.has(s)) {
      const r = e.get(s);
      UP(r, i);
    }
}
class Ed extends F1 {
  /**
   * Create new instance of the Mesh, or make a copy of existing one
   * @param {object} [options]
   * @param {boolean} [options.autoIncrementIds]   - use auto incremented integers as IDs
   *                                            for Vertices, Edges and Contours
   */
  constructor({ autoIncrementIds: n = !1 } = {}) {
    super(void 0, Rr.ENTITY, Oe.MESH_CHANGES), this.cellTable = /* @__PURE__ */ new Map(), this.vertices = new cc(), this.edges = new cc(), this.contours = new cc(), this.bounds = new Fn(), this.virtualVertices = new cc(), this.virtualEdges = new cc(), this.virtualContours = new cc(), n && (this._ids = {
      vertices: 0,
      edges: 0,
      contours: 0
    }), this._meshHelper = new wP(this), this._isCollinear = !1, this.id = Zr(gi.MESH);
  }
  get isEmpty() {
    return this.bounds.isInfinite;
  }
  get isCollinear() {
    return this._isCollinear;
  }
  /**
  * Create Mesh instance from serialized data
  * @param {Mesh} mesh
  * @param  {MeshData} data
  */
  // addFromData : { vertices, edges, contours } using the same id to create edge, vertex and contours
  static addFromData(n, { vertices: s, edges: i, contours: r }) {
    const o = ac.processVertices(n, s, !0), a = ac.processEdges(n, i, o, !0);
    ac.processContours(n, r, a), n.recalculateBounds();
  }
  /**
   * Create Mesh instance from serialized data
   * @param  {MeshData} data
   * @returns {Mesh}
   */
  static fromData({ vertices: n, edges: s, contours: i }) {
    const r = new Ed(), o = ac.processVertices(r, n), a = ac.processEdges(r, s, o);
    return ac.processContours(r, i, a), r.recalculateBounds(), r;
  }
  /**
   * Creates a copy of this Mesh
   * @param {boolean} [keepID]
   * @param {Map<string, VertexData>} basePath
   * @returns {Mesh} new mesh instance
   */
  copy(n = !1, s) {
    const i = new Ed(), r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
    for (const a of this.vertices) {
      const c = a.copy();
      if (n && (c.id = a.id), s && s.has(a.id)) {
        const l = s.get(a.id);
        c.pos.x = l.pos[0], c.pos.y = l.pos[1], c.mirror = l.mirror;
      }
      r.set(a, c), i.vertices.add(c), i.cellTable.set(c.id, c);
    }
    for (const a of i.vertices)
      a.unlinkedCurveControl != null && (a.unlinkedCurveControl = r.get(a.unlinkedCurveControl)), a.adjacentMainVertex != null && (a.adjacentMainVertex = r.get(a.adjacentMainVertex));
    for (const a of this.edges) {
      const c = r.get(a.v), l = r.get(a.cpV), h = r.get(a.cpW), d = r.get(a.w);
      if (!c || !l || !h || !d) {
        console.warn("The edge can not get its own vertex in the mesh, please check your duplicate function or mesh id in case the instance of mesh is replaced incorrectly");
        continue;
      }
      const p = a.copy(r.get(a.v), r.get(a.cpV), r.get(a.cpW), r.get(a.w));
      n && (p.id = a.id), o.set(a.halves[0], p.halves[0]), o.set(a.halves[1], p.halves[1]), i.edges.add(p), i.cellTable.set(p.id, p);
    }
    for (const a of this.contours) {
      const c = a.copy();
      if (n && (c.id = a.id), [...a.halves].some((l) => !o.get(l) || !o.get(l).edge)) {
        console.warn("The contour can not get its own edge in the mesh, please check your duplicate function or mesh id in case the instance of mesh is replaced incorrectly");
        continue;
      }
      c.halves = new Set([...a.halves].map((l) => o.get(l))), i.contours.add(c), i.cellTable.set(c.id, c);
    }
    return i.bounds.copy(this.bounds), i;
  }
  /**
  * The Figma style no longer meets our animation requirements, but we don't have time to update the unit tests.
  * The unit tests aren't flexible enough to solely verify the algorithm.
  * @returns {MeshData}
  */
  saveFigmaData() {
    return {
      vertices: [...this.vertices].filter((n) => !n.isFlagged(Be.CURVE_VERT)).map((n) => {
        const s = n.save(!0);
        if (n.upperTierIDs.size === 1) {
          const i = this.cellTable.get(n.upperTierIDs.values().next().value);
          s.mirror = i && i.id && i.isCurve ? pe.INDEPENDENT : pe.NONE;
        }
        return s;
      }),
      edges: [...this.edges].map((n) => n.save(!0)),
      contours: [...this.contours].map((n) => n.save())
    };
  }
  /**
   * Serialize Mesh structure
   * @param {Map<string, VertexData> } basePath
   * @returns {MeshData}
   */
  save(n) {
    const s = new Array(), i = new Array(), r = new Array();
    n && sm(this.cellTable, n);
    for (const o of this.vertices)
      s.push(o.save());
    for (const o of this.edges)
      i.push(o.save());
    for (const o of this.contours)
      r.push(o.save());
    return n && sm(this.cellTable, n), { vertices: s, edges: i, contours: r };
  }
  /**
   * Returns iterator over mesh Vertices
   * @param {object} [options]
   * @param {object} [options.virtual = false]  iterates only over virtual Vertices
   * @param {object} [options.all = false]      iterates over all Vertices
   * @yields {Vertex}
   */
  *getVertices({ virtual: n = !1, all: s = !1 } = {}) {
    if (s || !n)
      for (const i of this.vertices)
        i.isFlagged(Be.CURVE_VERT) || (yield i);
    if (s || n)
      for (const i of this.virtualVertices)
        yield i;
  }
  /**
   * Returns iterator over mesh Edges
   * @param {object} [options]
   * @param {object} [options.virtual = false]  iterates only over virtual Edges
   * @param {object} [options.all = false]      iterates over all Edges
   * @yields {Edge}
   */
  *getEdges({ virtual: n = !1, all: s = !1 } = {}) {
    if (s || !n)
      for (const i of this.edges)
        yield i;
    if (s || n)
      for (const i of this.virtualEdges)
        yield i;
  }
  /**
   * Returns iterator over mesh Contours
   * @param {object} [options]
   * @param {object} [options.virtual = false]  iterates only over virtual Contours
   * @param {object} [options.all = false]      iterates over all Contours
   * @yields {Contour}
   */
  *getContours({ virtual: n = !1, all: s = !1 } = {}) {
    if (s || !n)
      for (const i of this.contours)
        yield i;
    if (s || n)
      for (const i of this.virtualContours)
        yield i;
  }
  /**
   * Returns total number of Vertices in this Mesh
   * @param {object} [options]
   * @param {object} [options.virtual = false]  includes only number of virtual Vertices
   * @param {object} [options.all = false]      includes both real and virtual Vertices
   * @returns {number}
   */
  getNumVertices({ virtual: n = !1, all: s = !1 } = {}) {
    let i = 0;
    return (s || !n) && (i += this.vertices.size), (s || n) && (i += this.virtualVertices.size), i;
  }
  /**
   * Returns total number of Edges in this Mesh
   * @param {object} [options]
   * @param {object} [options.virtual = false]  includes only number of virtual Edges
   * @param {object} [options.all = false]      includes both real and virtual Edges
   * @returns {number}
   */
  getNumEdges({ virtual: n = !1, all: s = !1 } = {}) {
    let i = 0;
    return (s || !n) && (i += this.edges.size), (s || n) && (i += this.virtualEdges.size), i;
  }
  /**
   * Returns total number of Contours in this Mesh
   * @param {object} [options]
   * @param {object} [options.virtual = false]  includes only number of virtual Contours
   * @param {object} [options.all = false]      includes both real and virtual Contours
   * @returns {number}
   */
  getNumContours({ virtual: n = !1, all: s = !1 } = {}) {
    let i = 0;
    return (s || !n) && (i += this.contours.size), (s || n) && (i += this.virtualContours.size), i;
  }
  /**
   * Finds first vertex closest to the specified point
   *  (within the optional epsilon proximity)
   * @param {_Vector2} pos                          position of the point
   * @param {object} [options]
   * @param {number} [options.epsilon=0.0001]      proximity (default is 0.0001)
   * @param {boolean} [options.virtual=false]         if true, only searches virtual vertices
   * @param {boolean} [options.all=false]             if true, searches both real and virtual vertices
   * @returns {Vertex}                             closest vertex
   */
  findVertex(n, s = { epsilon: wn }) {
    return this.findVertices(n, s).next().value;
  }
  /**
   * Returns iterator over all the vertices closest to the specified point (within the optional epsilon proximity)
   * @param {_Vector2} pos                          position of the point
   * @param {object} [options]
   * @param {number} [options.epsilon=0.0001]      proximity (default is 0.0001)
   * @param {boolean} [options.virtual=false]         if true, only searches virtual vertices
   * @param {boolean} [options.all=false]             if true, searches both real and virtual vertices
   * @yields {Vertex}             vertices that are within proximity to the point pos
   */
  *findVertices(n, {
    epsilon: s = wn,
    virtual: i = !1,
    all: r = !1
  } = { epsilon: wn }) {
    if (r || !i)
      for (const o of this.vertices.values())
        ka(o.pos, n, s) && (yield o);
    if (r || i)
      for (const o of this.virtualVertices.values())
        ka(o.pos, n, s) && (yield o);
  }
  /**
   * Wipes previous contour records and enumerates all existing contours again
   * by traversing the Mesh
   */
  detectContours() {
    for (const n of this.contours)
      n.disconnect(), this._deleteContour(n);
    for (const n of this._meshHelper.findContours())
      this.addContour(n);
  }
  /**
   * Resolve self-intersections and create resulting virtual Vertices, Edges, and Contours
   * Erases all previous virtual structures.
   */
  selfIntersect() {
    this.deleteVirtualStructures(), this._meshHelper.selfIntersect();
  }
  /**
   * Resets and recalculates bounds of the whole Mesh
   * @returns {AABB}  new recalculated bounds
   */
  recalculateBounds() {
    this.bounds.reset();
    for (const n of this.getVertices())
      n.isFlagged(Be.CURVE_VERT) || this.bounds.minMax(n.pos);
    this._isCollinear = !0;
    for (const n of this.edges)
      WP(this, n) || (this._isCollinear = !1, n.updateBounds(), this._updateBounds(n.bounds));
    return this._isCollinear && this._validateCollinear(), this.bounds;
  }
  _validateCollinear() {
    const n = Array.from(this.edges.values());
    if (n.length < 2)
      return;
    const s = n[0].v.pos, i = n[0].w.pos, r = [i.x - s.x, i.y - s.y];
    for (let o = 1; o < n.length; o++) {
      const a = n[o].v.pos, c = n[o].w.pos, l = [c.x - a.x, c.y - a.y];
      if (!gd(r[0], r[1], l[0], l[1])) {
        this._isCollinear = !1;
        return;
      }
    }
  }
  /**
   * Check if Vertex exists in this Mesh
   * @param  {Vertex}  v
   * @returns {boolean}
   */
  hasVertex(n) {
    return this.vertices.has(n) || this.virtualVertices.has(n);
  }
  /**
   * Check if Edge exists in this Mesh
   * @param  {Edge}  e
   * @returns {boolean}
   */
  hasEdge(n) {
    return this.edges.has(n) || this.virtualEdges.has(n);
  }
  /**
   * Check if Contour exists in this Mesh
   * @param  {Contour}  c
   * @returns {boolean}
   */
  hasContour(n) {
    return this.contours.has(n) || this.virtualContours.has(n);
  }
  /**
   * Add Vertex at the point `pos`
   * @param {_Vector2}  pos
   * @param {object} [options]
   * @param {object} [options.data]           data that can be provided to Vertex#set()
   * @param {boolean} [options.virtual=false]     set to true if adding a virtual Vertex
   * @param {boolean} [options.findExisting=false]  if true and there's an existing vertex at
   *                                               position `pos`, returns an existing one
   * @param {number} [options.epsilon=0.0001]    proximity (default is 0.0001)
   * @returns {Vertex}
   */
  addVertex(n, {
    data: s = void 0,
    virtual: i = !1,
    findExisting: r = !1,
    epsilon: o = wn
  } = { epsilon: wn }) {
    let a;
    return r ? a = this.findVertices(n, { epsilon: o, virtual: i }) : (a = new Yo(i), this._ids && (a.id = Zr(gi.MESH)), a.set({ ...s, pos: n }), this._addVertex(a), this.cellTable.set(a.id, a)), a;
  }
  /**
   * Adds a new edge connecting two vertices. If a position provided as second argument
   * instead of existing vertex, then a new vertex is added at that position as well
   * @param {Vertex}  v
   * @param {Vertex}  w
   * @param {object} [options]
   * @param {_Vector2[]} [options.curve=null]
   * @param {boolean} [options.virtual=false]
   * @returns {Edge}
   */
  addEdge(n, s, {
    curve: i = null,
    virtual: r = !1
  } = { curve: null }) {
    if (!n || !s || !this.hasVertex(n))
      return;
    if (!r && (n.isVirtual || s.isVirtual))
      throw new Error("Not allowed to add a real edge to virtual vertices");
    const o = this.hasVertex(s) ? s : this.addVertex(s, r), a = new Bi(r);
    this._ids && (a.id = Zr(gi.MESH));
    const c = this.addVertex(i ? i[0] : n.pos, r);
    this.cellTable.set(c.id, c);
    const l = this.addVertex(i ? i[1] : s.pos, r);
    return this.cellTable.set(l.id, l), a.set({ v: n, cpV: c, cpW: l, w: o }, i !== null), this._addEdge(a), this._updateBounds(a.bounds), this.cellTable.set(a.id, a), a;
  }
  /**
   * Manualy add a closed Contour to Mesh.
   * @param {Set<HalfEdge>}  halves
   * @param {object} [options]
   * @param {boolean} [options.virtual=false]
   * @returns {Contour}
   */
  addContour(n, { virtual: s = !1 } = {}) {
    const i = new Ua(s);
    return this._ids && (i.id = Zr(gi.MESH)), i.set({ isClosed: !0, halves: n }), this._addContour(i), i;
  }
  /**
   * Adds a vertex to an existing edge, spliting it in two edges. Original edge
   *  will be removed if isVirtual === false.
   *  Splits will be made in order
   *  (v,splitPoints[0]), (splitPoints[1], splitPoints[2]), ..., (splitPoints[-1], w)
   * @param {Edge} edge
   * @param {number[]} fractions          list of fractions (in range [0, 1] each) along the
   *                                          length of the edge at edge need to be split
   * @param {object} [options]
   * @param {boolean} [options.virtual=false]      set to true to make new edges and vertices virtual
   * @param {boolean} [options.findExisting=false]   if true, will use existing vertices found
   *                                                at split positions (if any)
   * @returns {Edge[]} new edges created after split
   */
  splitEdge(n, s, {
    virtual: i = !1,
    findExisting: r = !1
  } = { virtual: !1, findExisting: !1 }) {
    if (!n || !s || s.length === 0)
      return;
    const { atPositions: o, newCurves: a } = n.split(s), c = [];
    for (const h of o)
      c.push(this.addVertex(h, { virtual: i, findExisting: r }));
    const l = [];
    l.push(this.addEdge(n.v, c[0], {
      curve: a[0],
      virtual: i
    }));
    for (let h = 0; h < c.length - 1; h++)
      l.push(this.addEdge(c[h], c[h + 1], {
        curve: a[h],
        virtual: i
      }));
    return l.push(this.addEdge(c[c.length - 1], n.w, {
      curve: a[a.length - 1],
      virtual: i
    })), i ? n.addVirtualEdges(l) : (n.disconnect(), this._deleteEdge(n)), l;
  }
  /**
   * @param {Vertex} vertex
   */
  deleteVertex(n) {
    let s;
    if (n.isVirtual ? s = this.virtualVertices.delete(n) : s = this.vertices.delete(n), s)
      for (const i of n.getEdges())
        i.disconnect(), i.isVirtual ? this.virtualEdges.delete(i) : this.edges.delete(i);
  }
  /**
   * Delete cells by vertex
   * @param {Vertex[]} vertices
   * @param {boolean} undoable
   * @todo Sort cells by type when supporting Edge, Contour editing
   */
  deleteCellsByVertex(n, s = !0) {
    const i = /* @__PURE__ */ new Set(), r = [], o = /* @__PURE__ */ new Set();
    for (const h of n)
      if (h.isFlagged(Be.CURVE_VERT))
        o.add(h);
      else {
        for (const d of h.upperTierIDs)
          i.add(d), r.push(this.cellTable.get(d));
        h.unlinkedCurveControl && i.add(h.unlinkedCurveControl), this.cellTable.has(xo.CURVE_CONTROL) && i.add(this.cellTable.get(xo.CURVE_CONTROL).id), i.add(h.id);
      }
    const a = /* @__PURE__ */ new Map();
    for (const h of r) {
      i.add(h.cpV.id), i.add(h.cpW.id);
      const d = i.has(h.v.id) ? h.w : h.v;
      let p = 0;
      a.has(d.id) && (p = a.get(d.id)), p++, p === d.upperTierIDs.size ? (i.add(d.id), d.unlinkedCurveControl && i.add(d.unlinkedCurveControl)) : a.set(d.id, p);
      for (const E of h.upperTierIDs)
        i.add(E);
    }
    const c = this.changes, l = [];
    for (const h of o) {
      const d = h.adjacentMainVertex;
      l.push(d);
      const p = new nn({
        before: new se(h.pos),
        after: new se(d.pos)
      });
      c.update(h.id, "pos", p);
    }
    for (const h of l) {
      let d = !0;
      for (const g of h.upperTierIDs)
        if (this.cellTable.get(g).isCurve) {
          d = !1;
          break;
        }
      let p = null;
      h.unlinkedCurveControl && this.cellTable.has(h.unlinkedCurveControl) && (p = this.cellTable.get(h.unlinkedCurveControl)), p && this.vertices.has(p) && !i.has(h.unlinkedCurveControl) && p.pos.eq(h.pos) && (d = !1);
      const E = new nn({
        before: h.mirror,
        after: d ? pe.NONE : pe.INDEPENDENT
      });
      c.update(h.id, "mirror", E);
    }
    c.delete(i), this.applyChanges(this.changes), this.fire(s);
  }
  deleteEdge() {
  }
  deleteContour() {
  }
  deleteVirtualStructures() {
    const n = { virtual: !0 };
    for (const s of this.getContours(n))
      s.disconnect(), this._deleteContour(s);
    for (const s of this.getEdges(n))
      s.disconnect(), this._deleteEdge(s);
    for (const s of this.getVertices(n))
      this._deleteVertex(s);
  }
  /**
   * Trims empty space between the vertex positions and bounds.
   */
  trim() {
    const n = new se(this.bounds.min);
    if (!q2(n, se.ZERO))
      for (const s of this.vertices) {
        const i = ba(s.pos, s.pos, n);
        s.set({ pos: i });
      }
    this.recalculateBounds();
  }
  // ----------------------------
  /**
   * @param {AABB} edgeBounds
   */
  _updateBounds(n) {
    this.bounds.minMax(n);
  }
  /**
   * @param {Vertex} v
   */
  _addVertex(n) {
    n.isVirtual ? this.virtualVertices.add(n) : this.vertices.add(n);
  }
  /**
   * @param {Edge} e
   */
  _addEdge(n) {
    n.isVirtual ? this.virtualEdges.add(n) : this.edges.add(n);
  }
  /**
   * @param {Contour} c
   */
  _addContour(n) {
    n.isVirtual ? this.virtualContours.add(n) : this.contours.add(n);
  }
  /**
   * @param {Vertex} v
   */
  _deleteVertex(n) {
    n.isVirtual ? this.virtualVertices.delete(n) : this.vertices.delete(n);
  }
  /**
   * @param {Edge} e
   */
  _deleteEdge(n) {
    n.isVirtual ? this.virtualEdges.delete(n) : this.edges.delete(n);
  }
  /**
   * @param {Contour} c
   */
  _deleteContour(n) {
    n.isVirtual ? this.virtualContours.delete(n) : this.contours.delete(n);
  }
  /**
   * Move the vertices by offsets and the size of the element space
   * @param {Vertex[]} vertices The vertices we want to move
   * @param {number} offsetX the offset in the x component
   * @param {number} offsetY the offset in the y component
   * @param {bool} [undoable=true]
   * @param {bool} [fire=true]
   */
  moveVertex(n, s, i, r = !0, o = !0) {
    if (!n || !(n.length > 0)) {
      console.warn("Empty parameter of moveVertex");
      return;
    }
    const a = new se(s, i);
    Math.abs(s) < Wo && Math.abs(this.bounds.width) < Wo && (a.x = 0), Math.abs(i) < Wo && Math.abs(this.bounds.height) < Wo && (a.y = 0), this._changePointShapesWhenMoving(n);
    for (const c of n)
      this._preparePositionUpdate(c.id, a), c.isFlagged(Be.CURVE_VERT) ? this._prepareMirrorCurveUpdates(c, a) : this._prepareConnectedCurveUpdates(c, a);
    this.applyChanges(this.changes), o && this.fire(r);
  }
  /**
   * Note: This function will not submit the change
   * Changes to a vertex's position and move their associated vertices
   * @param {Vertex} vertex - The target vertex whose position needs to be changed.
   * @param {number} x
   * @param {number} y
   * @returns {void}
   *
   * @throws {Error} - Throws an error if certain conditions are not met, e.g., unexpected vertex IDs.
   */
  situateVertexToPos(n, s, i) {
    const r = new se(s, i), o = new nn({
      before: new se(n.pos),
      after: r
    });
    this.changes.update(n.id, "pos", o);
    const c = new se(r.x - n.pos.x, r.y - n.pos.y);
    n.isFlagged(Be.CURVE_VERT) ? this._prepareMirrorCurveUpdates(n, c) : this._prepareConnectedCurveUpdates(n, c);
  }
  /**
   *
   * @param {Vertex[]} vertices
   */
  _changePointShapesWhenMoving(n) {
    Vp.clear();
    for (const s of n) {
      if (!s.isFlagged(Be.CURVE_VERT)) continue;
      const i = s.adjacentMainVertex;
      if (n.indexOf(i) === -1)
        if (Vp.has(i.id) && i.mirror !== pe.INDEPENDENT || i.upperTierIDs.size > 2) {
          const r = new nn({
            before: i.mirror,
            after: pe.INDEPENDENT
          });
          this.changes.update(i.id, "mirror", r);
        } else
          Vp.add(i.id);
    }
  }
  /**
   * Updates the position of a curve control handle's corresponding mirror based on movement of the initial handle.
   * This function shows the disavandatges of using the edge-based curve control data structure
   * @param {Vertex} movingCurveHandle - The curve handle that is being moved.
   * @param {_Vector2} movementOffset - The vector by which the handle has moved.
   */
  _prepareMirrorCurveUpdates(n, s) {
    const i = n.adjacentMainVertex, r = i.mirror !== pe.ANGLE_AND_LENGTH && i.mirror !== pe.ANGLE, o = i.upperTierIDs.size > 2;
    if (r || o) return;
    let a = null;
    switch (i.upperTierIDs.size) {
      case 1:
        if (!i.unlinkedCurveControl || i.unlinkedCurveControl === n.id)
          a = i.upperTierIDs.values().next().value;
        else {
          this._moveMirrorCurveControl(
            this.cellTable.get(i.unlinkedCurveControl),
            s,
            n,
            i
          );
          return;
        }
        break;
      case 2:
        i.unlinkedCurveControl && console.warn("Unexpected unlinkedCurveControl detected; check the loading process."), a = Array.from(i.upperTierIDs).find((l) => l !== n.controllingEdge.id);
        break;
    }
    if (a) {
      const c = this.cellTable.get(a), l = c.v === i, h = c.curve[l ? 0 : 1];
      this._moveMirrorCurveControl(
        h,
        s,
        n,
        i
      );
    }
  }
  /**
   *
   * @param {Vertex} oppositeCurveControl
   * @param {_Vector2} localOffset
   * @param {Vertex} movingCurveHandle
   * @param {_Vector2} wedgeVert
   */
  _moveMirrorCurveControl(n, s, i, r) {
    const o = new se();
    if (Fi(o, i.pos, s), ba(o, o, r.pos), o.x *= -1, o.y *= -1, r.mirror === pe.ANGLE) {
      ba(im, n.pos, r.pos);
      const l = FE(im);
      Dl(o, o), o.x *= l, o.y *= l;
    }
    const a = new se();
    Fi(a, r.pos, o);
    const c = new nn({
      before: new se(n.pos),
      after: a
    });
    this.changes.update(n.id, "pos", c);
  }
  /**
   *
   * @param {Vertex} vertex
   * @param {_Vector2} offset
   */
  _prepareConnectedCurveUpdates(n, s) {
    n.unlinkedCurveControl && this._preparePositionUpdate(n.unlinkedCurveControl, s);
    for (const i of n.upperTierIDs) {
      const r = this.cellTable.get(i), o = r.v.id === n.id ? 0 : 1;
      this._preparePositionUpdate(r.curve[o].id, s);
    }
  }
  /**
   *
   * @param {EntityChange} changes
   */
  applyCreateChanges(n) {
    const s = /* @__PURE__ */ new Map();
    s.set("Vertex", /* @__PURE__ */ new Set()), s.set("Edge", /* @__PURE__ */ new Set()), s.set("Contour", /* @__PURE__ */ new Set());
    for (const i of n.CREATE) {
      const r = this.cellTable.get(i);
      s.get(r.type).add(r);
    }
    for (const i of s.get("Vertex"))
      this.vertices.add(i);
    for (const i of s.get("Edge")) {
      this.edges.add(i);
      const r = i;
      r.v.connectEdge(r), r.w.connectEdge(r);
    }
    for (const i of s.get("Contour")) {
      this.contours.add(i);
      const r = i;
      for (const o of r.halves)
        o.edge.upperTierIDs.add(r.id);
    }
  }
  /**
   *
   * @param {EntityChange} changes
   */
  applyDeleteChanges(n) {
    const s = /* @__PURE__ */ new Map();
    s.set("Vertex", /* @__PURE__ */ new Set()), s.set("Edge", /* @__PURE__ */ new Set()), s.set("Contour", /* @__PURE__ */ new Set());
    for (const i of n.DELETE) {
      const r = this.cellTable.get(i);
      s.get(r.type).add(r);
    }
    for (const i of s.get("Contour")) {
      this.contours.delete(i);
      const r = i;
      for (const o of r.halves)
        o.edge.upperTierIDs.delete(r.id);
    }
    for (const i of s.get("Edge")) {
      this.edges.delete(i);
      const r = i;
      r.v.disconnectEdge(r), r.w.disconnectEdge(r);
    }
    for (const i of s.get("Vertex"))
      this.vertices.delete(i);
  }
  /**
   *
   * @param {EntityChange} changes
   */
  applyUpdateChanges(n) {
    const s = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
    for (const [r, o] of n.UPDATE) {
      const a = this.cellTable.get(r);
      for (const [c, l] of o)
        c === "pos" ? (a[c].copy(l.after), i.add(a)) : a[c] = l.after;
    }
    for (const r of i)
      if (r.isFlagged(Be.CURVE_VERT))
        r.controllingEdge && s.add(r.controllingEdge.id);
      else
        for (const o of r.upperTierIDs)
          s.add(o);
    for (const r of s)
      this.cellTable.get(r).updateBounds();
  }
  /**
   *
   * @param {EntityChange} changes
   */
  applyChanges(n) {
    n.CREATE.size !== 0 && this.applyCreateChanges(n), n.DELETE.size !== 0 && this.applyDeleteChanges(n), n.UPDATE.size !== 0 && this.applyUpdateChanges(n), this.recalculateBounds();
  }
  /**
   *
   * @param {PointChange[]} changes
   */
  applyVerticesPosition(n) {
    const s = new sh();
    for (const i of n) {
      const r = this.cellTable.get(i.id);
      if (!r) {
        console.warn(`Vertex ${i.id} not found when applying position change`);
        continue;
      }
      i.mirror !== void 0 && i.mirror !== null && s.update(i.id, "mirror", new nn({
        before: r.mirror,
        after: i.mirror
      })), i.x !== void 0 && i.y !== void 0 && s.update(i.id, "pos", new nn({
        before: new se(r.pos),
        after: new se(i.x, i.y)
      }));
    }
    this.applyChanges(s);
  }
  /**
   *
   * @param {EntityChange} changes
   */
  undo(n) {
    const s = U1(n);
    this.applyChanges(s), this.changes = s, this.fire(!1, { undoable: !1, interaction: !1 });
  }
  /**
   *
   * @param {EntityChange} changes
   */
  redo(n) {
    this.applyChanges(n), this.changes = n, this.fire(!1);
  }
  /**
   * Get the position of the vertex in the meshTransformmeshTransform[0,size] region,
   * with the extension transform of class Geometry if existing
   * @param {string} id
   * @param {Float32Array} [container]
   * @returns {Float32Array}
   */
  getVertPos(n, s = null) {
    const i = this.cellTable.get(n), r = s || new se();
    if (!i)
      return console.trace(), console.warn("invalid vertex id ocurred when get vertex position"), r;
    const o = i.pos;
    return r[0] = o.x - this.bounds.min.x, r[1] = o.y - this.bounds.min.y, r;
  }
  /**
   * Get the position of the curves in the meshTransformmeshTransform[0,size] region,
   * with the extension transform of class Geometry if existing
   * @param {string} id
   * @param {Float32Array[]} [container]
   * @returns {Float32Array[]}
   */
  getEdgeCurve(n, s = null) {
    const i = this.cellTable.get(n), r = s || [new se(), new se()], [o, a] = i.curve;
    return this.getVertPos(o.id, r[0]), this.getVertPos(a.id, r[1]), r;
  }
  /**
   * Get the clousre of single cell
   * @param {Cell} cell
   * @param {Set<Cell>} [outputSet] Assign it if the searching is shared between other cell inputs.
   * @param {Map<Cell, number>} [numVisitedChildren] Assign it if the searching is shared between other cell inputs.
   * @returns {Set<Cell>}
   */
  closure(n, s = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map()) {
    const r = [n];
    for (; r.length > 0; ) {
      const o = r.pop();
      if (s.add(o), o.type === "Edge") {
        const a = o;
        s.add(a.v), s.add(a.w);
      }
      for (const a of o.upperTierIDs) {
        const c = this.cellTable.get(a);
        s.has(c) || (o.type === "Edge" ? (i.set(
          c,
          i.get(c) ? i.get(c) + 1 : 1
        ), c.numEdges - i.get(c) === 0 && r.push(c)) : r.push(c));
      }
    }
    return s;
  }
  /**
   * Get the closure of the cells
   * @param {Cell[]} cells
   * @returns {Set<Cell>}
   */
  closureOfCells(n) {
    const s = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map();
    for (const r of n)
      this.closure(r, s, i);
    return s;
  }
  /**
   * @param {Cell[]} cellArray
   * @param {positions} [positions]  optional map of new positions for every cell
   * @param {boolean} [undoable]
   * @returns {Cell[]} list of duplicated cells
   */
  duplicateCells(n, s = {}, i = !0) {
    const r = /* @__PURE__ */ new Map();
    r.set("Contour", []), r.set("Edge", []), r.set("Vertex", []);
    for (let g = 0; g < n.length; g++) {
      const T = n[g].type;
      r.get(T).push(n[g]);
    }
    const o = {}, a = {}, c = [], l = [], h = r.get("Vertex");
    for (const g of h) {
      const T = Yo.fromData(g);
      this.cellTable.has(T.id) && (T.id = Zr(gi.MESH)), s[g.id] && T.pos.copy(s[g.id]), c.push(T.id), this.cellTable.set(T.id, T), l.push(T), o[g.id] = T;
    }
    const d = r.get("Edge");
    for (const g of d) {
      const T = Bi.fromData({
        id: Zr(gi.MESH),
        v: o[g.v],
        cpV: this._createAndRecordVertex(c),
        cpW: this._createAndRecordVertex(c),
        w: o[g.w]
      }, !1);
      if (s[g.id])
        for (let A = 0; A < 2; A++) {
          const m = new nn({
            before: new se(T.curve[A].pos),
            after: new se(s[g.id][A][0], s[g.id][A][1])
          });
          this.changes.update(T.curve[A].id, "pos", m);
        }
      c.push(T.id), this.cellTable.set(T.id, T), a[g.id] = T;
    }
    const p = r.get("Contour");
    for (const g of p) {
      const T = Ua.fromData({
        id: Zr(gi.MESH),
        isClosed: g.isClosed,
        isFilled: g.isFilled,
        isHole: g.isHole
      });
      for (let A = 0; A < g.halves[0].length; A++) {
        const m = a[g.halves[0][A]].halves[g.halves[1][A]];
        m.edge.upperTierIDs.add(T.id), T.addHalfEdge(m);
      }
      c.push(T.id), this.cellTable.set(T.id, T);
    }
    return this.changes.create(c), this.applyChanges(this.changes), this.fire(i), l;
  }
  /**
   * Start a new vertex
   * @param {number} x the x component of target coordinate in the element space
   * @param {number} y the y component of target coordinate in the element space
   * @param {boolean} undoable
   * @returns {Cell} the vertex that created via this function
   */
  startNewPath(n, s, i = !0) {
    const r = [], o = this._createAndRecordVertex(r), a = new se();
    return this.isEmpty ? (a.x = 0, a.y = 0, this.bounds.minMax(a)) : (a.x = n, a.y = s), o.set({ pos: a }), this.changes.create(r), this.applyChanges(this.changes), this.fire(i), o;
  }
  /**
   * @typedef {object} CreatedCell
   * @property {Cell} vertex The vertex that created
   * @property {Cell} edge The edge that created
   * @property {Cell} curveCtrl The curve control on the edge and near by the vertex
   */
  /**
   * Append a line to the selected vertex
   * @param {string} cellId
   * @param {number} x the x component of target coordinate in the element space
   * @param {number} y the y component of target coordinate in the element space
   * @param {boolean} mirrorPrevEdge Mirror the previous curve if the parameter is true
   * @param {boolean} undoable
   * @returns {CreatedCell} the vertex and edge that created via this function
   */
  appendLine(n, s, i, r, o = !0) {
    const a = [], c = this.cellTable.get(n), l = this._createAndRecordVertex(a), h = new se(s, i);
    l.set({ pos: h });
    const [d, p] = this._setupEdgeCurves(c, l, r, a), E = new Bi();
    E.set({ v: c, cpV: d, cpW: p, w: l }, !0), this.cellTable.set(E.id, E), a.push(E.id);
    const g = E.curve;
    if (c.upperTierIDs.size === 1 && !g[0].pos.eq(c.pos) && c.mirror === pe.ANGLE_AND_LENGTH) {
      const A = this._createAndRecordVertex(a);
      A.set({
        pos: c.pos,
        cap: c.cap,
        end: c.end,
        join: c.join,
        mirror: pe.ANGLE_AND_LENGTH
      }), A.cornerRadius = c.cornerRadius, A.flag(Be.CURVE_VERT), A.adjacentMainVertex = c;
      const m = new nn({
        before: c.unlinkedCurveControl,
        after: A.id
      });
      this.changes.update(c.id, "unlinkedCurveControl", m);
      const O = new se();
      ts(O, c.pos, g[0].pos);
      const S = new se();
      Fi(S, c.pos, O);
      const y = new nn({
        before: new se(A.pos),
        after: S
      });
      this.changes.update(A.id, "pos", y);
    }
    return this.changes.create(a), this.applyChanges(this.changes), this.fire(o), { vertex: l, edge: E, curveCtrl: g[1] };
  }
  /**
   * Connect the selected vertex to the clicked cell
   * @param {string} vId
   * @param {string} wId
   * @param {boolean} mirror Mirror the previous curve if the parameter is true
   * @param {boolean} undoable
   * @returns {CreatedCell|null} the created edge
   */
  connectVertices(n, s, i, r = !0) {
    if (n === s) return null;
    let o = [];
    const a = [], c = this.cellTable.get(n), l = this.cellTable.get(s);
    for (const g of c.upperTierIDs) {
      const T = this.cellTable.get(g);
      if ((T.w.id === l.id || T.v.id === l.id) && T.isStraight && !c.unlinkedCurveControl)
        return null;
    }
    if (l.unlinkedCurveControl) {
      const g = new nn({
        before: l.mirror,
        after: l.upperTierIDs.size === 1 && i ? pe.ANGLE_AND_LENGTH : pe.INDEPENDENT
      });
      this.changes.update(l.id, "mirror", g);
    }
    const [h, d] = this._setupEdgeCurves(c, l, i, o), p = new Bi();
    p.set({ v: c, cpV: h, cpW: d, w: l }, !0), this.cellTable.set(p.id, p), o.push(p.id);
    const E = p.curve;
    this.changes.create(o), this.applyChanges(this.changes), this.fire(r), o = [];
    for (const g of this.contours)
      a.push(g.id);
    for (const g of this._meshHelper.findContours()) {
      const T = new Ua(!1);
      T.set({ isClosed: !0, isFilled: !0, halves: g }), this.cellTable.set(T.id, T), o.push(T.id);
    }
    return this.changes.create(o), this.changes.delete(a), this.applyChanges(this.changes), this.fire(r), { vertex: null, edge: p, curveCtrl: E[1] };
  }
  /**
   *
   * @param {Vertex} v
   * @param {Vertex} w
   * @param {boolean} mirror
   * @param {string[]} createIDList
   * @returns {[Vertex, Vertex]} curve The output curve
   */
  _setupEdgeCurves(n, s, i, r) {
    const o = [n, s], a = [];
    for (let c = 0; c < 2; c++) {
      const l = o[c];
      if (l.unlinkedCurveControl) {
        a.push(this.cellTable.get(l.unlinkedCurveControl));
        const h = new nn({
          before: l.unlinkedCurveControl,
          after: null
        });
        this.changes.update(
          l.id,
          "unlinkedCurveControl",
          h
        ), i || this.changes.update(
          a[c].id,
          "pos",
          new nn({
            before: new se(a[c].pos),
            after: new se(l.pos)
          })
        );
      } else {
        const h = this._createAndRecordVertex(r);
        h.set({ pos: l.pos }), a.push(h);
      }
    }
    return a;
  }
  /**
   * Prepares changes to vertex properties based on the provided key and value, storing them for later application.
   *
   * @param {string} vertexId - ID of the vertex to be modified.
   * @param {string} key - Property key of the vertex to be changed.
   * @param {*} value - New value to assign to the specified vertex property.
   *
   * @returns {void}
   *
   * Notes:
   * - The function performs safety checks to ensure the provided vertex ID exists and is visible.
   * - Depending on the key, changes are prepared with specific behaviors.
   * - To apply the changes, call this.applyChanges(this.changes) followed by this.fire(undoable).
   * - All vertices need to be added to mesh change (a member of the mesh class) before applying.
   *
   * @throws {Error} Throws an error for unknown vertex IDs.
   * @throws {Warning} Warns if the vertex ID is not visible or if an unexpected key is provided.
  */
  prepareVertexPropertyChanges(n, s, i) {
    const r = this.cellTable.get(n);
    if (!r) {
      console.error(`constructVertexPropertiesChanges: Unknown vertex id: ${n}`);
      return;
    }
    if (!this.vertices.has(r)) {
      console.warn(`constructVertexPropertiesChanges: Invisible vertex id: ${n}`);
      return;
    }
    const o = new nn({
      before: r[s],
      after: i
    });
    switch (s) {
      case "cornerRadius":
        this._spreadVertProp(r, s, o, n);
        break;
      case "mirror":
        {
          let a = r;
          r.isFlagged(Be.CURVE_VERT) && (a = r.adjacentMainVertex), this.changes.update(a.id, "mirror", o), this.processPointShape(a, i);
        }
        break;
      default:
        console.warn(`Unexpected key ${s} for constructVertexPropertiesChanges`);
    }
  }
  /**
   *
   * @param {Vertex} vertex
   * @param {PointShape} value
   */
  processPointShape(n, s) {
    n.isFlagged(Be.CURVE_VERT) || (n.upperTierIDs.size === 1 ? this._processPointShapeEndpoint(n, s) : n.upperTierIDs.size === 2 ? this._processPointShapeRegular(n, s) : this._processPointShapeVectorNetworks(n, s));
  }
  _processPointShapeVectorNetworks(n, s) {
    if (n.mirror !== pe.NONE && s === pe.NONE)
      for (const i of n.upperTierIDs) {
        const r = this.cellTable.get(i);
        this._setCurveControlPos(r, n, r.v === n ? r.v.pos : r.w.pos);
      }
    else if (n.mirror === pe.NONE && s !== pe.NONE) {
      let i = 0;
      if (s === pe.ANGLE_AND_LENGTH)
        for (const a of n.upperTierIDs) {
          const c = this.cellTable.get(a), l = new se();
          ts(l, (c.v === n ? c.w : c.v).pos, n.pos), i = Math.max(i, Wr(l));
        }
      let r = 0;
      const o = Math.PI * 2 / n.upperTierIDs.size;
      for (const a of n.upperTierIDs) {
        const c = this.cellTable.get(a), l = new se();
        let h;
        if (s === pe.ANGLE_AND_LENGTH)
          h = 0.2 * i;
        else {
          const d = new se();
          ts(d, (c.v === n ? c.w : c.v).pos, n.pos), h = 0.2 * Wr(d);
        }
        l.x = Math.sin(r * o), l.y = Math.cos(r * o), Hr(l, l, h), ts(l, n.pos, l), this._setCurveControlPos(c, n, l), r++;
      }
    } else if (n.mirror !== pe.ANGLE_AND_LENGTH && s === pe.ANGLE_AND_LENGTH) {
      let i = 0;
      for (const a of n.upperTierIDs) {
        const c = this.cellTable.get(a), l = new se();
        ts(l, (c.v === n ? c.w : c.v).pos, n.pos);
        const h = this.cellTable.get(c.curve[c.v === n ? 0 : 1]);
        ts(l, h.pos, n.pos), i = Math.max(i, Wr(l));
      }
      let r = 0;
      const o = Math.PI * 2 / n.upperTierIDs.size;
      for (const a of n.upperTierIDs) {
        const c = this.cellTable.get(a), l = new se();
        l.x = Math.sin(r * o), l.y = Math.cos(r * o), Hr(l, l, i), ts(l, n.pos, l), this._setCurveControlPos(c, n, l), r++;
      }
    } else if (n.mirror !== pe.ANGLE && n.mirror !== pe.ANGLE_AND_LENGTH && s === pe.ANGLE) {
      let i = 0;
      const r = Math.PI * 2 / n.upperTierIDs.size;
      for (const o of n.upperTierIDs) {
        const a = this.cellTable.get(o), c = new se();
        let l;
        const h = a.curve[a.v === n ? 0 : 1];
        if (h && this.vertices.has(h)) {
          const d = new se();
          ts(d, h.pos, n.pos), l = Wr(d);
        } else {
          const d = new se();
          ts(d, (a.v === n ? a.w : a.v).pos, n.pos), l = 0.2 * Wr(d);
        }
        c.x = Math.sin(i * r), c.y = Math.cos(i * r), Hr(c, c, l), ts(c, n.pos, c), this._setCurveControlPos(a, n, c), i++;
      }
    }
  }
  /**
   *
   * @param {Vertex} vertex
   * @param {PointShape} value
   */
  _processPointShapeEndpoint(n, s) {
    const i = n.upperTierIDs.values(), r = this.cellTable.get(i.next().value);
    if (n.mirror !== pe.NONE && s === pe.NONE) {
      if (this._setCurveControlPos(r, n, r.v === n ? r.v.pos : r.w.pos), n.unlinkedCurveControl) {
        const o = this.cellTable.get(n.unlinkedCurveControl), a = new nn({
          before: new se(o.pos),
          after: new se(n.pos.x, n.pos.y)
        });
        this.changes.update(o.id, "pos", a);
      }
    } else if (n.mirror === pe.NONE && s !== pe.NONE) {
      const o = new se();
      ts(o, (r.v === n ? r.w : r.v).pos, n.pos);
      const a = Wr(o);
      Dl(o, o), Hr(o, o, a * 0.2), Fi(o, n.pos, o), this._setCurveControlPos(r, n, o), ts(o, n.pos, (r.v === n ? r.w : r.v).pos), Dl(o, o), Hr(o, o, a * (s === pe.ANGLE_AND_LENGTH ? 0.2 : 0.3));
      const c = new se();
      Fi(c, n.pos, o);
      const l = this._ensureIndCurveExist(n), h = new nn({
        before: new se(l.pos),
        after: c
      });
      this.changes.update(l.id, "pos", h);
    } else if (n.mirror === pe.INDEPENDENT && s !== pe.INDEPENDENT) {
      const o = this._ensureIndCurveExist(n), a = r.curve[r.v === n ? 0 : 1];
      if (s === pe.ANGLE) {
        const c = new se();
        ts(c, n.pos, (r.v === n ? r.w : r.v).pos);
        const l = FE(c);
        this._alignExistingCurves(a, n, o, s, l * 0.2);
      } else
        this._alignExistingCurves(a, n, o, s);
    }
  }
  /**
   *
   * @param {Vertex} vertex
   * @param {PointShape} value
   */
  _processPointShapeRegular(n, s) {
    const i = n.upperTierIDs.values(), r = this.cellTable.get(i.next().value), o = this.cellTable.get(i.next().value);
    if (n.mirror !== pe.NONE && s === pe.NONE)
      this._setCurveControlPos(r, n, r.v === n ? r.v.pos : r.w.pos), this._setCurveControlPos(o, n, o.v === n ? o.v.pos : o.w.pos);
    else if (n.mirror === pe.NONE) {
      if (s === pe.ANGLE || s === pe.INDEPENDENT || s === pe.ANGLE_AND_LENGTH) {
        const a = r.v === n ? r.w : r.v, c = o.v === n ? o.w : o.v;
        let l, h;
        if (a.pos.eq(c.pos)) {
          const d = new se();
          ts(d, n.pos, a.pos);
          const p = Wr(d);
          Hr(d, d, 1 / p);
          const E = d.x;
          d.x = d.y, d.y = -E, l = new se(), Hr(d, d, p * 0.2), Fi(l, n.pos, d), h = new se(), Hr(d, d, -1), Fi(h, n.pos, d), r.index > o.index && ([l, h] = [h, l]);
        } else {
          const d = Sc(a.pos, n.pos, c.pos);
          l = d.e1, h = d.e2, s === pe.ANGLE_AND_LENGTH && GP(l, n.pos, h);
        }
        this._setCurveControlPos(r, n, l), this._setCurveControlPos(o, n, h);
      }
    } else if (n.mirror === pe.ANGLE && s === pe.ANGLE_AND_LENGTH) {
      const a = r.curve[r.v === n ? 0 : 1], c = o.curve[o.v === n ? 0 : 1];
      this._alignExistingCurves(a, n, c, s);
    } else if (n.mirror === pe.INDEPENDENT && s === pe.ANGLE_AND_LENGTH) {
      const a = r.curve[r.v === n ? 0 : 1], c = o.curve[o.v === n ? 0 : 1];
      this._alignExistingCurves(a, n, c, s);
    } else if (n.mirror === pe.INDEPENDENT && s === pe.ANGLE) {
      let a = 0;
      if (r.curve[r.v === n ? 0 : 1].pos.eq(r.v === n ? r.v : r.w)) {
        const h = r.v === n ? r.w : r.v, d = o.v === n ? o.w : o.v, { e1: p } = Sc(h.pos, n.pos, d.pos);
        a = Math.sqrt(Math.pow(p.x - n.pos.x, 2) + Math.pow(p.y - n.pos.y, 2)), this._setCurveControlPos(r, n, p);
      } else if (o.curve[o.v === n ? 0 : 1].pos.eq(o.v === n ? o.v : o.w)) {
        const h = r.v === n ? r.w : r.v, d = o.v === n ? o.w : o.v, { e2: p } = Sc(h.pos, n.pos, d.pos);
        a = Math.sqrt(Math.pow(p.x - n.pos.x, 2) + Math.pow(p.y - n.pos.y, 2)), this._setCurveControlPos(o, n, p);
      }
      const c = r.curve[r.v === n ? 0 : 1], l = o.curve[o.v === n ? 0 : 1];
      this._alignExistingCurves(c, n, l, s, a);
    }
  }
  _alignExistingCurves(n, s, i, r, o = 0) {
    const a = new se();
    ts(a, s.pos, n.pos);
    const c = new se();
    ts(c, s.pos, i.pos);
    let l, h, d;
    const p = Wr(a), E = Wr(c);
    p < E ? (l = i, h = n, d = r === pe.ANGLE_AND_LENGTH ? E : p) : (l = n, h = i, d = r === pe.ANGLE_AND_LENGTH ? p : E), d < 1e-5 && (d = o), ts(a, l.pos, s.pos), a.x = -1 * (l.pos.x - s.pos.x), a.y = -1 * (l.pos.y - s.pos.y), Dl(a, a), Hr(a, a, d);
    const g = new se();
    Fi(g, s.pos, a);
    const T = new nn({
      before: new se(h.pos),
      after: g
    });
    this.changes.update(h.id, "pos", T);
  }
  /**
   *
   * @param {Vertex} vertex
   * @param {string} key
   * @param {Change} change
   */
  _spreadVertProp(n, s, i) {
    const r = n.isFlagged(Be.CURVE_VERT) ? n.adjacentMainVertex : n;
    this.changes.update(r.id, s, i);
    for (const o of r.upperTierIDs) {
      const a = this.cellTable.get(o), c = a.curve[a.v === r ? 0 : 1];
      this.changes.update(c.id, s, i);
    }
  }
  /**
   *
   * @param {Edge} edge
   * @param {Vertex} wedge
   * @param {_Vector2} pos Won't change or occupy the Vector2
   */
  _setCurveControlPos(n, s, i) {
    const r = n.curve[n.v === s ? 0 : 1], o = new nn({
      before: new se(r.pos),
      after: new se(i.x, i.y)
    });
    this.changes.update(r.id, "pos", o);
  }
  /**
   *
   * @param {Vertex} vertex The vertex will have an independent curve control handle
   * @param {PointShape} pointShape The point shape needs to be updated in the samae event because the UI will filter the event by time
   * @param {boolean} undoable
   * @returns {Vertex}
   */
  addIndpendentCurveCtrl(n, s, i = !0) {
    const r = this._ensureIndCurveExist(n, s);
    return (this.changes.CREATE.size !== 0 || this.changes.UPDATE.size !== 0) && (this.applyChanges(this.changes), this.fire(i)), r;
  }
  _ensureIndCurveExist(n, s) {
    if (n.unlinkedCurveControl) {
      const a = this.cellTable.get(n.unlinkedCurveControl);
      if (this.vertices.has(a) || this.changes.create([a.id]), s && n.mirror !== s) {
        const c = new nn({
          before: n.mirror,
          after: s
        });
        this.changes.update(n.id, "mirror", c);
      }
      return a;
    }
    const i = [], r = this._createAndRecordVertex(i);
    r.set({
      pos: n.pos,
      cap: n.cap,
      end: n.end,
      join: n.join,
      mirror: pe.ANGLE_AND_LENGTH
    }), r.flag(Be.CURVE_VERT), this.cellTable.set(r.id, r), r.adjacentMainVertex = n, r.cornerRadius = n.cornerRadius;
    const o = new nn({
      before: n.unlinkedCurveControl,
      after: r.id
    });
    if (this.changes.update(n.id, "unlinkedCurveControl", o), s && n.mirror !== s) {
      const a = new nn({
        before: n.mirror,
        after: s
      });
      this.changes.update(n.id, "mirror", a);
    }
    return this.changes.create(i), r;
  }
  /**
   * Falsify the independent curve control, can't undo
   * @param {Vertex} vertex The vertex will have an independent curve control handle
   * @returns {Vertex}
   */
  falsifyIndCurveCtrl(n) {
    if (!this.cellTable.has(xo.CURVE_CONTROL)) {
      const i = new Yo();
      i.id = xo.CURVE_CONTROL, i.flag(Be.CURVE_VERT), this.cellTable.set(xo.CURVE_CONTROL, i);
    }
    const s = this.cellTable.get(xo.CURVE_CONTROL);
    return s.adjacentMainVertex = n, s.set({
      pos: n.pos,
      cap: n.cap,
      join: n.join,
      mirror: n.mirror
    }), s.cornerRadius = n.cornerRadius, this.vertices.add(s), s;
  }
  hideFakeIndCurveCtrl() {
    if (!this.cellTable.has(xo.CURVE_CONTROL)) return;
    const n = this.cellTable.get(xo.CURVE_CONTROL);
    this.vertices.has(n) && this.vertices.delete(n);
  }
  /**
   * Move the independent curve control and force the specific curve control mirror to this curve control
   * @param {Vertex} curveCtrl The curve control to move
   * @param {vertex} wedgeVert The wedge vertex between 2 controls
   * @param {Vertex} oppCurveCtrl The curve control to mirror, allow to be null
   * @param {number} x the position in the x component
   * @param {number} y the position in the y component
   * @param {bool} undoable
   */
  moveIndCurveControl(n, s, i, r, o, a = !0) {
    if (!n.isFlagged(Be.CURVE_VERT)) {
      console.warn("The dragging object isn't a curve control");
      return;
    }
    const c = new se(r, o), l = new se();
    l.copy(c);
    const h = new nn({
      before: new se(n.pos),
      after: l
    });
    if (this.changes.update(n.id, "pos", h), i) {
      const p = new se();
      p.x = l.x - s.pos.x, p.y = l.y - s.pos.y, p.x = p.x * -1 + s.pos.x, p.y = p.y * -1 + s.pos.y;
      const E = new nn({
        before: new se(i.pos),
        after: p
      });
      this.changes.update(i.id, "pos", E);
    }
    this.applyChanges(this.changes), this.fire(a);
  }
  /**
   *
   * @param {string[]} createList
   * @returns {Vertex}
   */
  _createAndRecordVertex(n) {
    const s = new Yo();
    return this.cellTable.set(s.id, s), n && n.push(s.id), s;
  }
  /**
   * Prepares a position update for any connected component based on an offset and creates the change record.
   * This method can be used for any movable entity represented by a unique ID.
   * @param {string} id - The ID of the component to update.
   * @param {_Vector2} offset - The offset to apply to the component's position.
   */
  _preparePositionUpdate(n, s) {
    const i = this.cellTable.get(n), r = new se(i.pos), o = new se();
    Fi(o, i.pos, s);
    const a = new nn({
      before: r,
      after: o
    });
    this.changes.update(n, "pos", a);
  }
}
function GP(e, n, s) {
  let i = e.x - n.x, r = e.y - n.y, o = s.x - n.x, a = s.y - n.y;
  const c = Math.sqrt(i * i + r * r), l = Math.sqrt(o * o + a * a);
  c < l ? (i = i / c * l, r = r / c * l, e.x = n.x + i, e.y = n.y + r) : (o = o / l * c, a = a / l * c, s.x = n.x + o, s.y = n.y + a);
}
class cc extends Set {
  constructor() {
    super(), this.currIndex = 0;
  }
  add(n) {
    return n.index = this.currIndex++, super.add(n);
  }
  delete(n) {
    return n.index = -1, super.delete(n);
  }
}
const im = new se(), Vp = /* @__PURE__ */ new Set();
class Ys extends Float32Array {
  /**
   * Creates new Matrix2D from from 6 number components or copies values from a single mat2d-like object
   * @param  {number | Matrix2D | mat2d | object } a     a component or mat2d-like object
   * @param  {number} b   b component
   * @param  {number} c   c component
   * @param  {number} d   d component
   * @param  {number} tx  tx component
   * @param  {number} ty  ty component
   */
  constructor(n, s, i, r, o, a) {
    super(6), typeof n == "number" && typeof s == "number" && typeof i == "number" && typeof r == "number" && typeof o == "number" && typeof a == "number" ? (this[0] = n, this[1] = s, this[2] = i, this[3] = r, this[4] = o, this[5] = a) : n ? this.copy(n) : (this[0] = 1, this[3] = 1);
  }
  /**
   * Copies values from an array
   * @param  {number[]} array
   */
  fromArray(n) {
    Ge(n) || _A(this, ...n);
  }
  clone() {
    return new Ys(...this);
  }
  /**
   * Copies values from the mat2d-like object
   * @param  {Matrix2D | mat2d | object} val
   * @returns {Matrix2D} returns itself
   */
  copy(n) {
    if (Ge(n))
      return;
    const s = ee(n[0]) ? n[0] : n.a, i = ee(n[1]) ? n[1] : n.b, r = ee(n[2]) ? n[2] : n.c, o = ee(n[3]) ? n[3] : n.d, a = ee(n[4]) ? n[4] : n.tx, c = ee(n[5]) ? n[5] : n.ty;
    return be(s) && be(i) && be(r) && be(o) && be(a) && be(c) && _A(this, s, i, r, o, a, c), this;
  }
  /**
   * Checks if this Matrix2D is equal (has same corresponding component values) to another mat2d-like object
   * @param {Matrix2D | mat2d | object} val     mat2d-like object
   * @param {number} epsilon                    precision; default is 0.0001
   * @returns {boolean}                        true if vectors are equal; false othewise
   */
  eq(n, s = wn) {
    if (Ge(n))
      return !1;
    const i = [
      ee(n[0]) ? n[0] : n.a,
      ee(n[1]) ? n[1] : n.b,
      ee(n[2]) ? n[2] : n.c,
      ee(n[3]) ? n[3] : n.d,
      ee(n[4]) ? n[4] : n.tx,
      ee(n[5]) ? n[5] : n.ty
    ];
    return sP(this, i, s);
  }
  /**
   * Creates new basis transform matrix (leaving out translation)
   * @returns {Matrix2D}   new Matrix2D
   */
  basis() {
    return iP(new Ys(), this);
  }
  get a() {
    return this[0];
  }
  set a(n) {
    this[0] = n;
  }
  get b() {
    return this[1];
  }
  set b(n) {
    this[1] = n;
  }
  get c() {
    return this[2];
  }
  set c(n) {
    this[2] = n;
  }
  get d() {
    return this[3];
  }
  set d(n) {
    this[3] = n;
  }
  get tx() {
    return this[4];
  }
  set tx(n) {
    this[4] = n;
  }
  get ty() {
    return this[5];
  }
  set ty(n) {
    this[5] = n;
  }
  save() {
    return [
      this[0],
      this[1],
      this[2],
      this[3],
      this[4],
      this[5]
    ];
  }
}
Ys.IDENTITY = new Ys();
Ys.ZERO = new Ys(0, 0, 0, 0, 0, 0);
function FP(e, n) {
  const s = ba(w1(), n, e);
  return kP(s, !0);
}
function kP(e, n = !1) {
  const s = new se(e[1], -e[0]);
  return n && Dl(s, s), s;
}
function XE(e, n, s) {
  return gd(s[0] - e[0], s[1] - e[1], s[0] - n[0], s[1] - n[1]) ? s[0] >= Math.min(e[0], n[0]) && s[0] <= Math.max(e[0], n[0]) && s[1] >= Math.min(e[1], n[1]) && s[1] <= Math.max(e[1], n[1]) : !1;
}
new se();
new se(), new se();
const Wl = Bt.getUtils();
function Sc(e, n, s) {
  const i = Wl.dist(e, n), r = Wl.dist(s, n), o = i / (i + r), { A: a, C: c } = Bt.getABC(3, e, n, s, o);
  return BP(o, a, n, c, e, s);
}
function BP(e, n, s, i, r, o) {
  const a = Math.atan2(o.y - r.y, o.x - r.x) - Math.atan2(s.y - r.y, s.x - r.x), c = (a < 0 || a > Math.PI ? -1 : 1) * Wl.dist(r, o) / 3, l = e * c, h = (1 - e) * c;
  if (Math.abs(a) < wn) {
    const R = { x: s.x + 0.5 * (r.x - s.x), y: s.y + 0.5 * (r.y - s.y) }, M = { x: s.x + 0.5 * (o.x - s.x), y: s.y + 0.5 * (o.y - s.y) };
    return { e1: R, e2: M };
  }
  const d = Wl.getccenter(r, s, o), p = [
    { x: s.x - (s.y - d.y), y: s.y + (s.x - d.x) },
    { x: s.x + (s.y - d.y), y: s.y - (s.x - d.x) }
  ], E = Wl.dist(p[0], p[1]), g = (p[1].x - p[0].x) / E, T = (p[1].y - p[0].y) / E, A = { x: s.x + l * g, y: s.y + l * T }, m = { x: s.x - h * g, y: s.y - h * T }, O = {
    x: n.x + (A.x - n.x) / (1 - e),
    y: n.y + (A.y - n.y) / (1 - e)
  }, S = {
    x: n.x + (m.x - n.x) / e,
    y: n.y + (m.y - n.y) / e
  }, y = {
    x: r.x + (O.x - r.x) / e,
    y: r.y + (O.y - r.y) / e
  }, v = {
    x: o.x + (S.x - o.x) / (1 - e),
    y: o.y + (S.y - o.y) / (1 - e)
  };
  return { e1: A, e2: m, C1: y, C2: v };
}
function VP(e) {
  const n = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map();
  for (const [m, O] of e.UPDATE.entries()) {
    if (!O.has("children"))
      continue;
    const { before: S, after: y } = O.get("children");
    if (c.set(m, S), l.set(m, y), !S || !y) {
      console.warn(`Invalid Scene Tree Changes of ${m}`);
      continue;
    }
    for (const v of S)
      n.has(v) ? console.warn(`Child ${v} has multiple old parents: ${n.get(v)} and ${m}`) : (n.set(v, m), i.add(v));
    for (const v of y)
      i.has(v) ? (i.delete(v), n.get(v) !== m ? (o.add(v), s.set(v, m)) : (a.add(v), s.set(v, m))) : (r.add(v), s.set(v, m));
  }
  const h = [];
  for (const m of r)
    i.has(m) && (i.delete(m), h.push(m));
  for (const m of h)
    r.delete(m), o.add(m);
  const d = /* @__PURE__ */ new Set(), p = /* @__PURE__ */ new Set();
  function E(m) {
    return c.get(m) || [];
  }
  function g(m) {
    return l.get(m) || [];
  }
  const T = /* @__PURE__ */ new Set();
  for (const m of i)
    zE(m, E, T, d, i);
  const A = /* @__PURE__ */ new Set();
  for (const m of a)
    zE(m, g, A, p, a);
  return { oldParents: n, newParents: s, removed: d, added: r, moved: o, reordered: p };
}
function zE(e, n, s, i, r) {
  if (s.has(e)) return;
  s.add(e);
  const o = n(e);
  for (const a of o)
    zE(a, n, s, i, r);
  r.has(e) && i.add(e);
}
const HP = (e, n, s) => {
  let i = -1, r = -1;
  for (let a = 0; a < e.length; a++) {
    const c = e[a];
    c.position <= s && (i === -1 || e[i].position < c.position) && (i = a), c.position >= s && (r === -1 || e[r].position > c.position) && (r = a);
  }
  let o = e[n].color;
  if (i === -1)
    o = e[r].color;
  else if (r === -1)
    o = e[i].color;
  else {
    const a = e[i], c = e[r], l = (s - a.position) / (c.position - a.position), h = Ra(a.color.r, c.color.r, l), d = Ra(a.color.g, c.color.g, l), p = Ra(a.color.b, c.color.b, l), E = Ra(a.color.a, c.color.a, l);
    o = new as(h, d, p, E);
  }
  return o;
}, gd = (e, n, s, i) => Math.abs(e * i - n * s) <= Math.sqrt((e * e + n * n) * (s * s + i * i)) * wn;
function WP(e, n) {
  if (n.isStraight) return !0;
  if (!XE(n.v.pos, n.w.pos, n.cpV.pos) || !XE(n.v.pos, n.w.pos, n.cpW.pos)) return !1;
  if (n.v.unlinkedCurveControl != null && e.cellTable.has(n.v.unlinkedCurveControl)) {
    const s = e.cellTable.get(n.v.unlinkedCurveControl).pos;
    if (!gd(n.v.pos[0] - s[0], n.v.pos[1] - s[1], n.w.pos[0] - s[0], n.w.pos[1] - s[1])) return !1;
  }
  if (n.w.unlinkedCurveControl != null && e.cellTable.has(n.w.unlinkedCurveControl)) {
    const s = e.cellTable.get(n.w.unlinkedCurveControl).pos;
    if (!gd(n.v.pos[0] - s[0], n.v.pos[1] - s[1], n.w.pos[0] - s[0], n.w.pos[1] - s[1])) return !1;
  }
  return !0;
}
const On = { commit: !1 }, Ku = { fire: !1 }, s0 = { interaction: !1 }, H1 = { undoable: !1 }, YP = { ...H1, ...s0 }, XP = { ...Ku, ...On };
({ ...On });
const zP = { commit: !1, fire: !1, flags: or.FROM_DRAG_DUPLICATE };
class KP {
  constructor(n = {}) {
    this.enum = n.enum, this.type = n.type, this.itemType = n.itemType;
  }
  /**
   * Load a new object of type specified by this PropType with data (serialized or deserialized, if compatible)
   * @param  {any} data
   * @returns {any}        new object of type specified by PropType
   */
  copy(n) {
    if (this.type)
      return this.type === Map ? OA(n, (s, i) => [s, this.itemType ? new this.itemType(i) : i]) : this.type === Array ? n.map((s) => this.itemType ? new this.itemType(s) : s) : new this.type(n);
  }
  eq(n, s) {
    return n === s ? !0 : Ge(n) || Ge(s) ? !1 : mA(n.eq) ? n.eq(s) : this.type === Array ? $2(n, s, (i, r) => i && mA(i.eq) ? i.eq(r) : i === r) : this.type === Map ? !1 : n === s;
  }
  save(n) {
    if (J2(n))
      return [...OA(n, (s, i) => [s, i.save && i.save.constructor === Function ? i.save() : i])];
    if (hd(n))
      return [...n.map((s) => s.save && s.save.constructor === Function ? s.save() : s)];
  }
  get isIterable() {
    return this.type === Array || this.type === Map;
  }
}
function Wc(e) {
  const n = {};
  for (const s in e)
    e.hasOwnProperty(s) && (n[s] = new KP(e[s]));
  return n;
}
const Ss = {
  /**
   * @param {number} a
   * @param {number} b
   * @param {number} [esp=0.0001]
   * @returns {boolean}
   */
  Equal(e, n, s = 1e-4) {
    return Math.abs(e - n) < s;
  },
  /**
   * @param {number} v
   * @param {number} min
   * @param {number} max
   * @returns {number}
   */
  clamp(e, n, s) {
    return e > s ? s : e < n ? n : e;
  },
  /**
   * @param {number} a
   * @param {number} b
   * @param {number} t
   * @returns {number}
   */
  lerp(e, n, s) {
    return e * (1 - s) + n * s;
  },
  /**
   * @param {number} a
   * @param {number} b
   * @param {number} t
   * @returns {number}
   */
  lerp_angle(e, n, s) {
    const i = (n - e) % (Math.PI * 2), r = i * 2 % (Math.PI * 2) - i;
    return e + r * s;
  },
  /**
   * @param {number} value
   * @returns {boolean}
   */
  IsPowerOf2(e) {
    return (e & e - 1) === 0;
  },
  /**
   * @param {number} value
   * @returns {number}
   */
  NearestPowerOf2(e) {
    if (e === 0) return 0;
    let n = e;
    return n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n + 1;
  },
  /**
   * @param {number} value
   * @param {number} istart
   * @param {number} istop
   * @param {number} ostart
   * @param {number} ostop
   * @returns {number}
   */
  map(e, n, s, i, r) {
    return i + (r - i) * ((e - n) / (s - n));
  }
}, rm = 1e-5, W1 = 1e-8;
function N(e = 0, n = 0) {
  this.x = e, this.y = n, this._array = null;
}
N.isOrthogonal = (e, n, s, i) => Math.abs(e * s + n * i) <= Math.sqrt((e * e + n * n) * (s * s + i * i)) * W1;
N.isCollinear = (e, n, s, i) => (
  // NOTE: We use normalized vectors so that the epsilon comparison is
  // reliable. We could instead scale the epsilon based on the vector
  // length. But instead of normalizing the vectors before calculating
  // the cross product, we can scale the epsilon accordingly.
  Math.abs(e * i - n * s) <= Math.sqrt((e * e + n * n) * (s * s + i * i)) * W1
);
N.getThirds = function(e, n) {
  const s = n.clone().subtract(e);
  return {
    oneThird: e.clone().add(s.clone().scale(1 / 3)),
    twoThirds: e.clone().add(s.clone().scale(2 / 3))
  };
};
N.prototype = {
  constructor: N,
  get width() {
    return this.x;
  },
  set width(e) {
    this.x = e;
  },
  /**
   * @param {number} value
   */
  set_width(e) {
    this.x = e;
  },
  get height() {
    return this.y;
  },
  set height(e) {
    this.y = e;
  },
  /**
   * @param {number} value
   */
  set_height(e) {
    this.y = e;
  },
  /**
   * @param {number} value
   */
  set_x(e) {
    this.x = e;
  },
  /**
   * @param {number} value
   */
  set_y(e) {
    this.y = e;
  },
  /**
   * @param {[number, number]} [out]
   * @returns {[number, number]}
   */
  as_array(e) {
    if (!e && !this._array)
      return this._array = [this.x, this.y], this._array;
    const n = e || this._array;
    return n[0] = this.x, n[1] = this.y, n;
  },
  /**
   * @param {number[]} arr
   * @returns {this}
   */
  fromArray(e) {
    return this.x = e[0], this.y = e[1], this;
  },
  /**
   * Sets the point to a new x and y position.
   * If y is omitted, both x and y will be set to x.
   *
   * @param {number} [x] - position of the point on the x axis
   * @param {number} [y] - position of the point on the y axis
   * @returns {this}
   */
  set(e = 0, n = 0) {
    return this.x = e, this.y = n, this;
  },
  /**
   * Copy value from other vector
   *
   * @param {Vector2Like} p_b
   * @returns {this}
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  },
  /**
   * @param {Vector2Like} p_b
   * @param {number} t
   * @returns {this}
   */
  mix_with(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this;
  },
  /**
   * Returns new Vector2 with same value.
   * @returns {Vector2}
   */
  clone() {
    return new N(this.x, this.y);
  },
  /**
   * Returns new Vector2 but normalized.
   * @returns {Vector2}
   */
  normalized() {
    return this.clone().normalize();
  },
  /**
   * Returns new Vector2 but clamped.
   * @param {number} p_length
   * @returns {Vector2}
   */
  clamped(e) {
    const n = this.length(), s = this.clone();
    return n > 0 && e < n && s.scale(e / n), s;
  },
  /**
   * Returns new Vector2 but rotated.
   *
   * @param {number} p_rotation
   * @returns {Vector2}
   */
  rotated(e) {
    return this.clone().rotate(e);
  },
  /**
   * Whether this equals to another point
   * @param {Vector2Like} p_b
   * @returns {boolean}
   */
  equals(e) {
    const n = this.x, s = this.y, i = e.x, r = e.y;
    return Math.abs(n - i) <= rm * Math.max(1, Math.abs(n), Math.abs(i)) && Math.abs(s - r) <= rm * Math.max(1, Math.abs(s), Math.abs(r));
  },
  /**
   * Whether this equals to another point(precisely)
   * @param {Vector2Like} p_b
   * @returns {boolean}
   */
  exact_equals(e) {
    return this.x === e.x && this.y === e.y;
  },
  /**
   * Add the vector by another vector or number.
   * @param {number | Vector2Like} x
   * @param {number} [y]
   * @returns {this}
   */
  add(e, n) {
    return n === void 0 ? (this.x += e.x, this.y += e.y) : (this.x += e, this.y += n), this;
  },
  /**
   * Subtract the vector by another vector or number.
   * @param {number | Vector2Like} x
   * @param {number} [y]
   * @returns {this}
   */
  subtract(e, n) {
    return n === void 0 ? (this.x -= e.x, this.y -= e.y) : (this.x -= e, this.y -= n), this;
  },
  /**
   * Subtract the vector by another vector or number.
   * @param {number | Vector2Like} x
   * @param {number} [y]
   * @returns {this}
   */
  sub(e, n) {
    return n === void 0 ? (this.x -= e.x, this.y -= e.y) : (this.x -= e, this.y -= n), this;
  },
  /**
   * Multiply the vector by another vector or number.
   * @param {number | Vector2Like} x
   * @param {number} [y]
   * @returns {this}
   */
  multiply(e, n) {
    return n === void 0 ? (this.x *= e.x, this.y *= e.y) : (this.x *= e, this.y *= n), this;
  },
  /**
   * Divide x and y by another vector or number.
   * @param {number | Vector2Like} x
   * @param {number} [y]
   * @returns {this}
   */
  divide(e, n) {
    return n === void 0 ? (this.x /= e.x, this.y /= e.y) : (this.x /= e, this.y /= n), this;
  },
  /**
   * Dot multiply another vector.
   * @param {Vector2Like} p_b
   * @returns {number}
   */
  dot(e) {
    return this.x * e.x + this.y * e.y;
  },
  /**
   * Cross multiply another vector.
   * @param {Vector2Like} p_b
   * @returns {number}
   */
  cross(e) {
    return this.x * e.y - this.y * e.x;
  },
  /**
   * Change x and y components to their absolute values.
   * @returns {this}
   */
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
  },
  /**
   * Change x and y components to their sign values.
   * @returns {this}
   */
  sign() {
    return this.x = Math.sign(this.x), this.y = Math.sign(this.y), this;
  },
  /**
   * Ceil x and y components.
   * @returns {this}
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  },
  /**
   * Floor x and y components.
   * @returns {this}
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  },
  /**
   * Round to int vector.
   * @returns {this}
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  },
  /**
   * Truncate to int vector.
   * @returns {this}
   */
  trunc() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  },
  /**
   * Clamp the vector to specific length.
   * @param {number} p_length
   * @returns {this}
   */
  clamp(e) {
    const n = this.length();
    return n > 0 && e < n && this.scale(e / n), this;
  },
  /**
   * Scale the vector by a number factor.
   * @param {number} p_factor
   * @returns {this}
   */
  scale(e) {
    return this.x *= e, this.y *= e, this;
  },
  /**
   * Scale the vector by a number factor.
   * @param {number} scale
   * @param {Vector2} center
   * @returns {this}
   */
  scale_with_center(e, n) {
    return this.sub(n).scale(e).add(n), this;
  },
  /**
   * Negate x and y components.
   * @returns {this}
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  },
  /**
   * Inverse the x and y components.
   * @returns {this}
   */
  inverse() {
    return this.x = 1 / this.x, this.y = 1 / this.y, this;
  },
  /**
   * Swap the x and y components.
   * @returns {this}
   */
  swap() {
    const e = this.x;
    return this.x = this.y, this.y = e, this;
  },
  /**
   * Normalize this vector to unit length.
   * @returns {this}
   */
  normalize() {
    const e = this.x, n = this.y;
    let s = e * e + n * n;
    return s > 0 && (s = 1 / Math.sqrt(s), this.x *= s, this.y *= s), this;
  },
  /**
   * Rotates the vector by “phi” radians.
   * @param {number} p_rotation
   * @returns {this}
   */
  rotate(e) {
    const n = this.x, s = this.y, i = Math.cos(e), r = Math.sin(e);
    return this.x = n * i - s * r, this.y = n * r + s * i, this;
  },
  /**
   * Change this vector to be perpendicular to what it was before. (Effectively
   * roatates it 90 degrees in a clockwise direction with the Y axis pointing up)
   * @returns {this}
   */
  perp() {
    const e = this.x;
    return this.x = this.y, this.y = -e, this;
  },
  /**
   * Change this vector to be perpendicular to what it was before. (Effectively
   * roatates it 90 degrees in a ccw direction with the Y axis pointing up)
   * @returns {this}
   */
  perp_inv() {
    const e = this.x;
    return this.x = -this.y, this.y = e, this;
  },
  /**
   * Returns the normal vector of the line formed by `this` and `b`
   *
   * @param {Vector2} b
   * @returns {Vector2}
   */
  normal(e) {
    return e.clone().sub(this).normalize().perp();
  },
  /**
   * Returns the directional vector of the line formed by `this` and `b`
   *
   * @param {Vector2} b
   * @returns {Vector2}
   */
  direction(e) {
    return e.clone().sub(this).normalize();
  },
  /**
   * Returns new Vector2.
   * @param {number} p_d
   * @param {Vector2} p_vec
   * @returns {Vector2}
   */
  plane_project(e, n) {
    const s = this.clone();
    return n.clone().subtract(s.scale(this.dot(n) - e));
  },
  /**
   * Project to a vector.
   * @param {Vector2} p_b
   * @returns {this}
   */
  project(e) {
    const n = this.dot(e) / e.length_squared();
    return this.x = n * e.x, this.y = n * e.y, this;
  },
  /**
   * Project to a vector which is already normalized.
   * @param {Vector2Like} p_b
   * @returns {this}
   */
  project_n(e) {
    const n = this.dot(e);
    return this.x = n * e.x, this.y = n * e.y, this;
  },
  /**
   * Reflects the vector along the given plane, specified by its normal vector.
   * @param {Vector2Like} axis
   * @returns {this}
   */
  reflect(e) {
    const n = this.dot(e);
    return this.x = 2 * e.x * n - this.x, this.y = 2 * e.y * n - this.y, this;
  },
  /**
   * Bounce returns the vector “bounced off” from the given plane, specified by its normal vector.
   * @param {Vector2Like} normal
   * @returns {this}
   */
  bounce(e) {
    return this.reflect(e).negate();
  },
  /**
   * Slide returns the component of the vector along the given plane, specified by its normal vector.
   * @param {Vector2Like} normal
   * @returns {this}
   */
  slide(e) {
    return this.subtract(QP.copy(e).scale(this.dot(e)));
  },
  /**
   * Returns the length of the vector.
   * @returns {number}
   */
  length() {
    const e = this.x, n = this.y;
    return Math.sqrt(e * e + n * n);
  },
  /**
   * Returns the squared length of the vector. Prefer this function
   * over “length” if you need to sort vectors or need the squared length for some formula.
   * @returns {number}
   */
  length_squared() {
    const e = this.x, n = this.y;
    return e * e + n * n;
  },
  /**
   * Returns the result of atan2 when called with the Vector’s x and y as parameters (Math::atan2(x,y)).
   * @returns {number} [-PI, PI]
   */
  angle() {
    return Math.atan2(this.y, this.x);
  },
  /**
   * Returns the angle in radians between the two vectors.
   * @param {Vector2Like} p_b
   * @returns {number} [-PI, PI]
   */
  angle_to(e) {
    return Math.atan2(this.cross(e), this.dot(e));
  },
  /**
   * Returns the angle in radians between the two vectors.
   * @param {Vector2Like} p_b
   * @returns {number} [0, 2PI]
   */
  angle_to_2(e) {
    let n = this.angle_to(e);
    return n < 0 && (n += 2 * Math.PI), n;
  },
  /**
   * Returns the ccw angle in radians between the two vectors.
   * @param {Vector2Like} p_b
   * @returns {number} [0, 2PI]
   */
  angle_to_ccw(e) {
    let n = Math.atan2(this.y, this.x) - Math.atan2(e.y, e.x);
    return n < 0 && (n += 2 * Math.PI), n;
  },
  /**
   * @param {Vector2Like} p_b
   * @returns {number}
   */
  angle_to_point(e) {
    return Math.atan2(this.y - e.y, this.x - e.x);
  },
  /**
   * Returns the distance to vector “b”.
   * @param {Vector2Like} p_b
   * @returns {number}
   */
  distance_to(e) {
    const n = e.x - this.x, s = e.y - this.y;
    return Math.sqrt(n * n + s * s);
  },
  /**
   * Returns the squared distance to vector “b”. Prefer this function
   * over “distance_to” if you need to sort vectors or need the squared distance for some formula.
   * @param {Vector2Like} p_b
   * @returns {number}
   */
  distance_squared_to(e) {
    const n = e.x - this.x, s = e.y - this.y;
    return n * n + s * s;
  },
  /**
   * Returns a perpendicular vector.
   * @param {Vector2} [r_out]
   * @returns {Vector2}
   */
  tangent(e = new N()) {
    return e.set(this.y, -this.x);
  },
  aspect() {
    return this.x / this.y;
  },
  is_zero(e = null) {
    return e ? om(this.x, e) && om(this.y, e) : this.x === 0 && this.y === 0;
  },
  /**
   * @param {Vector2} point
   * @returns {boolean}
   */
  isOrthogonal(e) {
    return N.isOrthogonal(this.x, this.y, e.x, e.y);
  },
  // /**
  //  * @param {number} x1
  //  * @param {number} y1
  //  * @param {number} x2
  //  * @param {number} y2
  //  */
  // static isOrthogonal(x1, y1, x2, y2) {
  //     return Math.abs(x1 * x2 + y1 * y2)
  //             <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
  //                 * TRIGONOMETRIC_EPSILON
  // }
  /**
   * Checks if this vector is collinear (parallel) to another vector.
   *
   * @param {Vector2} vec the vector to check against
   * @returns {boolean}
   */
  isCollinear(e) {
    return N.isCollinear(this.x, this.y, e.x, e.y);
  },
  /**
   * @param {Vector2Like} p_b
   * @param {number} p_t
   * @returns {this}
   */
  linear_interpolate(e, n) {
    return this.x += n * (e.x - this.x), this.y += n * (e.y - this.y), this;
  },
  /**
   * Returns new Vector2.
   * @param {Vector2Like} p_b
   * @param {Vector2Like} p_pre_a
   * @param {Vector2Like} p_post_b
   * @param {number} p_t
   * @returns {Vector2}
   */
  cubic_interpolate(e, n, s, i) {
    const r = i * i, o = r * i;
    return new N(
      0.5 * (this.x * 2 + (-n.x + e.x) * i + (2 * n.x - 5 * this.x + 4 * e.x - s.x) * r + (-n.x + 3 * this.x - 3 * e.x + s.x) * o),
      0.5 * (this.y * 2 + (-n.y + e.y) * i + (2 * n.y - 5 * this.y + 4 * e.y - s.y) * r + (-n.y + 3 * this.y - 3 * e.y + s.y) * o)
    );
  },
  /**
   * @returns {boolean}
   */
  valid() {
    return !isNaN(this.x) && !isNaN(this.y);
  },
  /**
   * Checks if the point is within a given distance of another point.
   * @param {Vector2} point the point to check against
   * @param {number} tolerance the maximum distance allowed
   * @returns {boolean} {@true if it is within the given distance}
   */
  isClose(e, n) {
    return this.getDistance(e) <= n;
  },
  /**
   * Returns the distance between the point and another point.
   * @param {Vector2} point
   * @param {boolean} [squared=false] Controls whether the distance should
   * remain squared, or its square root should be calculated
   * @returns {number}
   */
  getDistance(e, n = !1) {
    const s = e.x - this.x, i = e.y - this.y, r = s * s + i * i;
    return n ? r : Math.sqrt(r);
  },
  /**
   * @param {Rect2} rect
   * @returns {boolean}
   */
  isInside(e) {
    return e.contains(this.x, this.y);
  },
  /**
   * @param {Vector2} v1
   * @returns {number}
   */
  angleToPoint(e) {
    return Math.atan2(this.y - e.y, this.x - e.x);
  },
  /**
   * @param {Vector2} v1
   * @returns {number}
   */
  distance(e) {
    return Math.hypot(this.x - e.x, this.y - e.y);
  }
};
const om = (e, n) => e >= -n && e <= n;
N.ZERO = Object.freeze(new N(0, 0));
N.ONE = Object.freeze(new N(1, 1));
N.INF = Object.freeze(new N(1 / 0, 1 / 0));
N.LEFT = Object.freeze(new N(-1, 0));
N.RIGHT = Object.freeze(new N(1, 0));
N.UP = Object.freeze(new N(0, -1));
N.DOWN = Object.freeze(new N(0, 1));
const QP = new N(), ZP = 1e-5, ve = {
  M: 1,
  L: 2,
  Q: 3,
  C: 4,
  Z: 5
}, qP = {
  [ve.M]: 2,
  [ve.L]: 2,
  [ve.Q]: 4,
  [ve.C]: 6
};
class Vs {
  /**
   * @param {number[]} verticies
   * @param {Command[]} commands
   */
  constructor(n = [], s = []) {
    this.vertices = n, this.commands = s, this.metadata = {}, this.cornerRadiusOverrides = {}, this.hasOpenOrNetworkSubaths = !1;
  }
  toSVGPathString() {
    let n = "", s = 0;
    for (let i = 0; i < this.commands.length; ++i)
      switch (this.commands[i]) {
        case 1: {
          const r = this.vertices[s++], o = this.vertices[s++];
          n += `M${r} ${o}`;
          break;
        }
        case 2: {
          const r = this.vertices[s++], o = this.vertices[s++];
          n += `L${r} ${o}`;
          break;
        }
        case 3: {
          const r = this.vertices[s++], o = this.vertices[s++], a = this.vertices[s++], c = this.vertices[s++];
          n += `Q${r} ${o} ${a} ${c}`;
          break;
        }
        case 4: {
          const r = this.vertices[s++], o = this.vertices[s++], a = this.vertices[s++], c = this.vertices[s++], l = this.vertices[s++], h = this.vertices[s++];
          n += `C${r} ${o} ${a} ${c} ${l} ${h}`;
          break;
        }
        case 5: {
          n += "Z";
          break;
        }
      }
    return n;
  }
  /**
   * @param {number} subpathStartIndex
   * @param {string} key
   * @param {any} value
   */
  attachMetadata(n, s, i) {
    this.metadata[n] || (this.metadata[n] = {}), this.metadata[n][s] = i;
  }
  *iter() {
    const n = this.getSubpathBoundaries();
    for (let s = 0; s < n.length - 1; s++) {
      const i = n[s][0], r = n[s + 1][0], o = n[s][1], a = n[s + 1][1];
      yield new jP(this, i, r, o, a);
    }
  }
  /**
   * First number is an index in the commands array
   *
   * Second number is an index in the vertices array
   *
   * @returns {[number, number][]}
   */
  getSubpathBoundaries() {
    const n = [];
    let s = 0;
    for (let i = 0; i < this.commands.length; i++) {
      const r = this.commands[i];
      r === ve.M && n.push([i, s]), s += qP[r];
    }
    return n.push([this.commands.length, this.vertices.length]), n;
  }
  reverseSubpaths() {
    const n = this.getSubpathBoundaries();
    for (let s = 0; s < n.length - 1; s++) {
      const i = n[s][0], r = n[s + 1][0];
      for (let o = 1; o < Math.ceil((r - i) / 2); o++) {
        const a = this.commands[i + o];
        this.commands[i + o] = this.commands[r - o], this.commands[r - o] = a;
      }
    }
    for (let s = 0; s < n.length - 1; s++) {
      const i = n[s][1], r = n[s + 1][1] - 1, o = r - i + 1;
      for (let a = 0; a < Math.floor(o / 4); a++) {
        const c = a * 2, l = i + c, h = i + c + 1, d = r - c - 1, p = r - c, E = this.vertices[l], g = this.vertices[h];
        this.vertices[l] = this.vertices[d], this.vertices[h] = this.vertices[p], this.vertices[d] = E, this.vertices[p] = g;
      }
    }
  }
  /**
   * @param {number} startCmdI
   * @param {number} startVerI
   * @param {number} lastCmdI
   * @param {number} lastVerI
   */
  connectFirstAndLastSubpaths(n, s, i, r) {
    this.vertices.pop(), this.vertices.pop();
    const o = this.commands.slice(i), a = this.vertices.slice(r);
    for (let c = i - 1; c >= n; c--)
      this.commands[c + o.length - 1] = this.commands[c];
    for (let c = r - 1; c >= s; c--)
      this.vertices[c + a.length] = this.vertices[c];
    for (let c = 0; c < o.length; c++)
      this.commands[n + c] = o[c];
    for (let c = 0; c < a.length; c++)
      this.vertices[s + c] = a[c];
    this.commands.pop();
  }
  clear() {
    this.commands.length = 0, this.vertices.length = 0;
  }
  applyXorm(n) {
    const s = new Vs();
    s.commands = this.commands, s.vertices = [];
    const i = new N(), r = new N();
    for (let o = 0; o < this.vertices.length / 2; o++)
      n.xform(i.set(this.vertices[o * 2], this.vertices[o * 2 + 1]), r), s.vertices.push(r.x, r.y);
    return s;
  }
  get debugString() {
    let n = "";
    n += `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
`, n += `<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`, n += `<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
`;
    let s = 0;
    for (let i = 0; i < this.commands.length; ++i)
      switch (this.commands[i]) {
        case 1:
          {
            const r = this.vertices[s++], o = this.vertices[s++];
            i !== 0 && (n += `" stroke="black" style="fill:none"/>
`), n += `<path d="M${r} ${o} `;
          }
          break;
        case 2:
          {
            const r = this.vertices[s++], o = this.vertices[s++];
            n += `L ${r} ${o} `;
          }
          break;
        case 3:
          {
            const r = this.vertices[s++], o = this.vertices[s++], a = this.vertices[s++], c = this.vertices[s++];
            n += `Q ${r} ${o} ${a} ${c} `;
          }
          break;
        case 4:
          {
            const r = this.vertices[s++], o = this.vertices[s++], a = this.vertices[s++], c = this.vertices[s++], l = this.vertices[s++], h = this.vertices[s++];
            n += `C ${r} ${o} ${a} ${c} ${l} ${h} `;
          }
          break;
      }
    return n += `" stroke="black" style="fill:none"/>
`, n += "</svg>", n;
  }
}
class i0 {
  constructor() {
    this.path = new Vs(), this._started = !1, this.firstX = null, this.firstY = null, this.lastX = null, this.lastY = null;
  }
  clear() {
    this.path.clear(), this._started = !1, this.firstX = null, this.firstY = null, this.lastX = null, this.lastY = null;
  }
  /**
   * @param {Vector2Like} vec
   */
  start_vec(n) {
    this.start(n.x, n.y);
  }
  /**
   * @param {Vector2Like} vec
   */
  line_vec(n) {
    this.line(n.x, n.y);
  }
  /**
   * @param {Vector2Like} vec
   */
  assure_vec(n) {
    this.assure(n.x, n.y);
  }
  /**
   * @param {Vector2Like} vec
   * @param {Vector2Like} cp0
   */
  quadratic_vec(n, s) {
    this.quadratic(n.x, n.y, s.x, s.y);
  }
  /**
   * @param {Vector2Like} vec
   * @param {Vector2Like} cp0
   * @param {Vector2Like} cp1
   */
  cubic_vec(n, s, i) {
    this.cubic(n.x, n.y, s.x, s.y, i.x, i.y);
  }
  /**
   * @param {number} x
   * @param {number} y
   */
  start(n, s) {
    this._started || (this._started = !0, this.path.commands.push(ve.M), this.path.vertices.push(n, s), this.firstX = n, this.firstY = s, this.lastX = n, this.lastY = s);
  }
  /**
   * @param {number} x
   * @param {number} y
   */
  assure(n, s) {
    this._started ? Ss.Equal(this.lastX, n) && Ss.Equal(this.lastY, s) || this.line(n, s) : this.start(n, s);
  }
  /**
   * @param {number} x
   * @param {number} y
   */
  line(n, s) {
    this._started && (this.path.commands.push(ve.L), this.path.vertices.push(n, s), this.lastX = n, this.lastY = s);
  }
  /**
   * @param {number} xc
   * @param {number} yc
   * @param {number} x
   * @param {number} y
   */
  quadratic(n, s, i, r) {
    this._started && (this.path.commands.push(ve.Q), this.path.vertices.push(n, s, i, r), this.lastX = i, this.lastY = r);
  }
  /**
   * @param {number} xc
   * @param {number} yc
   * @param {number} xc2
   * @param {number} yc2
   * @param {number} x
   * @param {number} y
   */
  cubic(n, s, i, r, o, a) {
    this._started && (this.path.commands.push(ve.C), this.path.vertices.push(n, s, i, r, o, a), this.lastX = o, this.lastY = a);
  }
  /**
   * @param {Bezier} curve
   */
  bezier(n) {
    n.order === 2 ? this.quadratic_vec(n.points[1], n.points[2]) : n.order === 3 ? this.cubic_vec(n.points[1], n.points[2], n.points[3]) : console.warn("should not have happened");
  }
  /**
   * @param {Bezier} curve
   */
  bezier_assure_first_point(n) {
    this.assure_vec(n.points[0]), this.bezier(n);
  }
  end(n = !1) {
    this._started && (this._started = !1, n && this.path.commands.push(ve.Z));
  }
  /**
   * @param {Subpath} subpath
   * @param {boolean} [continuePath]
   * @param {number} [offsetCmdS]
   * @param {number} [offsetCmdE]
   * @param {number} [offsetVerS]
   * @param {number} [offsetVerE]
   */
  copySubpath(n, s = !1, i = 0, r = 0, o = 0, a = 0) {
    this.copy(n.path, s, n.cmdS + i, n.cmdE - r, n.verS + o, n.verE - a);
  }
  /**
   * @param {PathData} path
   * @param {boolean} [continuePath=false]
   * @param {number} [cmdS]
   * @param {number} [cmdE]
   * @param {number} [verS]
   * @param {number} [verE]
   */
  copy(n, s = !1, i = 0, r = n.commands.length, o = 0, a = n.vertices.length) {
    for (let c = i; c < r; c++)
      s && n.commands[c] === ve.M ? this.path.commands.push(ve.L) : this.path.commands.push(n.commands[c]);
    for (let c = o; c < a; c++)
      this.path.vertices.push(n.vertices[c]);
  }
}
class jP {
  /**
   * @param {PathData} path
   * @param {number} cmdS
   * @param {number} cmdE
   * @param {number} verS
   * @param {number} verE
   */
  constructor(n, s, i, r, o) {
    this.path = n, this.cmdS = s, this.cmdE = i, this.verS = r, this.verE = o, this.isClosed = this._isClosed(), this.metadata = n.metadata[s] || {}, this.isEnd0Cap = this.metadata.isEnd0Cap === void 0 ? !0 : this.metadata.isEnd0Cap, this.isEnd1Cap = this.metadata.isEnd1Cap === void 0 ? !0 : this.metadata.isEnd1Cap;
  }
  get hasCurves() {
    for (let n = this.cmdS + 1; n < this.cmdE; n++)
      if (this.path.commands[n] !== ve.L) return !0;
    return !1;
  }
  /** @returns {Part} */
  first() {
    const n = this.path.commands[this.cmdS + 1], s = n === ve.Q || n === ve.C;
    let i = this.verS;
    const r = this.path.vertices[i++], o = this.path.vertices[i++];
    let a, c, l, h;
    s && (a = this.path.vertices[i++], c = this.path.vertices[i++]), n === ve.C && (l = this.path.vertices[i++], h = this.path.vertices[i++]);
    const d = this.path.vertices[i++], p = this.path.vertices[i];
    return new Hp(
      n,
      r,
      o,
      a,
      c,
      l,
      h,
      d,
      p,
      !0,
      this.cmdS + 1 === this.cmdE - 1,
      this.path.cornerRadiusOverrides[this.verS],
      this.path.cornerRadiusOverrides[i - 1]
    );
  }
  /** @returns {Part} */
  last() {
    const n = this.path.commands[this.cmdE - 1], s = n === ve.Q || n === ve.C;
    let i = this.verE - 1;
    const r = this.path.vertices[i--], o = this.path.vertices[i--];
    let a, c, l, h;
    n === ve.C && (h = this.path.vertices[i--], l = this.path.vertices[i--]), s && (c = this.path.vertices[i--], a = this.path.vertices[i--]);
    const d = this.path.vertices[i--], p = this.path.vertices[i];
    return new Hp(
      n,
      p,
      d,
      a,
      c,
      l,
      h,
      o,
      r,
      this.cmdS === this.cmdE - 1,
      !0,
      this.path.cornerRadiusOverrides[i],
      this.path.cornerRadiusOverrides[this.verE - 2]
    );
  }
  *iter() {
    let n = this.verS, s = this.path.vertices[n++], i = this.path.vertices[n++];
    for (let r = this.cmdS + 1; r < this.cmdE; r++) {
      if (n >= this.path.vertices.length) return;
      const o = this.path.commands[r], a = o === ve.Q || o === ve.C, c = this.path.cornerRadiusOverrides[n - 2], l = s, h = i;
      let d, p, E, g;
      a && (d = this.path.vertices[n++], p = this.path.vertices[n++]), o === ve.C && (E = this.path.vertices[n++], g = this.path.vertices[n++]);
      const T = this.path.cornerRadiusOverrides[n], A = this.path.vertices[n++], m = this.path.vertices[n++];
      s = A, i = m, yield new Hp(
        o,
        l,
        h,
        d,
        p,
        E,
        g,
        A,
        m,
        r === this.cmdS + 1,
        r === this.cmdE - 1,
        c,
        T
      );
    }
  }
  /** @param {ForEachFn} fn */
  forEach(n) {
    const s = this.iter(), i = s.next().value;
    let r = i, o = !0;
    for (const a of s)
      n(r, a, o, !this.isClosed && a.isLast), o = !1, r = a;
    this.isClosed && n(r, i, o, !0);
  }
  /** @returns {boolean} */
  _isClosed() {
    const n = this.path.vertices[this.verS], s = this.path.vertices[this.verS + 1], i = this.path.vertices[this.verE - 2], r = this.path.vertices[this.verE - 1];
    return Ss.Equal(n, i) && Ss.Equal(s, r);
  }
}
class Hp {
  /**
   * @param {Command} cmd
   * @param {number} x0
   * @param {number} y0
   * @param {number} x0c
   * @param {number} y0c
   * @param {number} x1c
   * @param {number} y1c
   * @param {number} x1
   * @param {number} y1
   * @param {boolean} isFirst
   * @param {boolean} isLast
   * @param {number} cornerRadiusOverride0
   * @param {number} cornerRadiusOverride1
   */
  constructor(n, s, i, r, o, a, c, l, h, d, p, E, g) {
    this.cmd = n, this.p0 = new N(s, i), this.cp0 = r !== void 0 && new N(r, o), this.cp1 = a !== void 0 && new N(a, c), this.p1 = new N(l, h), this.isFirst = d, this.isLast = p, this.isCurve = n === ve.Q || n === ve.C, this.cornerRadiusOverride0 = E, this.cornerRadiusOverride1 = g;
  }
  /** @returns {Vector2} a point that can be used to calculate the tangent at `p0` */
  get tan0() {
    return this.p0.equals(this.cp0) ? this.cmd === ve.C ? this.cp1 : this.p1 : this.cp0;
  }
  /** @returns {Vector2} a point that can be used to calculate the tangent at `p1` */
  get tan1() {
    return this.cmd === ve.C ? this.p1.equals(this.cp1) ? this.cp0 : this.cp1 : this.p1.equals(this.cp0) ? this.p0 : this.cp0;
  }
  bezier() {
    if (!this.isCurve) throw new Error("not a curve");
    if (this.cmd === ve.C) {
      const n = this.p0.equals(this.cp0), s = this.p1.equals(this.cp1), i = n ? am(this.p0, this.cp1) : this.cp0, r = s ? am(this.p1, this.cp0) : this.cp1;
      return new Bt(this.p0.x, this.p0.y, i.x, i.y, r.x, r.y, this.p1.x, this.p1.y);
    } else
      return new Bt(this.p0.x, this.p0.y, this.cp0.x, this.cp0.y, this.p1.x, this.p1.y);
  }
  bezierData() {
    if (!this.isCurve) throw new Error("not a curve");
    return JP(this.p0, this.cp0, this.cp1, this.p1);
  }
}
function JP(e, n, s, i, r = 256) {
  const [o, a] = $P(e, n, s, i, r), c = (d) => L1(d, e, n, s, i), l = (d) => {
    if (d <= 0) return 0;
    if (d >= a) return 1;
    for (let p = 0; p < r; p++)
      if (o[p] >= d) {
        const E = o[p], g = o[p + 1], T = (d - E) / (g - E);
        return (p + T) / r;
      }
    return 1;
  };
  return { length: a, getPointAt: (d) => c(l(d)), getTAt: l, getP: c };
}
function am(e, n) {
  return n.clone().sub(e).normalize().scale(ZP * 100).add(e);
}
const $P = (e, n, s, i, r = 256) => {
  const o = new Array(r + 1);
  o[0] = 0;
  let a = 0;
  const c = new N().copy(e);
  for (let l = 1; l <= r; l++) {
    const h = L1(l / r, e, n, s, i);
    a += h.distance_to(c), o[l] = a, c.copy(h);
  }
  return [o, a];
};
function Y1(e, n, s, i, r = !1, o = !1) {
  const a = s.commands.length;
  let c = !1, l = null, h = null;
  for (const p of n) {
    if (l === null) {
      l = p.v, s.vertices.push(...i(e, l.id)), s.commands.push(ve.M);
      const T = p.v.inHalves.size > 2;
      (T || o) && s.attachMetadata(a, "isEnd0Cap", !1);
      const A = T ? 0 : p.v.cornerRadius;
      A !== null && (s.cornerRadiusOverrides[s.vertices.length - 2] = A);
    } else h !== p.v && console.warn("previous end vertex is not the same as current start vertex!");
    h = p.w, p.edge.isCurve ? (h === p.edge.w ? s.vertices.push(...i(e, p.edge.cpV.id), ...i(e, p.edge.cpW.id), ...i(e, h.id)) : s.vertices.push(...i(e, p.edge.cpW.id), ...i(e, p.edge.cpV.id), ...i(e, h.id)), s.commands.push(ve.C)) : (s.vertices.push(...i(e, h.id)), s.commands.push(ve.L));
    const E = p.w.inHalves.size > 2;
    c = E, s.hasOpenOrNetworkSubaths || (s.hasOpenOrNetworkSubaths = E);
    const g = E ? 0 : p.w.cornerRadius;
    g !== null && (s.cornerRadiusOverrides[s.vertices.length - 2] = g);
  }
  (c || o) && s.attachMetadata(a, "isEnd1Cap", !1);
  const d = h !== l;
  d || s.commands.push(ve.Z), s.hasOpenOrNetworkSubaths || (s.hasOpenOrNetworkSubaths = d), d && !r && console.warn("first and last verticies should be the same!");
}
function _d(e) {
  const n = /* @__PURE__ */ new Set();
  X1(e, n);
  const s = new Vs(), i = (r, o) => r.getVertPos(o);
  for (const r of n)
    Y1(e, r, s, i, !0);
  return s;
}
function X1(e, n) {
  const s = /* @__PURE__ */ new Map();
  for (const i of e.getEdges()) {
    const r = i.v, o = i.w, a = s.get(r), c = s.get(o);
    if (a && c)
      if (a.path === c.path)
        a.last ? a.path.push(i.halves[0]) : a.path.push(i.halves[1]), s.delete(r), s.delete(o);
      else {
        let l;
        if (a.last && c.last)
          l = a.path, l.push(i.halves[0]), eb(c.path, l);
        else if (!a.last && !c.last) {
          l = a.path, l.reverse();
          for (let h = 0; h < l.length; h++)
            l[h] = l[h].twin;
          l.push(i.halves[0], ...c.path);
        } else a.last && !c.last ? (l = a.path, l.push(i.halves[0], ...c.path)) : (l = c.path, l.push(i.halves[1], ...a.path));
        s.delete(r), s.delete(o), n.delete(l === a.path ? c.path : a.path), s.set(l[0].v, { path: l, last: !1 }), s.set(l[l.length - 1].w, { path: l, last: !0 });
      }
    else if (a)
      a.last ? a.path.push(i.halves[0]) : a.path.unshift(i.halves[1]), s.delete(r), s.set(o, { path: a.path, last: a.last });
    else if (c)
      c.last ? c.path.push(i.halves[1]) : c.path.unshift(i.halves[0]), s.delete(o), s.set(r, { path: c.path, last: c.last });
    else {
      const l = [i.halves[0]];
      n.add(l), s.set(r, { path: l, last: !1 }), s.set(o, { path: l, last: !0 });
    }
  }
}
function eb(e, n) {
  for (let s = e.length - 1; s >= 0; s--)
    n.push(e[s].twin);
}
let tb = class z1 {
  /**
   * Creates a line in one of the following ways:
   *  - zero length line (if first argument is not defined)
   *  - from another Line-like object (that has `from` and `to` Vector2-like components)
   *  - from two Vector2-like points
   *  - from 4 components (x,y of one point and x,y of another point)
   * @param  {number | Line | _Vector2} [ax]  x component of the first point OR a Line-like object, OR Vector2-like object, OR not defined
   * @param  {number | _Vector2} [ay]   y component of the first point OR a Vector2-like object
   * @param  {number} [bx]    x component of the second point
   * @param  {number} [by]    y component of the second point
   */
  constructor(n, s, i, r) {
    Ge(n) ? (this.from = new se(), this.to = new se()) : n.from && n.to ? (this.from = new se(n.from), this.to = new se(n.to)) : n.x && n.y && s.x && s.y ? (this.from = new se(n), this.to = new se(s)) : (this.from = new se(n, s), this.to = new se(i, r));
  }
  /**
   * @param {_Vector2} p0
   * @param {_Vector2} p1
   * @returns
   */
  setP(n, s) {
    return this.from = n, this.to = s, this;
  }
  /**
   * Transforms the line by the transformation matrix
   * @param  {mat2d} transform
   * @param  {boolean} newInstance    if true returns a new instance of the Line, instead of modifying this one
   * @returns {Line}                  resulting Line
   */
  transform(n, s = !0) {
    const i = s ? new z1() : this;
    return i.from = Vl(i.from, this.from, n), i.to = Vl(i.to, this.to, n), i;
  }
  /**
   * Test if this line intersects another line
   * @param  {[type]} ax [description]
   * @param  {[type]} ay [description]
   * @param  {[type]} bx [description]
   * @param  {[type]} by [description]
   * @returns {boolean}    true if two lines intersect; false otherwise
   */
  intersectsLine(n, s, i, r) {
    let o = typeof n == "number" ? n : void 0;
    o === void 0 && (o = ee(n.a) ? n.a.x : n.x);
    let a = typeof s == "number" ? s : void 0;
    a === void 0 && (a = ee(n.a) ? n.a.y : n.y);
    let c = typeof i == "number" ? i : void 0;
    c === void 0 && (c = ee(n.b) ? n.b.x : s.x);
    let l = typeof r == "number" ? r : void 0;
    l === void 0 && (l = ee(n.b) ? n.b.y : s.y);
    const h = this.b.x - this.a.x, d = this.b.y - this.a.y, p = c - o, E = l - a, g = (-d * (this.a.x - o) + h * (this.a.y - a)) / (-p * d + h * E), T = (p * (this.a.y - a) - E * (this.a.x - o)) / (-p * d + h * E);
    return g >= 0 && g <= 1 && T >= 0 && T <= 1;
  }
  /**
   * Test if this line intersects a box
   * @param  {[type]} x [description]
   * @param  {[type]} y [description]
   * @param  {[type]} width [description]
   * @param  {[type]} height [description]
   * @returns {boolean}    true if line and box intersect; false otherwise
   */
  intersectsBox(n, s, i, r) {
    const o = new Fn(n, s, i, r), a = o.topLeft, c = o.topRight, l = o.bottomRight, h = o.bottomLeft;
    return this.intersectsLine(a, c) || this.intersectsLine(c, l) || this.intersectsLine(l, h) || this.intersectsLine(h, a);
  }
  normal() {
    return new se(FP(this.from, this.to));
  }
  /**
   * @param {_Vector2} p
   * @returns
   */
  nearest(n) {
    const s = this.a, i = this.getVector(), r = s.clone().add(i), o = i.dot(n.clone().sub(s)), a = i.dot(i);
    let c = 0, l = 0;
    return o <= 0 ? (c = 0, l = n.distance_squared_to(s)) : o >= a ? (c = 1, l = n.distance_squared_to(r)) : (c = o / a, l = this.eval(c).sub(n).length_squared()), { distance_sq: l, t: c };
  }
  /**
   * The direction of the line as a vector.
   * @returns
   */
  getVector() {
    return this.to.clone().sub(this.from);
  }
  /**
   * @param {number} t
   * @returns
   */
  eval(n) {
    const s = this.getVector();
    return this.from.clone().add(
      Ra(0, s.x, n),
      Ra(0, s.y, n)
    );
  }
  get a() {
    return this.from;
  }
  get b() {
    return this.to;
  }
};
class Wp {
  /**
   * [constructor description]
   * @param  {OpacityStopData} data
   */
  constructor({ position: n, opacity: s } = {}) {
    typeof s == "number" && typeof n == "number" ? (this.position = n, this.opacity = s) : this.copy(n);
  }
  copy(n) {
    this.position = n.position, this.opacity = n.opacity;
  }
  eq(n) {
    return n && this.position === n.position && this.opacity === n.opacity;
  }
  save() {
    const n = {};
    return n.position = this.position, n.opacity = this.opacity, n;
  }
}
class Va {
  /**
   * Creates new ColorStop object from data
   * @param  {ColorStopData} data
   */
  constructor({ position: n, color: s } = {}) {
    if (Ge(n) || Ge(s))
      throw new Error("ColorStop position or color arguments are missing");
    this.position = n, this.color = new as(s);
  }
  /**
   * Copies values from another ColorStop
   * @param  {(ColorStop | ColorStopData)} data
   */
  copy({ position: n, color: s } = {}) {
    this.position = n, this.color = new as(s);
  }
  /**
   * Checks if this ColorStop is equal to another ColorStop
   * @param  {ColorStop} cs
   * @returns {bool}      true if equal; false otherwise
   */
  eq(n) {
    return n && this.position === n.position && this.color.eq(n.color);
  }
  /**
   * Serialize ColorStop data
   * @returns {ColorStopData}
   */
  save() {
    const n = {};
    return n.position = this.position, n.color = [...this.color], n;
  }
}
const Yp = 5, nb = !1;
class sb {
  constructor() {
    this._enabled = nb, this._logger = {}, this._reset();
  }
  help() {
    console.log(`stats.activate(): enable the frame monitoring
`), console.log(`stats.deactivate(): disable the frame monitoring
`), console.log(`stats.dump(): get the monitoring result
`), console.log(`stats.help(): show the usage of this tool
`);
  }
  activate() {
    this._reset(), this._enabled = !0, console.log("The frame monitoring utility is activated.");
  }
  deactivate() {
    this._reset(), this._enabled = !1, console.log("The frame monitoring utility is deactivated.");
  }
  has(n) {
    const [s, i] = this._getMetricNames(n), r = this.metricGroups[s];
    return r ? !!r[i] : !1;
  }
  get(n) {
    if (!this.has(n))
      throw new Error(`The metrics "${n}" does not exist`);
    const [s, i] = this._getMetricNames(n);
    return this.metricGroups[s][i];
  }
  /**
   * @param {string} metricPath 
   */
  begin(n) {
    if (!this._enabled)
      return;
    const [s, i] = this._getMetricNames(n);
    this.metricGroups[s] || (this.metricGroups[s] = {}), this.metricGroups[s][i] || (this.metricGroups[s][i] = {
      frameCounter: 0,
      deltaTime: 0,
      maxDeltaTime: 0,
      minDeltaTime: 1 / 0,
      deltaTimeBuffer: new Array(Yp).fill(0),
      useSubTimer: !1
    }), this.metricGroups[s][i].beginTime = performance.now(), this.metricGroups[s][i].deltaTime = 0, this.metricGroups[s][i].useSubTimer = !1;
  }
  /**
   * @param {string} metricPath
   * @returns {number}
   */
  end(n) {
    if (!this._enabled)
      return;
    const s = this.get(n);
    return s.useSubTimer || (s.deltaTime = performance.now() - s.beginTime), this._recalculateAvgMinMax(s), s.deltaTime;
  }
  beginSub(n) {
    if (!this._enabled)
      return;
    const s = this.get(n);
    s.useSubTimer = !0, s.beginTime = performance.now();
  }
  endSub(n) {
    if (!this._enabled)
      return;
    const s = this.get(n);
    s.deltaTime += performance.now() - s.beginTime;
  }
  log(n, s) {
    this._enabled && (this._logger[n] = s);
  }
  /**
   * @param {string} metricPath 
   * @returns {[string, string]}
   */
  _getMetricNames(n) {
    const s = n.split("/");
    return s.length <= 1 ? ["_", s[0]] : [s[0], s[1]];
  }
  /**
   * @param {*} metric
   */
  _recalculateAvgMinMax(n) {
    n.deltaTimeBuffer[n.frameCounter++ % Yp] = n.deltaTime, n.maxDeltaTime = Math.max(n.maxDeltaTime, n.deltaTime), n.minDeltaTime = Math.min(n.minDeltaTime, n.deltaTime), n.avgDeltaTime = n.deltaTimeBuffer.reduce((s, i) => s + i, 0) / Yp;
  }
  _reset() {
    this.metricGroups = {
      _: {}
      // default metric group
    }, this._logger = {};
  }
  dump() {
    const n = this._logger;
    return Object.keys(this.metricGroups).reduce((s, i) => {
      const r = this.metricGroups[i], o = Object.keys(r).reduce((a, c) => a + r[c].avgDeltaTime, 0);
      return s[i] = Object.keys(r).reduce((a, c) => (a[c] = {
        frames: r[c].frameCounter,
        avg: r[c].avgDeltaTime,
        min: r[c].minDeltaTime,
        max: r[c].maxDeltaTime,
        pct: 100 * (r[c].avgDeltaTime / o)
      }, a), {}), s;
    }, n);
  }
}
const zt = new sb();
typeof window < "u" && (window.stats = zt);
const ib = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI4IiB2aWV3Qm94PSIwIDAgOCA4IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMjYxMF8xODU5KSI+CjxwYXRoIGQ9Ik0yIDBIMFYySDJWMFoiIGZpbGw9ImJsYWNrIi8+CjxwYXRoIGQ9Ik00IDBIMlYySDRWMFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik02IDBINFYySDZWMFoiIGZpbGw9ImJsYWNrIi8+CjxwYXRoIGQ9Ik04IDBINlYySDhWMFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik00IDJIMlY0SDRWMloiIGZpbGw9ImJsYWNrIi8+CjxwYXRoIGQ9Ik02IDJINFY0SDZWMloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik04IDJINlY0SDhWMloiIGZpbGw9ImJsYWNrIi8+CjxwYXRoIGQ9Ik0yIDJIMFY0SDJWMloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0yIDRIMFY2SDJWNFoiIGZpbGw9ImJsYWNrIi8+CjxwYXRoIGQ9Ik00IDRIMlY2SDRWNFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik02IDRINFY2SDZWNFoiIGZpbGw9ImJsYWNrIi8+CjxwYXRoIGQ9Ik04IDRINlY2SDhWNFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik00IDZIMlY4SDRWNloiIGZpbGw9ImJsYWNrIi8+CjxwYXRoIGQ9Ik02IDZINFY4SDZWNloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik04IDZINlY4SDhWNloiIGZpbGw9ImJsYWNrIi8+CjxwYXRoIGQ9Ik0yIDZIMFY4SDJWNloiIGZpbGw9IndoaXRlIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMjYxMF8xODU5Ij4KPHJlY3Qgd2lkdGg9IjgiIGhlaWdodD0iOCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K";
var rb = Object.defineProperty, ob = (e, n, s) => n in e ? rb(e, n, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[n] = s, Xe = (e, n, s) => ob(e, typeof n != "symbol" ? n + "" : n, s), K1 = { exports: {} };
(function(e) {
  var n = Object.prototype.hasOwnProperty, s = "~";
  function i() {
  }
  Object.create && (i.prototype = /* @__PURE__ */ Object.create(null), new i().__proto__ || (s = !1));
  function r(l, h, d) {
    this.fn = l, this.context = h, this.once = d || !1;
  }
  function o(l, h, d, p, E) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var g = new r(d, p || l, E), T = s ? s + h : h;
    return l._events[T] ? l._events[T].fn ? l._events[T] = [l._events[T], g] : l._events[T].push(g) : (l._events[T] = g, l._eventsCount++), l;
  }
  function a(l, h) {
    --l._eventsCount === 0 ? l._events = new i() : delete l._events[h];
  }
  function c() {
    this._events = new i(), this._eventsCount = 0;
  }
  c.prototype.eventNames = function() {
    var l = [], h, d;
    if (this._eventsCount === 0) return l;
    for (d in h = this._events)
      n.call(h, d) && l.push(s ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(h)) : l;
  }, c.prototype.listeners = function(l) {
    var h = s ? s + l : l, d = this._events[h];
    if (!d) return [];
    if (d.fn) return [d.fn];
    for (var p = 0, E = d.length, g = new Array(E); p < E; p++)
      g[p] = d[p].fn;
    return g;
  }, c.prototype.listenerCount = function(l) {
    var h = s ? s + l : l, d = this._events[h];
    return d ? d.fn ? 1 : d.length : 0;
  }, c.prototype.emit = function(l, h, d, p, E, g) {
    var T = s ? s + l : l;
    if (!this._events[T]) return !1;
    var A = this._events[T], m = arguments.length, O, S;
    if (A.fn) {
      switch (A.once && this.removeListener(l, A.fn, void 0, !0), m) {
        case 1:
          return A.fn.call(A.context), !0;
        case 2:
          return A.fn.call(A.context, h), !0;
        case 3:
          return A.fn.call(A.context, h, d), !0;
        case 4:
          return A.fn.call(A.context, h, d, p), !0;
        case 5:
          return A.fn.call(A.context, h, d, p, E), !0;
        case 6:
          return A.fn.call(A.context, h, d, p, E, g), !0;
      }
      for (S = 1, O = new Array(m - 1); S < m; S++)
        O[S - 1] = arguments[S];
      A.fn.apply(A.context, O);
    } else {
      var y = A.length, v;
      for (S = 0; S < y; S++)
        switch (A[S].once && this.removeListener(l, A[S].fn, void 0, !0), m) {
          case 1:
            A[S].fn.call(A[S].context);
            break;
          case 2:
            A[S].fn.call(A[S].context, h);
            break;
          case 3:
            A[S].fn.call(A[S].context, h, d);
            break;
          case 4:
            A[S].fn.call(A[S].context, h, d, p);
            break;
          default:
            if (!O) for (v = 1, O = new Array(m - 1); v < m; v++)
              O[v - 1] = arguments[v];
            A[S].fn.apply(A[S].context, O);
        }
    }
    return !0;
  }, c.prototype.on = function(l, h, d) {
    return o(this, l, h, d, !1);
  }, c.prototype.once = function(l, h, d) {
    return o(this, l, h, d, !0);
  }, c.prototype.removeListener = function(l, h, d, p) {
    var E = s ? s + l : l;
    if (!this._events[E]) return this;
    if (!h)
      return a(this, E), this;
    var g = this._events[E];
    if (g.fn)
      g.fn === h && (!p || g.once) && (!d || g.context === d) && a(this, E);
    else {
      for (var T = 0, A = [], m = g.length; T < m; T++)
        (g[T].fn !== h || p && !g[T].once || d && g[T].context !== d) && A.push(g[T]);
      A.length ? this._events[E] = A.length === 1 ? A[0] : A : a(this, E);
    }
    return this;
  }, c.prototype.removeAllListeners = function(l) {
    var h;
    return l ? (h = s ? s + l : l, this._events[h] && a(this, h)) : (this._events = new i(), this._eventsCount = 0), this;
  }, c.prototype.off = c.prototype.removeListener, c.prototype.addListener = c.prototype.on, c.prefixed = s, c.EventEmitter = c, e.exports = c;
})(K1);
var Q1 = K1.exports;
const Td = navigator.userAgent.includes("Mac"), ab = Td ? "Mac" : "Other", cb = "+", lb = {
  // modifiers
  ControlLeft: "Control",
  ControlRight: "Control",
  MetaLeft: "Modifier",
  MetaRight: "Modifier",
  ShiftLeft: "Shift",
  ShiftRight: "Shift",
  AltLeft: "Alt",
  AltRight: "Alt",
  // numbers
  Digit0: "0",
  Digit1: "1",
  Digit2: "2",
  Digit3: "3",
  Digit4: "4",
  Digit5: "5",
  Digit6: "6",
  Digit7: "7",
  Digit8: "8",
  Digit9: "9",
  Numpad0: "0",
  Numpad1: "1",
  Numpad2: "2",
  Numpad3: "3",
  Numpad4: "4",
  Numpad5: "5",
  Numpad6: "6",
  Numpad7: "7",
  Numpad8: "8",
  Numpad9: "9",
  KeyA: "A",
  KeyB: "B",
  KeyC: "C",
  KeyD: "D",
  KeyE: "E",
  KeyF: "F",
  KeyG: "G",
  KeyH: "H",
  KeyI: "I",
  KeyJ: "J",
  KeyK: "K",
  KeyL: "L",
  KeyM: "M",
  KeyN: "N",
  KeyO: "O",
  KeyP: "P",
  KeyQ: "Q",
  KeyR: "R",
  KeyS: "S",
  KeyT: "T",
  KeyU: "U",
  KeyV: "V",
  KeyW: "W",
  KeyX: "X",
  KeyY: "Y",
  KeyZ: "Z",
  // symbols
  Equal: "=",
  NumpadAdd: "=",
  Minus: "-",
  NumpadSubtract: "-",
  Period: ".",
  NumpadDecimal: ".",
  Slash: "/",
  NumpadDivide: "/",
  Backslash: "\\",
  BracketRight: "]",
  BracketLeft: "[",
  Quote: "'",
  Semicolon: ";",
  Comma: ",",
  Backquote: "`",
  // align to key
  NumLock: "Clear",
  Help: "Insert",
  // keep code as key
  Space: "Space"
}, Ee = {
  LEFT_CLICK: "LEFT_CLICK",
  LEFT_CLICK_MOVE: "LEFT_CLICK_MOVE",
  LEFT_CLICK_DOWN: "LEFT_CLICK_DOWN",
  LEFT_CLICK_UP: "LEFT_CLICK_UP",
  SPACE: "SPACE",
  MIDDLE_CLICK_MOVE: "MIDDLE_CLICK_MOVE",
  RIGHT_CLICK_MOVE: "RIGHT_CLICK_MOVE",
  MOUSE_MOVE: "MOUSE_MOVE",
  MOUSE_ENTER: "MOUSE_ENTER",
  MOUSE_LEAVE: "MOUSE_LEAVE",
  DOUBLE_LEFT_CLICK: "DOUBLE_LEFT_CLICK",
  DRAG_OVER: "DRAG_OVER",
  DRAG_END: "DRAG_END",
  DROP: "DROP",
  SELECT_PREVIOUS_ELEMENT: "SELECT_PREVIOUS_ELEMENT",
  SELECT_NEXT_ELEMENT: "SELECT_NEXT_ELEMENT",
  TEXT_MOVE_CARET_TO_LINE_START: "TEXT_MOVE_CARET_TO_LINE_START",
  TEXT_MOVE_CARET_TO_TEXT_START: "TEXT_MOVE_CARET_TO_TEXT_START",
  TEXT_EXPAND_SELECTION_TO_LINE_START: "TEXT_EXPAND_SELECTION_TO_LINE_START",
  TEXT_EXPAND_SELECTION_TO_TEXT_START: "TEXT_EXPAND_SELECTION_TO_TEXT_START",
  TEXT_MOVE_CARET_TO_LINE_END: "TEXT_MOVE_CARET_TO_LINE_END",
  TEXT_MOVE_CARET_TO_TEXT_END: "TEXT_MOVE_CARET_TO_TEXT_END",
  TEXT_EXPAND_SELECTION_TO_LINE_END: "TEXT_EXPAND_SELECTION_TO_LINE_END",
  TEXT_EXPAND_SELECTION_TO_TEXT_END: "TEXT_EXPAND_SELECTION_TO_TEXT_END",
  ENTER: "ENTER",
  ENTER_SHIFT: "ENTER_SHIFT",
  ESCAPE: "ESCAPE",
  DELETE: "DELETE",
  MOVE_RIGHT: "MOVE_RIGHT",
  MOVE_LEFT: "MOVE_LEFT",
  MOVE_UP: "MOVE_UP",
  MOVE_DOWN: "MOVE_DOWN",
  UNDO: "UNDO",
  REDO: "REDO",
  ZOOM_OUT: "ZOOM_OUT",
  ZOOM_IN: "ZOOM_IN",
  ZOOM_RESET: "ZOOM_RESET",
  ZOOM_FIT_CONTENT: "ZOOM_FIT_CONTENT",
  ZOOM_FIT_SELECTION: "ZOOM_FIT_SELECTION",
  ZOOM_CENTER_SELECTION: "ZOOM_CENTER_SELECTION",
  COPY: "COPY",
  PASTE: "PASTE",
  CUT: "CUT",
  DUPLICATE: "DUPLICATE",
  SELECT_ALL: "SELECT_ALL",
  TOGGLE_ANIMATE_MODE: "TOGGLE_ANIMATE_MODE",
  ACTIVATE_SELECT_TOOL: "ACTIVATE_SELECT_TOOL",
  ACTIVATE_SCALE_TOOL: "ACTIVATE_SCALE_TOOL",
  ACTIVATE_HAND_TOOL: "ACTIVATE_HAND_TOOL",
  ACTIVATE_RECTANGLE_TOOL: "ACTIVATE_RECTANGLE_TOOL",
  RESTART_PROTOTYPE: "RESTART_PROTOTYPE",
  TOGGLE_PROTOTYPE_MODE: "TOGGLE_PROTOTYPE_MODE",
  EXIT_PROTOTYPE_MODE: "EXIT_PROTOTYPE_MODE",
  ENTER_PROTOTYPE_MODE_FULL_SCREEN: "ENTER_PROTOTYPE_MODE_FULL_SCREEN",
  ACTIVATE_CONTAINER_TOOL: "ACTIVATE_CONTAINER_TOOL",
  ACTIVATE_ELLIPSE_TOOL: "ACTIVATE_ELLIPSE_TOOL",
  ACTIVATE_PEN_TOOL: "ACTIVATE_PEN_TOOL",
  ACTIVATE_COMMENT_TOOL: "ACTIVATE_COMMENT_TOOL",
  ACTIVATE_TEXT_TOOL: "ACTIVATE_TEXT_TOOL",
  TOGGLE_EYE_DROPPER_TOOL: "TOGGLE_EYE_DROPPER_TOOL",
  INCREASE_CORNER_RADIUS: "INCREASE_CORNER_RADIUS",
  DECREASE_CORNER_RADIUS: "DECREASE_CORNER_RADIUS",
  GROUP_ELEMENTS: "GROUP_ELEMENTS",
  UNGROUP_ELEMENT: "UNGROUP_ELEMENT",
  TOGGLE_EXPAND: "TOGGLE_EXPAND",
  WHEEL_PAN_VIEWPORT: "WHEEL_PAN_VIEWPORT",
  WHEEL_ZOOM_TO_POINTER: "WHEEL_ZOOM_TO_POINTER",
  TRACKPAD_ZOOM_TO_POINTER: "TRACKPAD_ZOOM_TO_POINTER",
  MOBILE_PINCH_ZOOM_TO_POINTER: "MOBILE_PINCH_ZOOM_TO_POINTER",
  MOBILE_TOUCH_PAN: "MOBILE_TOUCH_PAN",
  ALIGN_LEFT: "ALIGN_LEFT",
  ALIGN_CENTER: "ALIGN_CENTER",
  ALIGN_RIGHT: "ALIGN_RIGHT",
  ALIGN_TOP: "ALIGN_TOP",
  ALIGN_MIDDLE: "ALIGN_MIDDLE",
  ALIGN_BOTTOM: "ALIGN_BOTTOM",
  DISTRIBUTE_HORIZONTAL: "DISTRIBUTE_HORIZONTAL",
  DISTRIBUTE_VERTICAL: "DISTRIBUTE_VERTICAL",
  TOGGLE_ORIGIN: "TOGGLE_ORIGIN",
  TOGGLE_RULER: "TOGGLE_RULER",
  TOGGLE_ACTION_PANEL: "TOGGLE_ACTION_PANEL",
  ADD_ACTION: "ADD_ACTION",
  TOGGLE_INTERFACE: "TOGGLE_INTERFACE",
  TOGGLE_COMMENT_VISIBILITY: "TOGGLE_COMMENT_VISIBILITY",
  TOGGLE_VISIBLE: "TOGGLE_VISIBLE",
  TOGGLE_LOCK: "TOGGLE_LOCK",
  BRING_TO_FRONT: "BRING_TO_FRONT",
  SEND_TO_BACK: "SEND_TO_BACK",
  MOVE_FORWARD: "MOVE_FORWARD",
  MOVE_BACKWARD: "MOVE_BACKWARD",
  MASK_SELECTION: "MASK_SELECTION",
  TOGGLE_PRESENCE: "TOGGLE_PRESENCE",
  EDIT_ORIGIN: "EDIT_ORIGIN",
  TOGGLE_INSPECTING: "TOGGLE_INSPECTING",
  KEY_DOWN: "KEY_DOWN",
  KEY_UP: "KEY_UP"
}, cm = /* @__PURE__ */ new Map(), lm = (e) => {
  if (!e) return null;
  const n = cm.get(e);
  if (n)
    return n;
  const s = new r0(e);
  return cm.set(e, s), s;
};
class r0 {
  constructor(n) {
    Xe(this, "sourceStr"), Xe(this, "triggerKeyCode"), Xe(this, "modifiers"), this.sourceStr = n;
    const s = r0._splitStr(n, cb);
    this.triggerKeyCode = s.pop() || "", this.modifiers = s.reduce(
      (i, r) => (i[r.toLowerCase()] = !0, i),
      {
        modifier: !1,
        ctrl: !1,
        shift: !1,
        alt: !1
      }
    );
  }
  static _splitStr(n, s) {
    const i = n.replace(/ /g, "");
    let r = "";
    const o = [];
    for (let a = 0; a < i.length; a++) {
      if (a !== i.length - 1 && i[a + 1] === s) {
        r += i[a] === "\\" ? s : i[a], o.push(r), r = "", a++;
        continue;
      }
      r += i[a];
    }
    return r && o.push(r), o;
  }
  shouldTrigger(n, s = !1) {
    return n.key !== this.triggerKeyCode ? !1 : s ? !0 : Object.entries(this.modifiers).every(([i, r]) => {
      if (n.modifiers[i] === r)
        return !0;
      if (!Td)
        switch (i) {
          case "ctrl":
            return n.modifiers.modifier === this.modifiers.modifier;
          case "modifier":
            return n.modifiers.modifier || n.modifiers.ctrl;
        }
    });
  }
}
class Z1 extends Q1.EventEmitter {
  constructor(n, s, i, r = !1) {
    super(), Xe(this, "name"), Xe(this, "fallback"), Xe(this, "defaultKeyCombos"), Xe(this, "context"), Xe(this, "_keyCombos"), Xe(this, "_active"), Xe(this, "_pressed"), this.name = n, this.context = i, this.fallback = r, this.defaultKeyCombos = s, this._keyCombos = s.map((o) => lm(o)).filter((o) => o !== null), this._active = !0, this._pressed = !1;
  }
  get active() {
    return this._active;
  }
  set active(n) {
    this._active = n, this._pressed && (this._pressed = !1);
  }
  get keyCombos() {
    return this._keyCombos.map((n) => n && n.sourceStr);
  }
  set keyCombos(n) {
    !this.active && n.length !== 0 && (this.active = !0), n.length === 0 && (this.active = !1), this._keyCombos = n.map((s) => lm(s)).filter((s) => s !== null);
  }
  get pressed() {
    return this._pressed;
  }
  get usesDefaultKeyCombo() {
    return this.keyCombos.every(
      (n, s) => n === this.defaultKeyCombos[s]
    );
  }
  _press(n, s) {
    if (this._active)
      return n.handled = !0, this._pressed ? this.emit("update", n, s.modifiers) : (!this.emit("trigger", n, s.modifiers) && !this.emit("start", n, s.modifiers) && (n.handled = !1), n.handled && (this._pressed = this.listeners("end").length !== 0)), n.handled;
  }
  end() {
    this._active && (this._pressed = !1, this.emit("end"));
  }
  trigger(n, s) {
    return this.shouldTrigger(n) && this._press(s, n);
  }
  transitionTo(n, s, i) {
    return n.canBeActive(s) ? (n._pressed = !0, n._press(i, s), this._pressed = !1, !0) : !1;
  }
  shouldTrigger(n) {
    return this.canBeActive(n);
  }
  canBeActive(n) {
    return this._keyCombos.some(
      (s) => s.shouldTrigger(n, this.fallback)
    );
  }
  hasKeyCode(n) {
    return this._keyCombos.some((s) => n === s.triggerKeyCode);
  }
  resetKeyCombo() {
    this.keyCombos = this.defaultKeyCombos;
  }
}
var Uc = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var e = 0, n = arguments.length; n--; )
    e += arguments[n] * arguments[n];
  return Math.sqrt(e);
});
function hb() {
  var e = new Uc(6);
  return Uc != Float32Array && (e[1] = 0, e[2] = 0, e[4] = 0, e[5] = 0), e[0] = 1, e[3] = 1, e;
}
function hm(e, n, s, i, r, o, a) {
  return e[0] = n, e[1] = s, e[2] = i, e[3] = r, e[4] = o, e[5] = a, e;
}
function ub() {
  var e = new Uc(4);
  return Uc != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0), e;
}
function um(e, n, s, i, r) {
  return e[0] = n, e[1] = s, e[2] = i, e[3] = r, e;
}
(function() {
  var e = ub();
  return function(n, s, i, r, o, a) {
    var c, l;
    for (s || (s = 4), i || (i = 0), r ? l = Math.min(r * s + i, n.length) : l = n.length, c = i; c < l; c += s)
      e[0] = n[c], e[1] = n[c + 1], e[2] = n[c + 2], e[3] = n[c + 3], o(e, e, a), n[c] = e[0], n[c + 1] = e[1], n[c + 2] = e[2], n[c + 3] = e[3];
    return n;
  };
})();
function db() {
  var e = new Uc(2);
  return Uc != Float32Array && (e[0] = 0, e[1] = 0), e;
}
function dm(e, n, s) {
  return e[0] = n, e[1] = s, e;
}
(function() {
  var e = db();
  return function(n, s, i, r, o, a) {
    var c, l;
    for (s || (s = 2), i || (i = 0), r ? l = Math.min(r * s + i, n.length) : l = n.length, c = i; c < l; c += s)
      e[0] = n[c], e[1] = n[c + 1], o(e, e, a), n[c] = e[0], n[c + 1] = e[1];
    return n;
  };
})();
const Yc = 1e-4;
hb();
function Vn(e) {
  return e == null;
}
function qt(e) {
  return !Vn(e);
}
function Vi(e) {
  return typeof e == "number";
}
function fb(e, n, s = Yc) {
  const i = e[0], r = e[1], o = n[0], a = n[1];
  return Math.abs(i - o) <= s * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(r - a) <= s * Math.max(1, Math.abs(r), Math.abs(a));
}
function pb(e, n, s = Yc) {
  const i = e[0], r = e[1], o = e[2], a = e[3], c = n[0], l = n[1], h = n[2], d = n[3];
  return Math.abs(i - c) <= s * Math.max(1, Math.abs(i), Math.abs(c)) && Math.abs(r - l) <= s * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(o - h) <= s * Math.max(1, Math.abs(o), Math.abs(h)) && Math.abs(a - d) <= s * Math.max(1, Math.abs(a), Math.abs(d));
}
function Eb(e, n, s = Yc) {
  const i = e[0], r = e[1], o = e[2], a = e[3], c = e[4], l = e[5], h = n[0], d = n[1], p = n[2], E = n[3], g = n[4], T = n[5];
  return Math.abs(i - h) <= s * Math.max(1, Math.abs(i), Math.abs(h)) && Math.abs(r - d) <= s * Math.max(1, Math.abs(r), Math.abs(d)) && Math.abs(o - p) <= s * Math.max(1, Math.abs(o), Math.abs(p)) && Math.abs(a - E) <= s * Math.max(1, Math.abs(a), Math.abs(E)) && Math.abs(c - g) <= s * Math.max(1, Math.abs(c), Math.abs(g)) && Math.abs(l - T) <= s * Math.max(1, Math.abs(l), Math.abs(T));
}
function gb(e, n) {
  return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = 0, e[5] = 0, e;
}
class Jo extends Float32Array {
  /**
   * Creates new Vector2 from 2 number components or copies values from a single vec2-like object
   * @param  {number | _Vector2 | vec2 | object} x  x component or vec2-like object
   * @param  {number} y   y component
   */
  constructor(n, s) {
    super(2), typeof n == "number" && typeof s == "number" ? dm(this, n, s) : this.copy(n);
  }
  /**
   * Copies values from the vec2-like object
   * @param  {_Vector2 | vec2 | object} val
   * @returns {_Vector2} self
   */
  copy(n) {
    if (Vn(n))
      return;
    let s = qt(n[0]) ? n[0] : n.x;
    Vn(s) && (s = n.width);
    let i = qt(n[1]) ? n[1] : n.y;
    if (Vn(i) && (i = n.height), Vi(s) && Vi(i))
      dm(this, s, i);
    else
      throw new Error("Trying to copy NaN to Vector2");
    return this;
  }
  /**
   * Checks if this Vector2 is equal (has same corresponding component values) to another vec2-like object
   * @param {_Vector2 | vec2 | object} val     vec2-like object
   * @param {number} [epsilon]                precision, default is 0.0001
   * @returns {boolean}                        true if vectors are equal; false othewise
   */
  eq(n, s = Yc) {
    if (Vn(n))
      return !1;
    let i = qt(n[0]) ? n[0] : n.x;
    Vn(i) && (i = n.width);
    let r = qt(n[1]) ? n[1] : n.y;
    return Vn(r) && (r = n.height), fb(this, [i, r], s);
  }
  get x() {
    return this[0];
  }
  set x(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to x component of Vector2");
    this[0] = n;
  }
  get y() {
    return this[1];
  }
  set y(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to y component of Vector2");
    this[1] = n;
  }
  get width() {
    return this[0];
  }
  set width(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to width component of Vector2");
    this[0] = n;
  }
  get height() {
    return this[1];
  }
  set height(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to height component of Vector2");
    this[1] = n;
  }
}
Jo.ZERO = new Jo(0, 0);
Jo.ONE = new Jo(1, 1);
var fm;
(function(e) {
  e.PERSONAL = "u", e.TEAM = "t";
})(fm || (fm = {}));
var pm;
(function(e) {
  e.BASE = "bs", e.ELEMENT = "el", e.PROPERTY_COMPONENT = "pc", e.INTERACTION_MANAGER_COMPONENT = "im", e.LAYER = "ly", e.MESH = "ms", e.TRANSITION_MANAGER_COMPONENT = "tm", e.ELEMENT_INTERACTION = "ei";
})(pm || (pm = {}));
var Em;
(function(e) {
  e[e.PIXEL = 0] = "PIXEL", e[e.PERCENT = 1] = "PERCENT";
})(Em || (Em = {}));
var gm;
(function(e) {
  e[e.PIXEL = 0] = "PIXEL", e[e.PERCENT = 1] = "PERCENT";
})(gm || (gm = {}));
var _m;
(function(e) {
  e[e.PIXEL = 0] = "PIXEL", e[e.PERCENT = 1] = "PERCENT", e[e.INCH = 2] = "INCH", e[e.CM = 3] = "CM", e[e.MM = 4] = "MM";
})(_m || (_m = {}));
var Ad;
(function(e) {
  e[e.PROPERTY = 0] = "PROPERTY", e[e.ENTITY = 1] = "ENTITY";
})(Ad || (Ad = {}));
var Yl;
(function(e) {
  e.BASE_CHANGES = "BASE_CHANGES", e.DEFAULT_CHANGES = "CHANGES", e.EDITOR_CHANGES = "EDITOR_CHANGES", e.EFFECT_LIST_CHANGES = "EFFECT_LIST_CHANGES", e.ELEMENT_INTERACTION_CHANGES = "ELEMENT_INTERACTION_CHANGES", e.GROUP_ADD_CHILDREN = "GROUP_ADD_CHILDREN", e.GROUP_REMOVE_CHILDREN = "GROUP_REMOVE_CHILDREN", e.GUIDELINES_CHANGES = "GUIDELINES_CHANGES", e.IMAGE_CHANGES = "IMAGE_CHANGES", e.INTERACTION_CHANGES = "INTERACTION_CHANGES", e.KFINFO_CHANGES = "KFINFO_CHANGES", e.LAYER_LIST_CHANGES = "LAYER_LIST_CHANGES", e.LIBRARY_CHANGES = "LIBRARY_CHANGES", e.LOAD = "LOAD", e.LOAD_START = "LOAD_START", e.MESH_CHANGES = "MESH_CHANGES", e.MODIFIER_KEY_CHANGES = "MODIFIER_KEY_CHANGES", e.PRESET_LIST_CHANGES = "PRESET_LIST_CHANGES", e.PROPERTY_PANEL_UPDATE_NEEDED = "PROPERTY_PANEL_UPDATE_NEEDED", e.SCENE_TREE_CHANGES = "SCENE_TREE_CHANGES", e.SELECT = "SELECT", e.SELECT_CELL = "SELECT_CELL", e.TRANSACTION = "TRANSACTION", e.TRIGGER_VECTOR_FORCE_UPDATE = "TRIGGER_VECTOR_FORCE_UPDATE", e.UI_STATE_CHANGES = "UI_STATE_CHANGES", e.WORKSPACE_CHANGE = "WORKSPACE_CHANGE", e.WORKSPACE_CHANGE_WATCH = "WORKSPACE_CHANGE_WATCH", e.WORKSPACE_LIST_CHANGES = "WORKSPACE_LIST_CHANGES", e.SELECT_TEXT_RANGE = "SELECT_TEXT_RANGE", e.DATA_STORE_CLEAR = "DATA_STORE_CLEAR", e.VIEWPORT_ZOOM_CHANGE = "VIEWPORT_ZOOM_CHANGE", e.UNDO_CHECKPOINT_CROSSED = "UNDO_CHECKPOINT_CROSSED", e.VIEWPORT_RESIZE = "VIEWPORT_RESIZE";
})(Yl || (Yl = {}));
var Tm;
(function(e) {
  e[e.SOLID = 0] = "SOLID", e[e.LINEAR = 1] = "LINEAR", e[e.RADIAL = 2] = "RADIAL", e[e.ANGULAR = 3] = "ANGULAR", e[e.DIAMOND = 4] = "DIAMOND", e[e.SHAPE = 5] = "SHAPE", e[e.ACROSS = 6] = "ACROSS", e[e.ALONG = 7] = "ALONG";
})(Tm || (Tm = {}));
var Am;
(function(e) {
  e[e.TOP = 0] = "TOP", e[e.BOTTOM = 1] = "BOTTOM", e[e.MIDDLE = 2] = "MIDDLE";
})(Am || (Am = {}));
var mm;
(function(e) {
  e[e.LEFT = 0] = "LEFT", e[e.RIGHT = 1] = "RIGHT", e[e.CENTER = 2] = "CENTER", e[e.JUSTIFIED = 3] = "JUSTIFIED";
})(mm || (mm = {}));
var Om;
(function(e) {
  e[e.NORMAL = 0] = "NORMAL", e[e.UPPER = 1] = "UPPER", e[e.LOWER = 2] = "LOWER", e[e.TITLE = 3] = "TITLE";
})(Om || (Om = {}));
var Im;
(function(e) {
  e[e.NORMAL = 0] = "NORMAL", e[e.SUPERSCRIPT = 1] = "SUPERSCRIPT", e[e.SUBSCRIPT = 2] = "SUBSCRIPT";
})(Im || (Im = {}));
var Sm;
(function(e) {
  e[e.LTR = 0] = "LTR", e[e.RTL = 1] = "RTL";
})(Sm || (Sm = {}));
var ym;
(function(e) {
  e[e.AUTO_WIDTH = 0] = "AUTO_WIDTH", e[e.AUTO_HEIGHT = 1] = "AUTO_HEIGHT", e[e.FIXED = 2] = "FIXED";
})(ym || (ym = {}));
var Cm;
(function(e) {
  e[e.SOLID = 0] = "SOLID", e[e.IMAGE = 1] = "IMAGE", e[e.GRADIENT_LINEAR = 2] = "GRADIENT_LINEAR", e[e.GRADIENT_RADIAL = 3] = "GRADIENT_RADIAL", e[e.GRADIENT_ANGULAR = 4] = "GRADIENT_ANGULAR", e[e.GRADIENT_DIAMOND = 5] = "GRADIENT_DIAMOND";
})(Cm || (Cm = {}));
var Nm;
(function(e) {
  e[e.PASS_THROUGH = 0] = "PASS_THROUGH", e[e.NORMAL = 1] = "NORMAL", e[e.DARKEN = 2] = "DARKEN", e[e.MULTIPLY = 3] = "MULTIPLY", e[e.COLOR_BURN = 4] = "COLOR_BURN", e[e.LIGHTEN = 5] = "LIGHTEN", e[e.SCREEN = 6] = "SCREEN", e[e.COLOR_DODGE = 7] = "COLOR_DODGE", e[e.OVERLAY = 8] = "OVERLAY", e[e.SOFT_LIGHT = 9] = "SOFT_LIGHT", e[e.HARD_LIGHT = 10] = "HARD_LIGHT", e[e.DIFFERENCE = 11] = "DIFFERENCE", e[e.EXCLUSION = 12] = "EXCLUSION", e[e.HUE = 13] = "HUE", e[e.SATURATION = 14] = "SATURATION", e[e.COLOR = 15] = "COLOR", e[e.LUMINOSITY = 16] = "LUMINOSITY", e[e.DIVIDE = 17] = "DIVIDE", e[e.ADD = 18] = "ADD", e[e.SUBTRACT = 19] = "SUBTRACT", e[e.DISSOLVE = 20] = "DISSOLVE";
})(Nm || (Nm = {}));
var xm;
(function(e) {
  e[e.FILL = 0] = "FILL", e[e.STRETCH = 1] = "STRETCH", e[e.FIT = 2] = "FIT";
})(xm || (xm = {}));
var vm;
(function(e) {
  e[e.TOP_LEFT = 0] = "TOP_LEFT", e[e.TOP = 1] = "TOP", e[e.TOP_RIGHT = 2] = "TOP_RIGHT", e[e.LEFT = 3] = "LEFT", e[e.CENTER = 4] = "CENTER", e[e.RIGHT = 5] = "RIGHT", e[e.BOTTOM_LEFT = 6] = "BOTTOM_LEFT", e[e.BOTTOM = 7] = "BOTTOM", e[e.BOTTOM_RIGHT = 8] = "BOTTOM_RIGHT";
})(vm || (vm = {}));
var Rm;
(function(e) {
  e[e.NORMAL = 0] = "NORMAL", e[e.SPACE = 1] = "SPACE";
})(Rm || (Rm = {}));
var wm;
(function(e) {
  e[e.ZERO = 0] = "ZERO", e[e.NINETY = 1] = "NINETY", e[e.ONE_EIGHTY = 2] = "ONE_EIGHTY", e[e.TWO_SEVENTY = 3] = "TWO_SEVENTY";
})(wm || (wm = {}));
var Dm;
(function(e) {
  e[e.INSIDE = 0] = "INSIDE", e[e.CENTER = 1] = "CENTER", e[e.OUTSIDE = 2] = "OUTSIDE";
})(Dm || (Dm = {}));
var Lm;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.ROUND = 1] = "ROUND", e[e.LINE_ARROW = 2] = "LINE_ARROW", e[e.TRIANGLE_ARROW_SOLID = 3] = "TRIANGLE_ARROW_SOLID", e[e.TRIANGLE_ARROW_OUTLINE = 4] = "TRIANGLE_ARROW_OUTLINE", e[e.CIRCLE_SOLID = 5] = "CIRCLE_SOLID", e[e.CIRCLE_OUTLINE = 6] = "CIRCLE_OUTLINE", e[e.SQUARE_SOLID = 7] = "SQUARE_SOLID", e[e.SQUARE_OUTLINE = 8] = "SQUARE_OUTLINE";
})(Lm || (Lm = {}));
var Mm;
(function(e) {
  e[e.MITER = 0] = "MITER", e[e.CONCAVE = 1] = "CONCAVE", e[e.ROUND = 2] = "ROUND", e[e.BEVEL = 3] = "BEVEL", e[e.NONE = 4] = "NONE";
})(Mm || (Mm = {}));
var Pm;
(function(e) {
  e[e.STRAIGHT = 0] = "STRAIGHT", e[e.ROUND = 1] = "ROUND";
})(Pm || (Pm = {}));
var bm;
(function(e) {
  e[e.HORIZONTAL = 0] = "HORIZONTAL", e[e.VERTICAL = 1] = "VERTICAL";
})(bm || (bm = {}));
var Um;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.UNION = 1] = "UNION", e[e.SUBTRACT = 2] = "SUBTRACT", e[e.INTERSECT = 3] = "INTERSECT", e[e.DIFFERENCE = 4] = "DIFFERENCE";
})(Um || (Um = {}));
var Gm;
(function(e) {
  e[e.DOCUMENT = 0] = "DOCUMENT", e[e.DATA_STORE = 1] = "DATA_STORE", e[e.SELECTION = 2] = "SELECTION", e[e.WATCHER = 3] = "WATCHER", e[e.WORKSPACE = 4] = "WORKSPACE", e[e.ELEMENT = 5] = "ELEMENT", e[e.GEOMETRY = 6] = "GEOMETRY", e[e.ELEMENT_COMPONENT = 7] = "ELEMENT_COMPONENT", e[e.PROP_COMPONENT = 8] = "PROP_COMPONENT", e[e.LAYER = 9] = "LAYER", e[e.BASE = 10] = "BASE", e[e.COMPUTED_STYLE = 11] = "COMPUTED_STYLE", e[e.COMPUTED_LAYER = 12] = "COMPUTED_LAYER", e[e.IMAGE_RESOURCE = 13] = "IMAGE_RESOURCE", e[e.IMAGE_EXPORT = 14] = "IMAGE_EXPORT", e[e.IMAGE_PRESET = 15] = "IMAGE_PRESET", e[e.EFFECT = 16] = "EFFECT", e[e.COMPUTED_EFFECT = 17] = "COMPUTED_EFFECT";
})(Gm || (Gm = {}));
var Fm;
(function(e) {
  e[e.TEXT = 0] = "TEXT", e[e.PATH = 1] = "PATH", e[e.GROUP = 2] = "GROUP", e[e.CONTAINER = 3] = "CONTAINER", e[e.GEOMETRY_GROUP = 4] = "GEOMETRY_GROUP", e[e.SCREEN = 5] = "SCREEN", e[e.BOOLEAN_CONTAINER = 6] = "BOOLEAN_CONTAINER", e[e.MASK_CONTAINER = 7] = "MASK_CONTAINER", e[e.NORMAL_GROUP = 8] = "NORMAL_GROUP";
})(Fm || (Fm = {}));
var km;
(function(e) {
  e[e.ELEMENT = 0] = "ELEMENT", e[e.COMPONENT = 1] = "COMPONENT";
})(km || (km = {}));
var Bm;
(function(e) {
  e[e.CONTAINER = 3] = "CONTAINER", e[e.MASK_CONTAINER = 7] = "MASK_CONTAINER", e[e.BOOLEAN_CONTAINER = 6] = "BOOLEAN_CONTAINER", e[e.NORMAL_GROUP = 8] = "NORMAL_GROUP";
})(Bm || (Bm = {}));
var Vm;
(function(e) {
  e[e.RECTANGLE = 0] = "RECTANGLE", e[e.ELLIPSE = 1] = "ELLIPSE", e[e.POLYGON = 2] = "POLYGON", e[e.REGULAR_POLYGON = 3] = "REGULAR_POLYGON", e[e.STAR = 4] = "STAR", e[e.LINE = 5] = "LINE", e[e.TEXT = 6] = "TEXT";
})(Vm || (Vm = {}));
var Hm;
(function(e) {
  e[e.TRANSLATE = 0] = "TRANSLATE", e[e.DIMENSIONS = 1] = "DIMENSIONS", e[e.ROTATION = 2] = "ROTATION", e[e.OPACITY = 3] = "OPACITY", e[e.FILL = 4] = "FILL", e[e.STROKE = 5] = "STROKE", e[e.SHADOW = 6] = "SHADOW", e[e.INNER_SHADOW = 7] = "INNER_SHADOW", e[e.FONT = 8] = "FONT", e[e.TEXT_ALIGNMENT = 9] = "TEXT_ALIGNMENT", e[e.TEXT_DECORATION = 10] = "TEXT_DECORATION", e[e.TEXT_DIRECTION = 11] = "TEXT_DIRECTION", e[e.TEXT_SPACING = 12] = "TEXT_SPACING", e[e.SCALE = 13] = "SCALE", e[e.SKEW = 14] = "SKEW", e[e.ORIGIN = 15] = "ORIGIN", e[e.OVERFLOW = 16] = "OVERFLOW", e[e.BLUR_GAUSSIAN = 17] = "BLUR_GAUSSIAN", e[e.PAINT = 18] = "PAINT", e[e.IMAGE = 19] = "IMAGE", e[e.CORNER_RADIUS = 20] = "CORNER_RADIUS", e[e.CONTENT_ANCHOR = 21] = "CONTENT_ANCHOR", e[e.EFFECT = 22] = "EFFECT", e[e.REFERENCE_POINT = 23] = "REFERENCE_POINT";
})(Hm || (Hm = {}));
var Wm;
(function(e) {
  e[e.FILL = 4] = "FILL", e[e.STROKE = 5] = "STROKE", e[e.SHADOW = 6] = "SHADOW", e[e.INNER_SHADOW = 7] = "INNER_SHADOW";
})(Wm || (Wm = {}));
var Ym;
(function(e) {
  e[e.FONT = 8] = "FONT", e[e.TEXT_ALIGNMENT = 9] = "TEXT_ALIGNMENT", e[e.TEXT_DECORATION = 10] = "TEXT_DECORATION", e[e.TEXT_DIRECTION = 11] = "TEXT_DIRECTION";
})(Ym || (Ym = {}));
var Xm;
(function(e) {
  e[e.SCALE = 13] = "SCALE", e[e.SKEW = 14] = "SKEW", e[e.BLUR_GAUSSIAN = 17] = "BLUR_GAUSSIAN";
})(Xm || (Xm = {}));
var zm;
(function(e) {
  e[e.FILL = 4] = "FILL", e[e.STROKE = 5] = "STROKE", e[e.SHADOW = 6] = "SHADOW", e[e.INNER_SHADOW = 7] = "INNER_SHADOW";
})(zm || (zm = {}));
var Km;
(function(e) {
  e[e.VERTEX = 0] = "VERTEX", e[e.EDGE = 1] = "EDGE", e[e.CONTOUR = 2] = "CONTOUR";
})(Km || (Km = {}));
var Qm;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.ANGLE = 1] = "ANGLE", e[e.ANGLE_AND_LENGTH = 2] = "ANGLE_AND_LENGTH", e[e.INDEPENDENT = 3] = "INDEPENDENT";
})(Qm || (Qm = {}));
var Zm;
(function(e) {
  e[e.TRIM_PATH = 0] = "TRIM_PATH";
})(Zm || (Zm = {}));
var qm;
(function(e) {
  e[e.SIMULTANEOUSLY = 0] = "SIMULTANEOUSLY", e[e.INDIVIDUALLY = 1] = "INDIVIDUALLY";
})(qm || (qm = {}));
var jm;
(function(e) {
  e[e.ACTION = 0] = "ACTION", e[e.RESPONSE = 1] = "RESPONSE", e[e.TRIGGER = 2] = "TRIGGER", e[e.CONDITION = 3] = "CONDITION", e[e.ELEMENT_TRACK = 4] = "ELEMENT_TRACK", e[e.PROPERTY_TRACK = 5] = "PROPERTY_TRACK", e[e.KEY_FRAME = 6] = "KEY_FRAME", e[e.ANIMATION_PRESET = 7] = "ANIMATION_PRESET", e[e.TRANSFER = 8] = "TRANSFER";
})(jm || (jm = {}));
var Jm;
(function(e) {
  e[e.START = 0] = "START", e[e.DURING = 1] = "DURING", e[e.END = 2] = "END", e[e.START_AND_END = 3] = "START_AND_END";
})(Jm || (Jm = {}));
var $m;
(function(e) {
  e[e.LEFT = 0] = "LEFT", e[e.RIGHT = 1] = "RIGHT", e[e.MULTI = 2] = "MULTI";
})($m || ($m = {}));
var eO;
(function(e) {
  e.A = "A", e.B = "B", e.C = "C", e.D = "D", e.E = "E", e.F = "F", e.G = "G", e.H = "H", e.I = "I", e.J = "J", e.K = "K", e.L = "L", e.M = "M", e.N = "N", e.O = "O", e.P = "P", e.Q = "Q", e.R = "R", e.S = "S", e.T = "T", e.U = "U", e.V = "V", e.W = "W", e.X = "X", e.Y = "Y", e.Z = "Z", e.NUM_0 = "0", e.NUM_1 = "1", e.NUM_2 = "2", e.NUM_3 = "3", e.NUM_4 = "4", e.NUM_5 = "5", e.NUM_6 = "6", e.NUM_7 = "7", e.NUM_8 = "8", e.NUM_9 = "9";
})(eO || (eO = {}));
var tO;
(function(e) {
  e[e.CLICK = 0] = "CLICK", e[e.DOUBLE_CLICK = 1] = "DOUBLE_CLICK", e[e.DRAG = 2] = "DRAG", e[e.EDGE_SWIPE = 3] = "EDGE_SWIPE", e[e.FORCE_TAP = 4] = "FORCE_TAP", e[e.HOVER = 5] = "HOVER", e[e.MOUSE_ENTER = 6] = "MOUSE_ENTER", e[e.MOUSE_LEAVE = 7] = "MOUSE_LEAVE", e[e.MOUSE_UP = 8] = "MOUSE_UP", e[e.MOUSE_DOWN = 9] = "MOUSE_DOWN", e[e.KEY_PRESS = 10] = "KEY_PRESS", e[e.LOAD = 11] = "LOAD", e[e.LONG_PRESS = 12] = "LONG_PRESS", e[e.MANY_CLICK = 13] = "MANY_CLICK", e[e.MOUSE_MOVE = 14] = "MOUSE_MOVE", e[e.PINCH = 15] = "PINCH", e[e.PRESS = 16] = "PRESS", e[e.ROTATE = 17] = "ROTATE", e[e.SCROLL = 18] = "SCROLL", e[e.SWIPE = 19] = "SWIPE";
})(tO || (tO = {}));
var nO;
(function(e) {
  e[e.AND = 0] = "AND", e[e.OR = 1] = "OR";
})(nO || (nO = {}));
var sO;
(function(e) {
  e[e.NONE = 0] = "NONE";
})(sO || (sO = {}));
var iO;
(function(e) {
  e[e.EXPLICIT = 0] = "EXPLICIT", e[e.INITIAL = 1] = "INITIAL";
})(iO || (iO = {}));
var rO;
(function(e) {
  e.EXPLICIT = "EXPLICIT", e.INITIAL = "INITIAL", e.TWEEN = "TWEEN", e.NON_EDITABLE = "NON_EDITABLE";
})(rO || (rO = {}));
var oO;
(function(e) {
  e[e.ANY = 0] = "ANY", e[e.CLOCKWISE = 1] = "CLOCKWISE", e[e.COUNTERCLOCKWISE = 2] = "COUNTERCLOCKWISE", e[e.INWARD = 3] = "INWARD", e[e.OUTWARD = 4] = "OUTWARD", e[e.HORIZONTAL = 5] = "HORIZONTAL", e[e.VERTICAL = 6] = "VERTICAL", e[e.LEFT = 7] = "LEFT", e[e.RIGHT = 8] = "RIGHT", e[e.UP = 9] = "UP", e[e.DOWN = 10] = "DOWN", e[e.START = 11] = "START", e[e.END = 12] = "END";
})(oO || (oO = {}));
var aO;
(function(e) {
  e[e.LINEAR = 0] = "LINEAR", e[e.EASE = 1] = "EASE", e[e.EASE_IN = 2] = "EASE_IN", e[e.EASE_OUT = 3] = "EASE_OUT", e[e.EASE_IN_OUT = 4] = "EASE_IN_OUT", e[e.EASE_IN_SIN = 5] = "EASE_IN_SIN", e[e.EASE_OUT_SINE = 6] = "EASE_OUT_SINE", e[e.EASE_IN_OUT_SINE = 7] = "EASE_IN_OUT_SINE", e[e.EASE_IN_QUAD = 8] = "EASE_IN_QUAD", e[e.EASE_OUT_QUAD = 9] = "EASE_OUT_QUAD", e[e.EASE_IN_OUT_QUAD = 10] = "EASE_IN_OUT_QUAD", e[e.EASE_IN_CUBIC = 11] = "EASE_IN_CUBIC", e[e.EASE_OUT_CUBIC = 12] = "EASE_OUT_CUBIC", e[e.EASE_IN_OUT_CUBIC = 13] = "EASE_IN_OUT_CUBIC", e[e.EASE_IN_QUART = 14] = "EASE_IN_QUART", e[e.EASE_OUT_QUART = 15] = "EASE_OUT_QUART", e[e.EASE_IN_OUT_QUART = 16] = "EASE_IN_OUT_QUART", e[e.EASE_IN_QUINT = 17] = "EASE_IN_QUINT", e[e.EASE_OUT_QUINT = 18] = "EASE_OUT_QUINT", e[e.EASE_IN_OUT_QUINT = 19] = "EASE_IN_OUT_QUINT", e[e.EASE_IN_EXPO = 20] = "EASE_IN_EXPO", e[e.EASE_OUT_EXPO = 21] = "EASE_OUT_EXPO", e[e.EASE_IN_OUT_EXPO = 22] = "EASE_IN_OUT_EXPO", e[e.EASE_IN_CIRC = 23] = "EASE_IN_CIRC", e[e.EASE_OUT_CIRC = 24] = "EASE_OUT_CIRC", e[e.EASE_IN_OUT_CIRC = 25] = "EASE_IN_OUT_CIRC", e[e.EASE_IN_BACK = 26] = "EASE_IN_BACK", e[e.EASE_OUT_BACK = 27] = "EASE_OUT_BACK", e[e.EASE_IN_OUT_BACK = 28] = "EASE_IN_OUT_BACK", e[e.CUSTOM = 29] = "CUSTOM", e[e.STEP = 30] = "STEP", e[e.STEP_START = 31] = "STEP_START", e[e.STEP_MIDDLE = 32] = "STEP_MIDDLE", e[e.STEP_END = 33] = "STEP_END", e[e.STEP_CUSTOM = 34] = "STEP_CUSTOM", e[e.HOP_IN = 35] = "HOP_IN", e[e.HOP_OUT = 36] = "HOP_OUT", e[e.HOP_IN_OUT = 37] = "HOP_IN_OUT";
})(aO || (aO = {}));
var cO;
(function(e) {
  e[e.START = 0] = "START", e[e.END = 1] = "END";
})(cO || (cO = {}));
var lO;
(function(e) {
  e[e.FADE_IN = 0] = "FADE_IN", e[e.FADE_OUT = 1] = "FADE_OUT", e[e.MOVE_IN = 2] = "MOVE_IN", e[e.MOVE_OUT = 3] = "MOVE_OUT", e[e.SCALE_IN = 4] = "SCALE_IN", e[e.SCALE_OUT = 5] = "SCALE_OUT", e[e.SPIN_IN = 6] = "SPIN_IN", e[e.SPIN_OUT = 7] = "SPIN_OUT", e[e.TRIM_IN = 8] = "TRIM_IN", e[e.TRIM_OUT = 9] = "TRIM_OUT";
})(lO || (lO = {}));
var hO;
(function(e) {
  e.ELEMENT_LIST = "element_list", e.ACTION_LIST = "action_list";
})(hO || (hO = {}));
var uO;
(function(e) {
  e.EDITING = "EDITING", e.VIEWING = "VIEWING", e.INSPECTING = "INSPECTING", e.VERSIONING = "VERSIONING", e.PROTOTYPING = "PROTOTYPING";
})(uO || (uO = {}));
var dO;
(function(e) {
  e[e.SINGLE = 0] = "SINGLE", e[e.TABLE = 1] = "TABLE", e[e.SITEMAP = 2] = "SITEMAP";
})(dO || (dO = {}));
var fO;
(function(e) {
  e[e.ELEMENT = 0] = "ELEMENT", e[e.SHAPE = 1] = "SHAPE", e[e.TEXT = 2] = "TEXT", e[e.MOTION_PATH = 3] = "MOTION_PATH";
})(fO || (fO = {}));
var pO;
(function(e) {
  e[e.DESIGN = 0] = "DESIGN", e[e.ACTION = 1] = "ACTION";
})(pO || (pO = {}));
var C;
(function(e) {
  e.DESIGN_MODE = "DESIGN_MODE", e.ACTION_MODE = "ACTION_MODE", e.PROTOTYPE_MODE = "PROTOTYPE_MODE", e.INSPECT_MODE = "INSPECT_MODE", e.VERSION_MODE = "VERSION_MODE", e.VIEW_MODE = "VIEW_MODE", e.SELECTOR_MODE = "SELECTOR_MODE";
})(C || (C = {}));
var EO;
(function(e) {
  e.EDITING_STATE = "EDITING_STATE", e.VERSIONING_STATE = "VERSIONING_STATE";
})(EO || (EO = {}));
var gO;
(function(e) {
  e[e.SELECT = 0] = "SELECT", e[e.SCALE = 1] = "SCALE", e[e.HAND = 2] = "HAND", e[e.RECTANGLE = 3] = "RECTANGLE", e[e.ELLIPSE = 4] = "ELLIPSE", e[e.POLYGON = 5] = "POLYGON", e[e.STAR = 6] = "STAR", e[e.LINE = 7] = "LINE", e[e.ARROW = 8] = "ARROW", e[e.CONTAINER = 9] = "CONTAINER", e[e.PEN = 10] = "PEN", e[e.EYE_DROPPER = 11] = "EYE_DROPPER", e[e.COMMENT = 12] = "COMMENT", e[e.INSERT = 13] = "INSERT", e[e.PROTOTYPE = 14] = "PROTOTYPE", e[e.ADD_ACTION = 15] = "ADD_ACTION", e[e.TEXT = 16] = "TEXT";
})(gO || (gO = {}));
var _O;
(function(e) {
  e[e.SELECT = 0] = "SELECT", e[e.SCALE = 1] = "SCALE";
})(_O || (_O = {}));
var TO;
(function(e) {
  e[e.RECTANGLE = 3] = "RECTANGLE", e[e.ELLIPSE = 4] = "ELLIPSE", e[e.POLYGON = 5] = "POLYGON", e[e.STAR = 6] = "STAR", e[e.LINE = 7] = "LINE", e[e.ARROW = 8] = "ARROW", e[e.CONTAINER = 9] = "CONTAINER", e[e.PEN = 10] = "PEN", e[e.TEXT = 16] = "TEXT";
})(TO || (TO = {}));
var AO;
(function(e) {
  e[e.TOP = 0] = "TOP", e[e.MIDDLE = 1] = "MIDDLE", e[e.BOTTOM = 2] = "BOTTOM", e[e.LEFT = 3] = "LEFT", e[e.CENTER = 4] = "CENTER", e[e.RIGHT = 5] = "RIGHT";
})(AO || (AO = {}));
var mO;
(function(e) {
  e[e.HORIZONTAL = 0] = "HORIZONTAL", e[e.VERTICAL = 1] = "VERTICAL";
})(mO || (mO = {}));
var OO;
(function(e) {
  e[e.IN_PROGRESS = 0] = "IN_PROGRESS", e[e.COMPLETED = 1] = "COMPLETED", e[e.SKIPPED = 2] = "SKIPPED";
})(OO || (OO = {}));
var IO;
(function(e) {
  e[e.INITIAL = 0] = "INITIAL", e[e.WAITING = 1] = "WAITING", e[e.FINISHED = 2] = "FINISHED";
})(IO || (IO = {}));
var SO;
(function(e) {
  e[e.GIF = 0] = "GIF", e[e.MP4 = 1] = "MP4", e[e.LOTTIE = 2] = "LOTTIE", e[e.DOTLOTTIE = 3] = "DOTLOTTIE";
})(SO || (SO = {}));
var yO;
(function(e) {
  e[e.ULTRA = 0] = "ULTRA", e[e.HIGH = 1] = "HIGH", e[e.MEDIUM = 2] = "MEDIUM", e[e.LOW = 3] = "LOW";
})(yO || (yO = {}));
var CO;
(function(e) {
  e[e.IMPORT_LOTTIE_REMINDER_DIALOG_IN_ACTION = 0] = "IMPORT_LOTTIE_REMINDER_DIALOG_IN_ACTION", e[e.IMPORT_DOTLOTTIE_MULTIPLE_ANIMATIONS_DIALOG_IN_ACTION = 1] = "IMPORT_DOTLOTTIE_MULTIPLE_ANIMATIONS_DIALOG_IN_ACTION";
})(CO || (CO = {}));
var NO;
(function(e) {
  e[e.CONTENT = 0] = "CONTENT", e[e.POSITION = 1] = "POSITION";
})(NO || (NO = {}));
var xO;
(function(e) {
  e[e.STOP = 0] = "STOP", e[e.GRADIENT = 1] = "GRADIENT", e[e.HANDLE = 2] = "HANDLE", e[e.ASPECT_RATIO = 3] = "ASPECT_RATIO", e[e.REFERENCE = 4] = "REFERENCE";
})(xO || (xO = {}));
var vO;
(function(e) {
  e[e.BOTH = 0] = "BOTH", e[e.HORIZONTAL = 1] = "HORIZONTAL", e[e.VERTICAL = 2] = "VERTICAL";
})(vO || (vO = {}));
var RO;
(function(e) {
  e.GUEST = "GUEST", e.MEMBER = "MEMBER", e.ADMIN = "ADMIN", e.OWNER = "OWNER";
})(RO || (RO = {}));
var KE;
(function(e) {
  e.FROM_MESH_CHANGE = "FROM_MESH_CHANGE", e.FROM_PARENT_EDIT = "FROM_PARENT_EDIT", e.FROM_CHILDREN_CHANGE = "FROM_CHILDREN_CHANGE", e.FROM_ANIMATION = "FROM_ANIMATION", e.FROM_CHANGE_CONTAINER_TYPE = "FROM_CHANGE_CONTAINER_TYPE", e.FROM_DRAG_DUPLICATE = "FROM_DRAG_DUPLICATE", e.FROM_DATA_SYNC = "FROM_DATA_SYNC", e.FROM_INTERACTION_CONTINUOUSLY_CHANGE = "FROM_INTERACTION_CONTINUOUSLY_CHANGE", e.FROM_ELEMENT_CREATE = "FROM_ELEMENT_CREATE", e.SHOW_SCOPE_CHANGE_MODAL = "SHOW_SCOPE_CHANGE_MODAL", e.FROM_SYSTEM = "FROM_SYSTEM", e.FROM_TEXT_EDIT = "FROM_TEXT_EDIT";
})(KE || (KE = {}));
var wO;
(function(e) {
  e.USER_EDITING = "USER_EDITING", e.UNDO_REDO = "UNDO_REDO", e.ANIMATING = "ANIMATING", e.OTHER = "OTHER";
})(wO || (wO = {}));
var DO;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.UPDATE = 1] = "UPDATE", e[e.UPDATE_ALL = 2] = "UPDATE_ALL", e[e.UPDATE_NEED_BBOX_RECALC = 3] = "UPDATE_NEED_BBOX_RECALC", e[e.UPDATE_ALL_NEED_BBOX_RECALC = 4] = "UPDATE_ALL_NEED_BBOX_RECALC";
})(DO || (DO = {}));
var LO;
(function(e) {
  e.NONE = "NONE", e.ELEMENT = "ELEMENT", e.RESIZE_HANDLE = "RESIZE_HANDLE", e.ROTATE_HANDLE = "ROTATE_HANDLE", e.GRADIENT_STOP_HANDLE = "GRADIENT_STOP_HANDLE", e.GRADIENT_TRANSFORM_START_HANDLE = "GRADIENT_TRANSFORM_START_HANDLE", e.GRADIENT_TRANSFORM_END_HANDLE = "GRADIENT_TRANSFORM_END_HANDLE", e.GRADIENT_TRANSFORM_SHAPE_HANDLE = "GRADIENT_TRANSFORM_SHAPE_HANDLE", e.GRADIENT_TRANSFORM_REFERENCE_LINE = "GRADIENT_TRANSFORM_REFERENCE_LINE", e.SCROLLBAR = "SCROLLBAR", e.CURVE_CONTROL = "CURVE_CONTROL", e.VERTEX = "VERTEX", e.ENDPOINT = "ENDPOINT", e.EDGE = "EDGE", e.ORIGIN = "ORIGIN", e.MULTIPLE_SELECTION_BOUND = "MULTIPLE_SELECTION_BOUND", e.MOTION_POINT = "MOTION_POINT", e.MOTION_SEGMENT = "MOTION_SEGMENT", e.RULER = "RULER", e.GUIDELINE = "GUIDELINE";
})(LO || (LO = {}));
var MO;
(function(e) {
  e.ACTIVATE_ARROW_TOOL = "ACTIVATE_ARROW_TOOL", e.ACTIVATE_COMMENT_TOOL = "ACTIVATE_COMMENT_TOOL", e.ACTIVATE_CONTAINER_TOOL = "ACTIVATE_CONTAINER_TOOL", e.ACTIVATE_EDIT_GRADIENT = "ACTIVATE_EDIT_GRADIENT", e.ACTIVATE_ELLIPSE_TOOL = "ACTIVATE_ELLIPSE_TOOL", e.ACTIVATE_EXCLUDE_TOOL = "ACTIVATE_EXCLUDE_TOOL", e.ACTIVATE_EYE_DROPPER_TOOL = "ACTIVATE_EYE_DROPPER_TOOL", e.ACTIVATE_GRADIENT_HANDLES_MODE = "ACTIVATE_GRADIENT_HANDLES_MODE", e.ACTIVATE_HAND_TOOL = "ACTIVATE_HAND_TOOL", e.ACTIVATE_INTERSECT_TOOL = "ACTIVATE_INTERSECT_TOOL", e.ACTIVATE_LINE_TOOL = "ACTIVATE_LINE_TOOL", e.ACTIVATE_PAN = "ACTIVATE_PAN", e.ACTIVATE_PEN_TOOL = "ACTIVATE_PEN_TOOL", e.ACTIVATE_POLYGON_TOOL = "ACTIVATE_POLYGON_TOOL", e.ACTIVATE_RECTANGLE_TOOL = "ACTIVATE_RECTANGLE_TOOL", e.ACTIVATE_SCALE_TOOL = "ACTIVATE_SCALE_TOOL", e.ACTIVATE_SELECTOR_MODE = "ACTIVATE_SELECTOR_MODE", e.ACTIVATE_SELECT_TOOL = "ACTIVATE_SELECT_TOOL", e.ACTIVATE_SHAPE_MODE = "ACTIVATE_SHAPE_MODE", e.ACTIVATE_STAR_TOOL = "ACTIVATE_STAR_TOOL", e.ACTIVATE_SUBTRACT_TOOL = "ACTIVATE_SUBTRACT_TOOL", e.ACTIVATE_TEXT_EDIT_MODE = "ACTIVATE_TEXT_EDIT_MODE", e.ACTIVATE_TEXT_MODE = "ACTIVATE_TEXT_MODE", e.ACTIVATE_TEXT_TOOL = "ACTIVATE_TEXT_TOOL", e.ACTIVATE_UNION_TOOL = "ACTIVATE_UNION_TOOL", e.ADD_ACTION = "ADD_ACTION", e.ADD_LAYER = "ADD_LAYER", e.ADD_NEW_GRADIENT_STOP = "ADD_NEW_GRADIENT_STOP", e.ALIGN = "ALIGN", e.ALL = "*", e.APPEND_ELEMENT = "APPEND_ELEMENT", e.BOOLEAN_GROUP_ELEMENTS = "BOOLEAN_GROUP_ELEMENTS", e.BRING_TO_FRONT = "BRING_TO_FRONT", e.CANCEL_EXPORT_MEDIA = "CANCEL_EXPORT_MEDIA", e.CANCEL_SELECTOR_MODE = "CANCEL_SELECTOR_MODE", e.CHANGE_TEXT_CARET = "CHANGE_TEXT_CARET", e.CLOSE_MODAL = "CLOSE_MODAL", e.COMMENT_DEACTIVATE_PAN = "COMMENT_DEACTIVATE_PAN", e.CONFIRM_SELECTOR_MODE = "CONFIRM_SELECTOR_MODE", e.CONVERT_ELEMENT_TO_CONTAINER = "CONVERT_ELEMENT_TO_CONTAINER", e.CONVERT_ELEMENT_TO_GROUP = "CONVERT_ELEMENT_TO_GROUP", e.CONVERT_ELEMENT_TO_PATH = "CONVERT_ELEMENT_TO_PATH", e.CONVERT_SHAPE_TO_PATH = "CONVERT_SHAPE_TO_PATH", e.COPY = "COPY", e.CREATE_ELEMENT_W_DEFAULT_SIZE = "CREATE_ELEMENT_W_DEFAULT_SIZE", e.CUT = "CUT", e.DEACTIVATE_GRADIENT_HANDLES_MODE = "DEACTIVATE_GRADIENT_HANDLES_MODE", e.DEACTIVATE_PAN = "DEACTIVATE_PAN", e.DEACTIVATE_SELECTOR_MODE = "DEACTIVATE_SELECTOR_MODE", e.DEACTIVATE_SHAPE_MODE = "DEACTIVATE_SHAPE_MODE", e.DEACTIVATE_TEXT_EDIT_MODE = "DEACTIVATE_TEXT_EDIT_MODE", e.DEACTIVATE_TEXT_MODE = "DEACTIVATE_TEXT_MODE", e.DEACTIVATE_MOTION_PATH_MODE = "DEACTIVATE_MOTION_PATH_MODE", e.DECREASE_CORNER_RADIUS = "DECREASE_CORNER_RADIUS", e.DELETE_CELL = "DELETE_CELL", e.DELETE_ELEMENT = "DELETE_ELEMENT", e.DELETE_GRADIENT_STOP = "DELETE_GRADIENT_STOP", e.DELETE_GUIDELINES = "DELETE_GUIDELINES", e.DELETE_KEYFRAME = "DELETE_KEYFRAME", e.DELETE_LAYER = "DELETE_LAYER", e.DELETE_MOTION_POINT = "DELETE_MOTION_POINT", e.DELETE_TEXT = "DELETE_TEXT", e.DERECTLY_SELECT_GUIDE = "DERECTLY_SELECT_GUIDE", e.DESELECT_CELL = "DESELECT_CELL", e.DESELECT_ELEMENT = "DESELECT_ELEMENT", e.DESELECT_KEYFRAME = "DESELECT_KEYFRAME", e.DESELECT_MOTION_POINT = "DESELECT_MOTION_POINT", e.DIRECTLY_SELECT_GUIDE = "DIRECTLY_SELECT_GUIDE", e.DISTRIBUTE = "DISTRIBUTE", e.DOUBLE_LEFT_CLICK = "DOUBLE_LEFT_CLICK", e.DOWNLOAD_FILE = "DOWNLOAD_FILE", e.DRAG_END = "DRAG_END", e.DRAG_OVER = "DRAG_OVER", e.DROP_WITH_FILES = "DROP_WITH_FILES", e.DUPLICATE_CELL = "DUPLICATE_CELL", e.DUPLICATE_ELEMENT = "DUPLICATE_ELEMENT", e.DUPLICATE_KEYFRAME = "DUPLICATE_KEYFRAME", e.EDIT_NEXT_TEXT_ELEMENT = "EDIT_NEXT_TEXT_ELEMENT", e.EDIT_ORIGIN = "EDIT_ORIGIN", e.EDIT_PREVIOUS_TEXT_ELEMENT = "EDIT_PREVIOUS_TEXT_ELEMENT", e.EDIT_SELECTOR = "EDIT_SELECTOR", e.END_AREA_SELECT_CELL = "END_AREA_SELECT_CELL", e.END_AREA_SELECT_ELEMENT = "END_AREA_SELECT_ELEMENT", e.END_CREATE_ELEMENT = "END_CREATE_ELEMENT", e.END_CREATE_GUIDE = "END_CREATE_GUIDE", e.END_DRAG_CELL = "END_DRAG_CELL", e.END_DRAG_ELEMENT = "END_DRAG_ELEMENT", e.END_DRAG_GRADIENT_HANDLE = "END_DRAG_GRADIENT_HANDLE", e.END_DRAG_MOTION_POINT = "END_DRAG_MOTION_POINT", e.END_DRAG_MOTION_SEGMENT = "END_DRAG_MOTION_SEGMENT", e.END_DRAG_MULTI_ELEMENTS = "END_DRAG_MULTI_ELEMENTS", e.END_DRAG_ORIGIN = "END_DRAG_ORIGIN", e.END_DRAG_SCROLLBAR = "END_DRAG_SCROLLBAR", e.END_DRAW_PATH = "END_DRAW_PATH", e.END_DRAW_PATH_ON_EDGE = "END_DRAW_PATH_ON_EDGE", e.END_DRAW_PATH_ON_VERTEX = "END_DRAW_PATH_ON_VERTEX", e.END_EXPAND_TEXT_SELECTION = "END_EXPAND_TEXT_SELECTION", e.END_LEFT_CLICK_MOVE = "END_LEFT_CLICK_MOVE", e.END_MOVE_GUIDE = "END_MOVE_GUIDE", e.END_MOVE_GUIDE_WO_SELECT = "END_MOVE_GUIDE_WO_SELECT", e.END_MOVE_SCROLLBAR = "END_MOVE_SCROLLBAR", e.END_MOVE_TEXT_CARET = "END_MOVE_TEXT_CARET", e.END_PANNING = "END_PANNING", e.END_RESIZE_ELEMENT = "END_RESIZE_ELEMENT", e.END_RIGHT_CLICK_MOVE = "END_RIGHT_CLICK_MOVE", e.END_ROTATE_ELEMENT = "END_ROTATE_ELEMENT", e.END_SCALE_ELEMENT = "END_SCALE_ELEMENT", e.END_ZOOM_TO_SELECTION = "END_ZOOM_TO_SELECTION", e.ENTER_PROTOTYPE_MODE = "ENTER_PROTOTYPE_MODE", e.ENTER_PROTOTYPE_MODE_FULL_SCREEN = "ENTER_PROTOTYPE_MODE_FULL_SCREEN", e.EXIT_EDITOR = "EXIT_EDITOR", e.EXIT_PROTOTYPE_MODE = "EXIT_PROTOTYPE_MODE", e.EXPAND_TEXT_SELECTION = "EXPAND_TEXT_SELECTION", e.EXPAND_TEXT_SELECTION_KEY = "EXPAND_TEXT_SELECTION_KEY", e.EXPAND_TEXT_SELECTION_TO_LINE_START = "EXPAND_TEXT_SELECTION_TO_LINE_START", e.EXPAND_TEXT_SELECTION_TO_NEXT_WORD_KEY = "EXPAND_TEXT_SELECTION_TO_NEXT_WORD_KEY", e.EXPAND_TEXT_SELECTION_TO_TEXT_START = "EXPAND_TEXT_SELECTION_TO_TEXT_START", e.EXPORT_FINISH = "EXPORT_FINISH", e.EXPORT_MEDIA = "EXPORT_MEDIA", e.EXPORT_PROGRESS = "EXPORT_PROGRESS", e.GROUP_ELEMENTS = "GROUP_ELEMENTS", e.HOVER_BOX_HANDLE = "HOVER_BOX_HANDLE", e.HOVER_CELL = "HOVER_CELL", e.HOVER_CELL_WITH_SELECTION = "HOVER_CELL_WITH_SELECTION", e.HOVER_CREATE_PATH = "HOVER_CREATE_PATH", e.HOVER_DEEP_ELEMENT = "HOVER_DEEP_ELEMENT", e.HOVER_ELEMENT = "HOVER_ELEMENT", e.HOVER_GRADIENT_HANDLE = "HOVER_GRADIENT_HANDLE", e.HOVER_GUIDELINE = "HOVER_GUIDELINE", e.HOVER_MOTION_POINT = "HOVER_MOTION_POINT", e.HOVER_MOTION_SEGMENT = "HOVER_MOTION_SEGMENT", e.HOVER_ORIGIN = "HOVER_ORIGIN", e.HOVER_RULER = "HOVER_RULER", e.HOVER_SCROLLBAR = "HOVER_SCROLLBAR", e.INCREASE_CORNER_RADIUS = "INCREASE_CORNER_RADIUS", e.INSERT_ELEMENT = "INSERT_ELEMENT", e.INSERT_IMAGE = "INSERT_IMAGE", e.INSERT_SVG = "INSERT_SVG", e.LEAVE_VERSION_PREVIEW = "LEAVE_VERSION_PREVIEW", e.MAC_ZOOM_TO_POINTER = "MAC_ZOOM_TO_POINTER", e.MASK_GROUP_ELEMENTS = "MASK_GROUP_ELEMENTS", e.MOBILE_PINCH_ZOOM_TO_POINTER = "MOBILE_PINCH_ZOOM_TO_POINTER", e.MOBILE_TOUCH_PAN = "MOBILE_TOUCH_PAN", e.MOVE_BACKWARD = "MOVE_BACKWARD", e.MOVE_CELL_SELECTION_KEY = "MOVE_CELL_SELECTION_KEY", e.MOVE_ELEMENT_SELECTION_KEY = "MOVE_ELEMENT_SELECTION_KEY", e.MOVE_FORWARD = "MOVE_FORWARD", e.MOVE_GRADIENT_HANDLE_KEY = "MOVE_GRADIENT_HANDLE_KEY", e.MOVE_MOTION_POINTS_SELECTION_KEY = "MOVE_MOTION_POINTS_SELECTION_KEY", e.MOVE_TEXT_CARET_KEY = "MOVE_TEXT_CARET_KEY", e.MOVE_TEXT_CARET_TO_LINE_START = "MOVE_TEXT_CARET_TO_LINE_START", e.MOVE_TEXT_CARET_TO_NEXT_WORD_KEY = "MOVE_TEXT_CARET_TO_NEXT_WORD_KEY", e.MOVE_TEXT_CARET_TO_TEXT_START = "MOVE_TEXT_CARET_TO_TEXT_START", e.MOVE_VIEWPORT_KEY = "MOVE_VIEWPORT_KEY", e.MOVE_VIEWPORT_WHEEL = "MOVE_VIEWPORT_WHEEL", e.OPEN_CANVAS_CONTEXT_MENU = "OPEN_CANVAS_CONTEXT_MENU", e.OPEN_ELEMENT_CONTEXT_MENU = "OPEN_ELEMENT_CONTEXT_MENU", e.PASTE = "PASTE", e.PASTE_WITH_FILES = "PASTE_WITH_FILES", e.PAUSE_ANIMATION = "PAUSE_ANIMATION", e.PLAY_ANIMATION = "PLAY_ANIMATION", e.REDO = "REDO", e.RENAME_ELEMENT = "RENAME_ELEMENT", e.RESET_ANIMATION = "RESET_ANIMATION", e.RESET_GRADIENT_STOP_ACTIVE_INDEX = "RESET_GRADIENT_STOP_ACTIVE_INDEX", e.RESTART_PROTOTYPE = "RESTART_PROTOTYPE", e.RESUME_TEXT_EDIT_MODE = "RESUME_TEXT_EDIT_MODE", e.SELECT_ALL_CELLS = "SELECT_ALL_CELLS", e.SELECT_ALL_ELEMENTS = "SELECT_ALL_ELEMENTS", e.SELECT_ALL_MOTION_POINTS = "SELECT_ALL_MOTION_POINTS", e.SELECT_ALL_TEXT = "SELECT_ALL_TEXT", e.SELECT_CELL = "SELECT_CELL", e.SELECT_CHILD_ELEMENT = "SELECT_CHILD_ELEMENT", e.SELECT_ELEMENT = "SELECT_ELEMENT", e.SELECT_FIRST_ELEMENT = "SELECT_FIRST_ELEMENT", e.SELECT_GRADIENT_HANDLE = "SELECT_GRADIENT_HANDLE", e.SELECT_MOTION_POINT = "SELECT_MOTION_POINT", e.SELECT_NEXT_ELEMENT = "SELECT_NEXT_ELEMENT", e.SELECT_PARENT_ELEMENT = "SELECT_PARENT_ELEMENT", e.SELECT_PREVIOUS_ELEMENT = "SELECT_PREVIOUS_ELEMENT", e.SEND_TO_BACK = "SEND_TO_BACK", e.SET_CURSOR_OVERLAY = "SET_CURSOR_OVERLAY", e.SET_LOCK_GUIDES = "SET_LOCK_GUIDES", e.SHOW_CONFIRMATION = "SHOW_CONFIRMATION", e.SHOW_NOTIFICATION = "SHOW_NOTIFICATION", e.START_AREA_SELECT_CELL = "START_AREA_SELECT_CELL", e.START_AREA_SELECT_ELEMENT = "START_AREA_SELECT_ELEMENT", e.START_CREATE_ELEMENT = "START_CREATE_ELEMENT", e.START_CREATE_GUIDE = "START_CREATE_GUIDE", e.START_DRAG_CELL = "START_DRAG_CELL", e.START_DRAG_ELEMENT = "START_DRAG_ELEMENT", e.START_DRAG_GRADIENT_HANDLE = "START_DRAG_GRADIENT_HANDLE", e.START_DRAG_MOTION_POINT = "START_DRAG_MOTION_POINT", e.START_DRAG_MOTION_SEGMENT = "START_DRAG_MOTION_SEGMENT", e.START_DRAG_MULTI_ELEMENTS = "START_DRAG_MULTI_ELEMENTS", e.START_DRAG_ORIGIN = "START_DRAG_ORIGIN", e.START_DRAG_SCROLLBAR = "START_DRAG_SCROLLBAR", e.START_DRAW_PATH = "START_DRAW_PATH", e.START_DRAW_PATH_ON_EDGE = "START_DRAW_PATH_ON_EDGE", e.START_DRAW_PATH_ON_VERTEX = "START_DRAW_PATH_ON_VERTEX", e.START_EXPAND_TEXT_SELECTION = "START_EXPAND_TEXT_SELECTION", e.START_LEFT_CLICK_MOVE = "START_LEFT_CLICK_MOVE", e.START_MOVE_GUIDE = "START_MOVE_GUIDE", e.START_MOVE_GUIDE_WO_SELECT = "START_MOVE_GUIDE_WO_SELECT", e.START_MOVE_SCROLLBAR = "START_MOVE_SCROLLBAR", e.START_MOVE_TEXT_CARET = "START_MOVE_TEXT_CARET", e.START_PANNING = "START_PANNING", e.START_RESIZE_ELEMENT = "START_RESIZE_ELEMENT", e.START_RIGHT_CLICK_MOVE = "START_RIGHT_CLICK_MOVE", e.START_ROTATE_ELEMENT = "START_ROTATE_ELEMENT", e.START_SCALE_ELEMENT = "START_SCALE_ELEMENT", e.START_ZOOM_TO_SELECTION = "START_ZOOM_TO_SELECTION", e.STOP_ANIMATION = "STOP_ANIMATION", e.SWITCH_BEND_TOOL = "SWITCH_BEND_TOOL", e.SWITCH_DOCUMENT_MODE = "SWITCH_DOCUMENT_MODE", e.SWITCH_MODE = "SWITCH_MODE", e.SWITCH_TEXT_ELEMENT = "SWITCH_TEXT_ELEMENT", e.SWITCH_VIEW_MODE = "SWITCH_VIEW_MODE", e.TEXT_INSERT_NEW_LINE = "TEXT_INSERT_NEW_LINE", e.TOGGLE_ACTION_PANEL = "TOGGLE_ACTION_PANEL", e.TOGGLE_CELL_SELECTION = "TOGGLE_CELL_SELECTION", e.TOGGLE_COMMENT_VISIBILITY = "TOGGLE_COMMENT_VISIBILITY", e.TOGGLE_EXPAND = "TOGGLE_EXPAND", e.TOGGLE_INSPECTING = "TOGGLE_INSPECTING", e.TOGGLE_INTERFACE = "TOGGLE_INTERFACE", e.TOGGLE_LOCK = "TOGGLE_LOCK", e.TOGGLE_ORIGIN = "TOGGLE_ORIGIN", e.TOGGLE_PRESENCE = "TOGGLE_PRESENCE", e.TOGGLE_RULER = "TOGGLE_RULER", e.TOGGLE_SNAP_TO_OBJECT = "TOGGLE_SNAP_TO_OBJECT", e.TOGGLE_SNAP_TO_PIXEL_GRID = "TOGGLE_SNAP_TO_PIXEL_GRID", e.TOGGLE_VISIBLE = "TOGGLE_VISIBLE", e.TRACKPAD_ZOOM_TO_POINTER = "TRACKPAD_ZOOM_TO_POINTER", e.UNDO = "UNDO", e.UNGROUP_ELEMENTS = "UNGROUP_ELEMENTS", e.UPDATE_AREA_SELECT_CELL = "UPDATE_AREA_SELECT_CELL", e.UPDATE_AREA_SELECT_ELEMENT = "UPDATE_AREA_SELECT_ELEMENT", e.UPDATE_CREATE_ELEMENT = "UPDATE_CREATE_ELEMENT", e.UPDATE_CREATE_GUIDE = "UPDATE_CREATE_GUIDE", e.UPDATE_DRAG_CELL = "UPDATE_DRAG_CELL", e.UPDATE_DRAG_ELEMENT = "UPDATE_DRAG_ELEMENT", e.UPDATE_DRAG_GRADIENT_HANDLE = "UPDATE_DRAG_GRADIENT_HANDLE", e.UPDATE_DRAG_MOTION_POINT = "UPDATE_DRAG_MOTION_POINT", e.UPDATE_DRAG_MOTION_SEGMENT = "UPDATE_DRAG_MOTION_SEGMENT", e.UPDATE_DRAG_MULTI_ELEMENTS = "UPDATE_DRAG_MULTI_ELEMENTS", e.UPDATE_DRAG_ORIGIN = "UPDATE_DRAG_ORIGIN", e.UPDATE_DRAG_SCROLLBAR = "UPDATE_DRAG_SCROLLBAR", e.UPDATE_DRAW_PATH = "UPDATE_DRAW_PATH", e.UPDATE_DRAW_PATH_ON_EDGE = "UPDATE_DRAW_PATH_ON_EDGE", e.UPDATE_DRAW_PATH_ON_VERTEX = "UPDATE_DRAW_PATH_ON_VERTEX", e.UPDATE_EXPAND_TEXT_SELECTION = "UPDATE_EXPAND_TEXT_SELECTION", e.UPDATE_LEFT_CLICK_MOVE = "UPDATE_LEFT_CLICK_MOVE", e.UPDATE_MOVE_GUIDE = "UPDATE_MOVE_GUIDE", e.UPDATE_MOVE_GUIDE_WO_SELECT = "UPDATE_MOVE_GUIDE_WO_SELECT", e.UPDATE_MOVE_SCROLLBAR = "UPDATE_MOVE_SCROLLBAR", e.UPDATE_MOVE_TEXT_CARET = "UPDATE_MOVE_TEXT_CARET", e.UPDATE_PANNING = "UPDATE_PANNING", e.UPDATE_RESIZE_ELEMENT = "UPDATE_RESIZE_ELEMENT", e.UPDATE_RIGHT_CLICK_MOVE = "UPDATE_RIGHT_CLICK_MOVE", e.UPDATE_ROTATE_ELEMENT = "UPDATE_ROTATE_ELEMENT", e.UPDATE_SCALE_ELEMENT = "UPDATE_SCALE_ELEMENT", e.UPDATE_ZOOM_TO_SELECTION = "UPDATE_ZOOM_TO_SELECTION", e.WHEEL_PAN_VIEWPORT = "WHEEL_PAN_VIEWPORT", e.WHEEL_ZOOM_TO_POINTER = "WHEEL_ZOOM_TO_POINTER", e.ZOOM_CENTER_SELECTION = "ZOOM_CENTER_SELECTION", e.ZOOM_FIT_CONTENT = "ZOOM_FIT_CONTENT", e.ZOOM_FIT_HEIGHT = "ZOOM_FIT_HEIGHT", e.ZOOM_FIT_SELECTION = "ZOOM_FIT_SELECTION", e.ZOOM_FIT_WIDTH = "ZOOM_FIT_WIDTH", e.ZOOM_IN = "ZOOM_IN", e.ZOOM_OUT = "ZOOM_OUT", e.ZOOM_RESET = "ZOOM_RESET", e.ZOOM_TO_POINTER = "ZOOM_TO_POINTER", e.ZOOM_TO_VALUE = "ZOOM_TO_VALUE";
})(MO || (MO = {}));
var PO;
(function(e) {
  e.NONE = "NONE", e.SCREEN = "SCREEN", e.CONTAINER = "CONTAINER", e.TEXT = "TEXT", e.RECTANGLE = "RECTANGLE", e.ELLIPSE = "ELLIPSE", e.POLYGON = "POLYGON", e.REGULAR_POLYGON = "REGULAR_POLYGON", e.STAR = "STAR", e.LINE = "LINE", e.MULTIPLE = "MULTIPLE";
})(PO || (PO = {}));
class md extends Float32Array {
  /**
   * Creates new Vector4 from 4 number components or copies values from a single vec4-like object
   * @param  {number | Vector4 | vec4 | object} x  x component or vec4-like object
   * @param  {number} [y]  y component
   * @param  {number} [z]  z component
   * @param  {number} [w]  w component
   */
  constructor(n, s, i, r) {
    super(4), typeof n == "number" && typeof s == "number" && typeof i == "number" && typeof r == "number" ? um(this, n, s, i, r) : this.copy(n);
  }
  /**
   * Copies values from the vec4-like object
   * @param  {Vector4 | vec4 | object} val
   */
  copy(n) {
    if (Vn(n))
      return;
    let s = qt(n[0]) ? n[0] : n.x;
    Vn(s) && (s = n.r);
    let i = qt(n[1]) ? n[1] : n.y;
    Vn(i) && (i = n.g);
    let r = qt(n[2]) ? n[2] : n.z;
    Vn(r) && (r = qt(n.b) ? n.b : n.width);
    let o = qt(n[3]) ? n[3] : n.w;
    Vn(o) && (o = qt(n.a) ? n.a : n.height), Vi(s) && Vi(i) && Vi(r) && Vi(o) && um(this, s, i, r, o);
  }
  /**
   * Checks if this Vector4 is equal (has same corresponding component values) to anothe vec4-like object
   * @param {Vector4 | vec4 | object} val     vec4-like object
   * @param {number} epsilon                  precision; default is 0.0001
   * @returns {boolean}                        true if vectors are equal; false othewise
   */
  eq(n, s = Yc) {
    if (Vn(n))
      return !1;
    let i = qt(n[0]) ? n[0] : n.x;
    Vn(i) && (i = n.r);
    let r = qt(n[1]) ? n[1] : n.y;
    Vn(r) && (r = n.g);
    let o = qt(n[2]) ? n[2] : n.z;
    Vn(o) && (o = qt(n.b) ? n.b : n.width);
    let a = qt(n[3]) ? n[3] : n.w;
    return Vn(a) && (a = qt(n.a) ? n.a : n.height), pb(this, [i, r, o, a], s);
  }
  get x() {
    return this[0];
  }
  set x(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to x component of Vector4");
    this[0] = n;
  }
  get y() {
    return this[1];
  }
  set y(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to y component of Vector4");
    this[1] = n;
  }
  get z() {
    return this[2];
  }
  set z(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to z component of Vector4");
    this[2] = n;
  }
  get w() {
    return this[3];
  }
  set w(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to w component of Vector4");
    this[3] = n;
  }
  get r() {
    return this[0];
  }
  set r(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to r component of Vector4");
    this[0] = n;
  }
  get g() {
    return this[1];
  }
  set g(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to g component of Vector4");
    this[1] = n;
  }
  get b() {
    return this[2];
  }
  set b(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to b component of Vector4");
    this[2] = n;
  }
  get a() {
    return this[3];
  }
  set a(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to a component of Vector4");
    this[3] = n;
  }
  get width() {
    return this[2];
  }
  set width(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to width component of Vector4");
    this[2] = n;
  }
  get height() {
    return this[3];
  }
  set height(n) {
    if (isNaN(n))
      throw new Error("Trying to assign NaN to height component of Vector4");
    this[3] = n;
  }
}
md.ZERO = new md(0, 0, 0, 0);
md.ONE = new md(1, 1, 1, 1);
Ad.PROPERTY + "", Ad.ENTITY + "";
const _b = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let Tb = (e = 21) => {
  let n = "", s = crypto.getRandomValues(new Uint8Array(e |= 0));
  for (; e--; )
    n += _b[s[e] & 63];
  return n;
};
const Sa = "default", bO = 0, QE = "-", Ab = [
  "el",
  // Element
  "bs",
  // Base
  "pc",
  // Property Component
  "im",
  // Interaction Manager component
  "ly",
  // Layer Component
  "ms",
  // Mesh component
  "tm",
  // Transition Manager component
  "ei"
  // Element Interaction
], ZE = (e, n, s) => {
  if (e === Sa)
    return `${n}`;
  const i = [];
  return e && i.push(e), i.push(n), s && i.push(s), i.join(QE);
}, mb = () => {
  const e = Ab.reduce((n, s) => (n[s] = ZE(s, bO), n), {});
  return e[Sa] = `${bO}`, e;
};
class Ob {
  constructor() {
    this._counter = mb(), this.suffixKey = Tb(4);
  }
  getCurrentCount(n) {
    const s = this._getPrefixKey(n);
    return this._getNumber(s);
  }
  getIdBy(n) {
    const s = this._getPrefixKey(n);
    return this._counter[s];
  }
  create(n) {
    const s = this._getPrefixKey(n), i = this._getNumber(s);
    return this._counter[s] = ZE(s, i + 1, this.suffixKey), this._counter[s];
  }
  load(n, s) {
    const i = this._getPrefixKey(s), r = this._getNumber(i), o = this._getNumber(i, n), a = Math.max(r, o);
    this._counter[i] = ZE(i, a);
  }
  _getPrefixKey(n) {
    return this._counter[n] ? n : Sa;
  }
  _getNumber(n, s) {
    if (s && !this.isInCounter(s, n))
      return parseInt(this._counter[Sa]);
    const i = this._getPrefixKey(n), r = s || this._counter[i], o = isNaN(Number(r)) ? this._counter[Sa] : r, a = i === Sa ? o : r.split(QE)[1];
    return parseInt(a);
  }
  isInCounter(n, s) {
    if (!n || typeof n != "string" && typeof n != "number")
      return !1;
    let i = n.toString();
    typeof n == "number" && (i = `${n}`);
    const r = this._getPrefixKey(s);
    let o = i;
    if (r !== Sa) {
      const a = i.split(QE);
      if (a.length < 2 || a[0] !== r)
        return !1;
      o = a[1];
    }
    return !isNaN(Number(o));
  }
}
new Ob();
new Jo();
class Ha extends Float32Array {
  /**
   * Creates new Matrix2D from from 6 number components or copies values from a single mat2d-like object
   * @param  {number | Matrix2D | mat2d | object } a     a component or mat2d-like object
   * @param  {number} b   b component
   * @param  {number} c   c component
   * @param  {number} d   d component
   * @param  {number} tx  tx component
   * @param  {number} ty  ty component
   */
  constructor(n, s, i, r, o, a) {
    super(6), typeof n == "number" && typeof s == "number" && typeof i == "number" && typeof r == "number" && typeof o == "number" && typeof a == "number" ? (this[0] = n, this[1] = s, this[2] = i, this[3] = r, this[4] = o, this[5] = a) : n ? this.copy(n) : (this[0] = 1, this[3] = 1);
  }
  /**
   * Copies values from an array
   * @param  {number[]} array
   */
  fromArray(n) {
    Vn(n) || hm(this, ...n);
  }
  clone() {
    return new Ha(...this);
  }
  /**
   * Copies values from the mat2d-like object
   * @param  {Matrix2D | mat2d | object} val
   * @returns {Matrix2D} returns itself
   */
  copy(n) {
    if (Vn(n))
      return;
    const s = qt(n[0]) ? n[0] : n.a, i = qt(n[1]) ? n[1] : n.b, r = qt(n[2]) ? n[2] : n.c, o = qt(n[3]) ? n[3] : n.d, a = qt(n[4]) ? n[4] : n.tx, c = qt(n[5]) ? n[5] : n.ty;
    return Vi(s) && Vi(i) && Vi(r) && Vi(o) && Vi(a) && Vi(c) && hm(this, s, i, r, o, a, c), this;
  }
  /**
   * Checks if this Matrix2D is equal (has same corresponding component values) to another mat2d-like object
   * @param {Matrix2D | mat2d | object} val     mat2d-like object
   * @param {number} epsilon                    precision; default is 0.0001
   * @returns {boolean}                        true if vectors are equal; false othewise
   */
  eq(n, s = Yc) {
    if (Vn(n))
      return !1;
    const i = [
      qt(n[0]) ? n[0] : n.a,
      qt(n[1]) ? n[1] : n.b,
      qt(n[2]) ? n[2] : n.c,
      qt(n[3]) ? n[3] : n.d,
      qt(n[4]) ? n[4] : n.tx,
      qt(n[5]) ? n[5] : n.ty
    ];
    return Eb(this, i, s);
  }
  /**
   * Creates new basis transform matrix (leaving out translation)
   * @returns {Matrix2D}   new Matrix2D
   */
  basis() {
    return gb(new Ha(), this);
  }
  get a() {
    return this[0];
  }
  set a(n) {
    this[0] = n;
  }
  get b() {
    return this[1];
  }
  set b(n) {
    this[1] = n;
  }
  get c() {
    return this[2];
  }
  set c(n) {
    this[2] = n;
  }
  get d() {
    return this[3];
  }
  set d(n) {
    this[3] = n;
  }
  get tx() {
    return this[4];
  }
  set tx(n) {
    this[4] = n;
  }
  get ty() {
    return this[5];
  }
  set ty(n) {
    this[5] = n;
  }
  save() {
    return [
      this[0],
      this[1],
      this[2],
      this[3],
      this[4],
      this[5]
    ];
  }
}
Ha.IDENTITY = new Ha();
Ha.ZERO = new Ha(0, 0, 0, 0, 0, 0);
new Jo();
new Jo(), new Jo();
KE.FROM_DRAG_DUPLICATE;
const UO = 1e-5, q1 = 1e-8;
function Pt(e = 0, n = 0) {
  this.x = e, this.y = n, this._array = null;
}
Pt.isOrthogonal = (e, n, s, i) => Math.abs(e * s + n * i) <= Math.sqrt((e * e + n * n) * (s * s + i * i)) * q1;
Pt.isCollinear = (e, n, s, i) => (
  // NOTE: We use normalized vectors so that the epsilon comparison is
  // reliable. We could instead scale the epsilon based on the vector
  // length. But instead of normalizing the vectors before calculating
  // the cross product, we can scale the epsilon accordingly.
  Math.abs(e * i - n * s) <= Math.sqrt((e * e + n * n) * (s * s + i * i)) * q1
);
Pt.getThirds = function(e, n) {
  const s = n.clone().subtract(e);
  return {
    oneThird: e.clone().add(s.clone().scale(1 / 3)),
    twoThirds: e.clone().add(s.clone().scale(2 / 3))
  };
};
Pt.prototype = {
  constructor: Pt,
  get width() {
    return this.x;
  },
  set width(e) {
    this.x = e;
  },
  /**
   * @param {number} value
   */
  set_width(e) {
    this.x = e;
  },
  get height() {
    return this.y;
  },
  set height(e) {
    this.y = e;
  },
  /**
   * @param {number} value
   */
  set_height(e) {
    this.y = e;
  },
  /**
   * @param {number} value
   */
  set_x(e) {
    this.x = e;
  },
  /**
   * @param {number} value
   */
  set_y(e) {
    this.y = e;
  },
  /**
   * @param {[number, number]} [out]
   * @returns {[number, number]}
   */
  as_array(e) {
    if (!e && !this._array)
      return this._array = [this.x, this.y], this._array;
    const n = e || this._array;
    return n[0] = this.x, n[1] = this.y, n;
  },
  /**
   * @param {number[]} arr
   * @returns {this}
   */
  fromArray(e) {
    return this.x = e[0], this.y = e[1], this;
  },
  /**
   * Sets the point to a new x and y position.
   * If y is omitted, both x and y will be set to x.
   *
   * @param {number} [x] - position of the point on the x axis
   * @param {number} [y] - position of the point on the y axis
   * @returns {this}
   */
  set(e = 0, n = 0) {
    return this.x = e, this.y = n, this;
  },
  /**
   * Copy value from other vector
   *
   * @param {Vector2Like} p_b
   * @returns {this}
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  },
  /**
   * @param {Vector2Like} p_b
   * @param {number} t
   * @returns {this}
   */
  mix_with(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this;
  },
  /**
   * Returns new Vector2 with same value.
   * @returns {Vector2}
   */
  clone() {
    return new Pt(this.x, this.y);
  },
  /**
   * Returns new Vector2 but normalized.
   * @returns {Vector2}
   */
  normalized() {
    return this.clone().normalize();
  },
  /**
   * Returns new Vector2 but clamped.
   * @param {number} p_length
   * @returns {Vector2}
   */
  clamped(e) {
    const n = this.length(), s = this.clone();
    return n > 0 && e < n && s.scale(e / n), s;
  },
  /**
   * Returns new Vector2 but rotated.
   *
   * @param {number} p_rotation
   * @returns {Vector2}
   */
  rotated(e) {
    return this.clone().rotate(e);
  },
  /**
   * Whether this equals to another point
   * @param {Vector2Like} p_b
   * @returns {boolean}
   */
  equals(e) {
    const n = this.x, s = this.y, i = e.x, r = e.y;
    return Math.abs(n - i) <= UO * Math.max(1, Math.abs(n), Math.abs(i)) && Math.abs(s - r) <= UO * Math.max(1, Math.abs(s), Math.abs(r));
  },
  /**
   * Whether this equals to another point(precisely)
   * @param {Vector2Like} p_b
   * @returns {boolean}
   */
  exact_equals(e) {
    return this.x === e.x && this.y === e.y;
  },
  /**
   * Add the vector by another vector or number.
   * @param {number | Vector2Like} x
   * @param {number} [y]
   * @returns {this}
   */
  add(e, n) {
    return n === void 0 ? (this.x += e.x, this.y += e.y) : (this.x += e, this.y += n), this;
  },
  /**
   * Subtract the vector by another vector or number.
   * @param {number | Vector2Like} x
   * @param {number} [y]
   * @returns {this}
   */
  subtract(e, n) {
    return n === void 0 ? (this.x -= e.x, this.y -= e.y) : (this.x -= e, this.y -= n), this;
  },
  /**
   * Subtract the vector by another vector or number.
   * @param {number | Vector2Like} x
   * @param {number} [y]
   * @returns {this}
   */
  sub(e, n) {
    return n === void 0 ? (this.x -= e.x, this.y -= e.y) : (this.x -= e, this.y -= n), this;
  },
  /**
   * Multiply the vector by another vector or number.
   * @param {number | Vector2Like} x
   * @param {number} [y]
   * @returns {this}
   */
  multiply(e, n) {
    return n === void 0 ? (this.x *= e.x, this.y *= e.y) : (this.x *= e, this.y *= n), this;
  },
  /**
   * Divide x and y by another vector or number.
   * @param {number | Vector2Like} x
   * @param {number} [y]
   * @returns {this}
   */
  divide(e, n) {
    return n === void 0 ? (this.x /= e.x, this.y /= e.y) : (this.x /= e, this.y /= n), this;
  },
  /**
   * Dot multiply another vector.
   * @param {Vector2Like} p_b
   * @returns {number}
   */
  dot(e) {
    return this.x * e.x + this.y * e.y;
  },
  /**
   * Cross multiply another vector.
   * @param {Vector2Like} p_b
   * @returns {number}
   */
  cross(e) {
    return this.x * e.y - this.y * e.x;
  },
  /**
   * Change x and y components to their absolute values.
   * @returns {this}
   */
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
  },
  /**
   * Change x and y components to their sign values.
   * @returns {this}
   */
  sign() {
    return this.x = Math.sign(this.x), this.y = Math.sign(this.y), this;
  },
  /**
   * Ceil x and y components.
   * @returns {this}
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  },
  /**
   * Floor x and y components.
   * @returns {this}
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  },
  /**
   * Round to int vector.
   * @returns {this}
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  },
  /**
   * Truncate to int vector.
   * @returns {this}
   */
  trunc() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  },
  /**
   * Clamp the vector to specific length.
   * @param {number} p_length
   * @returns {this}
   */
  clamp(e) {
    const n = this.length();
    return n > 0 && e < n && this.scale(e / n), this;
  },
  /**
   * Scale the vector by a number factor.
   * @param {number} p_factor
   * @returns {this}
   */
  scale(e) {
    return this.x *= e, this.y *= e, this;
  },
  /**
   * Scale the vector by a number factor.
   * @param {number} scale
   * @param {Vector2} center
   * @returns {this}
   */
  scale_with_center(e, n) {
    return this.sub(n).scale(e).add(n), this;
  },
  /**
   * Negate x and y components.
   * @returns {this}
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  },
  /**
   * Inverse the x and y components.
   * @returns {this}
   */
  inverse() {
    return this.x = 1 / this.x, this.y = 1 / this.y, this;
  },
  /**
   * Swap the x and y components.
   * @returns {this}
   */
  swap() {
    const e = this.x;
    return this.x = this.y, this.y = e, this;
  },
  /**
   * Normalize this vector to unit length.
   * @returns {this}
   */
  normalize() {
    const e = this.x, n = this.y;
    let s = e * e + n * n;
    return s > 0 && (s = 1 / Math.sqrt(s), this.x *= s, this.y *= s), this;
  },
  /**
   * Rotates the vector by “phi” radians.
   * @param {number} p_rotation
   * @returns {this}
   */
  rotate(e) {
    const n = this.x, s = this.y, i = Math.cos(e), r = Math.sin(e);
    return this.x = n * i - s * r, this.y = n * r + s * i, this;
  },
  /**
   * Change this vector to be perpendicular to what it was before. (Effectively
   * roatates it 90 degrees in a clockwise direction with the Y axis pointing up)
   * @returns {this}
   */
  perp() {
    const e = this.x;
    return this.x = this.y, this.y = -e, this;
  },
  /**
   * Change this vector to be perpendicular to what it was before. (Effectively
   * roatates it 90 degrees in a ccw direction with the Y axis pointing up)
   * @returns {this}
   */
  perp_inv() {
    const e = this.x;
    return this.x = -this.y, this.y = e, this;
  },
  /**
   * Returns the normal vector of the line formed by `this` and `b`
   *
   * @param {Vector2} b
   * @returns {Vector2}
   */
  normal(e) {
    return e.clone().sub(this).normalize().perp();
  },
  /**
   * Returns the directional vector of the line formed by `this` and `b`
   *
   * @param {Vector2} b
   * @returns {Vector2}
   */
  direction(e) {
    return e.clone().sub(this).normalize();
  },
  /**
   * Returns new Vector2.
   * @param {number} p_d
   * @param {Vector2} p_vec
   * @returns {Vector2}
   */
  plane_project(e, n) {
    const s = this.clone();
    return n.clone().subtract(s.scale(this.dot(n) - e));
  },
  /**
   * Project to a vector.
   * @param {Vector2} p_b
   * @returns {this}
   */
  project(e) {
    const n = this.dot(e) / e.length_squared();
    return this.x = n * e.x, this.y = n * e.y, this;
  },
  /**
   * Project to a vector which is already normalized.
   * @param {Vector2Like} p_b
   * @returns {this}
   */
  project_n(e) {
    const n = this.dot(e);
    return this.x = n * e.x, this.y = n * e.y, this;
  },
  /**
   * Reflects the vector along the given plane, specified by its normal vector.
   * @param {Vector2Like} axis
   * @returns {this}
   */
  reflect(e) {
    const n = this.dot(e);
    return this.x = 2 * e.x * n - this.x, this.y = 2 * e.y * n - this.y, this;
  },
  /**
   * Bounce returns the vector “bounced off” from the given plane, specified by its normal vector.
   * @param {Vector2Like} normal
   * @returns {this}
   */
  bounce(e) {
    return this.reflect(e).negate();
  },
  /**
   * Slide returns the component of the vector along the given plane, specified by its normal vector.
   * @param {Vector2Like} normal
   * @returns {this}
   */
  slide(e) {
    return this.subtract(Ib.copy(e).scale(this.dot(e)));
  },
  /**
   * Returns the length of the vector.
   * @returns {number}
   */
  length() {
    const e = this.x, n = this.y;
    return Math.sqrt(e * e + n * n);
  },
  /**
   * Returns the squared length of the vector. Prefer this function
   * over “length” if you need to sort vectors or need the squared length for some formula.
   * @returns {number}
   */
  length_squared() {
    const e = this.x, n = this.y;
    return e * e + n * n;
  },
  /**
   * Returns the result of atan2 when called with the Vector’s x and y as parameters (Math::atan2(x,y)).
   * @returns {number} [-PI, PI]
   */
  angle() {
    return Math.atan2(this.y, this.x);
  },
  /**
   * Returns the angle in radians between the two vectors.
   * @param {Vector2Like} p_b
   * @returns {number} [-PI, PI]
   */
  angle_to(e) {
    return Math.atan2(this.cross(e), this.dot(e));
  },
  /**
   * Returns the angle in radians between the two vectors.
   * @param {Vector2Like} p_b
   * @returns {number} [0, 2PI]
   */
  angle_to_2(e) {
    let n = this.angle_to(e);
    return n < 0 && (n += 2 * Math.PI), n;
  },
  /**
   * Returns the ccw angle in radians between the two vectors.
   * @param {Vector2Like} p_b
   * @returns {number} [0, 2PI]
   */
  angle_to_ccw(e) {
    let n = Math.atan2(this.y, this.x) - Math.atan2(e.y, e.x);
    return n < 0 && (n += 2 * Math.PI), n;
  },
  /**
   * @param {Vector2Like} p_b
   * @returns {number}
   */
  angle_to_point(e) {
    return Math.atan2(this.y - e.y, this.x - e.x);
  },
  /**
   * Returns the distance to vector “b”.
   * @param {Vector2Like} p_b
   * @returns {number}
   */
  distance_to(e) {
    const n = e.x - this.x, s = e.y - this.y;
    return Math.sqrt(n * n + s * s);
  },
  /**
   * Returns the squared distance to vector “b”. Prefer this function
   * over “distance_to” if you need to sort vectors or need the squared distance for some formula.
   * @param {Vector2Like} p_b
   * @returns {number}
   */
  distance_squared_to(e) {
    const n = e.x - this.x, s = e.y - this.y;
    return n * n + s * s;
  },
  /**
   * Returns a perpendicular vector.
   * @param {Vector2} [r_out]
   * @returns {Vector2}
   */
  tangent(e = new Pt()) {
    return e.set(this.y, -this.x);
  },
  aspect() {
    return this.x / this.y;
  },
  is_zero(e = null) {
    return e ? GO(this.x, e) && GO(this.y, e) : this.x === 0 && this.y === 0;
  },
  /**
   * @param {Vector2} point
   * @returns {boolean}
   */
  isOrthogonal(e) {
    return Pt.isOrthogonal(this.x, this.y, e.x, e.y);
  },
  // /**
  //  * @param {number} x1
  //  * @param {number} y1
  //  * @param {number} x2
  //  * @param {number} y2
  //  */
  // static isOrthogonal(x1, y1, x2, y2) {
  //     return Math.abs(x1 * x2 + y1 * y2)
  //             <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
  //                 * TRIGONOMETRIC_EPSILON
  // }
  /**
   * Checks if this vector is collinear (parallel) to another vector.
   *
   * @param {Vector2} vec the vector to check against
   * @returns {boolean}
   */
  isCollinear(e) {
    return Pt.isCollinear(this.x, this.y, e.x, e.y);
  },
  /**
   * @param {Vector2Like} p_b
   * @param {number} p_t
   * @returns {this}
   */
  linear_interpolate(e, n) {
    return this.x += n * (e.x - this.x), this.y += n * (e.y - this.y), this;
  },
  /**
   * Returns new Vector2.
   * @param {Vector2Like} p_b
   * @param {Vector2Like} p_pre_a
   * @param {Vector2Like} p_post_b
   * @param {number} p_t
   * @returns {Vector2}
   */
  cubic_interpolate(e, n, s, i) {
    const r = i * i, o = r * i;
    return new Pt(
      0.5 * (this.x * 2 + (-n.x + e.x) * i + (2 * n.x - 5 * this.x + 4 * e.x - s.x) * r + (-n.x + 3 * this.x - 3 * e.x + s.x) * o),
      0.5 * (this.y * 2 + (-n.y + e.y) * i + (2 * n.y - 5 * this.y + 4 * e.y - s.y) * r + (-n.y + 3 * this.y - 3 * e.y + s.y) * o)
    );
  },
  /**
   * @returns {boolean}
   */
  valid() {
    return !isNaN(this.x) && !isNaN(this.y);
  },
  /**
   * Checks if the point is within a given distance of another point.
   * @param {Vector2} point the point to check against
   * @param {number} tolerance the maximum distance allowed
   * @returns {boolean} {@true if it is within the given distance}
   */
  isClose(e, n) {
    return this.getDistance(e) <= n;
  },
  /**
   * Returns the distance between the point and another point.
   * @param {Vector2} point
   * @param {boolean} [squared=false] Controls whether the distance should
   * remain squared, or its square root should be calculated
   * @returns {number}
   */
  getDistance(e, n = !1) {
    const s = e.x - this.x, i = e.y - this.y, r = s * s + i * i;
    return n ? r : Math.sqrt(r);
  },
  /**
   * @param {Rect2} rect
   * @returns {boolean}
   */
  isInside(e) {
    return e.contains(this.x, this.y);
  },
  /**
   * @param {Vector2} v1
   * @returns {number}
   */
  angleToPoint(e) {
    return Math.atan2(this.y - e.y, this.x - e.x);
  },
  /**
   * @param {Vector2} v1
   * @returns {number}
   */
  distance(e) {
    return Math.hypot(this.x - e.x, this.y - e.y);
  }
};
const GO = (e, n) => e >= -n && e <= n;
Pt.ZERO = Object.freeze(new Pt(0, 0));
Pt.ONE = Object.freeze(new Pt(1, 1));
Pt.INF = Object.freeze(new Pt(1 / 0, 1 / 0));
Pt.LEFT = Object.freeze(new Pt(-1, 0));
Pt.RIGHT = Object.freeze(new Pt(1, 0));
Pt.UP = Object.freeze(new Pt(0, -1));
Pt.DOWN = Object.freeze(new Pt(0, 1));
const Ib = new Pt(), Xp = 5, Sb = !1;
class yb {
  constructor() {
    this._enabled = Sb, this._logger = {}, this._reset();
  }
  help() {
    console.log(`stats.activate(): enable the frame monitoring
`), console.log(`stats.deactivate(): disable the frame monitoring
`), console.log(`stats.dump(): get the monitoring result
`), console.log(`stats.help(): show the usage of this tool
`);
  }
  activate() {
    this._reset(), this._enabled = !0, console.log("The frame monitoring utility is activated.");
  }
  deactivate() {
    this._reset(), this._enabled = !1, console.log("The frame monitoring utility is deactivated.");
  }
  has(n) {
    const [s, i] = this._getMetricNames(n), r = this.metricGroups[s];
    return r ? !!r[i] : !1;
  }
  get(n) {
    if (!this.has(n))
      throw new Error(`The metrics "${n}" does not exist`);
    const [s, i] = this._getMetricNames(n);
    return this.metricGroups[s][i];
  }
  /**
   * @param {string} metricPath 
   */
  begin(n) {
    if (!this._enabled)
      return;
    const [s, i] = this._getMetricNames(n);
    this.metricGroups[s] || (this.metricGroups[s] = {}), this.metricGroups[s][i] || (this.metricGroups[s][i] = {
      frameCounter: 0,
      deltaTime: 0,
      maxDeltaTime: 0,
      minDeltaTime: 1 / 0,
      deltaTimeBuffer: new Array(Xp).fill(0),
      useSubTimer: !1
    }), this.metricGroups[s][i].beginTime = performance.now(), this.metricGroups[s][i].deltaTime = 0, this.metricGroups[s][i].useSubTimer = !1;
  }
  /**
   * @param {string} metricPath
   * @returns {number}
   */
  end(n) {
    if (!this._enabled)
      return;
    const s = this.get(n);
    return s.useSubTimer || (s.deltaTime = performance.now() - s.beginTime), this._recalculateAvgMinMax(s), s.deltaTime;
  }
  beginSub(n) {
    if (!this._enabled)
      return;
    const s = this.get(n);
    s.useSubTimer = !0, s.beginTime = performance.now();
  }
  endSub(n) {
    if (!this._enabled)
      return;
    const s = this.get(n);
    s.deltaTime += performance.now() - s.beginTime;
  }
  log(n, s) {
    this._enabled && (this._logger[n] = s);
  }
  /**
   * @param {string} metricPath 
   * @returns {[string, string]}
   */
  _getMetricNames(n) {
    const s = n.split("/");
    return s.length <= 1 ? ["_", s[0]] : [s[0], s[1]];
  }
  /**
   * @param {*} metric
   */
  _recalculateAvgMinMax(n) {
    n.deltaTimeBuffer[n.frameCounter++ % Xp] = n.deltaTime, n.maxDeltaTime = Math.max(n.maxDeltaTime, n.deltaTime), n.minDeltaTime = Math.min(n.minDeltaTime, n.deltaTime), n.avgDeltaTime = n.deltaTimeBuffer.reduce((s, i) => s + i, 0) / Xp;
  }
  _reset() {
    this.metricGroups = {
      _: {}
      // default metric group
    }, this._logger = {};
  }
  dump() {
    const n = this._logger;
    return Object.keys(this.metricGroups).reduce((s, i) => {
      const r = this.metricGroups[i], o = Object.keys(r).reduce((a, c) => a + r[c].avgDeltaTime, 0);
      return s[i] = Object.keys(r).reduce((a, c) => (a[c] = {
        frames: r[c].frameCounter,
        avg: r[c].avgDeltaTime,
        min: r[c].minDeltaTime,
        max: r[c].maxDeltaTime,
        pct: 100 * (r[c].avgDeltaTime / o)
      }, a), {}), s;
    }, n);
  }
}
const Cb = new yb();
typeof window < "u" && (window.stats = Cb);
const zp = /* @__PURE__ */ new Set(["Alt", "Shift", "Modifier", "Control"]), da = {
  0: "LeftClick",
  1: "MiddleClick",
  2: "RightClick"
}, Kp = (e) => {
  const n = e.target;
  if (!n || (n.tagName === "INPUT" || n.tagName === "TEXTAREA" || n.tagName === "BUTTON") && (!n.classList.contains("input-system-handle-event") || n.classList.contains("input-system-no-handle")))
    return !0;
}, Nb = (e, n) => {
  const s = e.clientX - n.clientX, i = e.clientY - n.clientY;
  return Math.sqrt(s * s + i * i);
}, xb = (e, n) => {
  const s = (e.clientX + n.clientX) / 2, i = (e.clientY + n.clientY) / 2;
  return new Pt(s, i);
};
class vb extends Q1.EventEmitter {
  constructor(n = window) {
    super(), Xe(this, "_paused"), Xe(this, "_targetElement"), Xe(this, "_actions"), Xe(this, "_keys"), Xe(this, "_keyCode"), Xe(this, "_mouseKeyCode"), Xe(this, "_modifiers"), Xe(this, "_activeActionSet"), Xe(this, "_lastLeftClick"), Xe(this, "startPos"), Xe(this, "_touchId", null), Xe(this, "_activeTouches", /* @__PURE__ */ new Map()), Xe(this, "_pinchState", {
      active: !1,
      initialDistance: 0,
      initialScale: 1,
      center: new Pt(),
      lastScale: 1
    }), Xe(this, "_touchPanState", {
      active: !1,
      startPos: new Pt(),
      lastPos: new Pt(),
      threshold: 10
      // Minimum distance to start panning
    }), Xe(this, "_hoverElementsBoundsMap"), Xe(this, "_eventOpts"), Xe(this, "pressedMouseButton", null), Xe(this, "mousePos"), Xe(this, "wheelDelta"), Xe(this, "dataTransfer"), Xe(this, "event"), Xe(this, "ro"), Xe(this, "inputContext"), Xe(this, "handleVisibilityChange", () => {
      this.releaseAllKeys();
    }), Xe(this, "handleMouseDown", (s) => {
      const i = s;
      if (this._setMousePosition(i), this.startPos.x = i.clientX, this.startPos.y = i.clientY, i.button in da) {
        const r = da[i.button];
        this.pressedMouseButton = i.button, this._mouseKeyCode = r, this._trigger(`${r}Down`, i), this._trigger(r, i);
      }
    }), Xe(this, "handleMouseMove", (s) => {
      const i = s;
      this._setMousePosition(i);
      const r = s.target === this._targetElement;
      if (this.pressedMouseButton === null)
        this._mouseKeyCode = null, this._trigger("MouseMove", i, r);
      else {
        const o = da[this.pressedMouseButton];
        this._mouseKeyCode = `${o}Move`, this._trigger(`${o}Move`, i);
      }
    }), Xe(this, "handleKeyDown", (s) => {
      if (!s.key || Kp(s))
        return;
      const i = this.preprocessKeyboardEvent(s);
      if (this.checkModifierState(s), this._keyCode = i, zp.has(i)) {
        if (this._keyCode = null, s.repeat)
          return;
        this.emit(Yl.MODIFIER_KEY_CHANGES, this._modifiers);
      }
      this._trigger(this._keyCode, s);
    }), Xe(this, "handleKeyUp", (s) => {
      if (!s.key) return;
      const i = this.preprocessKeyboardEvent(s);
      this.checkModifierState(s), (this._keyCode === i || zp.has(i)) && (this._keyCode = null, zp.has(i) && this.emit(Yl.MODIFIER_KEY_CHANGES, this._modifiers)), this._trigger(this._keyCode, s);
    }), Xe(this, "handleMouseEnter", (s) => {
      const i = s;
      this._setMousePosition(i);
      const r = i.target === this._targetElement;
      this._trigger("MouseEnter", i, r);
    }), Xe(this, "handleMouseLeave", (s) => {
      const i = s;
      this._setMousePosition(i);
      const r = s.target === this._targetElement;
      this._trigger("MouseLeave", i, r);
    }), Xe(this, "handleMouseUp", (s) => {
      if (this.pressedMouseButton !== s.button)
        return;
      this._setMousePosition(s), this.pressedMouseButton = null;
      const i = da[s.button], r = s.target === this._targetElement;
      if (this._mouseKeyCode = null, this._trigger(`${i}Up`, s, r), i === "LeftClick") {
        const o = performance.now();
        o - this._lastLeftClick.timestamp < 500 && this._lastLeftClick.pos.equals(this.mousePos) ? (this._lastLeftClick.timestamp = 0, this._trigger("DoubleLeftClick", s, r)) : (this._lastLeftClick.timestamp = o, this._lastLeftClick.pos.copy(this.mousePos));
      }
    }), Xe(this, "handleWheel", (s) => {
      const i = s;
      if (this.checkModifierState(i), i.deltaX !== 0) {
        const r = Math.sign(i.deltaX) === 1 ? "WheelXPositive" : "WheelXNegative";
        this.wheelDelta.set(i.deltaX, 0), this._trigger(r, i);
      }
      if (i.deltaY !== 0) {
        const r = Math.sign(i.deltaY) === 1 ? "WheelYPositive" : "WheelYNegative";
        this.wheelDelta.set(0, i.deltaY), this._trigger(r, i);
      }
    }), Xe(this, "handleTouchEnd", (s) => {
      const i = s;
      if (this._pinchState.active && i.targetTouches.length < 2) {
        this._pinchState.active = !1, this._activeTouches.clear();
        return;
      }
      if (this._touchId === null) return;
      this._touchId = null, this._setMousePosition(i);
      const r = da[0];
      this.pressedMouseButton = null, this._keyCode = null, this._trigger(r, i, !0), this._touchPanState.active && (this._touchPanState.active = !1, this._trigger("TouchPanEnd", i, !0));
    }), Xe(this, "handleTouchStart", (s) => {
      var i;
      const r = s;
      if (r.targetTouches.length === 2) {
        this._updatePinchState(r);
        return;
      }
      if (this._touchId !== null && ((i = this.handleTouchEnd) == null || i.call(this, r)), r.targetTouches.length !== 1) return;
      this._touchId = r.targetTouches[0].identifier, this._setMousePosition(r), this._touchPanState.startPos.copy(this.mousePos), this._touchPanState.lastPos.copy(this.mousePos), this._touchPanState.active = !1, this.pressedMouseButton = 0;
      const o = da[0];
      this._keyCode = o, this._trigger(o, r);
    }), Xe(this, "handleTouchMove", (s) => {
      const i = s;
      if (i.targetTouches.length === 2) {
        this._updatePinchState(i);
        return;
      }
      if (i.targetTouches[0].identifier === this._touchId) {
        if (this._setMousePosition(i), !this._touchPanState.active && this.pressedMouseButton === 0 && this.mousePos.distance_to(
          this._touchPanState.startPos
        ) > this._touchPanState.threshold) {
          this._touchPanState.active = !0, this._touchPanState.lastPos.copy(this.mousePos), this._trigger("TouchPan", i);
          return;
        }
        if (this._touchPanState.active)
          this._touchPanState.lastPos.copy(this.mousePos), this._trigger("TouchPan", i);
        else if (this.pressedMouseButton === 0) {
          const r = da[0];
          this._trigger(r, i);
        }
      }
    }), Xe(this, "handlePaste", (s) => {
      Kp(s) || (this._setDataTransfer(s), this._trigger("Paste", s));
    }), Xe(this, "handleCopy", (s) => {
      Kp(s) || (this._setDataTransfer(s), this._trigger("Copy", s));
    }), Xe(this, "handleDragEnter", (s) => {
      const i = s;
      this._setMousePosition(i);
      const r = i.target === this._targetElement;
      this._trigger("DragOver", i, r);
    }), Xe(this, "handleDragOver", (s) => {
      const i = s;
      i.preventDefault(), this._setMousePosition(i);
      const r = s.target === this._targetElement;
      this._trigger("DragOver", i, r);
    }), Xe(this, "handleDragLeave", (s) => {
      const i = s;
      this._setMousePosition(i);
      const r = i.target === this._targetElement;
      this._trigger("DragEnd", i, r);
    }), Xe(this, "handleDrop", (s) => {
      const i = s;
      i.preventDefault(), this._setDataTransfer(i), this._setMousePosition(i);
      const r = i.target === this._targetElement;
      this._trigger("Drop", i, r);
    }), this._paused = !1, this._targetElement = null, this._actions = /* @__PURE__ */ new Map(), this._keys = /* @__PURE__ */ new Map(), this._keyCode = null, this._mouseKeyCode = null, this._modifiers = {
      modifier: !1,
      // ctrl / command (macOS)
      ctrl: !1,
      shift: !1,
      alt: !1
    }, this.startPos = { x: 0, y: 0 }, this._activeActionSet = /* @__PURE__ */ new Set(), this._lastLeftClick = {
      timestamp: 0,
      pos: new Pt()
    }, this._hoverElementsBoundsMap = /* @__PURE__ */ new Map(), this._eventOpts = { passive: !1 }, this.mousePos = new Pt(), this.wheelDelta = new Pt(), this.dataTransfer = {
      files: [],
      items: []
    }, this.event = {
      handled: !0,
      mousePos: this.mousePos,
      wheelDelta: this.wheelDelta,
      dataTransfer: this.dataTransfer,
      domEvent: null
    }, this.inputContext = C.DESIGN_MODE, this.ro = new ResizeObserver(() => {
      this._clearHoverElementsBounds();
    }), this.watch(n);
  }
  addAction(n) {
    this._actions.set(n.name, n), this._updateActions();
  }
  getAction(n) {
    return this._actions.get(n);
  }
  removeAction(n) {
    this._actions.delete(n.name);
  }
  watch(n) {
    this.stop(), this._targetElement = n, window.addEventListener("keydown", this.handleKeyDown, this._eventOpts), window.addEventListener("keyup", this.handleKeyUp, this._eventOpts), this._targetElement.addEventListener(
      "mousedown",
      this.handleMouseDown,
      this._eventOpts
    ), window.addEventListener(
      "mousemove",
      this.handleMouseMove,
      this._eventOpts
    ), window.addEventListener("mouseup", this.handleMouseUp, this._eventOpts), this._targetElement.addEventListener(
      "mouseenter",
      this.handleMouseEnter,
      this._eventOpts
    ), this._targetElement.addEventListener(
      "mouseleave",
      this.handleMouseLeave,
      this._eventOpts
    ), this._targetElement.addEventListener(
      "wheel",
      this.handleWheel,
      this._eventOpts
    ), this._targetElement.addEventListener(
      "touchstart",
      this.handleTouchStart,
      this._eventOpts
    ), this._targetElement.addEventListener(
      "touchmove",
      this.handleTouchMove,
      this._eventOpts
    ), this._targetElement.addEventListener(
      "touchend",
      this.handleTouchEnd,
      this._eventOpts
    ), document.body.addEventListener(
      "dragenter",
      this.handleDragEnter,
      this._eventOpts
    ), document.body.addEventListener(
      "dragleave",
      this.handleDragLeave,
      this._eventOpts
    ), document.body.addEventListener(
      "dragover",
      this.handleDragOver,
      this._eventOpts
    ), window.addEventListener("drop", this.handleDrop, this._eventOpts), document.addEventListener("paste", this.handlePaste, this._eventOpts), document.addEventListener("copy", this.handleCopy, this._eventOpts), this._targetElement.addEventListener(
      "focus",
      this.handleVisibilityChange,
      this._eventOpts
    ), this._targetElement.addEventListener(
      "blur",
      this.handleVisibilityChange,
      this._eventOpts
    ), document.addEventListener(
      "visibilitychange",
      this.handleVisibilityChange,
      this._eventOpts
    ), this._targetElement instanceof Element && this.ro.observe(this._targetElement);
  }
  // When you are wandering input-system stop listening to events, but the following functions such as stop, pause, reset, etc. are not called.
  // You need to check document.activeElement to see if an input element is focused.
  stop() {
    this._targetElement && (window.removeEventListener(
      "keydown",
      this.handleKeyDown,
      this._eventOpts
    ), window.removeEventListener("keyup", this.handleKeyUp, this._eventOpts), this._targetElement.removeEventListener(
      "mousedown",
      this.handleMouseDown,
      this._eventOpts
    ), window.removeEventListener(
      "mousemove",
      this.handleMouseMove,
      this._eventOpts
    ), window.removeEventListener(
      "mouseup",
      this.handleMouseUp,
      this._eventOpts
    ), this._targetElement.removeEventListener(
      "mouseenter",
      this.handleMouseEnter,
      this._eventOpts
    ), this._targetElement.removeEventListener(
      "mouseleave",
      this.handleMouseLeave,
      this._eventOpts
    ), this._targetElement.removeEventListener(
      "wheel",
      this.handleWheel,
      this._eventOpts
    ), this._targetElement.removeEventListener(
      "touchstart",
      this.handleTouchStart,
      this._eventOpts
    ), this._targetElement.removeEventListener(
      "touchmove",
      this.handleTouchMove,
      this._eventOpts
    ), this._targetElement.removeEventListener(
      "touchend",
      this.handleTouchEnd,
      this._eventOpts
    ), document.body.removeEventListener(
      "dragenter",
      this.handleDragEnter,
      this._eventOpts
    ), document.body.removeEventListener(
      "dragleave",
      this.handleDragLeave,
      this._eventOpts
    ), document.body.removeEventListener(
      "dragover",
      this.handleDragOver,
      this._eventOpts
    ), window.removeEventListener("drop", this.handleDrop, this._eventOpts), document.removeEventListener("paste", this.handlePaste, this._eventOpts), document.removeEventListener("copy", this.handleCopy, this._eventOpts), this._targetElement.removeEventListener(
      "focus",
      this.handleVisibilityChange,
      this._eventOpts
    ), this._targetElement.removeEventListener(
      "blur",
      this.handleVisibilityChange,
      this._eventOpts
    ), document.removeEventListener(
      "visibilitychange",
      this.handleVisibilityChange,
      this._eventOpts
    ), this.ro.disconnect(), this._targetElement = null);
  }
  endActiveAction() {
    const n = this._getKeyCombination(this._keyCode);
    this._activeActionSet.forEach((s) => {
      (!this._keyCode || !s.canBeActive(n)) && (s.end(), this._activeActionSet.delete(s));
    });
  }
  // When you are wandering input-system stop listening to events, but the following functions such as stop, pause, reset, etc. are not called.
  // You need to check document.activeElement to see if an input element is focused.
  releaseAllKeys() {
    this._paused || (this._keyCode = null, this._mouseKeyCode = null, this._modifiers = {
      modifier: !1,
      ctrl: !1,
      shift: !1,
      alt: !1
    }, this.emit(Yl.MODIFIER_KEY_CHANGES, this._modifiers), this.endActiveAction());
  }
  pause() {
    this._paused || (this.releaseAllKeys(), this._paused = !0);
  }
  resume() {
    this._paused = !1;
  }
  reset() {
    this.releaseAllKeys(), this._actions.clear();
  }
  _setMousePosition(n) {
    if (n instanceof MouseEvent)
      this.mousePos.set(n.clientX, n.clientY);
    else {
      const s = n.changedTouches[0];
      this.mousePos.set(s.clientX, s.clientY);
    }
    if (this._targetElement instanceof Element)
      if (this._hoverElementsBoundsMap.has(this._targetElement)) {
        const s = this._hoverElementsBoundsMap.get(
          this._targetElement
        );
        this.mousePos.sub(s);
      } else {
        const s = this._targetElement.getBoundingClientRect();
        this._hoverElementsBoundsMap.set(this._targetElement, s), this.mousePos.sub(s);
      }
  }
  _setDataTransfer(n) {
    switch (n.type) {
      case "drop": {
        const s = n;
        this.dataTransfer.files = s.dataTransfer ? [...s.dataTransfer.files] : [], this.dataTransfer.items = [];
        break;
      }
      case "copy": {
        this.dataTransfer.files = [], this.dataTransfer.items = [];
        break;
      }
      case "paste": {
        const s = n.clipboardData;
        this.dataTransfer.files = s ? [...s.files] : [], this.dataTransfer.items = s ? [...s.items] : [];
        break;
      }
    }
  }
  _clearHoverElementsBounds() {
    this._hoverElementsBoundsMap.clear();
  }
  _updateActions() {
    this._keys.clear();
    for (const [, s] of this._actions)
      for (const i of s._keyCombos) {
        const r = this._keys.get(i.triggerKeyCode);
        r ? r.push(s) : this._keys.set(i.triggerKeyCode, [s]);
      }
    ((s) => {
      for (const [, i] of s)
        i.sort((r, o) => Number(r.fallback) - Number(o.fallback));
    })(this._keys);
    const n = /* @__PURE__ */ new Set([
      "LeftClickMove",
      "MiddleClickMove",
      "RightClickMove",
      "DoubleLeftClick"
    ]);
    this._keys = new Map(
      [...this._keys.entries()].sort(
        (s, i) => (i[0] && n.has(i[0]) ? 1 : 0) - (s[0] && n.has(s[0]) ? 1 : 0)
      )
    );
  }
  _getKeyCombination(n = null) {
    return {
      key: n || this._keyCode || this._mouseKeyCode,
      modifiers: this._modifiers
    };
  }
  // isRightTarget - if false ignores the event that might trigger an action
  _trigger(n, s, i = !0) {
    if (this._paused) return;
    this.event.domEvent = s, s instanceof ClipboardEvent || this.checkModifierState(s);
    const r = this._getKeyCombination(n);
    let o = !1;
    r.key && (r.key.endsWith("ClickUp") || r.key.endsWith("TouchPanEnd")) && (this.endActiveAction(), o = !0), r.key || (this.endActiveAction(), r.key = "MouseMove");
    const a = this._keys.get(r.key);
    if (a) {
      for (const c of a)
        if (c.context.includes(this.inputContext) && i && c.trigger(r, this.event)) {
          this._activeActionSet.add(c), o = !0;
          break;
        }
    }
    o && s.preventDefault();
  }
  preprocessKeyboardEvent(n) {
    const s = lb[n.code] || n.key;
    return s === (Td ? "Meta" : "Control") ? "Modifier" : s;
  }
  checkModifierState(n) {
    this._modifiers.ctrl = n.ctrlKey, this._modifiers.shift = n.shiftKey, this._modifiers.alt = n.altKey, this._modifiers.modifier = Td ? n.metaKey : n.ctrlKey;
  }
  setInputContext(n) {
    this.inputContext = n;
  }
  _updatePinchState(n) {
    const s = n.targetTouches;
    if (s.length !== 2) {
      this._pinchState.active && (this._pinchState.active = !1, this._activeTouches.clear());
      return;
    }
    const i = s[0], r = s[1], o = Nb(i, r), a = xb(i, r);
    if (!this._pinchState.active)
      this._pinchState.active = !0, this._pinchState.initialDistance = o, this._pinchState.initialScale = 1, this._pinchState.lastScale = 1, this._pinchState.center.copy(a), this._activeTouches.set(i.identifier, i), this._activeTouches.set(r.identifier, r);
    else {
      const c = o / this._pinchState.initialDistance, l = c / this._pinchState.lastScale;
      if (Math.abs(l - 1) > 0.01) {
        if (this._pinchState.center.copy(a), this._pinchState.lastScale = c, this.mousePos.copy(a), this._targetElement instanceof Element)
          if (this._hoverElementsBoundsMap.has(this._targetElement)) {
            const d = this._hoverElementsBoundsMap.get(
              this._targetElement
            );
            this.mousePos.sub(d);
          } else {
            const d = this._targetElement.getBoundingClientRect();
            this._hoverElementsBoundsMap.set(
              this._targetElement,
              d
            ), this.mousePos.sub(d);
          }
        this.event.pinchScale = l, this.event.pinchCenter = this._pinchState.center.clone();
        const h = l > 1 ? "PinchZoomIn" : "PinchZoomOut";
        this._trigger(h, n, !0);
      }
    }
  }
}
const FO = {
  [Ee.LEFT_CLICK]: {
    keyCombos: ["LeftClick"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ],
    fallback: !0
  },
  [Ee.LEFT_CLICK_MOVE]: {
    keyCombos: ["LeftClickMove"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ],
    fallback: !0
  },
  [Ee.LEFT_CLICK_DOWN]: {
    keyCombos: ["LeftClickDown"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ],
    fallback: !0
  },
  [Ee.LEFT_CLICK_UP]: {
    keyCombos: ["LeftClickUp"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ],
    fallback: !0
  },
  [Ee.SPACE]: {
    keyCombos: ["Space"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.MIDDLE_CLICK_MOVE]: {
    keyCombos: ["MiddleClickMove"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.RIGHT_CLICK_MOVE]: {
    keyCombos: ["RightClick", "RightClickMove"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ],
    fallback: !0
  },
  [Ee.MOUSE_MOVE]: {
    keyCombos: ["MouseMove"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ],
    fallback: !0
  },
  [Ee.MOUSE_ENTER]: {
    keyCombos: ["MouseEnter"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ],
    fallback: !0
  },
  [Ee.MOUSE_LEAVE]: {
    keyCombos: ["MouseLeave"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ],
    fallback: !0
  },
  [Ee.DOUBLE_LEFT_CLICK]: {
    keyCombos: ["DoubleLeftClick"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.DRAG_OVER]: {
    keyCombos: ["DragOver"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ],
    fallback: !0
  },
  [Ee.DRAG_END]: {
    keyCombos: ["DragEnd"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ],
    fallback: !0
  },
  [Ee.DROP]: {
    keyCombos: ["Drop"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ],
    fallback: !0
  },
  [Ee.SELECT_PREVIOUS_ELEMENT]: {
    keyCombos: ["Tab"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.SELECT_NEXT_ELEMENT]: {
    keyCombos: ["Shift + Tab"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.TEXT_MOVE_CARET_TO_LINE_START]: {
    keyCombos: ["Home"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.TEXT_MOVE_CARET_TO_TEXT_START]: {
    keyCombos: ["Modifier + Home"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.TEXT_EXPAND_SELECTION_TO_LINE_START]: {
    keyCombos: ["Shift + Home"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.TEXT_EXPAND_SELECTION_TO_TEXT_START]: {
    keyCombos: ["Modifier + Shift + Home"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.TEXT_MOVE_CARET_TO_LINE_END]: {
    keyCombos: ["End"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.TEXT_MOVE_CARET_TO_TEXT_END]: {
    keyCombos: ["Modifier + End"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.TEXT_EXPAND_SELECTION_TO_LINE_END]: {
    keyCombos: ["Shift + End"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.TEXT_EXPAND_SELECTION_TO_TEXT_END]: {
    keyCombos: ["Modifier + Shift + End"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.ENTER]: {
    keyCombos: ["Enter"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.ENTER_SHIFT]: {
    keyCombos: ["Shift + Enter"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.ESCAPE]: {
    keyCombos: ["Escape"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ],
    fallback: !0
  },
  [Ee.DELETE]: {
    keyCombos: ["Delete", "Backspace"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ],
    fallback: !0
  },
  [Ee.MOVE_RIGHT]: {
    keyCombos: ["ArrowRight"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ],
    fallback: !0
  },
  [Ee.MOVE_LEFT]: {
    keyCombos: ["ArrowLeft"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ],
    fallback: !0
  },
  [Ee.MOVE_UP]: {
    keyCombos: ["ArrowUp"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ],
    fallback: !0
  },
  [Ee.MOVE_DOWN]: {
    keyCombos: ["ArrowDown"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ],
    fallback: !0
  },
  [Ee.UNDO]: {
    keyCombos: ["Modifier + Z"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.REDO]: {
    keyCombos: ["Modifier + Shift + Z"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.ZOOM_OUT]: {
    keyCombos: ["Modifier + -", "-"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE,
      C.PROTOTYPE_MODE
    ]
  },
  [Ee.ZOOM_IN]: {
    keyCombos: ["Modifier + =", "=", "+"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE,
      C.PROTOTYPE_MODE
    ]
  },
  [Ee.ZOOM_RESET]: {
    keyCombos: ["Modifier + 0"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.ZOOM_FIT_CONTENT]: {
    keyCombos: ["Modifier + 1"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.ZOOM_FIT_SELECTION]: {
    keyCombos: ["Modifier + 2"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.ZOOM_CENTER_SELECTION]: {
    keyCombos: ["Modifier + 3"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.COPY]: {
    keyCombos: ["Copy"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ],
    fallback: !0
  },
  [Ee.PASTE]: {
    keyCombos: ["Paste"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ],
    fallback: !0
  },
  [Ee.CUT]: {
    keyCombos: ["Modifier + X", "Shift + Modifier + X"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.DUPLICATE]: {
    keyCombos: ["Modifier + D", "Shift + Modifier + D"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.SELECT_ALL]: {
    keyCombos: ["Modifier + A"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.TOGGLE_ANIMATE_MODE]: {
    keyCombos: ["A"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.TOGGLE_ACTION_PANEL]: {
    keyCombos: ["["],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.ADD_ACTION]: {
    keyCombos: ["Alt + N"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.ACTIVATE_SELECT_TOOL]: {
    keyCombos: ["V"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.ACTIVATE_SCALE_TOOL]: {
    keyCombos: ["K"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.ACTIVATE_HAND_TOOL]: {
    keyCombos: ["H"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.ACTIVATE_RECTANGLE_TOOL]: {
    keyCombos: ["R"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.RESTART_PROTOTYPE]: {
    keyCombos: ["R"],
    context: [C.PROTOTYPE_MODE]
  },
  [Ee.ENTER_PROTOTYPE_MODE_FULL_SCREEN]: {
    keyCombos: ["F"],
    context: [C.PROTOTYPE_MODE]
  },
  [Ee.TOGGLE_PROTOTYPE_MODE]: {
    keyCombos: ["Shift + P"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE
    ]
  },
  [Ee.EXIT_PROTOTYPE_MODE]: {
    keyCombos: ["Escape"],
    context: [C.PROTOTYPE_MODE]
  },
  [Ee.ACTIVATE_CONTAINER_TOOL]: {
    keyCombos: ["N"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.ACTIVATE_ELLIPSE_TOOL]: {
    keyCombos: ["O"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.ACTIVATE_PEN_TOOL]: {
    keyCombos: ["P"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.ACTIVATE_COMMENT_TOOL]: {
    keyCombos: ["C"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.ACTIVATE_TEXT_TOOL]: {
    keyCombos: ["T"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.TOGGLE_EYE_DROPPER_TOOL]: {
    keyCombos: ["I"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.INCREASE_CORNER_RADIUS]: {
    keyCombos: ["Modifier + O"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.DECREASE_CORNER_RADIUS]: {
    keyCombos: ["Modifier + K"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.GROUP_ELEMENTS]: {
    keyCombos: ["Modifier + G", "Modifier + Alt + G"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.UNGROUP_ELEMENT]: {
    keyCombos: ["Modifier + Shift + G"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.TOGGLE_EXPAND]: {
    keyCombos: ["Alt + L"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.WHEEL_PAN_VIEWPORT]: {
    keyCombos: [
      "WheelXPositive",
      "WheelYPositive",
      "WheelXNegative",
      "WheelYNegative"
    ],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ],
    fallback: !0
  },
  [Ee.WHEEL_ZOOM_TO_POINTER]: {
    keyCombos: [
      "Modifier + WheelXPositive",
      "Modifier + WheelYPositive",
      "Modifier + WheelXNegative",
      "Modifier + WheelYNegative"
    ],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.TRACKPAD_ZOOM_TO_POINTER]: {
    keyCombos: [
      "Ctrl + WheelXPositive",
      "Ctrl + WheelYPositive",
      "Ctrl + WheelXNegative",
      "Ctrl + WheelYNegative"
    ],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ],
    platforms: ["Mac"]
  },
  [Ee.MOBILE_PINCH_ZOOM_TO_POINTER]: {
    keyCombos: ["PinchZoomIn", "PinchZoomOut"],
    context: [C.PROTOTYPE_MODE]
  },
  [Ee.MOBILE_TOUCH_PAN]: {
    keyCombos: ["TouchPan"],
    context: [C.PROTOTYPE_MODE]
  },
  [Ee.ALIGN_LEFT]: {
    keyCombos: ["Alt + A"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.ALIGN_CENTER]: {
    keyCombos: ["Alt + H"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.ALIGN_RIGHT]: {
    keyCombos: ["Alt + D"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.ALIGN_TOP]: {
    keyCombos: ["Alt + W"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.ALIGN_MIDDLE]: {
    keyCombos: ["Alt + V"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.ALIGN_BOTTOM]: {
    keyCombos: ["Alt + S"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.DISTRIBUTE_HORIZONTAL]: {
    keyCombos: ["Ctrl + Alt + H"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.DISTRIBUTE_VERTICAL]: {
    keyCombos: ["Ctrl + Alt + V"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.TOGGLE_ORIGIN]: {
    keyCombos: ["Shift + Y"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.TOGGLE_RULER]: {
    keyCombos: ["Shift + R"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.TOGGLE_INTERFACE]: {
    keyCombos: ["Modifier + \\"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.TOGGLE_COMMENT_VISIBILITY]: {
    keyCombos: ["Shift + C"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.TOGGLE_VISIBLE]: {
    keyCombos: ["Modifier + Shift + H"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.TOGGLE_LOCK]: {
    keyCombos: ["Modifier + Shift + L"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.BRING_TO_FRONT]: {
    keyCombos: ["Alt + Modifier + ]"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.SEND_TO_BACK]: {
    keyCombos: ["Alt + Modifier + ["],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.MOVE_FORWARD]: {
    keyCombos: ["Modifier + ]"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.MOVE_BACKWARD]: {
    keyCombos: ["Modifier + ["],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.MASK_SELECTION]: {
    keyCombos: ["Ctrl + Modifier + M"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.TOGGLE_PRESENCE]: {
    keyCombos: ["Shift + Modifier + \\"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.EDIT_ORIGIN]: {
    keyCombos: ["Y"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.TOGGLE_INSPECTING]: {
    keyCombos: ["Shift + I"],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE,
      C.SELECTOR_MODE
    ]
  },
  [Ee.KEY_DOWN]: {
    keyCombos: [
      "KeyDown_A",
      "KeyDown_B",
      "KeyDown_C",
      "KeyDown_D",
      "KeyDown_E",
      "KeyDown_F",
      "KeyDown_G",
      "KeyDown_H",
      "KeyDown_I",
      "KeyDown_J",
      "KeyDown_K",
      "KeyDown_L",
      "KeyDown_M",
      "KeyDown_N",
      "KeyDown_O",
      "KeyDown_P",
      "KeyDown_Q",
      "KeyDown_R",
      "KeyDown_S",
      "KeyDown_T",
      "KeyDown_U",
      "KeyDown_V",
      "KeyDown_W",
      "KeyDown_X",
      "KeyDown_Y",
      "KeyDown_Z",
      "KeyDown_0",
      "KeyDown_1",
      "KeyDown_2",
      "KeyDown_3",
      "KeyDown_4",
      "KeyDown_5",
      "KeyDown_6",
      "KeyDown_7",
      "KeyDown_8",
      "KeyDown_9"
    ],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  },
  [Ee.KEY_UP]: {
    keyCombos: [
      "KeyUp_A",
      "KeyUp_B",
      "KeyUp_C",
      "KeyUp_D",
      "KeyUp_E",
      "KeyUp_F",
      "KeyUp_G",
      "KeyUp_H",
      "KeyUp_I",
      "KeyUp_J",
      "KeyUp_K",
      "KeyUp_L",
      "KeyUp_M",
      "KeyUp_N",
      "KeyUp_O",
      "KeyUp_P",
      "KeyUp_Q",
      "KeyUp_R",
      "KeyUp_S",
      "KeyUp_T",
      "KeyUp_U",
      "KeyUp_V",
      "KeyUp_W",
      "KeyUp_X",
      "KeyUp_Y",
      "KeyUp_Z",
      "KeyUp_0",
      "KeyUp_1",
      "KeyUp_2",
      "KeyUp_3",
      "KeyUp_4",
      "KeyUp_5",
      "KeyUp_6",
      "KeyUp_7",
      "KeyUp_8",
      "KeyUp_9"
    ],
    context: [
      C.DESIGN_MODE,
      C.ACTION_MODE,
      C.PROTOTYPE_MODE,
      C.INSPECT_MODE,
      C.VERSION_MODE,
      C.VIEW_MODE
    ]
  }
}, Hs = new vb();
Hs.pause();
for (const e in FO) {
  const n = FO[e], s = new Z1(e, n.keyCombos, n.context, n.fallback);
  Hs.addAction(s);
}
const Rb = (e, n, s = [], i) => {
  const r = new Z1(e, n, s, i);
  Hs.addAction(r);
}, wb = (e) => {
  const n = Hs.getAction(e);
  n && Hs.removeAction(n);
}, Db = () => Hs.pause(), Lb = () => Hs.resume(), Mb = (e) => Hs.getAction(e), Pb = (e) => Hs.watch(e);
window.IS = Hs;
const bb = (e) => Hs.setInputContext(e), H = {
  on: Hs.on.bind(Hs),
  off: Hs.off.bind(Hs),
  get: Mb,
  pause: Db,
  resume: Lb,
  watch: Pb,
  platform: ab,
  registerAction: Rb,
  unregisterAction: wb,
  Events: Ee,
  setInputContext: bb
};
var Ln;
(function(e) {
  e.FILL = "fills", e.STROKE = "strokes", e.SHADOW = "shadows", e.INNER_SHADOW = "innerShadows";
})(Ln || (Ln = {}));
Ln.FILL, Ln.STROKE, Ln.SHADOW, Ln.INNER_SHADOW;
const o0 = [
  Ln.FILL,
  Ln.STROKE,
  Ln.SHADOW,
  Ln.INNER_SHADOW
];
new Set(o0);
ze.FILL + "", Ln.FILL, ze.STROKE + "", Ln.STROKE, ze.SHADOW + "", Ln.SHADOW, ze.INNER_SHADOW + "", Ln.INNER_SHADOW;
Ln.FILL + "", ze.FILL, Ln.STROKE + "", ze.STROKE, Ln.SHADOW + "", ze.SHADOW, Ln.INNER_SHADOW + "", ze.INNER_SHADOW;
const Ub = {
  [zi.TRIM_PATH]: "trimPath"
};
xn.FADE_IN + "", xn.FADE_OUT + "", xn.MOVE_IN + "", xn.MOVE_OUT + "", xn.SCALE_IN + "", xn.SCALE_OUT + "", xn.SPIN_IN + "", xn.SPIN_OUT + "", xn.TRIM_IN + "", xn.TRIM_OUT + "";
Te.LINEAR + "", Te.EASE + "", Te.EASE_IN + "", Te.EASE_OUT + "", Te.EASE_IN_OUT + "", Te.EASE_IN_SIN + "", Te.EASE_OUT_SINE + "", Te.EASE_IN_OUT_SINE + "", Te.EASE_IN_QUAD + "", Te.EASE_OUT_QUAD + "", Te.EASE_IN_OUT_QUAD + "", Te.EASE_IN_CUBIC + "", Te.EASE_OUT_CUBIC + "", Te.EASE_IN_OUT_CUBIC + "", Te.EASE_IN_QUART + "", Te.EASE_OUT_QUART + "", Te.EASE_IN_OUT_QUART + "", Te.EASE_IN_QUINT + "", Te.EASE_OUT_QUINT + "", Te.EASE_IN_OUT_QUINT + "", Te.EASE_IN_EXPO + "", Te.EASE_OUT_EXPO + "", Te.EASE_IN_OUT_EXPO + "", Te.EASE_IN_CIRC + "", Te.EASE_OUT_CIRC + "", Te.EASE_IN_OUT_CIRC + "", Te.EASE_IN_BACK + "", Te.EASE_OUT_BACK + "", Te.EASE_IN_OUT_BACK + "";
new Set(Object.values(Ub));
Object.freeze({
  fills: we.FILL,
  strokes: we.STROKE,
  shadows: we.SHADOW,
  innerShadows: we.INNER_SHADOW
});
Object.freeze({
  fills: ze.FILL,
  strokes: ze.STROKE,
  shadows: ze.SHADOW,
  innerShadows: ze.INNER_SHADOW
});
Te.LINEAR, Te.EASE, Te.EASE_IN, Te.EASE_OUT, Te.EASE_IN_OUT, Te.EASE_IN_SIN, Te.EASE_OUT_SINE, Te.EASE_IN_OUT_SINE, Te.EASE_IN_QUAD, Te.EASE_OUT_QUAD, Te.EASE_IN_OUT_QUAD, Te.EASE_IN_CUBIC, Te.EASE_OUT_CUBIC, Te.EASE_IN_OUT_CUBIC, Te.EASE_IN_QUART, Te.EASE_OUT_QUART, Te.EASE_IN_OUT_QUART, Te.EASE_IN_QUINT, Te.EASE_OUT_QUINT, Te.EASE_IN_OUT_QUINT, Te.EASE_IN_EXPO, Te.EASE_OUT_EXPO, Te.EASE_IN_OUT_EXPO, Te.EASE_IN_CIRC, Te.EASE_OUT_CIRC, Te.EASE_IN_OUT_CIRC, Te.EASE_IN_BACK, Te.EASE_OUT_BACK, Te.EASE_IN_OUT_BACK;
var Od = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
Od.exports;
(function(e, n) {
  (function() {
    var s, i = "4.17.21", r = 200, o = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", a = "Expected a function", c = "Invalid `variable` option passed into `_.template`", l = "__lodash_hash_undefined__", h = 500, d = "__lodash_placeholder__", p = 1, E = 2, g = 4, T = 1, A = 2, m = 1, O = 2, S = 4, y = 8, v = 16, R = 32, M = 64, L = 128, P = 256, k = 512, Q = 30, b = "...", X = 800, K = 16, V = 1, J = 2, ge = 3, ne = 1 / 0, ue = 9007199254740991, te = 17976931348623157e292, ie = NaN, re = 4294967295, fe = re - 1, Ne = re >>> 1, At = [
      ["ary", L],
      ["bind", m],
      ["bindKey", O],
      ["curry", y],
      ["curryRight", v],
      ["flip", k],
      ["partial", R],
      ["partialRight", M],
      ["rearg", P]
    ], Ke = "[object Arguments]", St = "[object Array]", rn = "[object AsyncFunction]", gt = "[object Boolean]", Wn = "[object Date]", Xs = "[object DOMException]", ls = "[object Error]", Ci = "[object Function]", ho = "[object GeneratorFunction]", Yn = "[object Map]", En = "[object Number]", Ni = "[object Null]", Bn = "[object Object]", ys = "[object Promise]", Dr = "[object Proxy]", Lr = "[object RegExp]", Cs = "[object Set]", fr = "[object String]", zs = "[object Symbol]", uo = "[object Undefined]", fo = "[object WeakMap]", Lh = "[object WeakSet]", na = "[object ArrayBuffer]", po = "[object DataView]", pr = "[object Float32Array]", pf = "[object Float64Array]", Ef = "[object Int8Array]", gf = "[object Int16Array]", _f = "[object Int32Array]", Tf = "[object Uint8Array]", Af = "[object Uint8ClampedArray]", mf = "[object Uint16Array]", Of = "[object Uint32Array]", WN = /\b__p \+= '';/g, YN = /\b(__p \+=) '' \+/g, XN = /(__e\(.*?\)|\b__t\)) \+\n'';/g, F0 = /&(?:amp|lt|gt|quot|#39);/g, k0 = /[&<>"']/g, zN = RegExp(F0.source), KN = RegExp(k0.source), QN = /<%-([\s\S]+?)%>/g, ZN = /<%([\s\S]+?)%>/g, B0 = /<%=([\s\S]+?)%>/g, qN = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, jN = /^\w*$/, JN = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, If = /[\\^$.*+?()[\]{}|]/g, $N = RegExp(If.source), Sf = /^\s+/, ex = /\s/, tx = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, nx = /\{\n\/\* \[wrapped with (.+)\] \*/, sx = /,? & /, ix = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, rx = /[()=,{}\[\]\/\s]/, ox = /\\(\\)?/g, ax = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, V0 = /\w*$/, cx = /^[-+]0x[0-9a-f]+$/i, lx = /^0b[01]+$/i, hx = /^\[object .+?Constructor\]$/, ux = /^0o[0-7]+$/i, dx = /^(?:0|[1-9]\d*)$/, fx = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Mh = /($^)/, px = /['\n\r\u2028\u2029\\]/g, Ph = "\\ud800-\\udfff", Ex = "\\u0300-\\u036f", gx = "\\ufe20-\\ufe2f", _x = "\\u20d0-\\u20ff", H0 = Ex + gx + _x, W0 = "\\u2700-\\u27bf", Y0 = "a-z\\xdf-\\xf6\\xf8-\\xff", Tx = "\\xac\\xb1\\xd7\\xf7", Ax = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", mx = "\\u2000-\\u206f", Ox = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", X0 = "A-Z\\xc0-\\xd6\\xd8-\\xde", z0 = "\\ufe0e\\ufe0f", K0 = Tx + Ax + mx + Ox, yf = "['’]", Ix = "[" + Ph + "]", Q0 = "[" + K0 + "]", bh = "[" + H0 + "]", Z0 = "\\d+", Sx = "[" + W0 + "]", q0 = "[" + Y0 + "]", j0 = "[^" + Ph + K0 + Z0 + W0 + Y0 + X0 + "]", Cf = "\\ud83c[\\udffb-\\udfff]", yx = "(?:" + bh + "|" + Cf + ")", J0 = "[^" + Ph + "]", Nf = "(?:\\ud83c[\\udde6-\\uddff]){2}", xf = "[\\ud800-\\udbff][\\udc00-\\udfff]", za = "[" + X0 + "]", $0 = "\\u200d", e_ = "(?:" + q0 + "|" + j0 + ")", Cx = "(?:" + za + "|" + j0 + ")", t_ = "(?:" + yf + "(?:d|ll|m|re|s|t|ve))?", n_ = "(?:" + yf + "(?:D|LL|M|RE|S|T|VE))?", s_ = yx + "?", i_ = "[" + z0 + "]?", Nx = "(?:" + $0 + "(?:" + [J0, Nf, xf].join("|") + ")" + i_ + s_ + ")*", xx = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", vx = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", r_ = i_ + s_ + Nx, Rx = "(?:" + [Sx, Nf, xf].join("|") + ")" + r_, wx = "(?:" + [J0 + bh + "?", bh, Nf, xf, Ix].join("|") + ")", Dx = RegExp(yf, "g"), Lx = RegExp(bh, "g"), vf = RegExp(Cf + "(?=" + Cf + ")|" + wx + r_, "g"), Mx = RegExp([
      za + "?" + q0 + "+" + t_ + "(?=" + [Q0, za, "$"].join("|") + ")",
      Cx + "+" + n_ + "(?=" + [Q0, za + e_, "$"].join("|") + ")",
      za + "?" + e_ + "+" + t_,
      za + "+" + n_,
      vx,
      xx,
      Z0,
      Rx
    ].join("|"), "g"), Px = RegExp("[" + $0 + Ph + H0 + z0 + "]"), bx = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Ux = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], Gx = -1, un = {};
    un[pr] = un[pf] = un[Ef] = un[gf] = un[_f] = un[Tf] = un[Af] = un[mf] = un[Of] = !0, un[Ke] = un[St] = un[na] = un[gt] = un[po] = un[Wn] = un[ls] = un[Ci] = un[Yn] = un[En] = un[Bn] = un[Lr] = un[Cs] = un[fr] = un[fo] = !1;
    var on = {};
    on[Ke] = on[St] = on[na] = on[po] = on[gt] = on[Wn] = on[pr] = on[pf] = on[Ef] = on[gf] = on[_f] = on[Yn] = on[En] = on[Bn] = on[Lr] = on[Cs] = on[fr] = on[zs] = on[Tf] = on[Af] = on[mf] = on[Of] = !0, on[ls] = on[Ci] = on[fo] = !1;
    var Fx = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, kx = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Bx = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Vx = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Hx = parseFloat, Wx = parseInt, o_ = typeof El == "object" && El && El.Object === Object && El, Yx = typeof self == "object" && self && self.Object === Object && self, hs = o_ || Yx || Function("return this")(), Rf = n && !n.nodeType && n, sa = Rf && !0 && e && !e.nodeType && e, a_ = sa && sa.exports === Rf, wf = a_ && o_.process, xi = function() {
      try {
        var W = sa && sa.require && sa.require("util").types;
        return W || wf && wf.binding && wf.binding("util");
      } catch {
      }
    }(), c_ = xi && xi.isArrayBuffer, l_ = xi && xi.isDate, h_ = xi && xi.isMap, u_ = xi && xi.isRegExp, d_ = xi && xi.isSet, f_ = xi && xi.isTypedArray;
    function ri(W, oe, j) {
      switch (j.length) {
        case 0:
          return W.call(oe);
        case 1:
          return W.call(oe, j[0]);
        case 2:
          return W.call(oe, j[0], j[1]);
        case 3:
          return W.call(oe, j[0], j[1], j[2]);
      }
      return W.apply(oe, j);
    }
    function Xx(W, oe, j, xe) {
      for (var rt = -1, bt = W == null ? 0 : W.length; ++rt < bt; ) {
        var Xn = W[rt];
        oe(xe, Xn, j(Xn), W);
      }
      return xe;
    }
    function vi(W, oe) {
      for (var j = -1, xe = W == null ? 0 : W.length; ++j < xe && oe(W[j], j, W) !== !1; )
        ;
      return W;
    }
    function zx(W, oe) {
      for (var j = W == null ? 0 : W.length; j-- && oe(W[j], j, W) !== !1; )
        ;
      return W;
    }
    function p_(W, oe) {
      for (var j = -1, xe = W == null ? 0 : W.length; ++j < xe; )
        if (!oe(W[j], j, W))
          return !1;
      return !0;
    }
    function Eo(W, oe) {
      for (var j = -1, xe = W == null ? 0 : W.length, rt = 0, bt = []; ++j < xe; ) {
        var Xn = W[j];
        oe(Xn, j, W) && (bt[rt++] = Xn);
      }
      return bt;
    }
    function Uh(W, oe) {
      var j = W == null ? 0 : W.length;
      return !!j && Ka(W, oe, 0) > -1;
    }
    function Df(W, oe, j) {
      for (var xe = -1, rt = W == null ? 0 : W.length; ++xe < rt; )
        if (j(oe, W[xe]))
          return !0;
      return !1;
    }
    function gn(W, oe) {
      for (var j = -1, xe = W == null ? 0 : W.length, rt = Array(xe); ++j < xe; )
        rt[j] = oe(W[j], j, W);
      return rt;
    }
    function go(W, oe) {
      for (var j = -1, xe = oe.length, rt = W.length; ++j < xe; )
        W[rt + j] = oe[j];
      return W;
    }
    function Lf(W, oe, j, xe) {
      var rt = -1, bt = W == null ? 0 : W.length;
      for (xe && bt && (j = W[++rt]); ++rt < bt; )
        j = oe(j, W[rt], rt, W);
      return j;
    }
    function Kx(W, oe, j, xe) {
      var rt = W == null ? 0 : W.length;
      for (xe && rt && (j = W[--rt]); rt--; )
        j = oe(j, W[rt], rt, W);
      return j;
    }
    function Mf(W, oe) {
      for (var j = -1, xe = W == null ? 0 : W.length; ++j < xe; )
        if (oe(W[j], j, W))
          return !0;
      return !1;
    }
    var Qx = Pf("length");
    function Zx(W) {
      return W.split("");
    }
    function qx(W) {
      return W.match(ix) || [];
    }
    function E_(W, oe, j) {
      var xe;
      return j(W, function(rt, bt, Xn) {
        if (oe(rt, bt, Xn))
          return xe = bt, !1;
      }), xe;
    }
    function Gh(W, oe, j, xe) {
      for (var rt = W.length, bt = j + (xe ? 1 : -1); xe ? bt-- : ++bt < rt; )
        if (oe(W[bt], bt, W))
          return bt;
      return -1;
    }
    function Ka(W, oe, j) {
      return oe === oe ? cv(W, oe, j) : Gh(W, g_, j);
    }
    function jx(W, oe, j, xe) {
      for (var rt = j - 1, bt = W.length; ++rt < bt; )
        if (xe(W[rt], oe))
          return rt;
      return -1;
    }
    function g_(W) {
      return W !== W;
    }
    function __(W, oe) {
      var j = W == null ? 0 : W.length;
      return j ? Uf(W, oe) / j : ie;
    }
    function Pf(W) {
      return function(oe) {
        return oe == null ? s : oe[W];
      };
    }
    function bf(W) {
      return function(oe) {
        return W == null ? s : W[oe];
      };
    }
    function T_(W, oe, j, xe, rt) {
      return rt(W, function(bt, Xn, en) {
        j = xe ? (xe = !1, bt) : oe(j, bt, Xn, en);
      }), j;
    }
    function Jx(W, oe) {
      var j = W.length;
      for (W.sort(oe); j--; )
        W[j] = W[j].value;
      return W;
    }
    function Uf(W, oe) {
      for (var j, xe = -1, rt = W.length; ++xe < rt; ) {
        var bt = oe(W[xe]);
        bt !== s && (j = j === s ? bt : j + bt);
      }
      return j;
    }
    function Gf(W, oe) {
      for (var j = -1, xe = Array(W); ++j < W; )
        xe[j] = oe(j);
      return xe;
    }
    function $x(W, oe) {
      return gn(oe, function(j) {
        return [j, W[j]];
      });
    }
    function A_(W) {
      return W && W.slice(0, S_(W) + 1).replace(Sf, "");
    }
    function oi(W) {
      return function(oe) {
        return W(oe);
      };
    }
    function Ff(W, oe) {
      return gn(oe, function(j) {
        return W[j];
      });
    }
    function Qc(W, oe) {
      return W.has(oe);
    }
    function m_(W, oe) {
      for (var j = -1, xe = W.length; ++j < xe && Ka(oe, W[j], 0) > -1; )
        ;
      return j;
    }
    function O_(W, oe) {
      for (var j = W.length; j-- && Ka(oe, W[j], 0) > -1; )
        ;
      return j;
    }
    function ev(W, oe) {
      for (var j = W.length, xe = 0; j--; )
        W[j] === oe && ++xe;
      return xe;
    }
    var tv = bf(Fx), nv = bf(kx);
    function sv(W) {
      return "\\" + Vx[W];
    }
    function iv(W, oe) {
      return W == null ? s : W[oe];
    }
    function Qa(W) {
      return Px.test(W);
    }
    function rv(W) {
      return bx.test(W);
    }
    function ov(W) {
      for (var oe, j = []; !(oe = W.next()).done; )
        j.push(oe.value);
      return j;
    }
    function kf(W) {
      var oe = -1, j = Array(W.size);
      return W.forEach(function(xe, rt) {
        j[++oe] = [rt, xe];
      }), j;
    }
    function I_(W, oe) {
      return function(j) {
        return W(oe(j));
      };
    }
    function _o(W, oe) {
      for (var j = -1, xe = W.length, rt = 0, bt = []; ++j < xe; ) {
        var Xn = W[j];
        (Xn === oe || Xn === d) && (W[j] = d, bt[rt++] = j);
      }
      return bt;
    }
    function Fh(W) {
      var oe = -1, j = Array(W.size);
      return W.forEach(function(xe) {
        j[++oe] = xe;
      }), j;
    }
    function av(W) {
      var oe = -1, j = Array(W.size);
      return W.forEach(function(xe) {
        j[++oe] = [xe, xe];
      }), j;
    }
    function cv(W, oe, j) {
      for (var xe = j - 1, rt = W.length; ++xe < rt; )
        if (W[xe] === oe)
          return xe;
      return -1;
    }
    function lv(W, oe, j) {
      for (var xe = j + 1; xe--; )
        if (W[xe] === oe)
          return xe;
      return xe;
    }
    function Za(W) {
      return Qa(W) ? uv(W) : Qx(W);
    }
    function Zi(W) {
      return Qa(W) ? dv(W) : Zx(W);
    }
    function S_(W) {
      for (var oe = W.length; oe-- && ex.test(W.charAt(oe)); )
        ;
      return oe;
    }
    var hv = bf(Bx);
    function uv(W) {
      for (var oe = vf.lastIndex = 0; vf.test(W); )
        ++oe;
      return oe;
    }
    function dv(W) {
      return W.match(vf) || [];
    }
    function fv(W) {
      return W.match(Mx) || [];
    }
    var pv = function W(oe) {
      oe = oe == null ? hs : qa.defaults(hs.Object(), oe, qa.pick(hs, Ux));
      var j = oe.Array, xe = oe.Date, rt = oe.Error, bt = oe.Function, Xn = oe.Math, en = oe.Object, Bf = oe.RegExp, Ev = oe.String, Ri = oe.TypeError, kh = j.prototype, gv = bt.prototype, ja = en.prototype, Bh = oe["__core-js_shared__"], Vh = gv.toString, Wt = ja.hasOwnProperty, _v = 0, y_ = function() {
        var u = /[^.]+$/.exec(Bh && Bh.keys && Bh.keys.IE_PROTO || "");
        return u ? "Symbol(src)_1." + u : "";
      }(), Hh = ja.toString, Tv = Vh.call(en), Av = hs._, mv = Bf(
        "^" + Vh.call(Wt).replace(If, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Wh = a_ ? oe.Buffer : s, To = oe.Symbol, Yh = oe.Uint8Array, C_ = Wh ? Wh.allocUnsafe : s, Xh = I_(en.getPrototypeOf, en), N_ = en.create, x_ = ja.propertyIsEnumerable, zh = kh.splice, v_ = To ? To.isConcatSpreadable : s, Zc = To ? To.iterator : s, ia = To ? To.toStringTag : s, Kh = function() {
        try {
          var u = la(en, "defineProperty");
          return u({}, "", {}), u;
        } catch {
        }
      }(), Ov = oe.clearTimeout !== hs.clearTimeout && oe.clearTimeout, Iv = xe && xe.now !== hs.Date.now && xe.now, Sv = oe.setTimeout !== hs.setTimeout && oe.setTimeout, Qh = Xn.ceil, Zh = Xn.floor, Vf = en.getOwnPropertySymbols, yv = Wh ? Wh.isBuffer : s, R_ = oe.isFinite, Cv = kh.join, Nv = I_(en.keys, en), zn = Xn.max, Ns = Xn.min, xv = xe.now, vv = oe.parseInt, w_ = Xn.random, Rv = kh.reverse, Hf = la(oe, "DataView"), qc = la(oe, "Map"), Wf = la(oe, "Promise"), Ja = la(oe, "Set"), jc = la(oe, "WeakMap"), Jc = la(en, "create"), qh = jc && new jc(), $a = {}, wv = ha(Hf), Dv = ha(qc), Lv = ha(Wf), Mv = ha(Ja), Pv = ha(jc), jh = To ? To.prototype : s, $c = jh ? jh.valueOf : s, D_ = jh ? jh.toString : s;
      function w(u) {
        if (Nn(u) && !ht(u) && !(u instanceof Ct)) {
          if (u instanceof wi)
            return u;
          if (Wt.call(u, "__wrapped__"))
            return LT(u);
        }
        return new wi(u);
      }
      var ec = /* @__PURE__ */ function() {
        function u() {
        }
        return function(f) {
          if (!In(f))
            return {};
          if (N_)
            return N_(f);
          u.prototype = f;
          var _ = new u();
          return u.prototype = s, _;
        };
      }();
      function Jh() {
      }
      function wi(u, f) {
        this.__wrapped__ = u, this.__actions__ = [], this.__chain__ = !!f, this.__index__ = 0, this.__values__ = s;
      }
      w.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: QN,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: ZN,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: B0,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: w
        }
      }, w.prototype = Jh.prototype, w.prototype.constructor = w, wi.prototype = ec(Jh.prototype), wi.prototype.constructor = wi;
      function Ct(u) {
        this.__wrapped__ = u, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = re, this.__views__ = [];
      }
      function bv() {
        var u = new Ct(this.__wrapped__);
        return u.__actions__ = Ks(this.__actions__), u.__dir__ = this.__dir__, u.__filtered__ = this.__filtered__, u.__iteratees__ = Ks(this.__iteratees__), u.__takeCount__ = this.__takeCount__, u.__views__ = Ks(this.__views__), u;
      }
      function Uv() {
        if (this.__filtered__) {
          var u = new Ct(this);
          u.__dir__ = -1, u.__filtered__ = !0;
        } else
          u = this.clone(), u.__dir__ *= -1;
        return u;
      }
      function Gv() {
        var u = this.__wrapped__.value(), f = this.__dir__, _ = ht(u), I = f < 0, x = _ ? u.length : 0, D = ZR(0, x, this.__views__), U = D.start, F = D.end, z = F - U, le = I ? F : U - 1, he = this.__iteratees__, de = he.length, me = 0, Pe = Ns(z, this.__takeCount__);
        if (!_ || !I && x == z && Pe == z)
          return tT(u, this.__actions__);
        var Qe = [];
        e:
          for (; z-- && me < Pe; ) {
            le += f;
            for (var _t = -1, Ze = u[le]; ++_t < de; ) {
              var yt = he[_t], vt = yt.iteratee, li = yt.type, Ls = vt(Ze);
              if (li == J)
                Ze = Ls;
              else if (!Ls) {
                if (li == V)
                  continue e;
                break e;
              }
            }
            Qe[me++] = Ze;
          }
        return Qe;
      }
      Ct.prototype = ec(Jh.prototype), Ct.prototype.constructor = Ct;
      function ra(u) {
        var f = -1, _ = u == null ? 0 : u.length;
        for (this.clear(); ++f < _; ) {
          var I = u[f];
          this.set(I[0], I[1]);
        }
      }
      function Fv() {
        this.__data__ = Jc ? Jc(null) : {}, this.size = 0;
      }
      function kv(u) {
        var f = this.has(u) && delete this.__data__[u];
        return this.size -= f ? 1 : 0, f;
      }
      function Bv(u) {
        var f = this.__data__;
        if (Jc) {
          var _ = f[u];
          return _ === l ? s : _;
        }
        return Wt.call(f, u) ? f[u] : s;
      }
      function Vv(u) {
        var f = this.__data__;
        return Jc ? f[u] !== s : Wt.call(f, u);
      }
      function Hv(u, f) {
        var _ = this.__data__;
        return this.size += this.has(u) ? 0 : 1, _[u] = Jc && f === s ? l : f, this;
      }
      ra.prototype.clear = Fv, ra.prototype.delete = kv, ra.prototype.get = Bv, ra.prototype.has = Vv, ra.prototype.set = Hv;
      function Mr(u) {
        var f = -1, _ = u == null ? 0 : u.length;
        for (this.clear(); ++f < _; ) {
          var I = u[f];
          this.set(I[0], I[1]);
        }
      }
      function Wv() {
        this.__data__ = [], this.size = 0;
      }
      function Yv(u) {
        var f = this.__data__, _ = $h(f, u);
        if (_ < 0)
          return !1;
        var I = f.length - 1;
        return _ == I ? f.pop() : zh.call(f, _, 1), --this.size, !0;
      }
      function Xv(u) {
        var f = this.__data__, _ = $h(f, u);
        return _ < 0 ? s : f[_][1];
      }
      function zv(u) {
        return $h(this.__data__, u) > -1;
      }
      function Kv(u, f) {
        var _ = this.__data__, I = $h(_, u);
        return I < 0 ? (++this.size, _.push([u, f])) : _[I][1] = f, this;
      }
      Mr.prototype.clear = Wv, Mr.prototype.delete = Yv, Mr.prototype.get = Xv, Mr.prototype.has = zv, Mr.prototype.set = Kv;
      function Pr(u) {
        var f = -1, _ = u == null ? 0 : u.length;
        for (this.clear(); ++f < _; ) {
          var I = u[f];
          this.set(I[0], I[1]);
        }
      }
      function Qv() {
        this.size = 0, this.__data__ = {
          hash: new ra(),
          map: new (qc || Mr)(),
          string: new ra()
        };
      }
      function Zv(u) {
        var f = uu(this, u).delete(u);
        return this.size -= f ? 1 : 0, f;
      }
      function qv(u) {
        return uu(this, u).get(u);
      }
      function jv(u) {
        return uu(this, u).has(u);
      }
      function Jv(u, f) {
        var _ = uu(this, u), I = _.size;
        return _.set(u, f), this.size += _.size == I ? 0 : 1, this;
      }
      Pr.prototype.clear = Qv, Pr.prototype.delete = Zv, Pr.prototype.get = qv, Pr.prototype.has = jv, Pr.prototype.set = Jv;
      function oa(u) {
        var f = -1, _ = u == null ? 0 : u.length;
        for (this.__data__ = new Pr(); ++f < _; )
          this.add(u[f]);
      }
      function $v(u) {
        return this.__data__.set(u, l), this;
      }
      function eR(u) {
        return this.__data__.has(u);
      }
      oa.prototype.add = oa.prototype.push = $v, oa.prototype.has = eR;
      function qi(u) {
        var f = this.__data__ = new Mr(u);
        this.size = f.size;
      }
      function tR() {
        this.__data__ = new Mr(), this.size = 0;
      }
      function nR(u) {
        var f = this.__data__, _ = f.delete(u);
        return this.size = f.size, _;
      }
      function sR(u) {
        return this.__data__.get(u);
      }
      function iR(u) {
        return this.__data__.has(u);
      }
      function rR(u, f) {
        var _ = this.__data__;
        if (_ instanceof Mr) {
          var I = _.__data__;
          if (!qc || I.length < r - 1)
            return I.push([u, f]), this.size = ++_.size, this;
          _ = this.__data__ = new Pr(I);
        }
        return _.set(u, f), this.size = _.size, this;
      }
      qi.prototype.clear = tR, qi.prototype.delete = nR, qi.prototype.get = sR, qi.prototype.has = iR, qi.prototype.set = rR;
      function L_(u, f) {
        var _ = ht(u), I = !_ && ua(u), x = !_ && !I && So(u), D = !_ && !I && !x && ic(u), U = _ || I || x || D, F = U ? Gf(u.length, Ev) : [], z = F.length;
        for (var le in u)
          (f || Wt.call(u, le)) && !(U && // Safari 9 has enumerable `arguments.length` in strict mode.
          (le == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          x && (le == "offset" || le == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          D && (le == "buffer" || le == "byteLength" || le == "byteOffset") || // Skip index properties.
          Fr(le, z))) && F.push(le);
        return F;
      }
      function M_(u) {
        var f = u.length;
        return f ? u[ep(0, f - 1)] : s;
      }
      function oR(u, f) {
        return du(Ks(u), aa(f, 0, u.length));
      }
      function aR(u) {
        return du(Ks(u));
      }
      function Yf(u, f, _) {
        (_ !== s && !ji(u[f], _) || _ === s && !(f in u)) && br(u, f, _);
      }
      function el(u, f, _) {
        var I = u[f];
        (!(Wt.call(u, f) && ji(I, _)) || _ === s && !(f in u)) && br(u, f, _);
      }
      function $h(u, f) {
        for (var _ = u.length; _--; )
          if (ji(u[_][0], f))
            return _;
        return -1;
      }
      function cR(u, f, _, I) {
        return Ao(u, function(x, D, U) {
          f(I, x, _(x), U);
        }), I;
      }
      function P_(u, f) {
        return u && gr(f, Jn(f), u);
      }
      function lR(u, f) {
        return u && gr(f, Zs(f), u);
      }
      function br(u, f, _) {
        f == "__proto__" && Kh ? Kh(u, f, {
          configurable: !0,
          enumerable: !0,
          value: _,
          writable: !0
        }) : u[f] = _;
      }
      function Xf(u, f) {
        for (var _ = -1, I = f.length, x = j(I), D = u == null; ++_ < I; )
          x[_] = D ? s : Cp(u, f[_]);
        return x;
      }
      function aa(u, f, _) {
        return u === u && (_ !== s && (u = u <= _ ? u : _), f !== s && (u = u >= f ? u : f)), u;
      }
      function Di(u, f, _, I, x, D) {
        var U, F = f & p, z = f & E, le = f & g;
        if (_ && (U = x ? _(u, I, x, D) : _(u)), U !== s)
          return U;
        if (!In(u))
          return u;
        var he = ht(u);
        if (he) {
          if (U = jR(u), !F)
            return Ks(u, U);
        } else {
          var de = xs(u), me = de == Ci || de == ho;
          if (So(u))
            return iT(u, F);
          if (de == Bn || de == Ke || me && !x) {
            if (U = z || me ? {} : ST(u), !F)
              return z ? BR(u, lR(U, u)) : kR(u, P_(U, u));
          } else {
            if (!on[de])
              return x ? u : {};
            U = JR(u, de, F);
          }
        }
        D || (D = new qi());
        var Pe = D.get(u);
        if (Pe)
          return Pe;
        D.set(u, U), JT(u) ? u.forEach(function(Ze) {
          U.add(Di(Ze, f, _, Ze, u, D));
        }) : qT(u) && u.forEach(function(Ze, yt) {
          U.set(yt, Di(Ze, f, _, yt, u, D));
        });
        var Qe = le ? z ? up : hp : z ? Zs : Jn, _t = he ? s : Qe(u);
        return vi(_t || u, function(Ze, yt) {
          _t && (yt = Ze, Ze = u[yt]), el(U, yt, Di(Ze, f, _, yt, u, D));
        }), U;
      }
      function hR(u) {
        var f = Jn(u);
        return function(_) {
          return b_(_, u, f);
        };
      }
      function b_(u, f, _) {
        var I = _.length;
        if (u == null)
          return !I;
        for (u = en(u); I--; ) {
          var x = _[I], D = f[x], U = u[x];
          if (U === s && !(x in u) || !D(U))
            return !1;
        }
        return !0;
      }
      function U_(u, f, _) {
        if (typeof u != "function")
          throw new Ri(a);
        return al(function() {
          u.apply(s, _);
        }, f);
      }
      function tl(u, f, _, I) {
        var x = -1, D = Uh, U = !0, F = u.length, z = [], le = f.length;
        if (!F)
          return z;
        _ && (f = gn(f, oi(_))), I ? (D = Df, U = !1) : f.length >= r && (D = Qc, U = !1, f = new oa(f));
        e:
          for (; ++x < F; ) {
            var he = u[x], de = _ == null ? he : _(he);
            if (he = I || he !== 0 ? he : 0, U && de === de) {
              for (var me = le; me--; )
                if (f[me] === de)
                  continue e;
              z.push(he);
            } else D(f, de, I) || z.push(he);
          }
        return z;
      }
      var Ao = lT(Er), G_ = lT(Kf, !0);
      function uR(u, f) {
        var _ = !0;
        return Ao(u, function(I, x, D) {
          return _ = !!f(I, x, D), _;
        }), _;
      }
      function eu(u, f, _) {
        for (var I = -1, x = u.length; ++I < x; ) {
          var D = u[I], U = f(D);
          if (U != null && (F === s ? U === U && !ci(U) : _(U, F)))
            var F = U, z = D;
        }
        return z;
      }
      function dR(u, f, _, I) {
        var x = u.length;
        for (_ = Et(_), _ < 0 && (_ = -_ > x ? 0 : x + _), I = I === s || I > x ? x : Et(I), I < 0 && (I += x), I = _ > I ? 0 : eA(I); _ < I; )
          u[_++] = f;
        return u;
      }
      function F_(u, f) {
        var _ = [];
        return Ao(u, function(I, x, D) {
          f(I, x, D) && _.push(I);
        }), _;
      }
      function us(u, f, _, I, x) {
        var D = -1, U = u.length;
        for (_ || (_ = ew), x || (x = []); ++D < U; ) {
          var F = u[D];
          f > 0 && _(F) ? f > 1 ? us(F, f - 1, _, I, x) : go(x, F) : I || (x[x.length] = F);
        }
        return x;
      }
      var zf = hT(), k_ = hT(!0);
      function Er(u, f) {
        return u && zf(u, f, Jn);
      }
      function Kf(u, f) {
        return u && k_(u, f, Jn);
      }
      function tu(u, f) {
        return Eo(f, function(_) {
          return kr(u[_]);
        });
      }
      function ca(u, f) {
        f = Oo(f, u);
        for (var _ = 0, I = f.length; u != null && _ < I; )
          u = u[_r(f[_++])];
        return _ && _ == I ? u : s;
      }
      function B_(u, f, _) {
        var I = f(u);
        return ht(u) ? I : go(I, _(u));
      }
      function ws(u) {
        return u == null ? u === s ? uo : Ni : ia && ia in en(u) ? QR(u) : aw(u);
      }
      function Qf(u, f) {
        return u > f;
      }
      function fR(u, f) {
        return u != null && Wt.call(u, f);
      }
      function pR(u, f) {
        return u != null && f in en(u);
      }
      function ER(u, f, _) {
        return u >= Ns(f, _) && u < zn(f, _);
      }
      function Zf(u, f, _) {
        for (var I = _ ? Df : Uh, x = u[0].length, D = u.length, U = D, F = j(D), z = 1 / 0, le = []; U--; ) {
          var he = u[U];
          U && f && (he = gn(he, oi(f))), z = Ns(he.length, z), F[U] = !_ && (f || x >= 120 && he.length >= 120) ? new oa(U && he) : s;
        }
        he = u[0];
        var de = -1, me = F[0];
        e:
          for (; ++de < x && le.length < z; ) {
            var Pe = he[de], Qe = f ? f(Pe) : Pe;
            if (Pe = _ || Pe !== 0 ? Pe : 0, !(me ? Qc(me, Qe) : I(le, Qe, _))) {
              for (U = D; --U; ) {
                var _t = F[U];
                if (!(_t ? Qc(_t, Qe) : I(u[U], Qe, _)))
                  continue e;
              }
              me && me.push(Qe), le.push(Pe);
            }
          }
        return le;
      }
      function gR(u, f, _, I) {
        return Er(u, function(x, D, U) {
          f(I, _(x), D, U);
        }), I;
      }
      function nl(u, f, _) {
        f = Oo(f, u), u = xT(u, f);
        var I = u == null ? u : u[_r(Mi(f))];
        return I == null ? s : ri(I, u, _);
      }
      function V_(u) {
        return Nn(u) && ws(u) == Ke;
      }
      function _R(u) {
        return Nn(u) && ws(u) == na;
      }
      function TR(u) {
        return Nn(u) && ws(u) == Wn;
      }
      function sl(u, f, _, I, x) {
        return u === f ? !0 : u == null || f == null || !Nn(u) && !Nn(f) ? u !== u && f !== f : AR(u, f, _, I, sl, x);
      }
      function AR(u, f, _, I, x, D) {
        var U = ht(u), F = ht(f), z = U ? St : xs(u), le = F ? St : xs(f);
        z = z == Ke ? Bn : z, le = le == Ke ? Bn : le;
        var he = z == Bn, de = le == Bn, me = z == le;
        if (me && So(u)) {
          if (!So(f))
            return !1;
          U = !0, he = !1;
        }
        if (me && !he)
          return D || (D = new qi()), U || ic(u) ? mT(u, f, _, I, x, D) : zR(u, f, z, _, I, x, D);
        if (!(_ & T)) {
          var Pe = he && Wt.call(u, "__wrapped__"), Qe = de && Wt.call(f, "__wrapped__");
          if (Pe || Qe) {
            var _t = Pe ? u.value() : u, Ze = Qe ? f.value() : f;
            return D || (D = new qi()), x(_t, Ze, _, I, D);
          }
        }
        return me ? (D || (D = new qi()), KR(u, f, _, I, x, D)) : !1;
      }
      function mR(u) {
        return Nn(u) && xs(u) == Yn;
      }
      function qf(u, f, _, I) {
        var x = _.length, D = x, U = !I;
        if (u == null)
          return !D;
        for (u = en(u); x--; ) {
          var F = _[x];
          if (U && F[2] ? F[1] !== u[F[0]] : !(F[0] in u))
            return !1;
        }
        for (; ++x < D; ) {
          F = _[x];
          var z = F[0], le = u[z], he = F[1];
          if (U && F[2]) {
            if (le === s && !(z in u))
              return !1;
          } else {
            var de = new qi();
            if (I)
              var me = I(le, he, z, u, f, de);
            if (!(me === s ? sl(he, le, T | A, I, de) : me))
              return !1;
          }
        }
        return !0;
      }
      function H_(u) {
        if (!In(u) || nw(u))
          return !1;
        var f = kr(u) ? mv : hx;
        return f.test(ha(u));
      }
      function OR(u) {
        return Nn(u) && ws(u) == Lr;
      }
      function IR(u) {
        return Nn(u) && xs(u) == Cs;
      }
      function SR(u) {
        return Nn(u) && Tu(u.length) && !!un[ws(u)];
      }
      function W_(u) {
        return typeof u == "function" ? u : u == null ? qs : typeof u == "object" ? ht(u) ? z_(u[0], u[1]) : X_(u) : uA(u);
      }
      function jf(u) {
        if (!ol(u))
          return Nv(u);
        var f = [];
        for (var _ in en(u))
          Wt.call(u, _) && _ != "constructor" && f.push(_);
        return f;
      }
      function yR(u) {
        if (!In(u))
          return ow(u);
        var f = ol(u), _ = [];
        for (var I in u)
          I == "constructor" && (f || !Wt.call(u, I)) || _.push(I);
        return _;
      }
      function Jf(u, f) {
        return u < f;
      }
      function Y_(u, f) {
        var _ = -1, I = Qs(u) ? j(u.length) : [];
        return Ao(u, function(x, D, U) {
          I[++_] = f(x, D, U);
        }), I;
      }
      function X_(u) {
        var f = fp(u);
        return f.length == 1 && f[0][2] ? CT(f[0][0], f[0][1]) : function(_) {
          return _ === u || qf(_, u, f);
        };
      }
      function z_(u, f) {
        return Ep(u) && yT(f) ? CT(_r(u), f) : function(_) {
          var I = Cp(_, u);
          return I === s && I === f ? Np(_, u) : sl(f, I, T | A);
        };
      }
      function nu(u, f, _, I, x) {
        u !== f && zf(f, function(D, U) {
          if (x || (x = new qi()), In(D))
            CR(u, f, U, _, nu, I, x);
          else {
            var F = I ? I(_p(u, U), D, U + "", u, f, x) : s;
            F === s && (F = D), Yf(u, U, F);
          }
        }, Zs);
      }
      function CR(u, f, _, I, x, D, U) {
        var F = _p(u, _), z = _p(f, _), le = U.get(z);
        if (le) {
          Yf(u, _, le);
          return;
        }
        var he = D ? D(F, z, _ + "", u, f, U) : s, de = he === s;
        if (de) {
          var me = ht(z), Pe = !me && So(z), Qe = !me && !Pe && ic(z);
          he = z, me || Pe || Qe ? ht(F) ? he = F : Pn(F) ? he = Ks(F) : Pe ? (de = !1, he = iT(z, !0)) : Qe ? (de = !1, he = rT(z, !0)) : he = [] : cl(z) || ua(z) ? (he = F, ua(F) ? he = tA(F) : (!In(F) || kr(F)) && (he = ST(z))) : de = !1;
        }
        de && (U.set(z, he), x(he, z, I, D, U), U.delete(z)), Yf(u, _, he);
      }
      function K_(u, f) {
        var _ = u.length;
        if (_)
          return f += f < 0 ? _ : 0, Fr(f, _) ? u[f] : s;
      }
      function Q_(u, f, _) {
        f.length ? f = gn(f, function(D) {
          return ht(D) ? function(U) {
            return ca(U, D.length === 1 ? D[0] : D);
          } : D;
        }) : f = [qs];
        var I = -1;
        f = gn(f, oi(Ye()));
        var x = Y_(u, function(D, U, F) {
          var z = gn(f, function(le) {
            return le(D);
          });
          return { criteria: z, index: ++I, value: D };
        });
        return Jx(x, function(D, U) {
          return FR(D, U, _);
        });
      }
      function NR(u, f) {
        return Z_(u, f, function(_, I) {
          return Np(u, I);
        });
      }
      function Z_(u, f, _) {
        for (var I = -1, x = f.length, D = {}; ++I < x; ) {
          var U = f[I], F = ca(u, U);
          _(F, U) && il(D, Oo(U, u), F);
        }
        return D;
      }
      function xR(u) {
        return function(f) {
          return ca(f, u);
        };
      }
      function $f(u, f, _, I) {
        var x = I ? jx : Ka, D = -1, U = f.length, F = u;
        for (u === f && (f = Ks(f)), _ && (F = gn(u, oi(_))); ++D < U; )
          for (var z = 0, le = f[D], he = _ ? _(le) : le; (z = x(F, he, z, I)) > -1; )
            F !== u && zh.call(F, z, 1), zh.call(u, z, 1);
        return u;
      }
      function q_(u, f) {
        for (var _ = u ? f.length : 0, I = _ - 1; _--; ) {
          var x = f[_];
          if (_ == I || x !== D) {
            var D = x;
            Fr(x) ? zh.call(u, x, 1) : sp(u, x);
          }
        }
        return u;
      }
      function ep(u, f) {
        return u + Zh(w_() * (f - u + 1));
      }
      function vR(u, f, _, I) {
        for (var x = -1, D = zn(Qh((f - u) / (_ || 1)), 0), U = j(D); D--; )
          U[I ? D : ++x] = u, u += _;
        return U;
      }
      function tp(u, f) {
        var _ = "";
        if (!u || f < 1 || f > ue)
          return _;
        do
          f % 2 && (_ += u), f = Zh(f / 2), f && (u += u);
        while (f);
        return _;
      }
      function mt(u, f) {
        return Tp(NT(u, f, qs), u + "");
      }
      function RR(u) {
        return M_(rc(u));
      }
      function wR(u, f) {
        var _ = rc(u);
        return du(_, aa(f, 0, _.length));
      }
      function il(u, f, _, I) {
        if (!In(u))
          return u;
        f = Oo(f, u);
        for (var x = -1, D = f.length, U = D - 1, F = u; F != null && ++x < D; ) {
          var z = _r(f[x]), le = _;
          if (z === "__proto__" || z === "constructor" || z === "prototype")
            return u;
          if (x != U) {
            var he = F[z];
            le = I ? I(he, z, F) : s, le === s && (le = In(he) ? he : Fr(f[x + 1]) ? [] : {});
          }
          el(F, z, le), F = F[z];
        }
        return u;
      }
      var j_ = qh ? function(u, f) {
        return qh.set(u, f), u;
      } : qs, DR = Kh ? function(u, f) {
        return Kh(u, "toString", {
          configurable: !0,
          enumerable: !1,
          value: vp(f),
          writable: !0
        });
      } : qs;
      function LR(u) {
        return du(rc(u));
      }
      function Li(u, f, _) {
        var I = -1, x = u.length;
        f < 0 && (f = -f > x ? 0 : x + f), _ = _ > x ? x : _, _ < 0 && (_ += x), x = f > _ ? 0 : _ - f >>> 0, f >>>= 0;
        for (var D = j(x); ++I < x; )
          D[I] = u[I + f];
        return D;
      }
      function MR(u, f) {
        var _;
        return Ao(u, function(I, x, D) {
          return _ = f(I, x, D), !_;
        }), !!_;
      }
      function su(u, f, _) {
        var I = 0, x = u == null ? I : u.length;
        if (typeof f == "number" && f === f && x <= Ne) {
          for (; I < x; ) {
            var D = I + x >>> 1, U = u[D];
            U !== null && !ci(U) && (_ ? U <= f : U < f) ? I = D + 1 : x = D;
          }
          return x;
        }
        return np(u, f, qs, _);
      }
      function np(u, f, _, I) {
        var x = 0, D = u == null ? 0 : u.length;
        if (D === 0)
          return 0;
        f = _(f);
        for (var U = f !== f, F = f === null, z = ci(f), le = f === s; x < D; ) {
          var he = Zh((x + D) / 2), de = _(u[he]), me = de !== s, Pe = de === null, Qe = de === de, _t = ci(de);
          if (U)
            var Ze = I || Qe;
          else le ? Ze = Qe && (I || me) : F ? Ze = Qe && me && (I || !Pe) : z ? Ze = Qe && me && !Pe && (I || !_t) : Pe || _t ? Ze = !1 : Ze = I ? de <= f : de < f;
          Ze ? x = he + 1 : D = he;
        }
        return Ns(D, fe);
      }
      function J_(u, f) {
        for (var _ = -1, I = u.length, x = 0, D = []; ++_ < I; ) {
          var U = u[_], F = f ? f(U) : U;
          if (!_ || !ji(F, z)) {
            var z = F;
            D[x++] = U === 0 ? 0 : U;
          }
        }
        return D;
      }
      function $_(u) {
        return typeof u == "number" ? u : ci(u) ? ie : +u;
      }
      function ai(u) {
        if (typeof u == "string")
          return u;
        if (ht(u))
          return gn(u, ai) + "";
        if (ci(u))
          return D_ ? D_.call(u) : "";
        var f = u + "";
        return f == "0" && 1 / u == -1 / 0 ? "-0" : f;
      }
      function mo(u, f, _) {
        var I = -1, x = Uh, D = u.length, U = !0, F = [], z = F;
        if (_)
          U = !1, x = Df;
        else if (D >= r) {
          var le = f ? null : YR(u);
          if (le)
            return Fh(le);
          U = !1, x = Qc, z = new oa();
        } else
          z = f ? [] : F;
        e:
          for (; ++I < D; ) {
            var he = u[I], de = f ? f(he) : he;
            if (he = _ || he !== 0 ? he : 0, U && de === de) {
              for (var me = z.length; me--; )
                if (z[me] === de)
                  continue e;
              f && z.push(de), F.push(he);
            } else x(z, de, _) || (z !== F && z.push(de), F.push(he));
          }
        return F;
      }
      function sp(u, f) {
        return f = Oo(f, u), u = xT(u, f), u == null || delete u[_r(Mi(f))];
      }
      function eT(u, f, _, I) {
        return il(u, f, _(ca(u, f)), I);
      }
      function iu(u, f, _, I) {
        for (var x = u.length, D = I ? x : -1; (I ? D-- : ++D < x) && f(u[D], D, u); )
          ;
        return _ ? Li(u, I ? 0 : D, I ? D + 1 : x) : Li(u, I ? D + 1 : 0, I ? x : D);
      }
      function tT(u, f) {
        var _ = u;
        return _ instanceof Ct && (_ = _.value()), Lf(f, function(I, x) {
          return x.func.apply(x.thisArg, go([I], x.args));
        }, _);
      }
      function ip(u, f, _) {
        var I = u.length;
        if (I < 2)
          return I ? mo(u[0]) : [];
        for (var x = -1, D = j(I); ++x < I; )
          for (var U = u[x], F = -1; ++F < I; )
            F != x && (D[x] = tl(D[x] || U, u[F], f, _));
        return mo(us(D, 1), f, _);
      }
      function nT(u, f, _) {
        for (var I = -1, x = u.length, D = f.length, U = {}; ++I < x; ) {
          var F = I < D ? f[I] : s;
          _(U, u[I], F);
        }
        return U;
      }
      function rp(u) {
        return Pn(u) ? u : [];
      }
      function op(u) {
        return typeof u == "function" ? u : qs;
      }
      function Oo(u, f) {
        return ht(u) ? u : Ep(u, f) ? [u] : DT(Ft(u));
      }
      var PR = mt;
      function Io(u, f, _) {
        var I = u.length;
        return _ = _ === s ? I : _, !f && _ >= I ? u : Li(u, f, _);
      }
      var sT = Ov || function(u) {
        return hs.clearTimeout(u);
      };
      function iT(u, f) {
        if (f)
          return u.slice();
        var _ = u.length, I = C_ ? C_(_) : new u.constructor(_);
        return u.copy(I), I;
      }
      function ap(u) {
        var f = new u.constructor(u.byteLength);
        return new Yh(f).set(new Yh(u)), f;
      }
      function bR(u, f) {
        var _ = f ? ap(u.buffer) : u.buffer;
        return new u.constructor(_, u.byteOffset, u.byteLength);
      }
      function UR(u) {
        var f = new u.constructor(u.source, V0.exec(u));
        return f.lastIndex = u.lastIndex, f;
      }
      function GR(u) {
        return $c ? en($c.call(u)) : {};
      }
      function rT(u, f) {
        var _ = f ? ap(u.buffer) : u.buffer;
        return new u.constructor(_, u.byteOffset, u.length);
      }
      function oT(u, f) {
        if (u !== f) {
          var _ = u !== s, I = u === null, x = u === u, D = ci(u), U = f !== s, F = f === null, z = f === f, le = ci(f);
          if (!F && !le && !D && u > f || D && U && z && !F && !le || I && U && z || !_ && z || !x)
            return 1;
          if (!I && !D && !le && u < f || le && _ && x && !I && !D || F && _ && x || !U && x || !z)
            return -1;
        }
        return 0;
      }
      function FR(u, f, _) {
        for (var I = -1, x = u.criteria, D = f.criteria, U = x.length, F = _.length; ++I < U; ) {
          var z = oT(x[I], D[I]);
          if (z) {
            if (I >= F)
              return z;
            var le = _[I];
            return z * (le == "desc" ? -1 : 1);
          }
        }
        return u.index - f.index;
      }
      function aT(u, f, _, I) {
        for (var x = -1, D = u.length, U = _.length, F = -1, z = f.length, le = zn(D - U, 0), he = j(z + le), de = !I; ++F < z; )
          he[F] = f[F];
        for (; ++x < U; )
          (de || x < D) && (he[_[x]] = u[x]);
        for (; le--; )
          he[F++] = u[x++];
        return he;
      }
      function cT(u, f, _, I) {
        for (var x = -1, D = u.length, U = -1, F = _.length, z = -1, le = f.length, he = zn(D - F, 0), de = j(he + le), me = !I; ++x < he; )
          de[x] = u[x];
        for (var Pe = x; ++z < le; )
          de[Pe + z] = f[z];
        for (; ++U < F; )
          (me || x < D) && (de[Pe + _[U]] = u[x++]);
        return de;
      }
      function Ks(u, f) {
        var _ = -1, I = u.length;
        for (f || (f = j(I)); ++_ < I; )
          f[_] = u[_];
        return f;
      }
      function gr(u, f, _, I) {
        var x = !_;
        _ || (_ = {});
        for (var D = -1, U = f.length; ++D < U; ) {
          var F = f[D], z = I ? I(_[F], u[F], F, _, u) : s;
          z === s && (z = u[F]), x ? br(_, F, z) : el(_, F, z);
        }
        return _;
      }
      function kR(u, f) {
        return gr(u, pp(u), f);
      }
      function BR(u, f) {
        return gr(u, OT(u), f);
      }
      function ru(u, f) {
        return function(_, I) {
          var x = ht(_) ? Xx : cR, D = f ? f() : {};
          return x(_, u, Ye(I, 2), D);
        };
      }
      function tc(u) {
        return mt(function(f, _) {
          var I = -1, x = _.length, D = x > 1 ? _[x - 1] : s, U = x > 2 ? _[2] : s;
          for (D = u.length > 3 && typeof D == "function" ? (x--, D) : s, U && Ds(_[0], _[1], U) && (D = x < 3 ? s : D, x = 1), f = en(f); ++I < x; ) {
            var F = _[I];
            F && u(f, F, I, D);
          }
          return f;
        });
      }
      function lT(u, f) {
        return function(_, I) {
          if (_ == null)
            return _;
          if (!Qs(_))
            return u(_, I);
          for (var x = _.length, D = f ? x : -1, U = en(_); (f ? D-- : ++D < x) && I(U[D], D, U) !== !1; )
            ;
          return _;
        };
      }
      function hT(u) {
        return function(f, _, I) {
          for (var x = -1, D = en(f), U = I(f), F = U.length; F--; ) {
            var z = U[u ? F : ++x];
            if (_(D[z], z, D) === !1)
              break;
          }
          return f;
        };
      }
      function VR(u, f, _) {
        var I = f & m, x = rl(u);
        function D() {
          var U = this && this !== hs && this instanceof D ? x : u;
          return U.apply(I ? _ : this, arguments);
        }
        return D;
      }
      function uT(u) {
        return function(f) {
          f = Ft(f);
          var _ = Qa(f) ? Zi(f) : s, I = _ ? _[0] : f.charAt(0), x = _ ? Io(_, 1).join("") : f.slice(1);
          return I[u]() + x;
        };
      }
      function nc(u) {
        return function(f) {
          return Lf(lA(cA(f).replace(Dx, "")), u, "");
        };
      }
      function rl(u) {
        return function() {
          var f = arguments;
          switch (f.length) {
            case 0:
              return new u();
            case 1:
              return new u(f[0]);
            case 2:
              return new u(f[0], f[1]);
            case 3:
              return new u(f[0], f[1], f[2]);
            case 4:
              return new u(f[0], f[1], f[2], f[3]);
            case 5:
              return new u(f[0], f[1], f[2], f[3], f[4]);
            case 6:
              return new u(f[0], f[1], f[2], f[3], f[4], f[5]);
            case 7:
              return new u(f[0], f[1], f[2], f[3], f[4], f[5], f[6]);
          }
          var _ = ec(u.prototype), I = u.apply(_, f);
          return In(I) ? I : _;
        };
      }
      function HR(u, f, _) {
        var I = rl(u);
        function x() {
          for (var D = arguments.length, U = j(D), F = D, z = sc(x); F--; )
            U[F] = arguments[F];
          var le = D < 3 && U[0] !== z && U[D - 1] !== z ? [] : _o(U, z);
          if (D -= le.length, D < _)
            return gT(
              u,
              f,
              ou,
              x.placeholder,
              s,
              U,
              le,
              s,
              s,
              _ - D
            );
          var he = this && this !== hs && this instanceof x ? I : u;
          return ri(he, this, U);
        }
        return x;
      }
      function dT(u) {
        return function(f, _, I) {
          var x = en(f);
          if (!Qs(f)) {
            var D = Ye(_, 3);
            f = Jn(f), _ = function(F) {
              return D(x[F], F, x);
            };
          }
          var U = u(f, _, I);
          return U > -1 ? x[D ? f[U] : U] : s;
        };
      }
      function fT(u) {
        return Gr(function(f) {
          var _ = f.length, I = _, x = wi.prototype.thru;
          for (u && f.reverse(); I--; ) {
            var D = f[I];
            if (typeof D != "function")
              throw new Ri(a);
            if (x && !U && hu(D) == "wrapper")
              var U = new wi([], !0);
          }
          for (I = U ? I : _; ++I < _; ) {
            D = f[I];
            var F = hu(D), z = F == "wrapper" ? dp(D) : s;
            z && gp(z[0]) && z[1] == (L | y | R | P) && !z[4].length && z[9] == 1 ? U = U[hu(z[0])].apply(U, z[3]) : U = D.length == 1 && gp(D) ? U[F]() : U.thru(D);
          }
          return function() {
            var le = arguments, he = le[0];
            if (U && le.length == 1 && ht(he))
              return U.plant(he).value();
            for (var de = 0, me = _ ? f[de].apply(this, le) : he; ++de < _; )
              me = f[de].call(this, me);
            return me;
          };
        });
      }
      function ou(u, f, _, I, x, D, U, F, z, le) {
        var he = f & L, de = f & m, me = f & O, Pe = f & (y | v), Qe = f & k, _t = me ? s : rl(u);
        function Ze() {
          for (var yt = arguments.length, vt = j(yt), li = yt; li--; )
            vt[li] = arguments[li];
          if (Pe)
            var Ls = sc(Ze), hi = ev(vt, Ls);
          if (I && (vt = aT(vt, I, x, Pe)), D && (vt = cT(vt, D, U, Pe)), yt -= hi, Pe && yt < le) {
            var bn = _o(vt, Ls);
            return gT(
              u,
              f,
              ou,
              Ze.placeholder,
              _,
              vt,
              bn,
              F,
              z,
              le - yt
            );
          }
          var Ji = de ? _ : this, Vr = me ? Ji[u] : u;
          return yt = vt.length, F ? vt = cw(vt, F) : Qe && yt > 1 && vt.reverse(), he && z < yt && (vt.length = z), this && this !== hs && this instanceof Ze && (Vr = _t || rl(Vr)), Vr.apply(Ji, vt);
        }
        return Ze;
      }
      function pT(u, f) {
        return function(_, I) {
          return gR(_, u, f(I), {});
        };
      }
      function au(u, f) {
        return function(_, I) {
          var x;
          if (_ === s && I === s)
            return f;
          if (_ !== s && (x = _), I !== s) {
            if (x === s)
              return I;
            typeof _ == "string" || typeof I == "string" ? (_ = ai(_), I = ai(I)) : (_ = $_(_), I = $_(I)), x = u(_, I);
          }
          return x;
        };
      }
      function cp(u) {
        return Gr(function(f) {
          return f = gn(f, oi(Ye())), mt(function(_) {
            var I = this;
            return u(f, function(x) {
              return ri(x, I, _);
            });
          });
        });
      }
      function cu(u, f) {
        f = f === s ? " " : ai(f);
        var _ = f.length;
        if (_ < 2)
          return _ ? tp(f, u) : f;
        var I = tp(f, Qh(u / Za(f)));
        return Qa(f) ? Io(Zi(I), 0, u).join("") : I.slice(0, u);
      }
      function WR(u, f, _, I) {
        var x = f & m, D = rl(u);
        function U() {
          for (var F = -1, z = arguments.length, le = -1, he = I.length, de = j(he + z), me = this && this !== hs && this instanceof U ? D : u; ++le < he; )
            de[le] = I[le];
          for (; z--; )
            de[le++] = arguments[++F];
          return ri(me, x ? _ : this, de);
        }
        return U;
      }
      function ET(u) {
        return function(f, _, I) {
          return I && typeof I != "number" && Ds(f, _, I) && (_ = I = s), f = Br(f), _ === s ? (_ = f, f = 0) : _ = Br(_), I = I === s ? f < _ ? 1 : -1 : Br(I), vR(f, _, I, u);
        };
      }
      function lu(u) {
        return function(f, _) {
          return typeof f == "string" && typeof _ == "string" || (f = Pi(f), _ = Pi(_)), u(f, _);
        };
      }
      function gT(u, f, _, I, x, D, U, F, z, le) {
        var he = f & y, de = he ? U : s, me = he ? s : U, Pe = he ? D : s, Qe = he ? s : D;
        f |= he ? R : M, f &= ~(he ? M : R), f & S || (f &= -4);
        var _t = [
          u,
          f,
          x,
          Pe,
          de,
          Qe,
          me,
          F,
          z,
          le
        ], Ze = _.apply(s, _t);
        return gp(u) && vT(Ze, _t), Ze.placeholder = I, RT(Ze, u, f);
      }
      function lp(u) {
        var f = Xn[u];
        return function(_, I) {
          if (_ = Pi(_), I = I == null ? 0 : Ns(Et(I), 292), I && R_(_)) {
            var x = (Ft(_) + "e").split("e"), D = f(x[0] + "e" + (+x[1] + I));
            return x = (Ft(D) + "e").split("e"), +(x[0] + "e" + (+x[1] - I));
          }
          return f(_);
        };
      }
      var YR = Ja && 1 / Fh(new Ja([, -0]))[1] == ne ? function(u) {
        return new Ja(u);
      } : Dp;
      function _T(u) {
        return function(f) {
          var _ = xs(f);
          return _ == Yn ? kf(f) : _ == Cs ? av(f) : $x(f, u(f));
        };
      }
      function Ur(u, f, _, I, x, D, U, F) {
        var z = f & O;
        if (!z && typeof u != "function")
          throw new Ri(a);
        var le = I ? I.length : 0;
        if (le || (f &= -97, I = x = s), U = U === s ? U : zn(Et(U), 0), F = F === s ? F : Et(F), le -= x ? x.length : 0, f & M) {
          var he = I, de = x;
          I = x = s;
        }
        var me = z ? s : dp(u), Pe = [
          u,
          f,
          _,
          I,
          x,
          he,
          de,
          D,
          U,
          F
        ];
        if (me && rw(Pe, me), u = Pe[0], f = Pe[1], _ = Pe[2], I = Pe[3], x = Pe[4], F = Pe[9] = Pe[9] === s ? z ? 0 : u.length : zn(Pe[9] - le, 0), !F && f & (y | v) && (f &= -25), !f || f == m)
          var Qe = VR(u, f, _);
        else f == y || f == v ? Qe = HR(u, f, F) : (f == R || f == (m | R)) && !x.length ? Qe = WR(u, f, _, I) : Qe = ou.apply(s, Pe);
        var _t = me ? j_ : vT;
        return RT(_t(Qe, Pe), u, f);
      }
      function TT(u, f, _, I) {
        return u === s || ji(u, ja[_]) && !Wt.call(I, _) ? f : u;
      }
      function AT(u, f, _, I, x, D) {
        return In(u) && In(f) && (D.set(f, u), nu(u, f, s, AT, D), D.delete(f)), u;
      }
      function XR(u) {
        return cl(u) ? s : u;
      }
      function mT(u, f, _, I, x, D) {
        var U = _ & T, F = u.length, z = f.length;
        if (F != z && !(U && z > F))
          return !1;
        var le = D.get(u), he = D.get(f);
        if (le && he)
          return le == f && he == u;
        var de = -1, me = !0, Pe = _ & A ? new oa() : s;
        for (D.set(u, f), D.set(f, u); ++de < F; ) {
          var Qe = u[de], _t = f[de];
          if (I)
            var Ze = U ? I(_t, Qe, de, f, u, D) : I(Qe, _t, de, u, f, D);
          if (Ze !== s) {
            if (Ze)
              continue;
            me = !1;
            break;
          }
          if (Pe) {
            if (!Mf(f, function(yt, vt) {
              if (!Qc(Pe, vt) && (Qe === yt || x(Qe, yt, _, I, D)))
                return Pe.push(vt);
            })) {
              me = !1;
              break;
            }
          } else if (!(Qe === _t || x(Qe, _t, _, I, D))) {
            me = !1;
            break;
          }
        }
        return D.delete(u), D.delete(f), me;
      }
      function zR(u, f, _, I, x, D, U) {
        switch (_) {
          case po:
            if (u.byteLength != f.byteLength || u.byteOffset != f.byteOffset)
              return !1;
            u = u.buffer, f = f.buffer;
          case na:
            return !(u.byteLength != f.byteLength || !D(new Yh(u), new Yh(f)));
          case gt:
          case Wn:
          case En:
            return ji(+u, +f);
          case ls:
            return u.name == f.name && u.message == f.message;
          case Lr:
          case fr:
            return u == f + "";
          case Yn:
            var F = kf;
          case Cs:
            var z = I & T;
            if (F || (F = Fh), u.size != f.size && !z)
              return !1;
            var le = U.get(u);
            if (le)
              return le == f;
            I |= A, U.set(u, f);
            var he = mT(F(u), F(f), I, x, D, U);
            return U.delete(u), he;
          case zs:
            if ($c)
              return $c.call(u) == $c.call(f);
        }
        return !1;
      }
      function KR(u, f, _, I, x, D) {
        var U = _ & T, F = hp(u), z = F.length, le = hp(f), he = le.length;
        if (z != he && !U)
          return !1;
        for (var de = z; de--; ) {
          var me = F[de];
          if (!(U ? me in f : Wt.call(f, me)))
            return !1;
        }
        var Pe = D.get(u), Qe = D.get(f);
        if (Pe && Qe)
          return Pe == f && Qe == u;
        var _t = !0;
        D.set(u, f), D.set(f, u);
        for (var Ze = U; ++de < z; ) {
          me = F[de];
          var yt = u[me], vt = f[me];
          if (I)
            var li = U ? I(vt, yt, me, f, u, D) : I(yt, vt, me, u, f, D);
          if (!(li === s ? yt === vt || x(yt, vt, _, I, D) : li)) {
            _t = !1;
            break;
          }
          Ze || (Ze = me == "constructor");
        }
        if (_t && !Ze) {
          var Ls = u.constructor, hi = f.constructor;
          Ls != hi && "constructor" in u && "constructor" in f && !(typeof Ls == "function" && Ls instanceof Ls && typeof hi == "function" && hi instanceof hi) && (_t = !1);
        }
        return D.delete(u), D.delete(f), _t;
      }
      function Gr(u) {
        return Tp(NT(u, s, bT), u + "");
      }
      function hp(u) {
        return B_(u, Jn, pp);
      }
      function up(u) {
        return B_(u, Zs, OT);
      }
      var dp = qh ? function(u) {
        return qh.get(u);
      } : Dp;
      function hu(u) {
        for (var f = u.name + "", _ = $a[f], I = Wt.call($a, f) ? _.length : 0; I--; ) {
          var x = _[I], D = x.func;
          if (D == null || D == u)
            return x.name;
        }
        return f;
      }
      function sc(u) {
        var f = Wt.call(w, "placeholder") ? w : u;
        return f.placeholder;
      }
      function Ye() {
        var u = w.iteratee || Rp;
        return u = u === Rp ? W_ : u, arguments.length ? u(arguments[0], arguments[1]) : u;
      }
      function uu(u, f) {
        var _ = u.__data__;
        return tw(f) ? _[typeof f == "string" ? "string" : "hash"] : _.map;
      }
      function fp(u) {
        for (var f = Jn(u), _ = f.length; _--; ) {
          var I = f[_], x = u[I];
          f[_] = [I, x, yT(x)];
        }
        return f;
      }
      function la(u, f) {
        var _ = iv(u, f);
        return H_(_) ? _ : s;
      }
      function QR(u) {
        var f = Wt.call(u, ia), _ = u[ia];
        try {
          u[ia] = s;
          var I = !0;
        } catch {
        }
        var x = Hh.call(u);
        return I && (f ? u[ia] = _ : delete u[ia]), x;
      }
      var pp = Vf ? function(u) {
        return u == null ? [] : (u = en(u), Eo(Vf(u), function(f) {
          return x_.call(u, f);
        }));
      } : Lp, OT = Vf ? function(u) {
        for (var f = []; u; )
          go(f, pp(u)), u = Xh(u);
        return f;
      } : Lp, xs = ws;
      (Hf && xs(new Hf(new ArrayBuffer(1))) != po || qc && xs(new qc()) != Yn || Wf && xs(Wf.resolve()) != ys || Ja && xs(new Ja()) != Cs || jc && xs(new jc()) != fo) && (xs = function(u) {
        var f = ws(u), _ = f == Bn ? u.constructor : s, I = _ ? ha(_) : "";
        if (I)
          switch (I) {
            case wv:
              return po;
            case Dv:
              return Yn;
            case Lv:
              return ys;
            case Mv:
              return Cs;
            case Pv:
              return fo;
          }
        return f;
      });
      function ZR(u, f, _) {
        for (var I = -1, x = _.length; ++I < x; ) {
          var D = _[I], U = D.size;
          switch (D.type) {
            case "drop":
              u += U;
              break;
            case "dropRight":
              f -= U;
              break;
            case "take":
              f = Ns(f, u + U);
              break;
            case "takeRight":
              u = zn(u, f - U);
              break;
          }
        }
        return { start: u, end: f };
      }
      function qR(u) {
        var f = u.match(nx);
        return f ? f[1].split(sx) : [];
      }
      function IT(u, f, _) {
        f = Oo(f, u);
        for (var I = -1, x = f.length, D = !1; ++I < x; ) {
          var U = _r(f[I]);
          if (!(D = u != null && _(u, U)))
            break;
          u = u[U];
        }
        return D || ++I != x ? D : (x = u == null ? 0 : u.length, !!x && Tu(x) && Fr(U, x) && (ht(u) || ua(u)));
      }
      function jR(u) {
        var f = u.length, _ = new u.constructor(f);
        return f && typeof u[0] == "string" && Wt.call(u, "index") && (_.index = u.index, _.input = u.input), _;
      }
      function ST(u) {
        return typeof u.constructor == "function" && !ol(u) ? ec(Xh(u)) : {};
      }
      function JR(u, f, _) {
        var I = u.constructor;
        switch (f) {
          case na:
            return ap(u);
          case gt:
          case Wn:
            return new I(+u);
          case po:
            return bR(u, _);
          case pr:
          case pf:
          case Ef:
          case gf:
          case _f:
          case Tf:
          case Af:
          case mf:
          case Of:
            return rT(u, _);
          case Yn:
            return new I();
          case En:
          case fr:
            return new I(u);
          case Lr:
            return UR(u);
          case Cs:
            return new I();
          case zs:
            return GR(u);
        }
      }
      function $R(u, f) {
        var _ = f.length;
        if (!_)
          return u;
        var I = _ - 1;
        return f[I] = (_ > 1 ? "& " : "") + f[I], f = f.join(_ > 2 ? ", " : " "), u.replace(tx, `{
/* [wrapped with ` + f + `] */
`);
      }
      function ew(u) {
        return ht(u) || ua(u) || !!(v_ && u && u[v_]);
      }
      function Fr(u, f) {
        var _ = typeof u;
        return f = f ?? ue, !!f && (_ == "number" || _ != "symbol" && dx.test(u)) && u > -1 && u % 1 == 0 && u < f;
      }
      function Ds(u, f, _) {
        if (!In(_))
          return !1;
        var I = typeof f;
        return (I == "number" ? Qs(_) && Fr(f, _.length) : I == "string" && f in _) ? ji(_[f], u) : !1;
      }
      function Ep(u, f) {
        if (ht(u))
          return !1;
        var _ = typeof u;
        return _ == "number" || _ == "symbol" || _ == "boolean" || u == null || ci(u) ? !0 : jN.test(u) || !qN.test(u) || f != null && u in en(f);
      }
      function tw(u) {
        var f = typeof u;
        return f == "string" || f == "number" || f == "symbol" || f == "boolean" ? u !== "__proto__" : u === null;
      }
      function gp(u) {
        var f = hu(u), _ = w[f];
        if (typeof _ != "function" || !(f in Ct.prototype))
          return !1;
        if (u === _)
          return !0;
        var I = dp(_);
        return !!I && u === I[0];
      }
      function nw(u) {
        return !!y_ && y_ in u;
      }
      var sw = Bh ? kr : Mp;
      function ol(u) {
        var f = u && u.constructor, _ = typeof f == "function" && f.prototype || ja;
        return u === _;
      }
      function yT(u) {
        return u === u && !In(u);
      }
      function CT(u, f) {
        return function(_) {
          return _ == null ? !1 : _[u] === f && (f !== s || u in en(_));
        };
      }
      function iw(u) {
        var f = gu(u, function(I) {
          return _.size === h && _.clear(), I;
        }), _ = f.cache;
        return f;
      }
      function rw(u, f) {
        var _ = u[1], I = f[1], x = _ | I, D = x < (m | O | L), U = I == L && _ == y || I == L && _ == P && u[7].length <= f[8] || I == (L | P) && f[7].length <= f[8] && _ == y;
        if (!(D || U))
          return u;
        I & m && (u[2] = f[2], x |= _ & m ? 0 : S);
        var F = f[3];
        if (F) {
          var z = u[3];
          u[3] = z ? aT(z, F, f[4]) : F, u[4] = z ? _o(u[3], d) : f[4];
        }
        return F = f[5], F && (z = u[5], u[5] = z ? cT(z, F, f[6]) : F, u[6] = z ? _o(u[5], d) : f[6]), F = f[7], F && (u[7] = F), I & L && (u[8] = u[8] == null ? f[8] : Ns(u[8], f[8])), u[9] == null && (u[9] = f[9]), u[0] = f[0], u[1] = x, u;
      }
      function ow(u) {
        var f = [];
        if (u != null)
          for (var _ in en(u))
            f.push(_);
        return f;
      }
      function aw(u) {
        return Hh.call(u);
      }
      function NT(u, f, _) {
        return f = zn(f === s ? u.length - 1 : f, 0), function() {
          for (var I = arguments, x = -1, D = zn(I.length - f, 0), U = j(D); ++x < D; )
            U[x] = I[f + x];
          x = -1;
          for (var F = j(f + 1); ++x < f; )
            F[x] = I[x];
          return F[f] = _(U), ri(u, this, F);
        };
      }
      function xT(u, f) {
        return f.length < 2 ? u : ca(u, Li(f, 0, -1));
      }
      function cw(u, f) {
        for (var _ = u.length, I = Ns(f.length, _), x = Ks(u); I--; ) {
          var D = f[I];
          u[I] = Fr(D, _) ? x[D] : s;
        }
        return u;
      }
      function _p(u, f) {
        if (!(f === "constructor" && typeof u[f] == "function") && f != "__proto__")
          return u[f];
      }
      var vT = wT(j_), al = Sv || function(u, f) {
        return hs.setTimeout(u, f);
      }, Tp = wT(DR);
      function RT(u, f, _) {
        var I = f + "";
        return Tp(u, $R(I, lw(qR(I), _)));
      }
      function wT(u) {
        var f = 0, _ = 0;
        return function() {
          var I = xv(), x = K - (I - _);
          if (_ = I, x > 0) {
            if (++f >= X)
              return arguments[0];
          } else
            f = 0;
          return u.apply(s, arguments);
        };
      }
      function du(u, f) {
        var _ = -1, I = u.length, x = I - 1;
        for (f = f === s ? I : f; ++_ < f; ) {
          var D = ep(_, x), U = u[D];
          u[D] = u[_], u[_] = U;
        }
        return u.length = f, u;
      }
      var DT = iw(function(u) {
        var f = [];
        return u.charCodeAt(0) === 46 && f.push(""), u.replace(JN, function(_, I, x, D) {
          f.push(x ? D.replace(ox, "$1") : I || _);
        }), f;
      });
      function _r(u) {
        if (typeof u == "string" || ci(u))
          return u;
        var f = u + "";
        return f == "0" && 1 / u == -1 / 0 ? "-0" : f;
      }
      function ha(u) {
        if (u != null) {
          try {
            return Vh.call(u);
          } catch {
          }
          try {
            return u + "";
          } catch {
          }
        }
        return "";
      }
      function lw(u, f) {
        return vi(At, function(_) {
          var I = "_." + _[0];
          f & _[1] && !Uh(u, I) && u.push(I);
        }), u.sort();
      }
      function LT(u) {
        if (u instanceof Ct)
          return u.clone();
        var f = new wi(u.__wrapped__, u.__chain__);
        return f.__actions__ = Ks(u.__actions__), f.__index__ = u.__index__, f.__values__ = u.__values__, f;
      }
      function hw(u, f, _) {
        (_ ? Ds(u, f, _) : f === s) ? f = 1 : f = zn(Et(f), 0);
        var I = u == null ? 0 : u.length;
        if (!I || f < 1)
          return [];
        for (var x = 0, D = 0, U = j(Qh(I / f)); x < I; )
          U[D++] = Li(u, x, x += f);
        return U;
      }
      function uw(u) {
        for (var f = -1, _ = u == null ? 0 : u.length, I = 0, x = []; ++f < _; ) {
          var D = u[f];
          D && (x[I++] = D);
        }
        return x;
      }
      function dw() {
        var u = arguments.length;
        if (!u)
          return [];
        for (var f = j(u - 1), _ = arguments[0], I = u; I--; )
          f[I - 1] = arguments[I];
        return go(ht(_) ? Ks(_) : [_], us(f, 1));
      }
      var fw = mt(function(u, f) {
        return Pn(u) ? tl(u, us(f, 1, Pn, !0)) : [];
      }), pw = mt(function(u, f) {
        var _ = Mi(f);
        return Pn(_) && (_ = s), Pn(u) ? tl(u, us(f, 1, Pn, !0), Ye(_, 2)) : [];
      }), Ew = mt(function(u, f) {
        var _ = Mi(f);
        return Pn(_) && (_ = s), Pn(u) ? tl(u, us(f, 1, Pn, !0), s, _) : [];
      });
      function gw(u, f, _) {
        var I = u == null ? 0 : u.length;
        return I ? (f = _ || f === s ? 1 : Et(f), Li(u, f < 0 ? 0 : f, I)) : [];
      }
      function _w(u, f, _) {
        var I = u == null ? 0 : u.length;
        return I ? (f = _ || f === s ? 1 : Et(f), f = I - f, Li(u, 0, f < 0 ? 0 : f)) : [];
      }
      function Tw(u, f) {
        return u && u.length ? iu(u, Ye(f, 3), !0, !0) : [];
      }
      function Aw(u, f) {
        return u && u.length ? iu(u, Ye(f, 3), !0) : [];
      }
      function mw(u, f, _, I) {
        var x = u == null ? 0 : u.length;
        return x ? (_ && typeof _ != "number" && Ds(u, f, _) && (_ = 0, I = x), dR(u, f, _, I)) : [];
      }
      function MT(u, f, _) {
        var I = u == null ? 0 : u.length;
        if (!I)
          return -1;
        var x = _ == null ? 0 : Et(_);
        return x < 0 && (x = zn(I + x, 0)), Gh(u, Ye(f, 3), x);
      }
      function PT(u, f, _) {
        var I = u == null ? 0 : u.length;
        if (!I)
          return -1;
        var x = I - 1;
        return _ !== s && (x = Et(_), x = _ < 0 ? zn(I + x, 0) : Ns(x, I - 1)), Gh(u, Ye(f, 3), x, !0);
      }
      function bT(u) {
        var f = u == null ? 0 : u.length;
        return f ? us(u, 1) : [];
      }
      function Ow(u) {
        var f = u == null ? 0 : u.length;
        return f ? us(u, ne) : [];
      }
      function Iw(u, f) {
        var _ = u == null ? 0 : u.length;
        return _ ? (f = f === s ? 1 : Et(f), us(u, f)) : [];
      }
      function Sw(u) {
        for (var f = -1, _ = u == null ? 0 : u.length, I = {}; ++f < _; ) {
          var x = u[f];
          I[x[0]] = x[1];
        }
        return I;
      }
      function UT(u) {
        return u && u.length ? u[0] : s;
      }
      function yw(u, f, _) {
        var I = u == null ? 0 : u.length;
        if (!I)
          return -1;
        var x = _ == null ? 0 : Et(_);
        return x < 0 && (x = zn(I + x, 0)), Ka(u, f, x);
      }
      function Cw(u) {
        var f = u == null ? 0 : u.length;
        return f ? Li(u, 0, -1) : [];
      }
      var Nw = mt(function(u) {
        var f = gn(u, rp);
        return f.length && f[0] === u[0] ? Zf(f) : [];
      }), xw = mt(function(u) {
        var f = Mi(u), _ = gn(u, rp);
        return f === Mi(_) ? f = s : _.pop(), _.length && _[0] === u[0] ? Zf(_, Ye(f, 2)) : [];
      }), vw = mt(function(u) {
        var f = Mi(u), _ = gn(u, rp);
        return f = typeof f == "function" ? f : s, f && _.pop(), _.length && _[0] === u[0] ? Zf(_, s, f) : [];
      });
      function Rw(u, f) {
        return u == null ? "" : Cv.call(u, f);
      }
      function Mi(u) {
        var f = u == null ? 0 : u.length;
        return f ? u[f - 1] : s;
      }
      function ww(u, f, _) {
        var I = u == null ? 0 : u.length;
        if (!I)
          return -1;
        var x = I;
        return _ !== s && (x = Et(_), x = x < 0 ? zn(I + x, 0) : Ns(x, I - 1)), f === f ? lv(u, f, x) : Gh(u, g_, x, !0);
      }
      function Dw(u, f) {
        return u && u.length ? K_(u, Et(f)) : s;
      }
      var Lw = mt(GT);
      function GT(u, f) {
        return u && u.length && f && f.length ? $f(u, f) : u;
      }
      function Mw(u, f, _) {
        return u && u.length && f && f.length ? $f(u, f, Ye(_, 2)) : u;
      }
      function Pw(u, f, _) {
        return u && u.length && f && f.length ? $f(u, f, s, _) : u;
      }
      var bw = Gr(function(u, f) {
        var _ = u == null ? 0 : u.length, I = Xf(u, f);
        return q_(u, gn(f, function(x) {
          return Fr(x, _) ? +x : x;
        }).sort(oT)), I;
      });
      function Uw(u, f) {
        var _ = [];
        if (!(u && u.length))
          return _;
        var I = -1, x = [], D = u.length;
        for (f = Ye(f, 3); ++I < D; ) {
          var U = u[I];
          f(U, I, u) && (_.push(U), x.push(I));
        }
        return q_(u, x), _;
      }
      function Ap(u) {
        return u == null ? u : Rv.call(u);
      }
      function Gw(u, f, _) {
        var I = u == null ? 0 : u.length;
        return I ? (_ && typeof _ != "number" && Ds(u, f, _) ? (f = 0, _ = I) : (f = f == null ? 0 : Et(f), _ = _ === s ? I : Et(_)), Li(u, f, _)) : [];
      }
      function Fw(u, f) {
        return su(u, f);
      }
      function kw(u, f, _) {
        return np(u, f, Ye(_, 2));
      }
      function Bw(u, f) {
        var _ = u == null ? 0 : u.length;
        if (_) {
          var I = su(u, f);
          if (I < _ && ji(u[I], f))
            return I;
        }
        return -1;
      }
      function Vw(u, f) {
        return su(u, f, !0);
      }
      function Hw(u, f, _) {
        return np(u, f, Ye(_, 2), !0);
      }
      function Ww(u, f) {
        var _ = u == null ? 0 : u.length;
        if (_) {
          var I = su(u, f, !0) - 1;
          if (ji(u[I], f))
            return I;
        }
        return -1;
      }
      function Yw(u) {
        return u && u.length ? J_(u) : [];
      }
      function Xw(u, f) {
        return u && u.length ? J_(u, Ye(f, 2)) : [];
      }
      function zw(u) {
        var f = u == null ? 0 : u.length;
        return f ? Li(u, 1, f) : [];
      }
      function Kw(u, f, _) {
        return u && u.length ? (f = _ || f === s ? 1 : Et(f), Li(u, 0, f < 0 ? 0 : f)) : [];
      }
      function Qw(u, f, _) {
        var I = u == null ? 0 : u.length;
        return I ? (f = _ || f === s ? 1 : Et(f), f = I - f, Li(u, f < 0 ? 0 : f, I)) : [];
      }
      function Zw(u, f) {
        return u && u.length ? iu(u, Ye(f, 3), !1, !0) : [];
      }
      function qw(u, f) {
        return u && u.length ? iu(u, Ye(f, 3)) : [];
      }
      var jw = mt(function(u) {
        return mo(us(u, 1, Pn, !0));
      }), Jw = mt(function(u) {
        var f = Mi(u);
        return Pn(f) && (f = s), mo(us(u, 1, Pn, !0), Ye(f, 2));
      }), $w = mt(function(u) {
        var f = Mi(u);
        return f = typeof f == "function" ? f : s, mo(us(u, 1, Pn, !0), s, f);
      });
      function eD(u) {
        return u && u.length ? mo(u) : [];
      }
      function tD(u, f) {
        return u && u.length ? mo(u, Ye(f, 2)) : [];
      }
      function nD(u, f) {
        return f = typeof f == "function" ? f : s, u && u.length ? mo(u, s, f) : [];
      }
      function mp(u) {
        if (!(u && u.length))
          return [];
        var f = 0;
        return u = Eo(u, function(_) {
          if (Pn(_))
            return f = zn(_.length, f), !0;
        }), Gf(f, function(_) {
          return gn(u, Pf(_));
        });
      }
      function FT(u, f) {
        if (!(u && u.length))
          return [];
        var _ = mp(u);
        return f == null ? _ : gn(_, function(I) {
          return ri(f, s, I);
        });
      }
      var sD = mt(function(u, f) {
        return Pn(u) ? tl(u, f) : [];
      }), iD = mt(function(u) {
        return ip(Eo(u, Pn));
      }), rD = mt(function(u) {
        var f = Mi(u);
        return Pn(f) && (f = s), ip(Eo(u, Pn), Ye(f, 2));
      }), oD = mt(function(u) {
        var f = Mi(u);
        return f = typeof f == "function" ? f : s, ip(Eo(u, Pn), s, f);
      }), aD = mt(mp);
      function cD(u, f) {
        return nT(u || [], f || [], el);
      }
      function lD(u, f) {
        return nT(u || [], f || [], il);
      }
      var hD = mt(function(u) {
        var f = u.length, _ = f > 1 ? u[f - 1] : s;
        return _ = typeof _ == "function" ? (u.pop(), _) : s, FT(u, _);
      });
      function kT(u) {
        var f = w(u);
        return f.__chain__ = !0, f;
      }
      function uD(u, f) {
        return f(u), u;
      }
      function fu(u, f) {
        return f(u);
      }
      var dD = Gr(function(u) {
        var f = u.length, _ = f ? u[0] : 0, I = this.__wrapped__, x = function(D) {
          return Xf(D, u);
        };
        return f > 1 || this.__actions__.length || !(I instanceof Ct) || !Fr(_) ? this.thru(x) : (I = I.slice(_, +_ + (f ? 1 : 0)), I.__actions__.push({
          func: fu,
          args: [x],
          thisArg: s
        }), new wi(I, this.__chain__).thru(function(D) {
          return f && !D.length && D.push(s), D;
        }));
      });
      function fD() {
        return kT(this);
      }
      function pD() {
        return new wi(this.value(), this.__chain__);
      }
      function ED() {
        this.__values__ === s && (this.__values__ = $T(this.value()));
        var u = this.__index__ >= this.__values__.length, f = u ? s : this.__values__[this.__index__++];
        return { done: u, value: f };
      }
      function gD() {
        return this;
      }
      function _D(u) {
        for (var f, _ = this; _ instanceof Jh; ) {
          var I = LT(_);
          I.__index__ = 0, I.__values__ = s, f ? x.__wrapped__ = I : f = I;
          var x = I;
          _ = _.__wrapped__;
        }
        return x.__wrapped__ = u, f;
      }
      function TD() {
        var u = this.__wrapped__;
        if (u instanceof Ct) {
          var f = u;
          return this.__actions__.length && (f = new Ct(this)), f = f.reverse(), f.__actions__.push({
            func: fu,
            args: [Ap],
            thisArg: s
          }), new wi(f, this.__chain__);
        }
        return this.thru(Ap);
      }
      function AD() {
        return tT(this.__wrapped__, this.__actions__);
      }
      var mD = ru(function(u, f, _) {
        Wt.call(u, _) ? ++u[_] : br(u, _, 1);
      });
      function OD(u, f, _) {
        var I = ht(u) ? p_ : uR;
        return _ && Ds(u, f, _) && (f = s), I(u, Ye(f, 3));
      }
      function ID(u, f) {
        var _ = ht(u) ? Eo : F_;
        return _(u, Ye(f, 3));
      }
      var SD = dT(MT), yD = dT(PT);
      function CD(u, f) {
        return us(pu(u, f), 1);
      }
      function ND(u, f) {
        return us(pu(u, f), ne);
      }
      function xD(u, f, _) {
        return _ = _ === s ? 1 : Et(_), us(pu(u, f), _);
      }
      function BT(u, f) {
        var _ = ht(u) ? vi : Ao;
        return _(u, Ye(f, 3));
      }
      function VT(u, f) {
        var _ = ht(u) ? zx : G_;
        return _(u, Ye(f, 3));
      }
      var vD = ru(function(u, f, _) {
        Wt.call(u, _) ? u[_].push(f) : br(u, _, [f]);
      });
      function RD(u, f, _, I) {
        u = Qs(u) ? u : rc(u), _ = _ && !I ? Et(_) : 0;
        var x = u.length;
        return _ < 0 && (_ = zn(x + _, 0)), Au(u) ? _ <= x && u.indexOf(f, _) > -1 : !!x && Ka(u, f, _) > -1;
      }
      var wD = mt(function(u, f, _) {
        var I = -1, x = typeof f == "function", D = Qs(u) ? j(u.length) : [];
        return Ao(u, function(U) {
          D[++I] = x ? ri(f, U, _) : nl(U, f, _);
        }), D;
      }), DD = ru(function(u, f, _) {
        br(u, _, f);
      });
      function pu(u, f) {
        var _ = ht(u) ? gn : Y_;
        return _(u, Ye(f, 3));
      }
      function LD(u, f, _, I) {
        return u == null ? [] : (ht(f) || (f = f == null ? [] : [f]), _ = I ? s : _, ht(_) || (_ = _ == null ? [] : [_]), Q_(u, f, _));
      }
      var MD = ru(function(u, f, _) {
        u[_ ? 0 : 1].push(f);
      }, function() {
        return [[], []];
      });
      function PD(u, f, _) {
        var I = ht(u) ? Lf : T_, x = arguments.length < 3;
        return I(u, Ye(f, 4), _, x, Ao);
      }
      function bD(u, f, _) {
        var I = ht(u) ? Kx : T_, x = arguments.length < 3;
        return I(u, Ye(f, 4), _, x, G_);
      }
      function UD(u, f) {
        var _ = ht(u) ? Eo : F_;
        return _(u, _u(Ye(f, 3)));
      }
      function GD(u) {
        var f = ht(u) ? M_ : RR;
        return f(u);
      }
      function FD(u, f, _) {
        (_ ? Ds(u, f, _) : f === s) ? f = 1 : f = Et(f);
        var I = ht(u) ? oR : wR;
        return I(u, f);
      }
      function kD(u) {
        var f = ht(u) ? aR : LR;
        return f(u);
      }
      function BD(u) {
        if (u == null)
          return 0;
        if (Qs(u))
          return Au(u) ? Za(u) : u.length;
        var f = xs(u);
        return f == Yn || f == Cs ? u.size : jf(u).length;
      }
      function VD(u, f, _) {
        var I = ht(u) ? Mf : MR;
        return _ && Ds(u, f, _) && (f = s), I(u, Ye(f, 3));
      }
      var HD = mt(function(u, f) {
        if (u == null)
          return [];
        var _ = f.length;
        return _ > 1 && Ds(u, f[0], f[1]) ? f = [] : _ > 2 && Ds(f[0], f[1], f[2]) && (f = [f[0]]), Q_(u, us(f, 1), []);
      }), Eu = Iv || function() {
        return hs.Date.now();
      };
      function WD(u, f) {
        if (typeof f != "function")
          throw new Ri(a);
        return u = Et(u), function() {
          if (--u < 1)
            return f.apply(this, arguments);
        };
      }
      function HT(u, f, _) {
        return f = _ ? s : f, f = u && f == null ? u.length : f, Ur(u, L, s, s, s, s, f);
      }
      function WT(u, f) {
        var _;
        if (typeof f != "function")
          throw new Ri(a);
        return u = Et(u), function() {
          return --u > 0 && (_ = f.apply(this, arguments)), u <= 1 && (f = s), _;
        };
      }
      var Op = mt(function(u, f, _) {
        var I = m;
        if (_.length) {
          var x = _o(_, sc(Op));
          I |= R;
        }
        return Ur(u, I, f, _, x);
      }), YT = mt(function(u, f, _) {
        var I = m | O;
        if (_.length) {
          var x = _o(_, sc(YT));
          I |= R;
        }
        return Ur(f, I, u, _, x);
      });
      function XT(u, f, _) {
        f = _ ? s : f;
        var I = Ur(u, y, s, s, s, s, s, f);
        return I.placeholder = XT.placeholder, I;
      }
      function zT(u, f, _) {
        f = _ ? s : f;
        var I = Ur(u, v, s, s, s, s, s, f);
        return I.placeholder = zT.placeholder, I;
      }
      function KT(u, f, _) {
        var I, x, D, U, F, z, le = 0, he = !1, de = !1, me = !0;
        if (typeof u != "function")
          throw new Ri(a);
        f = Pi(f) || 0, In(_) && (he = !!_.leading, de = "maxWait" in _, D = de ? zn(Pi(_.maxWait) || 0, f) : D, me = "trailing" in _ ? !!_.trailing : me);
        function Pe(bn) {
          var Ji = I, Vr = x;
          return I = x = s, le = bn, U = u.apply(Vr, Ji), U;
        }
        function Qe(bn) {
          return le = bn, F = al(yt, f), he ? Pe(bn) : U;
        }
        function _t(bn) {
          var Ji = bn - z, Vr = bn - le, dA = f - Ji;
          return de ? Ns(dA, D - Vr) : dA;
        }
        function Ze(bn) {
          var Ji = bn - z, Vr = bn - le;
          return z === s || Ji >= f || Ji < 0 || de && Vr >= D;
        }
        function yt() {
          var bn = Eu();
          if (Ze(bn))
            return vt(bn);
          F = al(yt, _t(bn));
        }
        function vt(bn) {
          return F = s, me && I ? Pe(bn) : (I = x = s, U);
        }
        function li() {
          F !== s && sT(F), le = 0, I = z = x = F = s;
        }
        function Ls() {
          return F === s ? U : vt(Eu());
        }
        function hi() {
          var bn = Eu(), Ji = Ze(bn);
          if (I = arguments, x = this, z = bn, Ji) {
            if (F === s)
              return Qe(z);
            if (de)
              return sT(F), F = al(yt, f), Pe(z);
          }
          return F === s && (F = al(yt, f)), U;
        }
        return hi.cancel = li, hi.flush = Ls, hi;
      }
      var YD = mt(function(u, f) {
        return U_(u, 1, f);
      }), XD = mt(function(u, f, _) {
        return U_(u, Pi(f) || 0, _);
      });
      function zD(u) {
        return Ur(u, k);
      }
      function gu(u, f) {
        if (typeof u != "function" || f != null && typeof f != "function")
          throw new Ri(a);
        var _ = function() {
          var I = arguments, x = f ? f.apply(this, I) : I[0], D = _.cache;
          if (D.has(x))
            return D.get(x);
          var U = u.apply(this, I);
          return _.cache = D.set(x, U) || D, U;
        };
        return _.cache = new (gu.Cache || Pr)(), _;
      }
      gu.Cache = Pr;
      function _u(u) {
        if (typeof u != "function")
          throw new Ri(a);
        return function() {
          var f = arguments;
          switch (f.length) {
            case 0:
              return !u.call(this);
            case 1:
              return !u.call(this, f[0]);
            case 2:
              return !u.call(this, f[0], f[1]);
            case 3:
              return !u.call(this, f[0], f[1], f[2]);
          }
          return !u.apply(this, f);
        };
      }
      function KD(u) {
        return WT(2, u);
      }
      var QD = PR(function(u, f) {
        f = f.length == 1 && ht(f[0]) ? gn(f[0], oi(Ye())) : gn(us(f, 1), oi(Ye()));
        var _ = f.length;
        return mt(function(I) {
          for (var x = -1, D = Ns(I.length, _); ++x < D; )
            I[x] = f[x].call(this, I[x]);
          return ri(u, this, I);
        });
      }), Ip = mt(function(u, f) {
        var _ = _o(f, sc(Ip));
        return Ur(u, R, s, f, _);
      }), QT = mt(function(u, f) {
        var _ = _o(f, sc(QT));
        return Ur(u, M, s, f, _);
      }), ZD = Gr(function(u, f) {
        return Ur(u, P, s, s, s, f);
      });
      function qD(u, f) {
        if (typeof u != "function")
          throw new Ri(a);
        return f = f === s ? f : Et(f), mt(u, f);
      }
      function jD(u, f) {
        if (typeof u != "function")
          throw new Ri(a);
        return f = f == null ? 0 : zn(Et(f), 0), mt(function(_) {
          var I = _[f], x = Io(_, 0, f);
          return I && go(x, I), ri(u, this, x);
        });
      }
      function JD(u, f, _) {
        var I = !0, x = !0;
        if (typeof u != "function")
          throw new Ri(a);
        return In(_) && (I = "leading" in _ ? !!_.leading : I, x = "trailing" in _ ? !!_.trailing : x), KT(u, f, {
          leading: I,
          maxWait: f,
          trailing: x
        });
      }
      function $D(u) {
        return HT(u, 1);
      }
      function eL(u, f) {
        return Ip(op(f), u);
      }
      function tL() {
        if (!arguments.length)
          return [];
        var u = arguments[0];
        return ht(u) ? u : [u];
      }
      function nL(u) {
        return Di(u, g);
      }
      function sL(u, f) {
        return f = typeof f == "function" ? f : s, Di(u, g, f);
      }
      function iL(u) {
        return Di(u, p | g);
      }
      function rL(u, f) {
        return f = typeof f == "function" ? f : s, Di(u, p | g, f);
      }
      function oL(u, f) {
        return f == null || b_(u, f, Jn(f));
      }
      function ji(u, f) {
        return u === f || u !== u && f !== f;
      }
      var aL = lu(Qf), cL = lu(function(u, f) {
        return u >= f;
      }), ua = V_(/* @__PURE__ */ function() {
        return arguments;
      }()) ? V_ : function(u) {
        return Nn(u) && Wt.call(u, "callee") && !x_.call(u, "callee");
      }, ht = j.isArray, lL = c_ ? oi(c_) : _R;
      function Qs(u) {
        return u != null && Tu(u.length) && !kr(u);
      }
      function Pn(u) {
        return Nn(u) && Qs(u);
      }
      function hL(u) {
        return u === !0 || u === !1 || Nn(u) && ws(u) == gt;
      }
      var So = yv || Mp, uL = l_ ? oi(l_) : TR;
      function dL(u) {
        return Nn(u) && u.nodeType === 1 && !cl(u);
      }
      function fL(u) {
        if (u == null)
          return !0;
        if (Qs(u) && (ht(u) || typeof u == "string" || typeof u.splice == "function" || So(u) || ic(u) || ua(u)))
          return !u.length;
        var f = xs(u);
        if (f == Yn || f == Cs)
          return !u.size;
        if (ol(u))
          return !jf(u).length;
        for (var _ in u)
          if (Wt.call(u, _))
            return !1;
        return !0;
      }
      function pL(u, f) {
        return sl(u, f);
      }
      function EL(u, f, _) {
        _ = typeof _ == "function" ? _ : s;
        var I = _ ? _(u, f) : s;
        return I === s ? sl(u, f, s, _) : !!I;
      }
      function Sp(u) {
        if (!Nn(u))
          return !1;
        var f = ws(u);
        return f == ls || f == Xs || typeof u.message == "string" && typeof u.name == "string" && !cl(u);
      }
      function gL(u) {
        return typeof u == "number" && R_(u);
      }
      function kr(u) {
        if (!In(u))
          return !1;
        var f = ws(u);
        return f == Ci || f == ho || f == rn || f == Dr;
      }
      function ZT(u) {
        return typeof u == "number" && u == Et(u);
      }
      function Tu(u) {
        return typeof u == "number" && u > -1 && u % 1 == 0 && u <= ue;
      }
      function In(u) {
        var f = typeof u;
        return u != null && (f == "object" || f == "function");
      }
      function Nn(u) {
        return u != null && typeof u == "object";
      }
      var qT = h_ ? oi(h_) : mR;
      function _L(u, f) {
        return u === f || qf(u, f, fp(f));
      }
      function TL(u, f, _) {
        return _ = typeof _ == "function" ? _ : s, qf(u, f, fp(f), _);
      }
      function AL(u) {
        return jT(u) && u != +u;
      }
      function mL(u) {
        if (sw(u))
          throw new rt(o);
        return H_(u);
      }
      function OL(u) {
        return u === null;
      }
      function IL(u) {
        return u == null;
      }
      function jT(u) {
        return typeof u == "number" || Nn(u) && ws(u) == En;
      }
      function cl(u) {
        if (!Nn(u) || ws(u) != Bn)
          return !1;
        var f = Xh(u);
        if (f === null)
          return !0;
        var _ = Wt.call(f, "constructor") && f.constructor;
        return typeof _ == "function" && _ instanceof _ && Vh.call(_) == Tv;
      }
      var yp = u_ ? oi(u_) : OR;
      function SL(u) {
        return ZT(u) && u >= -9007199254740991 && u <= ue;
      }
      var JT = d_ ? oi(d_) : IR;
      function Au(u) {
        return typeof u == "string" || !ht(u) && Nn(u) && ws(u) == fr;
      }
      function ci(u) {
        return typeof u == "symbol" || Nn(u) && ws(u) == zs;
      }
      var ic = f_ ? oi(f_) : SR;
      function yL(u) {
        return u === s;
      }
      function CL(u) {
        return Nn(u) && xs(u) == fo;
      }
      function NL(u) {
        return Nn(u) && ws(u) == Lh;
      }
      var xL = lu(Jf), vL = lu(function(u, f) {
        return u <= f;
      });
      function $T(u) {
        if (!u)
          return [];
        if (Qs(u))
          return Au(u) ? Zi(u) : Ks(u);
        if (Zc && u[Zc])
          return ov(u[Zc]());
        var f = xs(u), _ = f == Yn ? kf : f == Cs ? Fh : rc;
        return _(u);
      }
      function Br(u) {
        if (!u)
          return u === 0 ? u : 0;
        if (u = Pi(u), u === ne || u === -1 / 0) {
          var f = u < 0 ? -1 : 1;
          return f * te;
        }
        return u === u ? u : 0;
      }
      function Et(u) {
        var f = Br(u), _ = f % 1;
        return f === f ? _ ? f - _ : f : 0;
      }
      function eA(u) {
        return u ? aa(Et(u), 0, re) : 0;
      }
      function Pi(u) {
        if (typeof u == "number")
          return u;
        if (ci(u))
          return ie;
        if (In(u)) {
          var f = typeof u.valueOf == "function" ? u.valueOf() : u;
          u = In(f) ? f + "" : f;
        }
        if (typeof u != "string")
          return u === 0 ? u : +u;
        u = A_(u);
        var _ = lx.test(u);
        return _ || ux.test(u) ? Wx(u.slice(2), _ ? 2 : 8) : cx.test(u) ? ie : +u;
      }
      function tA(u) {
        return gr(u, Zs(u));
      }
      function RL(u) {
        return u ? aa(Et(u), -9007199254740991, ue) : u === 0 ? u : 0;
      }
      function Ft(u) {
        return u == null ? "" : ai(u);
      }
      var wL = tc(function(u, f) {
        if (ol(f) || Qs(f)) {
          gr(f, Jn(f), u);
          return;
        }
        for (var _ in f)
          Wt.call(f, _) && el(u, _, f[_]);
      }), nA = tc(function(u, f) {
        gr(f, Zs(f), u);
      }), mu = tc(function(u, f, _, I) {
        gr(f, Zs(f), u, I);
      }), DL = tc(function(u, f, _, I) {
        gr(f, Jn(f), u, I);
      }), LL = Gr(Xf);
      function ML(u, f) {
        var _ = ec(u);
        return f == null ? _ : P_(_, f);
      }
      var PL = mt(function(u, f) {
        u = en(u);
        var _ = -1, I = f.length, x = I > 2 ? f[2] : s;
        for (x && Ds(f[0], f[1], x) && (I = 1); ++_ < I; )
          for (var D = f[_], U = Zs(D), F = -1, z = U.length; ++F < z; ) {
            var le = U[F], he = u[le];
            (he === s || ji(he, ja[le]) && !Wt.call(u, le)) && (u[le] = D[le]);
          }
        return u;
      }), bL = mt(function(u) {
        return u.push(s, AT), ri(sA, s, u);
      });
      function UL(u, f) {
        return E_(u, Ye(f, 3), Er);
      }
      function GL(u, f) {
        return E_(u, Ye(f, 3), Kf);
      }
      function FL(u, f) {
        return u == null ? u : zf(u, Ye(f, 3), Zs);
      }
      function kL(u, f) {
        return u == null ? u : k_(u, Ye(f, 3), Zs);
      }
      function BL(u, f) {
        return u && Er(u, Ye(f, 3));
      }
      function VL(u, f) {
        return u && Kf(u, Ye(f, 3));
      }
      function HL(u) {
        return u == null ? [] : tu(u, Jn(u));
      }
      function WL(u) {
        return u == null ? [] : tu(u, Zs(u));
      }
      function Cp(u, f, _) {
        var I = u == null ? s : ca(u, f);
        return I === s ? _ : I;
      }
      function YL(u, f) {
        return u != null && IT(u, f, fR);
      }
      function Np(u, f) {
        return u != null && IT(u, f, pR);
      }
      var XL = pT(function(u, f, _) {
        f != null && typeof f.toString != "function" && (f = Hh.call(f)), u[f] = _;
      }, vp(qs)), zL = pT(function(u, f, _) {
        f != null && typeof f.toString != "function" && (f = Hh.call(f)), Wt.call(u, f) ? u[f].push(_) : u[f] = [_];
      }, Ye), KL = mt(nl);
      function Jn(u) {
        return Qs(u) ? L_(u) : jf(u);
      }
      function Zs(u) {
        return Qs(u) ? L_(u, !0) : yR(u);
      }
      function QL(u, f) {
        var _ = {};
        return f = Ye(f, 3), Er(u, function(I, x, D) {
          br(_, f(I, x, D), I);
        }), _;
      }
      function ZL(u, f) {
        var _ = {};
        return f = Ye(f, 3), Er(u, function(I, x, D) {
          br(_, x, f(I, x, D));
        }), _;
      }
      var qL = tc(function(u, f, _) {
        nu(u, f, _);
      }), sA = tc(function(u, f, _, I) {
        nu(u, f, _, I);
      }), jL = Gr(function(u, f) {
        var _ = {};
        if (u == null)
          return _;
        var I = !1;
        f = gn(f, function(D) {
          return D = Oo(D, u), I || (I = D.length > 1), D;
        }), gr(u, up(u), _), I && (_ = Di(_, p | E | g, XR));
        for (var x = f.length; x--; )
          sp(_, f[x]);
        return _;
      });
      function JL(u, f) {
        return iA(u, _u(Ye(f)));
      }
      var $L = Gr(function(u, f) {
        return u == null ? {} : NR(u, f);
      });
      function iA(u, f) {
        if (u == null)
          return {};
        var _ = gn(up(u), function(I) {
          return [I];
        });
        return f = Ye(f), Z_(u, _, function(I, x) {
          return f(I, x[0]);
        });
      }
      function eM(u, f, _) {
        f = Oo(f, u);
        var I = -1, x = f.length;
        for (x || (x = 1, u = s); ++I < x; ) {
          var D = u == null ? s : u[_r(f[I])];
          D === s && (I = x, D = _), u = kr(D) ? D.call(u) : D;
        }
        return u;
      }
      function tM(u, f, _) {
        return u == null ? u : il(u, f, _);
      }
      function nM(u, f, _, I) {
        return I = typeof I == "function" ? I : s, u == null ? u : il(u, f, _, I);
      }
      var rA = _T(Jn), oA = _T(Zs);
      function sM(u, f, _) {
        var I = ht(u), x = I || So(u) || ic(u);
        if (f = Ye(f, 4), _ == null) {
          var D = u && u.constructor;
          x ? _ = I ? new D() : [] : In(u) ? _ = kr(D) ? ec(Xh(u)) : {} : _ = {};
        }
        return (x ? vi : Er)(u, function(U, F, z) {
          return f(_, U, F, z);
        }), _;
      }
      function iM(u, f) {
        return u == null ? !0 : sp(u, f);
      }
      function rM(u, f, _) {
        return u == null ? u : eT(u, f, op(_));
      }
      function oM(u, f, _, I) {
        return I = typeof I == "function" ? I : s, u == null ? u : eT(u, f, op(_), I);
      }
      function rc(u) {
        return u == null ? [] : Ff(u, Jn(u));
      }
      function aM(u) {
        return u == null ? [] : Ff(u, Zs(u));
      }
      function cM(u, f, _) {
        return _ === s && (_ = f, f = s), _ !== s && (_ = Pi(_), _ = _ === _ ? _ : 0), f !== s && (f = Pi(f), f = f === f ? f : 0), aa(Pi(u), f, _);
      }
      function lM(u, f, _) {
        return f = Br(f), _ === s ? (_ = f, f = 0) : _ = Br(_), u = Pi(u), ER(u, f, _);
      }
      function hM(u, f, _) {
        if (_ && typeof _ != "boolean" && Ds(u, f, _) && (f = _ = s), _ === s && (typeof f == "boolean" ? (_ = f, f = s) : typeof u == "boolean" && (_ = u, u = s)), u === s && f === s ? (u = 0, f = 1) : (u = Br(u), f === s ? (f = u, u = 0) : f = Br(f)), u > f) {
          var I = u;
          u = f, f = I;
        }
        if (_ || u % 1 || f % 1) {
          var x = w_();
          return Ns(u + x * (f - u + Hx("1e-" + ((x + "").length - 1))), f);
        }
        return ep(u, f);
      }
      var uM = nc(function(u, f, _) {
        return f = f.toLowerCase(), u + (_ ? aA(f) : f);
      });
      function aA(u) {
        return xp(Ft(u).toLowerCase());
      }
      function cA(u) {
        return u = Ft(u), u && u.replace(fx, tv).replace(Lx, "");
      }
      function dM(u, f, _) {
        u = Ft(u), f = ai(f);
        var I = u.length;
        _ = _ === s ? I : aa(Et(_), 0, I);
        var x = _;
        return _ -= f.length, _ >= 0 && u.slice(_, x) == f;
      }
      function fM(u) {
        return u = Ft(u), u && KN.test(u) ? u.replace(k0, nv) : u;
      }
      function pM(u) {
        return u = Ft(u), u && $N.test(u) ? u.replace(If, "\\$&") : u;
      }
      var EM = nc(function(u, f, _) {
        return u + (_ ? "-" : "") + f.toLowerCase();
      }), gM = nc(function(u, f, _) {
        return u + (_ ? " " : "") + f.toLowerCase();
      }), _M = uT("toLowerCase");
      function TM(u, f, _) {
        u = Ft(u), f = Et(f);
        var I = f ? Za(u) : 0;
        if (!f || I >= f)
          return u;
        var x = (f - I) / 2;
        return cu(Zh(x), _) + u + cu(Qh(x), _);
      }
      function AM(u, f, _) {
        u = Ft(u), f = Et(f);
        var I = f ? Za(u) : 0;
        return f && I < f ? u + cu(f - I, _) : u;
      }
      function mM(u, f, _) {
        u = Ft(u), f = Et(f);
        var I = f ? Za(u) : 0;
        return f && I < f ? cu(f - I, _) + u : u;
      }
      function OM(u, f, _) {
        return _ || f == null ? f = 0 : f && (f = +f), vv(Ft(u).replace(Sf, ""), f || 0);
      }
      function IM(u, f, _) {
        return (_ ? Ds(u, f, _) : f === s) ? f = 1 : f = Et(f), tp(Ft(u), f);
      }
      function SM() {
        var u = arguments, f = Ft(u[0]);
        return u.length < 3 ? f : f.replace(u[1], u[2]);
      }
      var yM = nc(function(u, f, _) {
        return u + (_ ? "_" : "") + f.toLowerCase();
      });
      function CM(u, f, _) {
        return _ && typeof _ != "number" && Ds(u, f, _) && (f = _ = s), _ = _ === s ? re : _ >>> 0, _ ? (u = Ft(u), u && (typeof f == "string" || f != null && !yp(f)) && (f = ai(f), !f && Qa(u)) ? Io(Zi(u), 0, _) : u.split(f, _)) : [];
      }
      var NM = nc(function(u, f, _) {
        return u + (_ ? " " : "") + xp(f);
      });
      function xM(u, f, _) {
        return u = Ft(u), _ = _ == null ? 0 : aa(Et(_), 0, u.length), f = ai(f), u.slice(_, _ + f.length) == f;
      }
      function vM(u, f, _) {
        var I = w.templateSettings;
        _ && Ds(u, f, _) && (f = s), u = Ft(u), f = mu({}, f, I, TT);
        var x = mu({}, f.imports, I.imports, TT), D = Jn(x), U = Ff(x, D), F, z, le = 0, he = f.interpolate || Mh, de = "__p += '", me = Bf(
          (f.escape || Mh).source + "|" + he.source + "|" + (he === B0 ? ax : Mh).source + "|" + (f.evaluate || Mh).source + "|$",
          "g"
        ), Pe = "//# sourceURL=" + (Wt.call(f, "sourceURL") ? (f.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Gx + "]") + `
`;
        u.replace(me, function(Ze, yt, vt, li, Ls, hi) {
          return vt || (vt = li), de += u.slice(le, hi).replace(px, sv), yt && (F = !0, de += `' +
__e(` + yt + `) +
'`), Ls && (z = !0, de += `';
` + Ls + `;
__p += '`), vt && (de += `' +
((__t = (` + vt + `)) == null ? '' : __t) +
'`), le = hi + Ze.length, Ze;
        }), de += `';
`;
        var Qe = Wt.call(f, "variable") && f.variable;
        if (!Qe)
          de = `with (obj) {
` + de + `
}
`;
        else if (rx.test(Qe))
          throw new rt(c);
        de = (z ? de.replace(WN, "") : de).replace(YN, "$1").replace(XN, "$1;"), de = "function(" + (Qe || "obj") + `) {
` + (Qe ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (F ? ", __e = _.escape" : "") + (z ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + de + `return __p
}`;
        var _t = hA(function() {
          return bt(D, Pe + "return " + de).apply(s, U);
        });
        if (_t.source = de, Sp(_t))
          throw _t;
        return _t;
      }
      function RM(u) {
        return Ft(u).toLowerCase();
      }
      function wM(u) {
        return Ft(u).toUpperCase();
      }
      function DM(u, f, _) {
        if (u = Ft(u), u && (_ || f === s))
          return A_(u);
        if (!u || !(f = ai(f)))
          return u;
        var I = Zi(u), x = Zi(f), D = m_(I, x), U = O_(I, x) + 1;
        return Io(I, D, U).join("");
      }
      function LM(u, f, _) {
        if (u = Ft(u), u && (_ || f === s))
          return u.slice(0, S_(u) + 1);
        if (!u || !(f = ai(f)))
          return u;
        var I = Zi(u), x = O_(I, Zi(f)) + 1;
        return Io(I, 0, x).join("");
      }
      function MM(u, f, _) {
        if (u = Ft(u), u && (_ || f === s))
          return u.replace(Sf, "");
        if (!u || !(f = ai(f)))
          return u;
        var I = Zi(u), x = m_(I, Zi(f));
        return Io(I, x).join("");
      }
      function PM(u, f) {
        var _ = Q, I = b;
        if (In(f)) {
          var x = "separator" in f ? f.separator : x;
          _ = "length" in f ? Et(f.length) : _, I = "omission" in f ? ai(f.omission) : I;
        }
        u = Ft(u);
        var D = u.length;
        if (Qa(u)) {
          var U = Zi(u);
          D = U.length;
        }
        if (_ >= D)
          return u;
        var F = _ - Za(I);
        if (F < 1)
          return I;
        var z = U ? Io(U, 0, F).join("") : u.slice(0, F);
        if (x === s)
          return z + I;
        if (U && (F += z.length - F), yp(x)) {
          if (u.slice(F).search(x)) {
            var le, he = z;
            for (x.global || (x = Bf(x.source, Ft(V0.exec(x)) + "g")), x.lastIndex = 0; le = x.exec(he); )
              var de = le.index;
            z = z.slice(0, de === s ? F : de);
          }
        } else if (u.indexOf(ai(x), F) != F) {
          var me = z.lastIndexOf(x);
          me > -1 && (z = z.slice(0, me));
        }
        return z + I;
      }
      function bM(u) {
        return u = Ft(u), u && zN.test(u) ? u.replace(F0, hv) : u;
      }
      var UM = nc(function(u, f, _) {
        return u + (_ ? " " : "") + f.toUpperCase();
      }), xp = uT("toUpperCase");
      function lA(u, f, _) {
        return u = Ft(u), f = _ ? s : f, f === s ? rv(u) ? fv(u) : qx(u) : u.match(f) || [];
      }
      var hA = mt(function(u, f) {
        try {
          return ri(u, s, f);
        } catch (_) {
          return Sp(_) ? _ : new rt(_);
        }
      }), GM = Gr(function(u, f) {
        return vi(f, function(_) {
          _ = _r(_), br(u, _, Op(u[_], u));
        }), u;
      });
      function FM(u) {
        var f = u == null ? 0 : u.length, _ = Ye();
        return u = f ? gn(u, function(I) {
          if (typeof I[1] != "function")
            throw new Ri(a);
          return [_(I[0]), I[1]];
        }) : [], mt(function(I) {
          for (var x = -1; ++x < f; ) {
            var D = u[x];
            if (ri(D[0], this, I))
              return ri(D[1], this, I);
          }
        });
      }
      function kM(u) {
        return hR(Di(u, p));
      }
      function vp(u) {
        return function() {
          return u;
        };
      }
      function BM(u, f) {
        return u == null || u !== u ? f : u;
      }
      var VM = fT(), HM = fT(!0);
      function qs(u) {
        return u;
      }
      function Rp(u) {
        return W_(typeof u == "function" ? u : Di(u, p));
      }
      function WM(u) {
        return X_(Di(u, p));
      }
      function YM(u, f) {
        return z_(u, Di(f, p));
      }
      var XM = mt(function(u, f) {
        return function(_) {
          return nl(_, u, f);
        };
      }), zM = mt(function(u, f) {
        return function(_) {
          return nl(u, _, f);
        };
      });
      function wp(u, f, _) {
        var I = Jn(f), x = tu(f, I);
        _ == null && !(In(f) && (x.length || !I.length)) && (_ = f, f = u, u = this, x = tu(f, Jn(f)));
        var D = !(In(_) && "chain" in _) || !!_.chain, U = kr(u);
        return vi(x, function(F) {
          var z = f[F];
          u[F] = z, U && (u.prototype[F] = function() {
            var le = this.__chain__;
            if (D || le) {
              var he = u(this.__wrapped__), de = he.__actions__ = Ks(this.__actions__);
              return de.push({ func: z, args: arguments, thisArg: u }), he.__chain__ = le, he;
            }
            return z.apply(u, go([this.value()], arguments));
          });
        }), u;
      }
      function KM() {
        return hs._ === this && (hs._ = Av), this;
      }
      function Dp() {
      }
      function QM(u) {
        return u = Et(u), mt(function(f) {
          return K_(f, u);
        });
      }
      var ZM = cp(gn), qM = cp(p_), jM = cp(Mf);
      function uA(u) {
        return Ep(u) ? Pf(_r(u)) : xR(u);
      }
      function JM(u) {
        return function(f) {
          return u == null ? s : ca(u, f);
        };
      }
      var $M = ET(), e2 = ET(!0);
      function Lp() {
        return [];
      }
      function Mp() {
        return !1;
      }
      function t2() {
        return {};
      }
      function n2() {
        return "";
      }
      function s2() {
        return !0;
      }
      function i2(u, f) {
        if (u = Et(u), u < 1 || u > ue)
          return [];
        var _ = re, I = Ns(u, re);
        f = Ye(f), u -= re;
        for (var x = Gf(I, f); ++_ < u; )
          f(_);
        return x;
      }
      function r2(u) {
        return ht(u) ? gn(u, _r) : ci(u) ? [u] : Ks(DT(Ft(u)));
      }
      function o2(u) {
        var f = ++_v;
        return Ft(u) + f;
      }
      var a2 = au(function(u, f) {
        return u + f;
      }, 0), c2 = lp("ceil"), l2 = au(function(u, f) {
        return u / f;
      }, 1), h2 = lp("floor");
      function u2(u) {
        return u && u.length ? eu(u, qs, Qf) : s;
      }
      function d2(u, f) {
        return u && u.length ? eu(u, Ye(f, 2), Qf) : s;
      }
      function f2(u) {
        return __(u, qs);
      }
      function p2(u, f) {
        return __(u, Ye(f, 2));
      }
      function E2(u) {
        return u && u.length ? eu(u, qs, Jf) : s;
      }
      function g2(u, f) {
        return u && u.length ? eu(u, Ye(f, 2), Jf) : s;
      }
      var _2 = au(function(u, f) {
        return u * f;
      }, 1), T2 = lp("round"), A2 = au(function(u, f) {
        return u - f;
      }, 0);
      function m2(u) {
        return u && u.length ? Uf(u, qs) : 0;
      }
      function O2(u, f) {
        return u && u.length ? Uf(u, Ye(f, 2)) : 0;
      }
      return w.after = WD, w.ary = HT, w.assign = wL, w.assignIn = nA, w.assignInWith = mu, w.assignWith = DL, w.at = LL, w.before = WT, w.bind = Op, w.bindAll = GM, w.bindKey = YT, w.castArray = tL, w.chain = kT, w.chunk = hw, w.compact = uw, w.concat = dw, w.cond = FM, w.conforms = kM, w.constant = vp, w.countBy = mD, w.create = ML, w.curry = XT, w.curryRight = zT, w.debounce = KT, w.defaults = PL, w.defaultsDeep = bL, w.defer = YD, w.delay = XD, w.difference = fw, w.differenceBy = pw, w.differenceWith = Ew, w.drop = gw, w.dropRight = _w, w.dropRightWhile = Tw, w.dropWhile = Aw, w.fill = mw, w.filter = ID, w.flatMap = CD, w.flatMapDeep = ND, w.flatMapDepth = xD, w.flatten = bT, w.flattenDeep = Ow, w.flattenDepth = Iw, w.flip = zD, w.flow = VM, w.flowRight = HM, w.fromPairs = Sw, w.functions = HL, w.functionsIn = WL, w.groupBy = vD, w.initial = Cw, w.intersection = Nw, w.intersectionBy = xw, w.intersectionWith = vw, w.invert = XL, w.invertBy = zL, w.invokeMap = wD, w.iteratee = Rp, w.keyBy = DD, w.keys = Jn, w.keysIn = Zs, w.map = pu, w.mapKeys = QL, w.mapValues = ZL, w.matches = WM, w.matchesProperty = YM, w.memoize = gu, w.merge = qL, w.mergeWith = sA, w.method = XM, w.methodOf = zM, w.mixin = wp, w.negate = _u, w.nthArg = QM, w.omit = jL, w.omitBy = JL, w.once = KD, w.orderBy = LD, w.over = ZM, w.overArgs = QD, w.overEvery = qM, w.overSome = jM, w.partial = Ip, w.partialRight = QT, w.partition = MD, w.pick = $L, w.pickBy = iA, w.property = uA, w.propertyOf = JM, w.pull = Lw, w.pullAll = GT, w.pullAllBy = Mw, w.pullAllWith = Pw, w.pullAt = bw, w.range = $M, w.rangeRight = e2, w.rearg = ZD, w.reject = UD, w.remove = Uw, w.rest = qD, w.reverse = Ap, w.sampleSize = FD, w.set = tM, w.setWith = nM, w.shuffle = kD, w.slice = Gw, w.sortBy = HD, w.sortedUniq = Yw, w.sortedUniqBy = Xw, w.split = CM, w.spread = jD, w.tail = zw, w.take = Kw, w.takeRight = Qw, w.takeRightWhile = Zw, w.takeWhile = qw, w.tap = uD, w.throttle = JD, w.thru = fu, w.toArray = $T, w.toPairs = rA, w.toPairsIn = oA, w.toPath = r2, w.toPlainObject = tA, w.transform = sM, w.unary = $D, w.union = jw, w.unionBy = Jw, w.unionWith = $w, w.uniq = eD, w.uniqBy = tD, w.uniqWith = nD, w.unset = iM, w.unzip = mp, w.unzipWith = FT, w.update = rM, w.updateWith = oM, w.values = rc, w.valuesIn = aM, w.without = sD, w.words = lA, w.wrap = eL, w.xor = iD, w.xorBy = rD, w.xorWith = oD, w.zip = aD, w.zipObject = cD, w.zipObjectDeep = lD, w.zipWith = hD, w.entries = rA, w.entriesIn = oA, w.extend = nA, w.extendWith = mu, wp(w, w), w.add = a2, w.attempt = hA, w.camelCase = uM, w.capitalize = aA, w.ceil = c2, w.clamp = cM, w.clone = nL, w.cloneDeep = iL, w.cloneDeepWith = rL, w.cloneWith = sL, w.conformsTo = oL, w.deburr = cA, w.defaultTo = BM, w.divide = l2, w.endsWith = dM, w.eq = ji, w.escape = fM, w.escapeRegExp = pM, w.every = OD, w.find = SD, w.findIndex = MT, w.findKey = UL, w.findLast = yD, w.findLastIndex = PT, w.findLastKey = GL, w.floor = h2, w.forEach = BT, w.forEachRight = VT, w.forIn = FL, w.forInRight = kL, w.forOwn = BL, w.forOwnRight = VL, w.get = Cp, w.gt = aL, w.gte = cL, w.has = YL, w.hasIn = Np, w.head = UT, w.identity = qs, w.includes = RD, w.indexOf = yw, w.inRange = lM, w.invoke = KL, w.isArguments = ua, w.isArray = ht, w.isArrayBuffer = lL, w.isArrayLike = Qs, w.isArrayLikeObject = Pn, w.isBoolean = hL, w.isBuffer = So, w.isDate = uL, w.isElement = dL, w.isEmpty = fL, w.isEqual = pL, w.isEqualWith = EL, w.isError = Sp, w.isFinite = gL, w.isFunction = kr, w.isInteger = ZT, w.isLength = Tu, w.isMap = qT, w.isMatch = _L, w.isMatchWith = TL, w.isNaN = AL, w.isNative = mL, w.isNil = IL, w.isNull = OL, w.isNumber = jT, w.isObject = In, w.isObjectLike = Nn, w.isPlainObject = cl, w.isRegExp = yp, w.isSafeInteger = SL, w.isSet = JT, w.isString = Au, w.isSymbol = ci, w.isTypedArray = ic, w.isUndefined = yL, w.isWeakMap = CL, w.isWeakSet = NL, w.join = Rw, w.kebabCase = EM, w.last = Mi, w.lastIndexOf = ww, w.lowerCase = gM, w.lowerFirst = _M, w.lt = xL, w.lte = vL, w.max = u2, w.maxBy = d2, w.mean = f2, w.meanBy = p2, w.min = E2, w.minBy = g2, w.stubArray = Lp, w.stubFalse = Mp, w.stubObject = t2, w.stubString = n2, w.stubTrue = s2, w.multiply = _2, w.nth = Dw, w.noConflict = KM, w.noop = Dp, w.now = Eu, w.pad = TM, w.padEnd = AM, w.padStart = mM, w.parseInt = OM, w.random = hM, w.reduce = PD, w.reduceRight = bD, w.repeat = IM, w.replace = SM, w.result = eM, w.round = T2, w.runInContext = W, w.sample = GD, w.size = BD, w.snakeCase = yM, w.some = VD, w.sortedIndex = Fw, w.sortedIndexBy = kw, w.sortedIndexOf = Bw, w.sortedLastIndex = Vw, w.sortedLastIndexBy = Hw, w.sortedLastIndexOf = Ww, w.startCase = NM, w.startsWith = xM, w.subtract = A2, w.sum = m2, w.sumBy = O2, w.template = vM, w.times = i2, w.toFinite = Br, w.toInteger = Et, w.toLength = eA, w.toLower = RM, w.toNumber = Pi, w.toSafeInteger = RL, w.toString = Ft, w.toUpper = wM, w.trim = DM, w.trimEnd = LM, w.trimStart = MM, w.truncate = PM, w.unescape = bM, w.uniqueId = o2, w.upperCase = UM, w.upperFirst = xp, w.each = BT, w.eachRight = VT, w.first = UT, wp(w, function() {
        var u = {};
        return Er(w, function(f, _) {
          Wt.call(w.prototype, _) || (u[_] = f);
        }), u;
      }(), { chain: !1 }), w.VERSION = i, vi(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(u) {
        w[u].placeholder = w;
      }), vi(["drop", "take"], function(u, f) {
        Ct.prototype[u] = function(_) {
          _ = _ === s ? 1 : zn(Et(_), 0);
          var I = this.__filtered__ && !f ? new Ct(this) : this.clone();
          return I.__filtered__ ? I.__takeCount__ = Ns(_, I.__takeCount__) : I.__views__.push({
            size: Ns(_, re),
            type: u + (I.__dir__ < 0 ? "Right" : "")
          }), I;
        }, Ct.prototype[u + "Right"] = function(_) {
          return this.reverse()[u](_).reverse();
        };
      }), vi(["filter", "map", "takeWhile"], function(u, f) {
        var _ = f + 1, I = _ == V || _ == ge;
        Ct.prototype[u] = function(x) {
          var D = this.clone();
          return D.__iteratees__.push({
            iteratee: Ye(x, 3),
            type: _
          }), D.__filtered__ = D.__filtered__ || I, D;
        };
      }), vi(["head", "last"], function(u, f) {
        var _ = "take" + (f ? "Right" : "");
        Ct.prototype[u] = function() {
          return this[_](1).value()[0];
        };
      }), vi(["initial", "tail"], function(u, f) {
        var _ = "drop" + (f ? "" : "Right");
        Ct.prototype[u] = function() {
          return this.__filtered__ ? new Ct(this) : this[_](1);
        };
      }), Ct.prototype.compact = function() {
        return this.filter(qs);
      }, Ct.prototype.find = function(u) {
        return this.filter(u).head();
      }, Ct.prototype.findLast = function(u) {
        return this.reverse().find(u);
      }, Ct.prototype.invokeMap = mt(function(u, f) {
        return typeof u == "function" ? new Ct(this) : this.map(function(_) {
          return nl(_, u, f);
        });
      }), Ct.prototype.reject = function(u) {
        return this.filter(_u(Ye(u)));
      }, Ct.prototype.slice = function(u, f) {
        u = Et(u);
        var _ = this;
        return _.__filtered__ && (u > 0 || f < 0) ? new Ct(_) : (u < 0 ? _ = _.takeRight(-u) : u && (_ = _.drop(u)), f !== s && (f = Et(f), _ = f < 0 ? _.dropRight(-f) : _.take(f - u)), _);
      }, Ct.prototype.takeRightWhile = function(u) {
        return this.reverse().takeWhile(u).reverse();
      }, Ct.prototype.toArray = function() {
        return this.take(re);
      }, Er(Ct.prototype, function(u, f) {
        var _ = /^(?:filter|find|map|reject)|While$/.test(f), I = /^(?:head|last)$/.test(f), x = w[I ? "take" + (f == "last" ? "Right" : "") : f], D = I || /^find/.test(f);
        x && (w.prototype[f] = function() {
          var U = this.__wrapped__, F = I ? [1] : arguments, z = U instanceof Ct, le = F[0], he = z || ht(U), de = function(yt) {
            var vt = x.apply(w, go([yt], F));
            return I && me ? vt[0] : vt;
          };
          he && _ && typeof le == "function" && le.length != 1 && (z = he = !1);
          var me = this.__chain__, Pe = !!this.__actions__.length, Qe = D && !me, _t = z && !Pe;
          if (!D && he) {
            U = _t ? U : new Ct(this);
            var Ze = u.apply(U, F);
            return Ze.__actions__.push({ func: fu, args: [de], thisArg: s }), new wi(Ze, me);
          }
          return Qe && _t ? u.apply(this, F) : (Ze = this.thru(de), Qe ? I ? Ze.value()[0] : Ze.value() : Ze);
        });
      }), vi(["pop", "push", "shift", "sort", "splice", "unshift"], function(u) {
        var f = kh[u], _ = /^(?:push|sort|unshift)$/.test(u) ? "tap" : "thru", I = /^(?:pop|shift)$/.test(u);
        w.prototype[u] = function() {
          var x = arguments;
          if (I && !this.__chain__) {
            var D = this.value();
            return f.apply(ht(D) ? D : [], x);
          }
          return this[_](function(U) {
            return f.apply(ht(U) ? U : [], x);
          });
        };
      }), Er(Ct.prototype, function(u, f) {
        var _ = w[f];
        if (_) {
          var I = _.name + "";
          Wt.call($a, I) || ($a[I] = []), $a[I].push({ name: f, func: _ });
        }
      }), $a[ou(s, O).name] = [{
        name: "wrapper",
        func: s
      }], Ct.prototype.clone = bv, Ct.prototype.reverse = Uv, Ct.prototype.value = Gv, w.prototype.at = dD, w.prototype.chain = fD, w.prototype.commit = pD, w.prototype.next = ED, w.prototype.plant = _D, w.prototype.reverse = TD, w.prototype.toJSON = w.prototype.valueOf = w.prototype.value = AD, w.prototype.first = w.prototype.head, Zc && (w.prototype[Zc] = gD), w;
    }, qa = pv();
    sa ? ((sa.exports = qa)._ = qa, Rf._ = qa) : hs._ = qa;
  }).call(El);
})(Od, Od.exports);
var Gb = Od.exports, Id;
(function(e) {
  e.LEFT = "left", e.RIGHT = "right";
})(Id || (Id = {}));
var Sd;
(function(e) {
  e.LEFT = "v", e.RIGHT = "w";
})(Sd || (Sd = {}));
Id.LEFT + "", Sd.LEFT, Id.RIGHT + "", Sd.RIGHT;
/*! https://mths.be/codepointat v0.2.0 by @mathias */
String.prototype.codePointAt || function() {
  var e = function() {
    try {
      var s = {}, i = Object.defineProperty, r = i(s, s, s) && i;
    } catch {
    }
    return r;
  }(), n = function(s) {
    if (this == null)
      throw TypeError();
    var i = String(this), r = i.length, o = s ? Number(s) : 0;
    if (o != o && (o = 0), !(o < 0 || o >= r)) {
      var a = i.charCodeAt(o), c;
      return (
        // check if it’s the start of a surrogate pair
        a >= 55296 && a <= 56319 && // high surrogate
        r > o + 1 && (c = i.charCodeAt(o + 1), c >= 56320 && c <= 57343) ? (a - 55296) * 1024 + c - 56320 + 65536 : a
      );
    }
  };
  e ? e(String.prototype, "codePointAt", {
    value: n,
    configurable: !0,
    writable: !0
  }) : String.prototype.codePointAt = n;
}();
function j1() {
  this.table = new Uint16Array(16), this.trans = new Uint16Array(288);
}
var Fb = new j1(), kb = new j1(), J1 = new Uint8Array(30), $1 = new Uint16Array(30), Bb = new Uint8Array(30), Vb = new Uint16Array(30);
function ey(e, n, s, i) {
  var r, o;
  for (r = 0; r < s; ++r)
    e[r] = 0;
  for (r = 0; r < 30 - s; ++r)
    e[r + s] = r / s | 0;
  for (o = i, r = 0; r < 30; ++r)
    n[r] = o, o += 1 << e[r];
}
function Hb(e, n) {
  var s;
  for (s = 0; s < 7; ++s)
    e.table[s] = 0;
  for (e.table[7] = 24, e.table[8] = 152, e.table[9] = 112, s = 0; s < 24; ++s)
    e.trans[s] = 256 + s;
  for (s = 0; s < 144; ++s)
    e.trans[24 + s] = s;
  for (s = 0; s < 8; ++s)
    e.trans[168 + s] = 280 + s;
  for (s = 0; s < 112; ++s)
    e.trans[176 + s] = 144 + s;
  for (s = 0; s < 5; ++s)
    n.table[s] = 0;
  for (n.table[5] = 32, s = 0; s < 32; ++s)
    n.trans[s] = s;
}
Hb(Fb, kb);
ey(J1, $1, 4, 3);
ey(Bb, Vb, 2, 1);
J1[28] = 0;
$1[28] = 258;
function lc(e, n, s, i, r) {
  return Math.pow(1 - r, 3) * e + 3 * Math.pow(1 - r, 2) * r * n + 3 * (1 - r) * Math.pow(r, 2) * s + Math.pow(r, 3) * i;
}
function ta() {
  this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN;
}
ta.prototype.isEmpty = function() {
  return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
};
ta.prototype.addPoint = function(e, n) {
  typeof e == "number" && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = e, this.x2 = e), e < this.x1 && (this.x1 = e), e > this.x2 && (this.x2 = e)), typeof n == "number" && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = n, this.y2 = n), n < this.y1 && (this.y1 = n), n > this.y2 && (this.y2 = n));
};
ta.prototype.addX = function(e) {
  this.addPoint(e, null);
};
ta.prototype.addY = function(e) {
  this.addPoint(null, e);
};
ta.prototype.addBezier = function(e, n, s, i, r, o, a, c) {
  var l = [e, n], h = [s, i], d = [r, o], p = [a, c];
  this.addPoint(e, n), this.addPoint(a, c);
  for (var E = 0; E <= 1; E++) {
    var g = 6 * l[E] - 12 * h[E] + 6 * d[E], T = -3 * l[E] + 9 * h[E] - 9 * d[E] + 3 * p[E], A = 3 * h[E] - 3 * l[E];
    if (T === 0) {
      if (g === 0)
        continue;
      var m = -A / g;
      0 < m && m < 1 && (E === 0 && this.addX(lc(l[E], h[E], d[E], p[E], m)), E === 1 && this.addY(lc(l[E], h[E], d[E], p[E], m)));
      continue;
    }
    var O = Math.pow(g, 2) - 4 * A * T;
    if (!(O < 0)) {
      var S = (-g + Math.sqrt(O)) / (2 * T);
      0 < S && S < 1 && (E === 0 && this.addX(lc(l[E], h[E], d[E], p[E], S)), E === 1 && this.addY(lc(l[E], h[E], d[E], p[E], S)));
      var y = (-g - Math.sqrt(O)) / (2 * T);
      0 < y && y < 1 && (E === 0 && this.addX(lc(l[E], h[E], d[E], p[E], y)), E === 1 && this.addY(lc(l[E], h[E], d[E], p[E], y)));
    }
  }
};
ta.prototype.addQuad = function(e, n, s, i, r, o) {
  var a = e + 0.6666666666666666 * (s - e), c = n + 2 / 3 * (i - n), l = a + 1 / 3 * (r - e), h = c + 1 / 3 * (o - n);
  this.addBezier(e, n, a, c, l, h, r, o);
};
function jn() {
  this.commands = [], this.fill = "black", this.stroke = null, this.strokeWidth = 1;
}
jn.prototype.moveTo = function(e, n) {
  this.commands.push({
    type: "M",
    x: e,
    y: n
  });
};
jn.prototype.lineTo = function(e, n) {
  this.commands.push({
    type: "L",
    x: e,
    y: n
  });
};
jn.prototype.curveTo = jn.prototype.bezierCurveTo = function(e, n, s, i, r, o) {
  this.commands.push({
    type: "C",
    x1: e,
    y1: n,
    x2: s,
    y2: i,
    x: r,
    y: o
  });
};
jn.prototype.quadTo = jn.prototype.quadraticCurveTo = function(e, n, s, i) {
  this.commands.push({
    type: "Q",
    x1: e,
    y1: n,
    x: s,
    y: i
  });
};
jn.prototype.close = jn.prototype.closePath = function() {
  this.commands.push({
    type: "Z"
  });
};
jn.prototype.extend = function(e) {
  if (e.commands)
    e = e.commands;
  else if (e instanceof ta) {
    var n = e;
    this.moveTo(n.x1, n.y1), this.lineTo(n.x2, n.y1), this.lineTo(n.x2, n.y2), this.lineTo(n.x1, n.y2), this.close();
    return;
  }
  Array.prototype.push.apply(this.commands, e);
};
jn.prototype.getBoundingBox = function() {
  for (var e = new ta(), n = 0, s = 0, i = 0, r = 0, o = 0; o < this.commands.length; o++) {
    var a = this.commands[o];
    switch (a.type) {
      case "M":
        e.addPoint(a.x, a.y), n = i = a.x, s = r = a.y;
        break;
      case "L":
        e.addPoint(a.x, a.y), i = a.x, r = a.y;
        break;
      case "Q":
        e.addQuad(i, r, a.x1, a.y1, a.x, a.y), i = a.x, r = a.y;
        break;
      case "C":
        e.addBezier(i, r, a.x1, a.y1, a.x2, a.y2, a.x, a.y), i = a.x, r = a.y;
        break;
      case "Z":
        i = n, r = s;
        break;
      default:
        throw new Error("Unexpected path command " + a.type);
    }
  }
  return e.isEmpty() && e.addPoint(0, 0), e;
};
jn.prototype.draw = function(e) {
  e.beginPath();
  for (var n = 0; n < this.commands.length; n += 1) {
    var s = this.commands[n];
    s.type === "M" ? e.moveTo(s.x, s.y) : s.type === "L" ? e.lineTo(s.x, s.y) : s.type === "C" ? e.bezierCurveTo(s.x1, s.y1, s.x2, s.y2, s.x, s.y) : s.type === "Q" ? e.quadraticCurveTo(s.x1, s.y1, s.x, s.y) : s.type === "Z" && e.closePath();
  }
  this.fill && (e.fillStyle = this.fill, e.fill()), this.stroke && (e.strokeStyle = this.stroke, e.lineWidth = this.strokeWidth, e.stroke());
};
jn.prototype.toPathData = function(e) {
  e = e !== void 0 ? e : 2;
  function n(a) {
    return Math.round(a) === a ? "" + Math.round(a) : a.toFixed(e);
  }
  function s() {
    for (var a = arguments, c = "", l = 0; l < arguments.length; l += 1) {
      var h = a[l];
      h >= 0 && l > 0 && (c += " "), c += n(h);
    }
    return c;
  }
  for (var i = "", r = 0; r < this.commands.length; r += 1) {
    var o = this.commands[r];
    o.type === "M" ? i += "M" + s(o.x, o.y) : o.type === "L" ? i += "L" + s(o.x, o.y) : o.type === "C" ? i += "C" + s(o.x1, o.y1, o.x2, o.y2, o.x, o.y) : o.type === "Q" ? i += "Q" + s(o.x1, o.y1, o.x, o.y) : o.type === "Z" && (i += "Z");
  }
  return i;
};
jn.prototype.toSVG = function(e) {
  var n = '<path d="';
  return n += this.toPathData(e), n += '"', this.fill && this.fill !== "black" && (this.fill === null ? n += ' fill="none"' : n += ' fill="' + this.fill + '"'), this.stroke && (n += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"'), n += "/>", n;
};
jn.prototype.toDOMElement = function(e) {
  var n = this.toPathData(e), s = document.createElementNS("http://www.w3.org/2000/svg", "path");
  return s.setAttribute("d", n), s;
};
function ty(e) {
  throw new Error(e);
}
function kO(e, n) {
  e || ty(n);
}
var lt = { fail: ty, argument: kO, assert: kO }, BO = 32768, VO = 2147483648, Gc = {}, Ae = {}, $e = {};
function ur(e) {
  return function() {
    return e;
  };
}
Ae.BYTE = function(e) {
  return lt.argument(e >= 0 && e <= 255, "Byte value should be between 0 and 255."), [e];
};
$e.BYTE = ur(1);
Ae.CHAR = function(e) {
  return [e.charCodeAt(0)];
};
$e.CHAR = ur(1);
Ae.CHARARRAY = function(e) {
  typeof e > "u" && (e = "", console.warn("Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name."));
  for (var n = [], s = 0; s < e.length; s += 1)
    n[s] = e.charCodeAt(s);
  return n;
};
$e.CHARARRAY = function(e) {
  return typeof e > "u" ? 0 : e.length;
};
Ae.USHORT = function(e) {
  return [e >> 8 & 255, e & 255];
};
$e.USHORT = ur(2);
Ae.SHORT = function(e) {
  return e >= BO && (e = -(2 * BO - e)), [e >> 8 & 255, e & 255];
};
$e.SHORT = ur(2);
Ae.UINT24 = function(e) {
  return [e >> 16 & 255, e >> 8 & 255, e & 255];
};
$e.UINT24 = ur(3);
Ae.ULONG = function(e) {
  return [e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255];
};
$e.ULONG = ur(4);
Ae.LONG = function(e) {
  return e >= VO && (e = -(2 * VO - e)), [e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255];
};
$e.LONG = ur(4);
Ae.FIXED = Ae.ULONG;
$e.FIXED = $e.ULONG;
Ae.FWORD = Ae.SHORT;
$e.FWORD = $e.SHORT;
Ae.UFWORD = Ae.USHORT;
$e.UFWORD = $e.USHORT;
Ae.LONGDATETIME = function(e) {
  return [0, 0, 0, 0, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255];
};
$e.LONGDATETIME = ur(8);
Ae.TAG = function(e) {
  return lt.argument(e.length === 4, "Tag should be exactly 4 ASCII characters."), [
    e.charCodeAt(0),
    e.charCodeAt(1),
    e.charCodeAt(2),
    e.charCodeAt(3)
  ];
};
$e.TAG = ur(4);
Ae.Card8 = Ae.BYTE;
$e.Card8 = $e.BYTE;
Ae.Card16 = Ae.USHORT;
$e.Card16 = $e.USHORT;
Ae.OffSize = Ae.BYTE;
$e.OffSize = $e.BYTE;
Ae.SID = Ae.USHORT;
$e.SID = $e.USHORT;
Ae.NUMBER = function(e) {
  return e >= -107 && e <= 107 ? [e + 139] : e >= 108 && e <= 1131 ? (e = e - 108, [(e >> 8) + 247, e & 255]) : e >= -1131 && e <= -108 ? (e = -e - 108, [(e >> 8) + 251, e & 255]) : e >= -32768 && e <= 32767 ? Ae.NUMBER16(e) : Ae.NUMBER32(e);
};
$e.NUMBER = function(e) {
  return Ae.NUMBER(e).length;
};
Ae.NUMBER16 = function(e) {
  return [28, e >> 8 & 255, e & 255];
};
$e.NUMBER16 = ur(3);
Ae.NUMBER32 = function(e) {
  return [29, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255];
};
$e.NUMBER32 = ur(5);
Ae.REAL = function(e) {
  var n = e.toString(), s = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(n);
  if (s) {
    var i = parseFloat("1e" + ((s[2] ? +s[2] : 0) + s[1].length));
    n = (Math.round(e * i) / i).toString();
  }
  for (var r = "", o = 0, a = n.length; o < a; o += 1) {
    var c = n[o];
    c === "e" ? r += n[++o] === "-" ? "c" : "b" : c === "." ? r += "a" : c === "-" ? r += "e" : r += c;
  }
  r += r.length & 1 ? "f" : "ff";
  for (var l = [30], h = 0, d = r.length; h < d; h += 2)
    l.push(parseInt(r.substr(h, 2), 16));
  return l;
};
$e.REAL = function(e) {
  return Ae.REAL(e).length;
};
Ae.NAME = Ae.CHARARRAY;
$e.NAME = $e.CHARARRAY;
Ae.STRING = Ae.CHARARRAY;
$e.STRING = $e.CHARARRAY;
Gc.UTF8 = function(e, n, s) {
  for (var i = [], r = s, o = 0; o < r; o++, n += 1)
    i[o] = e.getUint8(n);
  return String.fromCharCode.apply(null, i);
};
Gc.UTF16 = function(e, n, s) {
  for (var i = [], r = s / 2, o = 0; o < r; o++, n += 2)
    i[o] = e.getUint16(n);
  return String.fromCharCode.apply(null, i);
};
Ae.UTF16 = function(e) {
  for (var n = [], s = 0; s < e.length; s += 1) {
    var i = e.charCodeAt(s);
    n[n.length] = i >> 8 & 255, n[n.length] = i & 255;
  }
  return n;
};
$e.UTF16 = function(e) {
  return e.length * 2;
};
var qE = {
  "x-mac-croatian": (
    // Python: 'mac_croatian'
    "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ"
  ),
  "x-mac-cyrillic": (
    // Python: 'mac_cyrillic'
    "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю"
  ),
  "x-mac-gaelic": (
    // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
    "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæøṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ"
  ),
  "x-mac-greek": (
    // Python: 'mac_greek'
    "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ­"
  ),
  "x-mac-icelandic": (
    // Python: 'mac_iceland'
    "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
  ),
  "x-mac-inuit": (
    // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
    "ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł"
  ),
  "x-mac-ce": (
    // Python: 'mac_latin2'
    "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ"
  ),
  macintosh: (
    // Python: 'mac_roman'
    "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
  ),
  "x-mac-romanian": (
    // Python: 'mac_romanian'
    "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
  ),
  "x-mac-turkish": (
    // Python: 'mac_turkish'
    "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ"
  )
};
Gc.MACSTRING = function(e, n, s, i) {
  var r = qE[i];
  if (r !== void 0) {
    for (var o = "", a = 0; a < s; a++) {
      var c = e.getUint8(n + a);
      c <= 127 ? o += String.fromCharCode(c) : o += r[c & 127];
    }
    return o;
  }
};
var Su = typeof WeakMap == "function" && /* @__PURE__ */ new WeakMap(), yu, Wb = function(e) {
  if (!yu) {
    yu = {};
    for (var n in qE)
      yu[n] = new String(n);
  }
  var s = yu[e];
  if (s !== void 0) {
    if (Su) {
      var i = Su.get(s);
      if (i !== void 0)
        return i;
    }
    var r = qE[e];
    if (r !== void 0) {
      for (var o = {}, a = 0; a < r.length; a++)
        o[r.charCodeAt(a)] = a + 128;
      return Su && Su.set(s, o), o;
    }
  }
};
Ae.MACSTRING = function(e, n) {
  var s = Wb(n);
  if (s !== void 0) {
    for (var i = [], r = 0; r < e.length; r++) {
      var o = e.charCodeAt(r);
      if (o >= 128 && (o = s[o], o === void 0))
        return;
      i[r] = o;
    }
    return i;
  }
};
$e.MACSTRING = function(e, n) {
  var s = Ae.MACSTRING(e, n);
  return s !== void 0 ? s.length : 0;
};
function jE(e) {
  return e >= -128 && e <= 127;
}
function Yb(e, n, s) {
  for (var i = 0, r = e.length; n < r && i < 64 && e[n] === 0; )
    ++n, ++i;
  return s.push(128 | i - 1), n;
}
function Xb(e, n, s) {
  for (var i = 0, r = e.length, o = n; o < r && i < 64; ) {
    var a = e[o];
    if (!jE(a) || a === 0 && o + 1 < r && e[o + 1] === 0)
      break;
    ++o, ++i;
  }
  s.push(i - 1);
  for (var c = n; c < o; ++c)
    s.push(e[c] + 256 & 255);
  return o;
}
function zb(e, n, s) {
  for (var i = 0, r = e.length, o = n; o < r && i < 64; ) {
    var a = e[o];
    if (a === 0 || jE(a) && o + 1 < r && jE(e[o + 1]))
      break;
    ++o, ++i;
  }
  s.push(64 | i - 1);
  for (var c = n; c < o; ++c) {
    var l = e[c];
    s.push(l + 65536 >> 8 & 255, l + 256 & 255);
  }
  return o;
}
Ae.VARDELTAS = function(e) {
  for (var n = 0, s = []; n < e.length; ) {
    var i = e[n];
    i === 0 ? n = Yb(e, n, s) : i >= -128 && i <= 127 ? n = Xb(e, n, s) : n = zb(e, n, s);
  }
  return s;
};
Ae.INDEX = function(e) {
  for (var n = 1, s = [n], i = [], r = 0; r < e.length; r += 1) {
    var o = Ae.OBJECT(e[r]);
    Array.prototype.push.apply(i, o), n += o.length, s.push(n);
  }
  if (i.length === 0)
    return [0, 0];
  for (var a = [], c = 1 + Math.floor(Math.log(n) / Math.log(2)) / 8 | 0, l = [void 0, Ae.BYTE, Ae.USHORT, Ae.UINT24, Ae.ULONG][c], h = 0; h < s.length; h += 1) {
    var d = l(s[h]);
    Array.prototype.push.apply(a, d);
  }
  return Array.prototype.concat(
    Ae.Card16(e.length),
    Ae.OffSize(c),
    a,
    i
  );
};
$e.INDEX = function(e) {
  return Ae.INDEX(e).length;
};
Ae.DICT = function(e) {
  for (var n = [], s = Object.keys(e), i = s.length, r = 0; r < i; r += 1) {
    var o = parseInt(s[r], 0), a = e[o];
    n = n.concat(Ae.OPERAND(a.value, a.type)), n = n.concat(Ae.OPERATOR(o));
  }
  return n;
};
$e.DICT = function(e) {
  return Ae.DICT(e).length;
};
Ae.OPERATOR = function(e) {
  return e < 1200 ? [e] : [12, e - 1200];
};
Ae.OPERAND = function(e, n) {
  var s = [];
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i += 1)
      lt.argument(e.length === n.length, "Not enough arguments given for type" + n), s = s.concat(Ae.OPERAND(e[i], n[i]));
  else if (n === "SID")
    s = s.concat(Ae.NUMBER(e));
  else if (n === "offset")
    s = s.concat(Ae.NUMBER32(e));
  else if (n === "number")
    s = s.concat(Ae.NUMBER(e));
  else if (n === "real")
    s = s.concat(Ae.REAL(e));
  else
    throw new Error("Unknown operand type " + n);
  return s;
};
Ae.OP = Ae.BYTE;
$e.OP = $e.BYTE;
var Cu = typeof WeakMap == "function" && /* @__PURE__ */ new WeakMap();
Ae.CHARSTRING = function(e) {
  if (Cu) {
    var n = Cu.get(e);
    if (n !== void 0)
      return n;
  }
  for (var s = [], i = e.length, r = 0; r < i; r += 1) {
    var o = e[r];
    s = s.concat(Ae[o.type](o.value));
  }
  return Cu && Cu.set(e, s), s;
};
$e.CHARSTRING = function(e) {
  return Ae.CHARSTRING(e).length;
};
Ae.OBJECT = function(e) {
  var n = Ae[e.type];
  return lt.argument(n !== void 0, "No encoding function for type " + e.type), n(e.value);
};
$e.OBJECT = function(e) {
  var n = $e[e.type];
  return lt.argument(n !== void 0, "No sizeOf function for type " + e.type), n(e.value);
};
Ae.TABLE = function(e) {
  for (var n = [], s = e.fields.length, i = [], r = [], o = 0; o < s; o += 1) {
    var a = e.fields[o], c = Ae[a.type];
    lt.argument(c !== void 0, "No encoding function for field type " + a.type + " (" + a.name + ")");
    var l = e[a.name];
    l === void 0 && (l = a.value);
    var h = c(l);
    a.type === "TABLE" ? (r.push(n.length), n = n.concat([0, 0]), i.push(h)) : n = n.concat(h);
  }
  for (var d = 0; d < i.length; d += 1) {
    var p = r[d], E = n.length;
    lt.argument(E < 65536, "Table " + e.tableName + " too big."), n[p] = E >> 8, n[p + 1] = E & 255, n = n.concat(i[d]);
  }
  return n;
};
$e.TABLE = function(e) {
  for (var n = 0, s = e.fields.length, i = 0; i < s; i += 1) {
    var r = e.fields[i], o = $e[r.type];
    lt.argument(o !== void 0, "No sizeOf function for field type " + r.type + " (" + r.name + ")");
    var a = e[r.name];
    a === void 0 && (a = r.value), n += o(a), r.type === "TABLE" && (n += 2);
  }
  return n;
};
Ae.RECORD = Ae.TABLE;
$e.RECORD = $e.TABLE;
Ae.LITERAL = function(e) {
  return e;
};
$e.LITERAL = function(e) {
  return e.length;
};
function cs(e, n, s) {
  if (n.length && (n[0].name !== "coverageFormat" || n[0].value === 1))
    for (var i = 0; i < n.length; i += 1) {
      var r = n[i];
      this[r.name] = r.value;
    }
  if (this.tableName = e, this.fields = n, s)
    for (var o = Object.keys(s), a = 0; a < o.length; a += 1) {
      var c = o[a], l = s[c];
      this[c] !== void 0 && (this[c] = l);
    }
}
cs.prototype.encode = function() {
  return Ae.TABLE(this);
};
cs.prototype.sizeOf = function() {
  return $e.TABLE(this);
};
function ih(e, n, s) {
  s === void 0 && (s = n.length);
  var i = new Array(n.length + 1);
  i[0] = { name: e + "Count", type: "USHORT", value: s };
  for (var r = 0; r < n.length; r++)
    i[r + 1] = { name: e + r, type: "USHORT", value: n[r] };
  return i;
}
function JE(e, n, s) {
  var i = n.length, r = new Array(i + 1);
  r[0] = { name: e + "Count", type: "USHORT", value: i };
  for (var o = 0; o < i; o++)
    r[o + 1] = { name: e + o, type: "TABLE", value: s(n[o], o) };
  return r;
}
function rh(e, n, s) {
  var i = n.length, r = [];
  r[0] = { name: e + "Count", type: "USHORT", value: i };
  for (var o = 0; o < i; o++)
    r = r.concat(s(n[o], o));
  return r;
}
function yd(e) {
  e.format === 1 ? cs.call(
    this,
    "coverageTable",
    [{ name: "coverageFormat", type: "USHORT", value: 1 }].concat(ih("glyph", e.glyphs))
  ) : e.format === 2 ? cs.call(
    this,
    "coverageTable",
    [{ name: "coverageFormat", type: "USHORT", value: 2 }].concat(rh("rangeRecord", e.ranges, function(n) {
      return [
        { name: "startGlyphID", type: "USHORT", value: n.start },
        { name: "endGlyphID", type: "USHORT", value: n.end },
        { name: "startCoverageIndex", type: "USHORT", value: n.index }
      ];
    }))
  ) : lt.assert(!1, "Coverage format must be 1 or 2.");
}
yd.prototype = Object.create(cs.prototype);
yd.prototype.constructor = yd;
function Cd(e) {
  cs.call(
    this,
    "scriptListTable",
    rh("scriptRecord", e, function(n, s) {
      var i = n.script, r = i.defaultLangSys;
      return lt.assert(!!r, "Unable to write GSUB: script " + n.tag + " has no default language system."), [
        { name: "scriptTag" + s, type: "TAG", value: n.tag },
        { name: "script" + s, type: "TABLE", value: new cs("scriptTable", [
          { name: "defaultLangSys", type: "TABLE", value: new cs("defaultLangSys", [
            { name: "lookupOrder", type: "USHORT", value: 0 },
            { name: "reqFeatureIndex", type: "USHORT", value: r.reqFeatureIndex }
          ].concat(ih("featureIndex", r.featureIndexes))) }
        ].concat(rh("langSys", i.langSysRecords, function(o, a) {
          var c = o.langSys;
          return [
            { name: "langSysTag" + a, type: "TAG", value: o.tag },
            { name: "langSys" + a, type: "TABLE", value: new cs("langSys", [
              { name: "lookupOrder", type: "USHORT", value: 0 },
              { name: "reqFeatureIndex", type: "USHORT", value: c.reqFeatureIndex }
            ].concat(ih("featureIndex", c.featureIndexes))) }
          ];
        }))) }
      ];
    })
  );
}
Cd.prototype = Object.create(cs.prototype);
Cd.prototype.constructor = Cd;
function Nd(e) {
  cs.call(
    this,
    "featureListTable",
    rh("featureRecord", e, function(n, s) {
      var i = n.feature;
      return [
        { name: "featureTag" + s, type: "TAG", value: n.tag },
        { name: "feature" + s, type: "TABLE", value: new cs("featureTable", [
          { name: "featureParams", type: "USHORT", value: i.featureParams }
        ].concat(ih("lookupListIndex", i.lookupListIndexes))) }
      ];
    })
  );
}
Nd.prototype = Object.create(cs.prototype);
Nd.prototype.constructor = Nd;
function xd(e, n) {
  cs.call(this, "lookupListTable", JE("lookup", e, function(s) {
    var i = n[s.lookupType];
    return lt.assert(!!i, "Unable to write GSUB lookup type " + s.lookupType + " tables."), new cs("lookupTable", [
      { name: "lookupType", type: "USHORT", value: s.lookupType },
      { name: "lookupFlag", type: "USHORT", value: s.lookupFlag }
    ].concat(JE("subtable", s.subtables, i)));
  }));
}
xd.prototype = Object.create(cs.prototype);
xd.prototype.constructor = xd;
var De = {
  Table: cs,
  Record: cs,
  Coverage: yd,
  ScriptList: Cd,
  FeatureList: Nd,
  LookupList: xd,
  ushortList: ih,
  tableList: JE,
  recordList: rh
};
function HO(e, n) {
  return e.getUint8(n);
}
function vd(e, n) {
  return e.getUint16(n, !1);
}
function Kb(e, n) {
  return e.getInt16(n, !1);
}
function a0(e, n) {
  return e.getUint32(n, !1);
}
function ny(e, n) {
  var s = e.getInt16(n, !1), i = e.getUint16(n + 2, !1);
  return s + i / 65535;
}
function Qb(e, n) {
  for (var s = "", i = n; i < n + 4; i += 1)
    s += String.fromCharCode(e.getInt8(i));
  return s;
}
function Zb(e, n, s) {
  for (var i = 0, r = 0; r < s; r += 1)
    i <<= 8, i += e.getUint8(n + r);
  return i;
}
function qb(e, n, s) {
  for (var i = [], r = n; r < s; r += 1)
    i.push(e.getUint8(r));
  return i;
}
function jb(e) {
  for (var n = "", s = 0; s < e.length; s += 1)
    n += String.fromCharCode(e[s]);
  return n;
}
var Jb = {
  byte: 1,
  uShort: 2,
  short: 2,
  uLong: 4,
  fixed: 4,
  longDateTime: 8,
  tag: 4
};
function $(e, n) {
  this.data = e, this.offset = n, this.relativeOffset = 0;
}
$.prototype.parseByte = function() {
  var e = this.data.getUint8(this.offset + this.relativeOffset);
  return this.relativeOffset += 1, e;
};
$.prototype.parseChar = function() {
  var e = this.data.getInt8(this.offset + this.relativeOffset);
  return this.relativeOffset += 1, e;
};
$.prototype.parseCard8 = $.prototype.parseByte;
$.prototype.parseUShort = function() {
  var e = this.data.getUint16(this.offset + this.relativeOffset);
  return this.relativeOffset += 2, e;
};
$.prototype.parseCard16 = $.prototype.parseUShort;
$.prototype.parseSID = $.prototype.parseUShort;
$.prototype.parseOffset16 = $.prototype.parseUShort;
$.prototype.parseShort = function() {
  var e = this.data.getInt16(this.offset + this.relativeOffset);
  return this.relativeOffset += 2, e;
};
$.prototype.parseF2Dot14 = function() {
  var e = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
  return this.relativeOffset += 2, e;
};
$.prototype.parseULong = function() {
  var e = a0(this.data, this.offset + this.relativeOffset);
  return this.relativeOffset += 4, e;
};
$.prototype.parseOffset32 = $.prototype.parseULong;
$.prototype.parseFixed = function() {
  var e = ny(this.data, this.offset + this.relativeOffset);
  return this.relativeOffset += 4, e;
};
$.prototype.parseString = function(e) {
  var n = this.data, s = this.offset + this.relativeOffset, i = "";
  this.relativeOffset += e;
  for (var r = 0; r < e; r++)
    i += String.fromCharCode(n.getUint8(s + r));
  return i;
};
$.prototype.parseTag = function() {
  return this.parseString(4);
};
$.prototype.parseLongDateTime = function() {
  var e = a0(this.data, this.offset + this.relativeOffset + 4);
  return e -= 2082844800, this.relativeOffset += 8, e;
};
$.prototype.parseVersion = function(e) {
  var n = vd(this.data, this.offset + this.relativeOffset), s = vd(this.data, this.offset + this.relativeOffset + 2);
  return this.relativeOffset += 4, e === void 0 && (e = 4096), n + s / e / 10;
};
$.prototype.skip = function(e, n) {
  n === void 0 && (n = 1), this.relativeOffset += Jb[e] * n;
};
$.prototype.parseULongList = function(e) {
  e === void 0 && (e = this.parseULong());
  for (var n = new Array(e), s = this.data, i = this.offset + this.relativeOffset, r = 0; r < e; r++)
    n[r] = s.getUint32(i), i += 4;
  return this.relativeOffset += e * 4, n;
};
$.prototype.parseOffset16List = $.prototype.parseUShortList = function(e) {
  e === void 0 && (e = this.parseUShort());
  for (var n = new Array(e), s = this.data, i = this.offset + this.relativeOffset, r = 0; r < e; r++)
    n[r] = s.getUint16(i), i += 2;
  return this.relativeOffset += e * 2, n;
};
$.prototype.parseShortList = function(e) {
  for (var n = new Array(e), s = this.data, i = this.offset + this.relativeOffset, r = 0; r < e; r++)
    n[r] = s.getInt16(i), i += 2;
  return this.relativeOffset += e * 2, n;
};
$.prototype.parseByteList = function(e) {
  for (var n = new Array(e), s = this.data, i = this.offset + this.relativeOffset, r = 0; r < e; r++)
    n[r] = s.getUint8(i++);
  return this.relativeOffset += e, n;
};
$.prototype.parseList = function(e, n) {
  n || (n = e, e = this.parseUShort());
  for (var s = new Array(e), i = 0; i < e; i++)
    s[i] = n.call(this);
  return s;
};
$.prototype.parseList32 = function(e, n) {
  n || (n = e, e = this.parseULong());
  for (var s = new Array(e), i = 0; i < e; i++)
    s[i] = n.call(this);
  return s;
};
$.prototype.parseRecordList = function(e, n) {
  n || (n = e, e = this.parseUShort());
  for (var s = new Array(e), i = Object.keys(n), r = 0; r < e; r++) {
    for (var o = {}, a = 0; a < i.length; a++) {
      var c = i[a], l = n[c];
      o[c] = l.call(this);
    }
    s[r] = o;
  }
  return s;
};
$.prototype.parseRecordList32 = function(e, n) {
  n || (n = e, e = this.parseULong());
  for (var s = new Array(e), i = Object.keys(n), r = 0; r < e; r++) {
    for (var o = {}, a = 0; a < i.length; a++) {
      var c = i[a], l = n[c];
      o[c] = l.call(this);
    }
    s[r] = o;
  }
  return s;
};
$.prototype.parseStruct = function(e) {
  if (typeof e == "function")
    return e.call(this);
  for (var n = Object.keys(e), s = {}, i = 0; i < n.length; i++) {
    var r = n[i], o = e[r];
    s[r] = o.call(this);
  }
  return s;
};
$.prototype.parseValueRecord = function(e) {
  if (e === void 0 && (e = this.parseUShort()), e !== 0) {
    var n = {};
    return e & 1 && (n.xPlacement = this.parseShort()), e & 2 && (n.yPlacement = this.parseShort()), e & 4 && (n.xAdvance = this.parseShort()), e & 8 && (n.yAdvance = this.parseShort()), e & 16 && (n.xPlaDevice = void 0, this.parseShort()), e & 32 && (n.yPlaDevice = void 0, this.parseShort()), e & 64 && (n.xAdvDevice = void 0, this.parseShort()), e & 128 && (n.yAdvDevice = void 0, this.parseShort()), n;
  }
};
$.prototype.parseValueRecordList = function() {
  for (var e = this.parseUShort(), n = this.parseUShort(), s = new Array(n), i = 0; i < n; i++)
    s[i] = this.parseValueRecord(e);
  return s;
};
$.prototype.parsePointer = function(e) {
  var n = this.parseOffset16();
  if (n > 0)
    return new $(this.data, this.offset + n).parseStruct(e);
};
$.prototype.parsePointer32 = function(e) {
  var n = this.parseOffset32();
  if (n > 0)
    return new $(this.data, this.offset + n).parseStruct(e);
};
$.prototype.parseListOfLists = function(e) {
  for (var n = this.parseOffset16List(), s = n.length, i = this.relativeOffset, r = new Array(s), o = 0; o < s; o++) {
    var a = n[o];
    if (a === 0) {
      r[o] = void 0;
      continue;
    }
    if (this.relativeOffset = a, e) {
      for (var c = this.parseOffset16List(), l = new Array(c.length), h = 0; h < c.length; h++)
        this.relativeOffset = a + c[h], l[h] = e.call(this);
      r[o] = l;
    } else
      r[o] = this.parseUShortList();
  }
  return this.relativeOffset = i, r;
};
$.prototype.parseCoverage = function() {
  var e = this.offset + this.relativeOffset, n = this.parseUShort(), s = this.parseUShort();
  if (n === 1)
    return {
      format: 1,
      glyphs: this.parseUShortList(s)
    };
  if (n === 2) {
    for (var i = new Array(s), r = 0; r < s; r++)
      i[r] = {
        start: this.parseUShort(),
        end: this.parseUShort(),
        index: this.parseUShort()
      };
    return {
      format: 2,
      ranges: i
    };
  }
  throw new Error("0x" + e.toString(16) + ": Coverage format must be 1 or 2.");
};
$.prototype.parseClassDef = function() {
  var e = this.offset + this.relativeOffset, n = this.parseUShort();
  if (n === 1)
    return {
      format: 1,
      startGlyph: this.parseUShort(),
      classes: this.parseUShortList()
    };
  if (n === 2)
    return {
      format: 2,
      ranges: this.parseRecordList({
        start: $.uShort,
        end: $.uShort,
        classId: $.uShort
      })
    };
  throw new Error("0x" + e.toString(16) + ": ClassDef format must be 1 or 2.");
};
$.list = function(e, n) {
  return function() {
    return this.parseList(e, n);
  };
};
$.list32 = function(e, n) {
  return function() {
    return this.parseList32(e, n);
  };
};
$.recordList = function(e, n) {
  return function() {
    return this.parseRecordList(e, n);
  };
};
$.recordList32 = function(e, n) {
  return function() {
    return this.parseRecordList32(e, n);
  };
};
$.pointer = function(e) {
  return function() {
    return this.parsePointer(e);
  };
};
$.pointer32 = function(e) {
  return function() {
    return this.parsePointer32(e);
  };
};
$.tag = $.prototype.parseTag;
$.byte = $.prototype.parseByte;
$.uShort = $.offset16 = $.prototype.parseUShort;
$.uShortList = $.prototype.parseUShortList;
$.uLong = $.offset32 = $.prototype.parseULong;
$.uLongList = $.prototype.parseULongList;
$.struct = $.prototype.parseStruct;
$.coverage = $.prototype.parseCoverage;
$.classDef = $.prototype.parseClassDef;
var WO = {
  reserved: $.uShort,
  reqFeatureIndex: $.uShort,
  featureIndexes: $.uShortList
};
$.prototype.parseScriptList = function() {
  return this.parsePointer($.recordList({
    tag: $.tag,
    script: $.pointer({
      defaultLangSys: $.pointer(WO),
      langSysRecords: $.recordList({
        tag: $.tag,
        langSys: $.pointer(WO)
      })
    })
  })) || [];
};
$.prototype.parseFeatureList = function() {
  return this.parsePointer($.recordList({
    tag: $.tag,
    feature: $.pointer({
      featureParams: $.offset16,
      lookupListIndexes: $.uShortList
    })
  })) || [];
};
$.prototype.parseLookupList = function(e) {
  return this.parsePointer($.list($.pointer(function() {
    var n = this.parseUShort();
    lt.argument(1 <= n && n <= 9, "GPOS/GSUB lookup type " + n + " unknown.");
    var s = this.parseUShort(), i = s & 16;
    return {
      lookupType: n,
      lookupFlag: s,
      subtables: this.parseList($.pointer(e[n])),
      markFilteringSet: i ? this.parseUShort() : void 0
    };
  }))) || [];
};
$.prototype.parseFeatureVariationsList = function() {
  return this.parsePointer32(function() {
    var e = this.parseUShort(), n = this.parseUShort();
    lt.argument(e === 1 && n < 1, "GPOS/GSUB feature variations table unknown.");
    var s = this.parseRecordList32({
      conditionSetOffset: $.offset32,
      featureTableSubstitutionOffset: $.offset32
    });
    return s;
  }) || [];
};
var pt = {
  getByte: HO,
  getCard8: HO,
  getUShort: vd,
  getCard16: vd,
  getShort: Kb,
  getULong: a0,
  getFixed: ny,
  getTag: Qb,
  getOffset: Zb,
  getBytes: qb,
  bytesToString: jb,
  Parser: $
};
function $b(e, n) {
  n.parseUShort(), e.length = n.parseULong(), e.language = n.parseULong();
  var s;
  e.groupCount = s = n.parseULong(), e.glyphIndexMap = {};
  for (var i = 0; i < s; i += 1)
    for (var r = n.parseULong(), o = n.parseULong(), a = n.parseULong(), c = r; c <= o; c += 1)
      e.glyphIndexMap[c] = a, a++;
}
function eU(e, n, s, i, r) {
  e.length = n.parseUShort(), e.language = n.parseUShort();
  var o;
  e.segCount = o = n.parseUShort() >> 1, n.skip("uShort", 3), e.glyphIndexMap = {};
  for (var a = new pt.Parser(s, i + r + 14), c = new pt.Parser(s, i + r + 16 + o * 2), l = new pt.Parser(s, i + r + 16 + o * 4), h = new pt.Parser(s, i + r + 16 + o * 6), d = i + r + 16 + o * 8, p = 0; p < o - 1; p += 1)
    for (var E = void 0, g = a.parseUShort(), T = c.parseUShort(), A = l.parseShort(), m = h.parseUShort(), O = T; O <= g; O += 1)
      m !== 0 ? (d = h.offset + h.relativeOffset - 2, d += m, d += (O - T) * 2, E = pt.getUShort(s, d), E !== 0 && (E = E + A & 65535)) : E = O + A & 65535, e.glyphIndexMap[O] = E;
}
function tU(e, n) {
  var s = {};
  s.version = pt.getUShort(e, n), lt.argument(s.version === 0, "cmap table version should be 0."), s.numTables = pt.getUShort(e, n + 2);
  for (var i = -1, r = s.numTables - 1; r >= 0; r -= 1) {
    var o = pt.getUShort(e, n + 4 + r * 8), a = pt.getUShort(e, n + 4 + r * 8 + 2);
    if (o === 3 && (a === 0 || a === 1 || a === 10) || o === 0 && (a === 0 || a === 1 || a === 2 || a === 3 || a === 4)) {
      i = pt.getULong(e, n + 4 + r * 8 + 4);
      break;
    }
  }
  if (i === -1)
    throw new Error("No valid cmap sub-tables found.");
  var c = new pt.Parser(e, n + i);
  if (s.format = c.parseUShort(), s.format === 12)
    $b(s, c);
  else if (s.format === 4)
    eU(s, c, e, n, i);
  else
    throw new Error("Only format 4 and 12 cmap tables are supported (found format " + s.format + ").");
  return s;
}
function nU(e, n, s) {
  e.segments.push({
    end: n,
    start: n,
    delta: -(n - s),
    offset: 0,
    glyphIndex: s
  });
}
function sU(e) {
  e.segments.push({
    end: 65535,
    start: 65535,
    delta: 1,
    offset: 0
  });
}
function iU(e) {
  var n = !0, s;
  for (s = e.length - 1; s > 0; s -= 1) {
    var i = e.get(s);
    if (i.unicode > 65535) {
      console.log("Adding CMAP format 12 (needed!)"), n = !1;
      break;
    }
  }
  var r = [
    { name: "version", type: "USHORT", value: 0 },
    { name: "numTables", type: "USHORT", value: n ? 1 : 2 },
    // CMAP 4 header
    { name: "platformID", type: "USHORT", value: 3 },
    { name: "encodingID", type: "USHORT", value: 1 },
    { name: "offset", type: "ULONG", value: n ? 12 : 20 }
  ];
  n || (r = r.concat([
    // CMAP 12 header
    { name: "cmap12PlatformID", type: "USHORT", value: 3 },
    // We encode only for PlatformID = 3 (Windows) because it is supported everywhere
    { name: "cmap12EncodingID", type: "USHORT", value: 10 },
    { name: "cmap12Offset", type: "ULONG", value: 0 }
  ])), r = r.concat([
    // CMAP 4 Subtable
    { name: "format", type: "USHORT", value: 4 },
    { name: "cmap4Length", type: "USHORT", value: 0 },
    { name: "language", type: "USHORT", value: 0 },
    { name: "segCountX2", type: "USHORT", value: 0 },
    { name: "searchRange", type: "USHORT", value: 0 },
    { name: "entrySelector", type: "USHORT", value: 0 },
    { name: "rangeShift", type: "USHORT", value: 0 }
  ]);
  var o = new De.Table("cmap", r);
  for (o.segments = [], s = 0; s < e.length; s += 1) {
    for (var a = e.get(s), c = 0; c < a.unicodes.length; c += 1)
      nU(o, a.unicodes[c], s);
    o.segments = o.segments.sort(function(S, y) {
      return S.start - y.start;
    });
  }
  sU(o);
  var l = o.segments.length, h = 0, d = [], p = [], E = [], g = [], T = [], A = [];
  for (s = 0; s < l; s += 1) {
    var m = o.segments[s];
    m.end <= 65535 && m.start <= 65535 ? (d = d.concat({ name: "end_" + s, type: "USHORT", value: m.end }), p = p.concat({ name: "start_" + s, type: "USHORT", value: m.start }), E = E.concat({ name: "idDelta_" + s, type: "SHORT", value: m.delta }), g = g.concat({ name: "idRangeOffset_" + s, type: "USHORT", value: m.offset }), m.glyphId !== void 0 && (T = T.concat({ name: "glyph_" + s, type: "USHORT", value: m.glyphId }))) : h += 1, !n && m.glyphIndex !== void 0 && (A = A.concat({ name: "cmap12Start_" + s, type: "ULONG", value: m.start }), A = A.concat({ name: "cmap12End_" + s, type: "ULONG", value: m.end }), A = A.concat({ name: "cmap12Glyph_" + s, type: "ULONG", value: m.glyphIndex }));
  }
  if (o.segCountX2 = (l - h) * 2, o.searchRange = Math.pow(2, Math.floor(Math.log(l - h) / Math.log(2))) * 2, o.entrySelector = Math.log(o.searchRange / 2) / Math.log(2), o.rangeShift = o.segCountX2 - o.searchRange, o.fields = o.fields.concat(d), o.fields.push({ name: "reservedPad", type: "USHORT", value: 0 }), o.fields = o.fields.concat(p), o.fields = o.fields.concat(E), o.fields = o.fields.concat(g), o.fields = o.fields.concat(T), o.cmap4Length = 14 + // Subtable header
  d.length * 2 + 2 + // reservedPad
  p.length * 2 + E.length * 2 + g.length * 2 + T.length * 2, !n) {
    var O = 16 + // Subtable header
    A.length * 4;
    o.cmap12Offset = 12 + 2 * 2 + 4 + o.cmap4Length, o.fields = o.fields.concat([
      { name: "cmap12Format", type: "USHORT", value: 12 },
      { name: "cmap12Reserved", type: "USHORT", value: 0 },
      { name: "cmap12Length", type: "ULONG", value: O },
      { name: "cmap12Language", type: "ULONG", value: 0 },
      { name: "cmap12nGroups", type: "ULONG", value: A.length / 3 }
    ]), o.fields = o.fields.concat(A);
  }
  return o;
}
var rU = { parse: tU, make: iU }, Qu = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "266 ff",
  "onedotenleader",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall",
  "001.000",
  "001.001",
  "001.002",
  "001.003",
  "Black",
  "Bold",
  "Book",
  "Light",
  "Medium",
  "Regular",
  "Roman",
  "Semibold"
], oU = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "",
  "questiondown",
  "",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "",
  "ring",
  "cedilla",
  "",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "AE",
  "",
  "ordfeminine",
  "",
  "",
  "",
  "",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "",
  "",
  "",
  "",
  "",
  "ae",
  "",
  "",
  "",
  "dotlessi",
  "",
  "",
  "lslash",
  "oslash",
  "oe",
  "germandbls"
], aU = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "",
  "",
  "isuperior",
  "",
  "",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "",
  "",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "",
  "",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "",
  "Dotaccentsmall",
  "",
  "",
  "Macronsmall",
  "",
  "",
  "figuredash",
  "hypheninferior",
  "",
  "",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "",
  "",
  "",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "",
  "",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
], YO = [
  ".notdef",
  ".null",
  "nonmarkingreturn",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quotesingle",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "grave",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "Adieresis",
  "Aring",
  "Ccedilla",
  "Eacute",
  "Ntilde",
  "Odieresis",
  "Udieresis",
  "aacute",
  "agrave",
  "acircumflex",
  "adieresis",
  "atilde",
  "aring",
  "ccedilla",
  "eacute",
  "egrave",
  "ecircumflex",
  "edieresis",
  "iacute",
  "igrave",
  "icircumflex",
  "idieresis",
  "ntilde",
  "oacute",
  "ograve",
  "ocircumflex",
  "odieresis",
  "otilde",
  "uacute",
  "ugrave",
  "ucircumflex",
  "udieresis",
  "dagger",
  "degree",
  "cent",
  "sterling",
  "section",
  "bullet",
  "paragraph",
  "germandbls",
  "registered",
  "copyright",
  "trademark",
  "acute",
  "dieresis",
  "notequal",
  "AE",
  "Oslash",
  "infinity",
  "plusminus",
  "lessequal",
  "greaterequal",
  "yen",
  "mu",
  "partialdiff",
  "summation",
  "product",
  "pi",
  "integral",
  "ordfeminine",
  "ordmasculine",
  "Omega",
  "ae",
  "oslash",
  "questiondown",
  "exclamdown",
  "logicalnot",
  "radical",
  "florin",
  "approxequal",
  "Delta",
  "guillemotleft",
  "guillemotright",
  "ellipsis",
  "nonbreakingspace",
  "Agrave",
  "Atilde",
  "Otilde",
  "OE",
  "oe",
  "endash",
  "emdash",
  "quotedblleft",
  "quotedblright",
  "quoteleft",
  "quoteright",
  "divide",
  "lozenge",
  "ydieresis",
  "Ydieresis",
  "fraction",
  "currency",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "daggerdbl",
  "periodcentered",
  "quotesinglbase",
  "quotedblbase",
  "perthousand",
  "Acircumflex",
  "Ecircumflex",
  "Aacute",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Oacute",
  "Ocircumflex",
  "apple",
  "Ograve",
  "Uacute",
  "Ucircumflex",
  "Ugrave",
  "dotlessi",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "Lslash",
  "lslash",
  "Scaron",
  "scaron",
  "Zcaron",
  "zcaron",
  "brokenbar",
  "Eth",
  "eth",
  "Yacute",
  "yacute",
  "Thorn",
  "thorn",
  "minus",
  "multiply",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "onehalf",
  "onequarter",
  "threequarters",
  "franc",
  "Gbreve",
  "gbreve",
  "Idotaccent",
  "Scedilla",
  "scedilla",
  "Cacute",
  "cacute",
  "Ccaron",
  "ccaron",
  "dcroat"
];
function sy(e) {
  this.font = e;
}
sy.prototype.charToGlyphIndex = function(e) {
  var n = e.codePointAt(0), s = this.font.glyphs;
  if (s) {
    for (var i = 0; i < s.length; i += 1)
      for (var r = s.get(i), o = 0; o < r.unicodes.length; o += 1)
        if (r.unicodes[o] === n)
          return i;
  }
  return null;
};
function Rd(e, n) {
  this.encoding = e, this.charset = n;
}
Rd.prototype.charToGlyphIndex = function(e) {
  var n = e.codePointAt(0), s = this.encoding[n];
  return this.charset.indexOf(s);
};
function cU(e, n, s, i, r) {
  e.beginPath(), e.moveTo(n, s), e.lineTo(i, r), e.stroke();
}
var fa = { line: cU };
function lU(e, n) {
  var s = n || new jn();
  return {
    configurable: !0,
    get: function() {
      return typeof s == "function" && (s = s()), s;
    },
    set: function(i) {
      s = i;
    }
  };
}
function Qi(e) {
  this.bindConstructorValues(e);
}
Qi.prototype.bindConstructorValues = function(e) {
  this.index = e.index || 0, this.name = e.name || null, this.unicode = e.unicode || void 0, this.unicodes = e.unicodes || e.unicode !== void 0 ? [e.unicode] : [], "xMin" in e && (this.xMin = e.xMin), "yMin" in e && (this.yMin = e.yMin), "xMax" in e && (this.xMax = e.xMax), "yMax" in e && (this.yMax = e.yMax), "advanceWidth" in e && (this.advanceWidth = e.advanceWidth), Object.defineProperty(this, "path", lU(this, e.path));
};
Qi.prototype.addUnicode = function(e) {
  this.unicodes.length === 0 && (this.unicode = e), this.unicodes.push(e);
};
Qi.prototype.getBoundingBox = function() {
  return this.path.getBoundingBox();
};
Qi.prototype.getPath = function(e, n, s, i, r) {
  e = e !== void 0 ? e : 0, n = n !== void 0 ? n : 0, s = s !== void 0 ? s : 72;
  var o, a;
  i || (i = {});
  var c = i.xScale, l = i.yScale;
  if (i.hinting && r && r.hinting && (a = this.path && r.hinting.exec(this, s)), a)
    o = r.hinting.getCommands(a), e = Math.round(e), n = Math.round(n), c = l = 1;
  else {
    o = this.path.commands;
    var h = 1 / (this.path.unitsPerEm || 1e3) * s;
    c === void 0 && (c = h), l === void 0 && (l = h);
  }
  for (var d = new jn(), p = 0; p < o.length; p += 1) {
    var E = o[p];
    E.type === "M" ? d.moveTo(e + E.x * c, n + -E.y * l) : E.type === "L" ? d.lineTo(e + E.x * c, n + -E.y * l) : E.type === "Q" ? d.quadraticCurveTo(
      e + E.x1 * c,
      n + -E.y1 * l,
      e + E.x * c,
      n + -E.y * l
    ) : E.type === "C" ? d.curveTo(
      e + E.x1 * c,
      n + -E.y1 * l,
      e + E.x2 * c,
      n + -E.y2 * l,
      e + E.x * c,
      n + -E.y * l
    ) : E.type === "Z" && d.closePath();
  }
  return d;
};
Qi.prototype.getContours = function() {
  if (this.points === void 0)
    return [];
  for (var e = [], n = [], s = 0; s < this.points.length; s += 1) {
    var i = this.points[s];
    n.push(i), i.lastPointOfContour && (e.push(n), n = []);
  }
  return lt.argument(n.length === 0, "There are still points left in the current contour."), e;
};
Qi.prototype.getMetrics = function() {
  for (var e = this.path.commands, n = [], s = [], i = 0; i < e.length; i += 1) {
    var r = e[i];
    r.type !== "Z" && (n.push(r.x), s.push(r.y)), (r.type === "Q" || r.type === "C") && (n.push(r.x1), s.push(r.y1)), r.type === "C" && (n.push(r.x2), s.push(r.y2));
  }
  var o = {
    xMin: Math.min.apply(null, n),
    yMin: Math.min.apply(null, s),
    xMax: Math.max.apply(null, n),
    yMax: Math.max.apply(null, s),
    leftSideBearing: this.leftSideBearing
  };
  return isFinite(o.xMin) || (o.xMin = 0), isFinite(o.xMax) || (o.xMax = this.advanceWidth), isFinite(o.yMin) || (o.yMin = 0), isFinite(o.yMax) || (o.yMax = 0), o.rightSideBearing = this.advanceWidth - o.leftSideBearing - (o.xMax - o.xMin), o;
};
Qi.prototype.draw = function(e, n, s, i, r) {
  this.getPath(n, s, i, r).draw(e);
};
Qi.prototype.drawPoints = function(e, n, s, i) {
  function r(p, E, g, T) {
    e.beginPath();
    for (var A = 0; A < p.length; A += 1)
      e.moveTo(E + p[A].x * T, g + p[A].y * T), e.arc(E + p[A].x * T, g + p[A].y * T, 2, 0, Math.PI * 2, !1);
    e.closePath(), e.fill();
  }
  n = n !== void 0 ? n : 0, s = s !== void 0 ? s : 0, i = i !== void 0 ? i : 24;
  for (var o = 1 / this.path.unitsPerEm * i, a = [], c = [], l = this.path, h = 0; h < l.commands.length; h += 1) {
    var d = l.commands[h];
    d.x !== void 0 && a.push({ x: d.x, y: -d.y }), d.x1 !== void 0 && c.push({ x: d.x1, y: -d.y1 }), d.x2 !== void 0 && c.push({ x: d.x2, y: -d.y2 });
  }
  e.fillStyle = "blue", r(a, n, s, o), e.fillStyle = "red", r(c, n, s, o);
};
Qi.prototype.drawMetrics = function(e, n, s, i) {
  var r;
  n = n !== void 0 ? n : 0, s = s !== void 0 ? s : 0, i = i !== void 0 ? i : 24, r = 1 / this.path.unitsPerEm * i, e.lineWidth = 1, e.strokeStyle = "black", fa.line(e, n, -1e4, n, 1e4), fa.line(e, -1e4, s, 1e4, s);
  var o = this.xMin || 0, a = this.yMin || 0, c = this.xMax || 0, l = this.yMax || 0, h = this.advanceWidth || 0;
  e.strokeStyle = "blue", fa.line(e, n + o * r, -1e4, n + o * r, 1e4), fa.line(e, n + c * r, -1e4, n + c * r, 1e4), fa.line(e, -1e4, s + -a * r, 1e4, s + -a * r), fa.line(e, -1e4, s + -l * r, 1e4, s + -l * r), e.strokeStyle = "green", fa.line(e, n + h * r, -1e4, n + h * r, 1e4);
};
function Nu(e, n, s) {
  Object.defineProperty(e, n, {
    get: function() {
      return e.path, e[s];
    },
    set: function(i) {
      e[s] = i;
    },
    enumerable: !0,
    configurable: !0
  });
}
function c0(e, n) {
  if (this.font = e, this.glyphs = {}, Array.isArray(n))
    for (var s = 0; s < n.length; s++) {
      var i = n[s];
      i.path.unitsPerEm = e.unitsPerEm, this.glyphs[s] = i;
    }
  this.length = n && n.length || 0;
}
c0.prototype.get = function(e) {
  if (this.glyphs[e] === void 0) {
    this.font._push(e), typeof this.glyphs[e] == "function" && (this.glyphs[e] = this.glyphs[e]());
    var n = this.glyphs[e], s = this.font._IndexToUnicodeMap[e];
    if (s)
      for (var i = 0; i < s.unicodes.length; i++)
        n.addUnicode(s.unicodes[i]);
    this.font.cffEncoding ? this.font.isCIDFont ? n.name = "gid" + e : n.name = this.font.cffEncoding.charset[e] : this.font.glyphNames.names && (n.name = this.font.glyphNames.glyphIndexToName(e)), this.glyphs[e].advanceWidth = this.font._hmtxTableData[e].advanceWidth, this.glyphs[e].leftSideBearing = this.font._hmtxTableData[e].leftSideBearing;
  } else
    typeof this.glyphs[e] == "function" && (this.glyphs[e] = this.glyphs[e]());
  return this.glyphs[e];
};
c0.prototype.push = function(e, n) {
  this.glyphs[e] = n, this.length++;
};
function hU(e, n) {
  return new Qi({ index: n, font: e });
}
function uU(e, n, s, i, r, o) {
  return function() {
    var a = new Qi({ index: n, font: e });
    return a.path = function() {
      s(a, i, r);
      var c = o(e.glyphs, a);
      return c.unitsPerEm = e.unitsPerEm, c;
    }, Nu(a, "xMin", "_xMin"), Nu(a, "xMax", "_xMax"), Nu(a, "yMin", "_yMin"), Nu(a, "yMax", "_yMax"), a;
  };
}
function dU(e, n, s, i) {
  return function() {
    var r = new Qi({ index: n, font: e });
    return r.path = function() {
      var o = s(e, r, i);
      return o.unitsPerEm = e.unitsPerEm, o;
    }, r;
  };
}
var Cr = { GlyphSet: c0, glyphLoader: hU, ttfGlyphLoader: uU, cffGlyphLoader: dU };
function iy(e, n) {
  if (e === n)
    return !0;
  if (Array.isArray(e) && Array.isArray(n)) {
    if (e.length !== n.length)
      return !1;
    for (var s = 0; s < e.length; s += 1)
      if (!iy(e[s], n[s]))
        return !1;
    return !0;
  } else
    return !1;
}
function $E(e) {
  var n;
  return e.length < 1240 ? n = 107 : e.length < 33900 ? n = 1131 : n = 32768, n;
}
function Go(e, n, s) {
  var i = [], r = [], o = pt.getCard16(e, n), a, c;
  if (o !== 0) {
    var l = pt.getByte(e, n + 2);
    a = n + (o + 1) * l + 2;
    for (var h = n + 3, d = 0; d < o + 1; d += 1)
      i.push(pt.getOffset(e, h, l)), h += l;
    c = a + i[o];
  } else
    c = n + 2;
  for (var p = 0; p < i.length - 1; p += 1) {
    var E = pt.getBytes(e, a + i[p], a + i[p + 1]);
    s && (E = s(E)), r.push(E);
  }
  return { objects: r, startOffset: n, endOffset: c };
}
function fU(e, n) {
  var s = [], i = pt.getCard16(e, n), r, o;
  if (i !== 0) {
    var a = pt.getByte(e, n + 2);
    r = n + (i + 1) * a + 2;
    for (var c = n + 3, l = 0; l < i + 1; l += 1)
      s.push(pt.getOffset(e, c, a)), c += a;
    o = r + s[i];
  } else
    o = n + 2;
  return { offsets: s, startOffset: n, endOffset: o };
}
function pU(e, n, s, i, r) {
  var o = pt.getCard16(s, i), a = 0;
  if (o !== 0) {
    var c = pt.getByte(s, i + 2);
    a = i + (o + 1) * c + 2;
  }
  var l = pt.getBytes(s, a + n[e], a + n[e + 1]);
  return l;
}
function EU(e) {
  for (var n = "", s = 15, i = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"]; ; ) {
    var r = e.parseByte(), o = r >> 4, a = r & 15;
    if (o === s || (n += i[o], a === s))
      break;
    n += i[a];
  }
  return parseFloat(n);
}
function gU(e, n) {
  var s, i, r, o;
  if (n === 28)
    return s = e.parseByte(), i = e.parseByte(), s << 8 | i;
  if (n === 29)
    return s = e.parseByte(), i = e.parseByte(), r = e.parseByte(), o = e.parseByte(), s << 24 | i << 16 | r << 8 | o;
  if (n === 30)
    return EU(e);
  if (n >= 32 && n <= 246)
    return n - 139;
  if (n >= 247 && n <= 250)
    return s = e.parseByte(), (n - 247) * 256 + s + 108;
  if (n >= 251 && n <= 254)
    return s = e.parseByte(), -(n - 251) * 256 - s - 108;
  throw new Error("Invalid b0 " + n);
}
function _U(e) {
  for (var n = {}, s = 0; s < e.length; s += 1) {
    var i = e[s][0], r = e[s][1], o = void 0;
    if (r.length === 1 ? o = r[0] : o = r, n.hasOwnProperty(i) && !isNaN(n[i]))
      throw new Error("Object " + n + " already has key " + i);
    n[i] = o;
  }
  return n;
}
function ry(e, n, s) {
  n = n !== void 0 ? n : 0;
  var i = new pt.Parser(e, n), r = [], o = [];
  for (s = s !== void 0 ? s : e.length; i.relativeOffset < s; ) {
    var a = i.parseByte();
    a <= 21 ? (a === 12 && (a = 1200 + i.parseByte()), r.push([a, o]), o = []) : o.push(gU(i, a));
  }
  return _U(r);
}
function Xl(e, n) {
  return n <= 390 ? n = Qu[n] : n = e[n - 391], n;
}
function oy(e, n, s) {
  for (var i = {}, r, o = 0; o < n.length; o += 1) {
    var a = n[o];
    if (Array.isArray(a.type)) {
      var c = [];
      c.length = a.type.length;
      for (var l = 0; l < a.type.length; l++)
        r = e[a.op] !== void 0 ? e[a.op][l] : void 0, r === void 0 && (r = a.value !== void 0 && a.value[l] !== void 0 ? a.value[l] : null), a.type[l] === "SID" && (r = Xl(s, r)), c[l] = r;
      i[a.name] = c;
    } else
      r = e[a.op], r === void 0 && (r = a.value !== void 0 ? a.value : null), a.type === "SID" && (r = Xl(s, r)), i[a.name] = r;
  }
  return i;
}
function TU(e, n) {
  var s = {};
  return s.formatMajor = pt.getCard8(e, n), s.formatMinor = pt.getCard8(e, n + 1), s.size = pt.getCard8(e, n + 2), s.offsetSize = pt.getCard8(e, n + 3), s.startOffset = n, s.endOffset = n + 4, s;
}
var ay = [
  { name: "version", op: 0, type: "SID" },
  { name: "notice", op: 1, type: "SID" },
  { name: "copyright", op: 1200, type: "SID" },
  { name: "fullName", op: 2, type: "SID" },
  { name: "familyName", op: 3, type: "SID" },
  { name: "weight", op: 4, type: "SID" },
  { name: "isFixedPitch", op: 1201, type: "number", value: 0 },
  { name: "italicAngle", op: 1202, type: "number", value: 0 },
  { name: "underlinePosition", op: 1203, type: "number", value: -100 },
  { name: "underlineThickness", op: 1204, type: "number", value: 50 },
  { name: "paintType", op: 1205, type: "number", value: 0 },
  { name: "charstringType", op: 1206, type: "number", value: 2 },
  {
    name: "fontMatrix",
    op: 1207,
    type: ["real", "real", "real", "real", "real", "real"],
    value: [1e-3, 0, 0, 1e-3, 0, 0]
  },
  { name: "uniqueId", op: 13, type: "number" },
  { name: "fontBBox", op: 5, type: ["number", "number", "number", "number"], value: [0, 0, 0, 0] },
  { name: "strokeWidth", op: 1208, type: "number", value: 0 },
  { name: "xuid", op: 14, type: [], value: null },
  { name: "charset", op: 15, type: "offset", value: 0 },
  { name: "encoding", op: 16, type: "offset", value: 0 },
  { name: "charStrings", op: 17, type: "offset", value: 0 },
  { name: "private", op: 18, type: ["number", "offset"], value: [0, 0] },
  { name: "ros", op: 1230, type: ["SID", "SID", "number"] },
  { name: "cidFontVersion", op: 1231, type: "number", value: 0 },
  { name: "cidFontRevision", op: 1232, type: "number", value: 0 },
  { name: "cidFontType", op: 1233, type: "number", value: 0 },
  { name: "cidCount", op: 1234, type: "number", value: 8720 },
  { name: "uidBase", op: 1235, type: "number" },
  { name: "fdArray", op: 1236, type: "offset" },
  { name: "fdSelect", op: 1237, type: "offset" },
  { name: "fontName", op: 1238, type: "SID" }
], cy = [
  { name: "subrs", op: 19, type: "offset", value: 0 },
  { name: "defaultWidthX", op: 20, type: "number", value: 0 },
  { name: "nominalWidthX", op: 21, type: "number", value: 0 }
];
function AU(e, n) {
  var s = ry(e, 0, e.byteLength);
  return oy(s, ay, n);
}
function ly(e, n, s, i) {
  var r = ry(e, n, s);
  return oy(r, cy, i);
}
function XO(e, n, s, i) {
  for (var r = [], o = 0; o < s.length; o += 1) {
    var a = new DataView(new Uint8Array(s[o]).buffer), c = AU(a, i);
    c._subrs = [], c._subrsBias = 0, c._defaultWidthX = 0, c._nominalWidthX = 0;
    var l = c.private[0], h = c.private[1];
    if (l !== 0 && h !== 0) {
      var d = ly(e, h + n, l, i);
      if (c._defaultWidthX = d.defaultWidthX, c._nominalWidthX = d.nominalWidthX, d.subrs !== 0) {
        var p = h + d.subrs, E = Go(e, p + n);
        c._subrs = E.objects, c._subrsBias = $E(c._subrs);
      }
      c._privateDict = d;
    }
    r.push(c);
  }
  return r;
}
function mU(e, n, s, i) {
  var r, o, a = new pt.Parser(e, n);
  s -= 1;
  var c = [".notdef"], l = a.parseCard8();
  if (l === 0)
    for (var h = 0; h < s; h += 1)
      r = a.parseSID(), c.push(Xl(i, r));
  else if (l === 1)
    for (; c.length <= s; ) {
      r = a.parseSID(), o = a.parseCard8();
      for (var d = 0; d <= o; d += 1)
        c.push(Xl(i, r)), r += 1;
    }
  else if (l === 2)
    for (; c.length <= s; ) {
      r = a.parseSID(), o = a.parseCard16();
      for (var p = 0; p <= o; p += 1)
        c.push(Xl(i, r)), r += 1;
    }
  else
    throw new Error("Unknown charset format " + l);
  return c;
}
function OU(e, n, s) {
  var i, r = {}, o = new pt.Parser(e, n), a = o.parseCard8();
  if (a === 0)
    for (var c = o.parseCard8(), l = 0; l < c; l += 1)
      i = o.parseCard8(), r[i] = l;
  else if (a === 1) {
    var h = o.parseCard8();
    i = 1;
    for (var d = 0; d < h; d += 1)
      for (var p = o.parseCard8(), E = o.parseCard8(), g = p; g <= p + E; g += 1)
        r[g] = i, i += 1;
  } else
    throw new Error("Unknown encoding format " + a);
  return new Rd(r, s);
}
function zO(e, n, s) {
  var i, r, o, a, c = new jn(), l = [], h = 0, d = !1, p = !1, E = 0, g = 0, T, A, m, O;
  if (e.isCIDFont) {
    var S = e.tables.cff.topDict._fdSelect[n.index], y = e.tables.cff.topDict._fdArray[S];
    T = y._subrs, A = y._subrsBias, m = y._defaultWidthX, O = y._nominalWidthX;
  } else
    T = e.tables.cff.topDict._subrs, A = e.tables.cff.topDict._subrsBias, m = e.tables.cff.topDict._defaultWidthX, O = e.tables.cff.topDict._nominalWidthX;
  var v = m;
  function R(P, k) {
    p && c.closePath(), c.moveTo(P, k), p = !0;
  }
  function M() {
    var P;
    P = l.length % 2 !== 0, P && !d && (v = l.shift() + O), h += l.length >> 1, l.length = 0, d = !0;
  }
  function L(P) {
    for (var k, Q, b, X, K, V, J, ge, ne, ue, te, ie, re = 0; re < P.length; ) {
      var fe = P[re];
      switch (re += 1, fe) {
        case 1:
          M();
          break;
        case 3:
          M();
          break;
        case 4:
          l.length > 1 && !d && (v = l.shift() + O, d = !0), g += l.pop(), R(E, g);
          break;
        case 5:
          for (; l.length > 0; )
            E += l.shift(), g += l.shift(), c.lineTo(E, g);
          break;
        case 6:
          for (; l.length > 0 && (E += l.shift(), c.lineTo(E, g), l.length !== 0); )
            g += l.shift(), c.lineTo(E, g);
          break;
        case 7:
          for (; l.length > 0 && (g += l.shift(), c.lineTo(E, g), l.length !== 0); )
            E += l.shift(), c.lineTo(E, g);
          break;
        case 8:
          for (; l.length > 0; )
            i = E + l.shift(), r = g + l.shift(), o = i + l.shift(), a = r + l.shift(), E = o + l.shift(), g = a + l.shift(), c.curveTo(i, r, o, a, E, g);
          break;
        case 10:
          K = l.pop() + A, V = T[K], V && L(V);
          break;
        case 11:
          return;
        case 12:
          switch (fe = P[re], re += 1, fe) {
            case 35:
              i = E + l.shift(), r = g + l.shift(), o = i + l.shift(), a = r + l.shift(), J = o + l.shift(), ge = a + l.shift(), ne = J + l.shift(), ue = ge + l.shift(), te = ne + l.shift(), ie = ue + l.shift(), E = te + l.shift(), g = ie + l.shift(), l.shift(), c.curveTo(i, r, o, a, J, ge), c.curveTo(ne, ue, te, ie, E, g);
              break;
            case 34:
              i = E + l.shift(), r = g, o = i + l.shift(), a = r + l.shift(), J = o + l.shift(), ge = a, ne = J + l.shift(), ue = a, te = ne + l.shift(), ie = g, E = te + l.shift(), c.curveTo(i, r, o, a, J, ge), c.curveTo(ne, ue, te, ie, E, g);
              break;
            case 36:
              i = E + l.shift(), r = g + l.shift(), o = i + l.shift(), a = r + l.shift(), J = o + l.shift(), ge = a, ne = J + l.shift(), ue = a, te = ne + l.shift(), ie = ue + l.shift(), E = te + l.shift(), c.curveTo(i, r, o, a, J, ge), c.curveTo(ne, ue, te, ie, E, g);
              break;
            case 37:
              i = E + l.shift(), r = g + l.shift(), o = i + l.shift(), a = r + l.shift(), J = o + l.shift(), ge = a + l.shift(), ne = J + l.shift(), ue = ge + l.shift(), te = ne + l.shift(), ie = ue + l.shift(), Math.abs(te - E) > Math.abs(ie - g) ? E = te + l.shift() : g = ie + l.shift(), c.curveTo(i, r, o, a, J, ge), c.curveTo(ne, ue, te, ie, E, g);
              break;
            default:
              console.log("Glyph " + n.index + ": unknown operator 1200" + fe), l.length = 0;
          }
          break;
        case 14:
          l.length > 0 && !d && (v = l.shift() + O, d = !0), p && (c.closePath(), p = !1);
          break;
        case 18:
          M();
          break;
        case 19:
        case 20:
          M(), re += h + 7 >> 3;
          break;
        case 21:
          l.length > 2 && !d && (v = l.shift() + O, d = !0), g += l.pop(), E += l.pop(), R(E, g);
          break;
        case 22:
          l.length > 1 && !d && (v = l.shift() + O, d = !0), E += l.pop(), R(E, g);
          break;
        case 23:
          M();
          break;
        case 24:
          for (; l.length > 2; )
            i = E + l.shift(), r = g + l.shift(), o = i + l.shift(), a = r + l.shift(), E = o + l.shift(), g = a + l.shift(), c.curveTo(i, r, o, a, E, g);
          E += l.shift(), g += l.shift(), c.lineTo(E, g);
          break;
        case 25:
          for (; l.length > 6; )
            E += l.shift(), g += l.shift(), c.lineTo(E, g);
          i = E + l.shift(), r = g + l.shift(), o = i + l.shift(), a = r + l.shift(), E = o + l.shift(), g = a + l.shift(), c.curveTo(i, r, o, a, E, g);
          break;
        case 26:
          for (l.length % 2 && (E += l.shift()); l.length > 0; )
            i = E, r = g + l.shift(), o = i + l.shift(), a = r + l.shift(), E = o, g = a + l.shift(), c.curveTo(i, r, o, a, E, g);
          break;
        case 27:
          for (l.length % 2 && (g += l.shift()); l.length > 0; )
            i = E + l.shift(), r = g, o = i + l.shift(), a = r + l.shift(), E = o + l.shift(), g = a, c.curveTo(i, r, o, a, E, g);
          break;
        case 28:
          k = P[re], Q = P[re + 1], l.push((k << 24 | Q << 16) >> 16), re += 2;
          break;
        case 29:
          K = l.pop() + e.gsubrsBias, V = e.gsubrs[K], V && L(V);
          break;
        case 30:
          for (; l.length > 0 && (i = E, r = g + l.shift(), o = i + l.shift(), a = r + l.shift(), E = o + l.shift(), g = a + (l.length === 1 ? l.shift() : 0), c.curveTo(i, r, o, a, E, g), l.length !== 0); )
            i = E + l.shift(), r = g, o = i + l.shift(), a = r + l.shift(), g = a + l.shift(), E = o + (l.length === 1 ? l.shift() : 0), c.curveTo(i, r, o, a, E, g);
          break;
        case 31:
          for (; l.length > 0 && (i = E + l.shift(), r = g, o = i + l.shift(), a = r + l.shift(), g = a + l.shift(), E = o + (l.length === 1 ? l.shift() : 0), c.curveTo(i, r, o, a, E, g), l.length !== 0); )
            i = E, r = g + l.shift(), o = i + l.shift(), a = r + l.shift(), E = o + l.shift(), g = a + (l.length === 1 ? l.shift() : 0), c.curveTo(i, r, o, a, E, g);
          break;
        default:
          fe < 32 ? console.log("Glyph " + n.index + ": unknown operator " + fe) : fe < 247 ? l.push(fe - 139) : fe < 251 ? (k = P[re], re += 1, l.push((fe - 247) * 256 + k + 108)) : fe < 255 ? (k = P[re], re += 1, l.push(-(fe - 251) * 256 - k - 108)) : (k = P[re], Q = P[re + 1], b = P[re + 2], X = P[re + 3], re += 4, l.push((k << 24 | Q << 16 | b << 8 | X) / 65536));
      }
    }
  }
  return L(s), n.advanceWidth = v, c;
}
function IU(e, n, s, i) {
  var r = [], o, a = new pt.Parser(e, n), c = a.parseCard8();
  if (c === 0)
    for (var l = 0; l < s; l++) {
      if (o = a.parseCard8(), o >= i)
        throw new Error("CFF table CID Font FDSelect has bad FD index value " + o + " (FD count " + i + ")");
      r.push(o);
    }
  else if (c === 3) {
    var h = a.parseCard16(), d = a.parseCard16();
    if (d !== 0)
      throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + d);
    for (var p, E = 0; E < h; E++) {
      if (o = a.parseCard8(), p = a.parseCard16(), o >= i)
        throw new Error("CFF table CID Font FDSelect has bad FD index value " + o + " (FD count " + i + ")");
      if (p > s)
        throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + p);
      for (; d < p; d++)
        r.push(o);
      d = p;
    }
    if (p !== s)
      throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + p);
  } else
    throw new Error("CFF Table CID Font FDSelect table has unsupported format " + c);
  return r;
}
function SU(e, n, s, i) {
  s.tables.cff = {};
  var r = TU(e, n), o = Go(e, r.endOffset, pt.bytesToString), a = Go(e, o.endOffset), c = Go(e, a.endOffset, pt.bytesToString), l = Go(e, c.endOffset);
  s.gsubrs = l.objects, s.gsubrsBias = $E(s.gsubrs);
  var h = XO(e, n, a.objects, c.objects);
  if (h.length !== 1)
    throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " + h.length);
  var d = h[0];
  if (s.tables.cff.topDict = d, d._privateDict && (s.defaultWidthX = d._privateDict.defaultWidthX, s.nominalWidthX = d._privateDict.nominalWidthX), d.ros[0] !== void 0 && d.ros[1] !== void 0 && (s.isCIDFont = !0), s.isCIDFont) {
    var p = d.fdArray, E = d.fdSelect;
    if (p === 0 || E === 0)
      throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");
    p += n;
    var g = Go(e, p), T = XO(e, n, g.objects, c.objects);
    d._fdArray = T, E += n, d._fdSelect = IU(e, E, s.numGlyphs, T.length);
  }
  var A = n + d.private[1], m = ly(e, A, d.private[0], c.objects);
  if (s.defaultWidthX = m.defaultWidthX, s.nominalWidthX = m.nominalWidthX, m.subrs !== 0) {
    var O = A + m.subrs, S = Go(e, O);
    s.subrs = S.objects, s.subrsBias = $E(s.subrs);
  } else
    s.subrs = [], s.subrsBias = 0;
  var y;
  i.lowMemory ? (y = fU(e, n + d.charStrings), s.nGlyphs = y.offsets.length) : (y = Go(e, n + d.charStrings), s.nGlyphs = y.objects.length);
  var v = mU(e, n + d.charset, s.nGlyphs, c.objects);
  if (d.encoding === 0 ? s.cffEncoding = new Rd(oU, v) : d.encoding === 1 ? s.cffEncoding = new Rd(aU, v) : s.cffEncoding = OU(e, n + d.encoding, v), s.encoding = s.encoding || s.cffEncoding, s.glyphs = new Cr.GlyphSet(s), i.lowMemory)
    s._push = function(L) {
      var P = pU(L, y.offsets, e, n + d.charStrings);
      s.glyphs.push(L, Cr.cffGlyphLoader(s, L, zO, P));
    };
  else
    for (var R = 0; R < s.nGlyphs; R += 1) {
      var M = y.objects[R];
      s.glyphs.push(R, Cr.cffGlyphLoader(s, R, zO, M));
    }
}
function hy(e, n) {
  var s, i = Qu.indexOf(e);
  return i >= 0 && (s = i), i = n.indexOf(e), i >= 0 ? s = i + Qu.length : (s = Qu.length + n.length, n.push(e)), s;
}
function yU() {
  return new De.Record("Header", [
    { name: "major", type: "Card8", value: 1 },
    { name: "minor", type: "Card8", value: 0 },
    { name: "hdrSize", type: "Card8", value: 4 },
    { name: "major", type: "Card8", value: 1 }
  ]);
}
function CU(e) {
  var n = new De.Record("Name INDEX", [
    { name: "names", type: "INDEX", value: [] }
  ]);
  n.names = [];
  for (var s = 0; s < e.length; s += 1)
    n.names.push({ name: "name_" + s, type: "NAME", value: e[s] });
  return n;
}
function uy(e, n, s) {
  for (var i = {}, r = 0; r < e.length; r += 1) {
    var o = e[r], a = n[o.name];
    a !== void 0 && !iy(a, o.value) && (o.type === "SID" && (a = hy(a, s)), i[o.op] = { name: o.name, type: o.type, value: a });
  }
  return i;
}
function KO(e, n) {
  var s = new De.Record("Top DICT", [
    { name: "dict", type: "DICT", value: {} }
  ]);
  return s.dict = uy(ay, e, n), s;
}
function QO(e) {
  var n = new De.Record("Top DICT INDEX", [
    { name: "topDicts", type: "INDEX", value: [] }
  ]);
  return n.topDicts = [{ name: "topDict_0", type: "TABLE", value: e }], n;
}
function NU(e) {
  var n = new De.Record("String INDEX", [
    { name: "strings", type: "INDEX", value: [] }
  ]);
  n.strings = [];
  for (var s = 0; s < e.length; s += 1)
    n.strings.push({ name: "string_" + s, type: "STRING", value: e[s] });
  return n;
}
function xU() {
  return new De.Record("Global Subr INDEX", [
    { name: "subrs", type: "INDEX", value: [] }
  ]);
}
function vU(e, n) {
  for (var s = new De.Record("Charsets", [
    { name: "format", type: "Card8", value: 0 }
  ]), i = 0; i < e.length; i += 1) {
    var r = e[i], o = hy(r, n);
    s.fields.push({ name: "glyph_" + i, type: "SID", value: o });
  }
  return s;
}
function RU(e) {
  var n = [], s = e.path;
  n.push({ name: "width", type: "NUMBER", value: e.advanceWidth });
  for (var i = 0, r = 0, o = 0; o < s.commands.length; o += 1) {
    var a = void 0, c = void 0, l = s.commands[o];
    if (l.type === "Q") {
      var h = 0.3333333333333333, d = 2 / 3;
      l = {
        type: "C",
        x: l.x,
        y: l.y,
        x1: Math.round(h * i + d * l.x1),
        y1: Math.round(h * r + d * l.y1),
        x2: Math.round(h * l.x + d * l.x1),
        y2: Math.round(h * l.y + d * l.y1)
      };
    }
    if (l.type === "M")
      a = Math.round(l.x - i), c = Math.round(l.y - r), n.push({ name: "dx", type: "NUMBER", value: a }), n.push({ name: "dy", type: "NUMBER", value: c }), n.push({ name: "rmoveto", type: "OP", value: 21 }), i = Math.round(l.x), r = Math.round(l.y);
    else if (l.type === "L")
      a = Math.round(l.x - i), c = Math.round(l.y - r), n.push({ name: "dx", type: "NUMBER", value: a }), n.push({ name: "dy", type: "NUMBER", value: c }), n.push({ name: "rlineto", type: "OP", value: 5 }), i = Math.round(l.x), r = Math.round(l.y);
    else if (l.type === "C") {
      var p = Math.round(l.x1 - i), E = Math.round(l.y1 - r), g = Math.round(l.x2 - l.x1), T = Math.round(l.y2 - l.y1);
      a = Math.round(l.x - l.x2), c = Math.round(l.y - l.y2), n.push({ name: "dx1", type: "NUMBER", value: p }), n.push({ name: "dy1", type: "NUMBER", value: E }), n.push({ name: "dx2", type: "NUMBER", value: g }), n.push({ name: "dy2", type: "NUMBER", value: T }), n.push({ name: "dx", type: "NUMBER", value: a }), n.push({ name: "dy", type: "NUMBER", value: c }), n.push({ name: "rrcurveto", type: "OP", value: 8 }), i = Math.round(l.x), r = Math.round(l.y);
    }
  }
  return n.push({ name: "endchar", type: "OP", value: 14 }), n;
}
function wU(e) {
  for (var n = new De.Record("CharStrings INDEX", [
    { name: "charStrings", type: "INDEX", value: [] }
  ]), s = 0; s < e.length; s += 1) {
    var i = e.get(s), r = RU(i);
    n.charStrings.push({ name: i.name, type: "CHARSTRING", value: r });
  }
  return n;
}
function DU(e, n) {
  var s = new De.Record("Private DICT", [
    { name: "dict", type: "DICT", value: {} }
  ]);
  return s.dict = uy(cy, e, n), s;
}
function LU(e, n) {
  for (var s = new De.Table("CFF ", [
    { name: "header", type: "RECORD" },
    { name: "nameIndex", type: "RECORD" },
    { name: "topDictIndex", type: "RECORD" },
    { name: "stringIndex", type: "RECORD" },
    { name: "globalSubrIndex", type: "RECORD" },
    { name: "charsets", type: "RECORD" },
    { name: "charStringsIndex", type: "RECORD" },
    { name: "privateDict", type: "RECORD" }
  ]), i = 1 / n.unitsPerEm, r = {
    version: n.version,
    fullName: n.fullName,
    familyName: n.familyName,
    weight: n.weightName,
    fontBBox: n.fontBBox || [0, 0, 0, 0],
    fontMatrix: [i, 0, 0, i, 0, 0],
    charset: 999,
    encoding: 0,
    charStrings: 999,
    private: [0, 999]
  }, o = {}, a = [], c, l = 1; l < e.length; l += 1)
    c = e.get(l), a.push(c.name);
  var h = [];
  s.header = yU(), s.nameIndex = CU([n.postScriptName]);
  var d = KO(r, h);
  s.topDictIndex = QO(d), s.globalSubrIndex = xU(), s.charsets = vU(a, h), s.charStringsIndex = wU(e), s.privateDict = DU(o, h), s.stringIndex = NU(h);
  var p = s.header.sizeOf() + s.nameIndex.sizeOf() + s.topDictIndex.sizeOf() + s.stringIndex.sizeOf() + s.globalSubrIndex.sizeOf();
  return r.charset = p, r.encoding = 0, r.charStrings = r.charset + s.charsets.sizeOf(), r.private[1] = r.charStrings + s.charStringsIndex.sizeOf(), d = KO(r, h), s.topDictIndex = QO(d), s;
}
var MU = { parse: SU, make: LU };
function PU(e, n) {
  var s = {}, i = new pt.Parser(e, n);
  return s.version = i.parseVersion(), s.fontRevision = Math.round(i.parseFixed() * 1e3) / 1e3, s.checkSumAdjustment = i.parseULong(), s.magicNumber = i.parseULong(), lt.argument(s.magicNumber === 1594834165, "Font header has wrong magic number."), s.flags = i.parseUShort(), s.unitsPerEm = i.parseUShort(), s.created = i.parseLongDateTime(), s.modified = i.parseLongDateTime(), s.xMin = i.parseShort(), s.yMin = i.parseShort(), s.xMax = i.parseShort(), s.yMax = i.parseShort(), s.macStyle = i.parseUShort(), s.lowestRecPPEM = i.parseUShort(), s.fontDirectionHint = i.parseShort(), s.indexToLocFormat = i.parseShort(), s.glyphDataFormat = i.parseShort(), s;
}
function bU(e) {
  var n = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) + 2082844800, s = n;
  return e.createdTimestamp && (s = e.createdTimestamp + 2082844800), new De.Table("head", [
    { name: "version", type: "FIXED", value: 65536 },
    { name: "fontRevision", type: "FIXED", value: 65536 },
    { name: "checkSumAdjustment", type: "ULONG", value: 0 },
    { name: "magicNumber", type: "ULONG", value: 1594834165 },
    { name: "flags", type: "USHORT", value: 0 },
    { name: "unitsPerEm", type: "USHORT", value: 1e3 },
    { name: "created", type: "LONGDATETIME", value: s },
    { name: "modified", type: "LONGDATETIME", value: n },
    { name: "xMin", type: "SHORT", value: 0 },
    { name: "yMin", type: "SHORT", value: 0 },
    { name: "xMax", type: "SHORT", value: 0 },
    { name: "yMax", type: "SHORT", value: 0 },
    { name: "macStyle", type: "USHORT", value: 0 },
    { name: "lowestRecPPEM", type: "USHORT", value: 0 },
    { name: "fontDirectionHint", type: "SHORT", value: 2 },
    { name: "indexToLocFormat", type: "SHORT", value: 0 },
    { name: "glyphDataFormat", type: "SHORT", value: 0 }
  ], e);
}
var UU = { parse: PU, make: bU };
function GU(e, n) {
  var s = {}, i = new pt.Parser(e, n);
  return s.version = i.parseVersion(), s.ascender = i.parseShort(), s.descender = i.parseShort(), s.lineGap = i.parseShort(), s.advanceWidthMax = i.parseUShort(), s.minLeftSideBearing = i.parseShort(), s.minRightSideBearing = i.parseShort(), s.xMaxExtent = i.parseShort(), s.caretSlopeRise = i.parseShort(), s.caretSlopeRun = i.parseShort(), s.caretOffset = i.parseShort(), i.relativeOffset += 8, s.metricDataFormat = i.parseShort(), s.numberOfHMetrics = i.parseUShort(), s;
}
function FU(e) {
  return new De.Table("hhea", [
    { name: "version", type: "FIXED", value: 65536 },
    { name: "ascender", type: "FWORD", value: 0 },
    { name: "descender", type: "FWORD", value: 0 },
    { name: "lineGap", type: "FWORD", value: 0 },
    { name: "advanceWidthMax", type: "UFWORD", value: 0 },
    { name: "minLeftSideBearing", type: "FWORD", value: 0 },
    { name: "minRightSideBearing", type: "FWORD", value: 0 },
    { name: "xMaxExtent", type: "FWORD", value: 0 },
    { name: "caretSlopeRise", type: "SHORT", value: 1 },
    { name: "caretSlopeRun", type: "SHORT", value: 0 },
    { name: "caretOffset", type: "SHORT", value: 0 },
    { name: "reserved1", type: "SHORT", value: 0 },
    { name: "reserved2", type: "SHORT", value: 0 },
    { name: "reserved3", type: "SHORT", value: 0 },
    { name: "reserved4", type: "SHORT", value: 0 },
    { name: "metricDataFormat", type: "SHORT", value: 0 },
    { name: "numberOfHMetrics", type: "USHORT", value: 0 }
  ], e);
}
var kU = { parse: GU, make: FU };
function BU(e, n, s, i, r) {
  for (var o, a, c = new pt.Parser(e, n), l = 0; l < i; l += 1) {
    l < s && (o = c.parseUShort(), a = c.parseShort());
    var h = r.get(l);
    h.advanceWidth = o, h.leftSideBearing = a;
  }
}
function VU(e, n, s, i, r) {
  e._hmtxTableData = {};
  for (var o, a, c = new pt.Parser(n, s), l = 0; l < r; l += 1)
    l < i && (o = c.parseUShort(), a = c.parseShort()), e._hmtxTableData[l] = {
      advanceWidth: o,
      leftSideBearing: a
    };
}
function HU(e, n, s, i, r, o, a) {
  a.lowMemory ? VU(e, n, s, i, r) : BU(n, s, i, r, o);
}
function WU(e) {
  for (var n = new De.Table("hmtx", []), s = 0; s < e.length; s += 1) {
    var i = e.get(s), r = i.advanceWidth || 0, o = i.leftSideBearing || 0;
    n.fields.push({ name: "advanceWidth_" + s, type: "USHORT", value: r }), n.fields.push({ name: "leftSideBearing_" + s, type: "SHORT", value: o });
  }
  return n;
}
var YU = { parse: HU, make: WU };
function XU(e) {
  for (var n = new De.Table("ltag", [
    { name: "version", type: "ULONG", value: 1 },
    { name: "flags", type: "ULONG", value: 0 },
    { name: "numTags", type: "ULONG", value: e.length }
  ]), s = "", i = 12 + e.length * 4, r = 0; r < e.length; ++r) {
    var o = s.indexOf(e[r]);
    o < 0 && (o = s.length, s += e[r]), n.fields.push({ name: "offset " + r, type: "USHORT", value: i + o }), n.fields.push({ name: "length " + r, type: "USHORT", value: e[r].length });
  }
  return n.fields.push({ name: "stringPool", type: "CHARARRAY", value: s }), n;
}
function zU(e, n) {
  var s = new pt.Parser(e, n), i = s.parseULong();
  lt.argument(i === 1, "Unsupported ltag table version."), s.skip("uLong", 1);
  for (var r = s.parseULong(), o = [], a = 0; a < r; a++) {
    for (var c = "", l = n + s.parseUShort(), h = s.parseUShort(), d = l; d < l + h; ++d)
      c += String.fromCharCode(e.getInt8(d));
    o.push(c);
  }
  return o;
}
var KU = { make: XU, parse: zU };
function QU(e, n) {
  var s = {}, i = new pt.Parser(e, n);
  return s.version = i.parseVersion(), s.numGlyphs = i.parseUShort(), s.version === 1 && (s.maxPoints = i.parseUShort(), s.maxContours = i.parseUShort(), s.maxCompositePoints = i.parseUShort(), s.maxCompositeContours = i.parseUShort(), s.maxZones = i.parseUShort(), s.maxTwilightPoints = i.parseUShort(), s.maxStorage = i.parseUShort(), s.maxFunctionDefs = i.parseUShort(), s.maxInstructionDefs = i.parseUShort(), s.maxStackElements = i.parseUShort(), s.maxSizeOfInstructions = i.parseUShort(), s.maxComponentElements = i.parseUShort(), s.maxComponentDepth = i.parseUShort()), s;
}
function ZU(e) {
  return new De.Table("maxp", [
    { name: "version", type: "FIXED", value: 20480 },
    { name: "numGlyphs", type: "USHORT", value: e }
  ]);
}
var qU = { parse: QU, make: ZU }, dy = [
  "copyright",
  // 0
  "fontFamily",
  // 1
  "fontSubfamily",
  // 2
  "uniqueID",
  // 3
  "fullName",
  // 4
  "version",
  // 5
  "postScriptName",
  // 6
  "trademark",
  // 7
  "manufacturer",
  // 8
  "designer",
  // 9
  "description",
  // 10
  "manufacturerURL",
  // 11
  "designerURL",
  // 12
  "license",
  // 13
  "licenseURL",
  // 14
  "reserved",
  // 15
  "preferredFamily",
  // 16
  "preferredSubfamily",
  // 17
  "compatibleFullName",
  // 18
  "sampleText",
  // 19
  "postScriptFindFontName",
  // 20
  "wwsFamily",
  // 21
  "wwsSubfamily"
  // 22
], fy = {
  0: "en",
  1: "fr",
  2: "de",
  3: "it",
  4: "nl",
  5: "sv",
  6: "es",
  7: "da",
  8: "pt",
  9: "no",
  10: "he",
  11: "ja",
  12: "ar",
  13: "fi",
  14: "el",
  15: "is",
  16: "mt",
  17: "tr",
  18: "hr",
  19: "zh-Hant",
  20: "ur",
  21: "hi",
  22: "th",
  23: "ko",
  24: "lt",
  25: "pl",
  26: "hu",
  27: "es",
  28: "lv",
  29: "se",
  30: "fo",
  31: "fa",
  32: "ru",
  33: "zh",
  34: "nl-BE",
  35: "ga",
  36: "sq",
  37: "ro",
  38: "cz",
  39: "sk",
  40: "si",
  41: "yi",
  42: "sr",
  43: "mk",
  44: "bg",
  45: "uk",
  46: "be",
  47: "uz",
  48: "kk",
  49: "az-Cyrl",
  50: "az-Arab",
  51: "hy",
  52: "ka",
  53: "mo",
  54: "ky",
  55: "tg",
  56: "tk",
  57: "mn-CN",
  58: "mn",
  59: "ps",
  60: "ks",
  61: "ku",
  62: "sd",
  63: "bo",
  64: "ne",
  65: "sa",
  66: "mr",
  67: "bn",
  68: "as",
  69: "gu",
  70: "pa",
  71: "or",
  72: "ml",
  73: "kn",
  74: "ta",
  75: "te",
  76: "si",
  77: "my",
  78: "km",
  79: "lo",
  80: "vi",
  81: "id",
  82: "tl",
  83: "ms",
  84: "ms-Arab",
  85: "am",
  86: "ti",
  87: "om",
  88: "so",
  89: "sw",
  90: "rw",
  91: "rn",
  92: "ny",
  93: "mg",
  94: "eo",
  128: "cy",
  129: "eu",
  130: "ca",
  131: "la",
  132: "qu",
  133: "gn",
  134: "ay",
  135: "tt",
  136: "ug",
  137: "dz",
  138: "jv",
  139: "su",
  140: "gl",
  141: "af",
  142: "br",
  143: "iu",
  144: "gd",
  145: "gv",
  146: "ga",
  147: "to",
  148: "el-polyton",
  149: "kl",
  150: "az",
  151: "nn"
}, jU = {
  0: 0,
  // langEnglish → smRoman
  1: 0,
  // langFrench → smRoman
  2: 0,
  // langGerman → smRoman
  3: 0,
  // langItalian → smRoman
  4: 0,
  // langDutch → smRoman
  5: 0,
  // langSwedish → smRoman
  6: 0,
  // langSpanish → smRoman
  7: 0,
  // langDanish → smRoman
  8: 0,
  // langPortuguese → smRoman
  9: 0,
  // langNorwegian → smRoman
  10: 5,
  // langHebrew → smHebrew
  11: 1,
  // langJapanese → smJapanese
  12: 4,
  // langArabic → smArabic
  13: 0,
  // langFinnish → smRoman
  14: 6,
  // langGreek → smGreek
  15: 0,
  // langIcelandic → smRoman (modified)
  16: 0,
  // langMaltese → smRoman
  17: 0,
  // langTurkish → smRoman (modified)
  18: 0,
  // langCroatian → smRoman (modified)
  19: 2,
  // langTradChinese → smTradChinese
  20: 4,
  // langUrdu → smArabic
  21: 9,
  // langHindi → smDevanagari
  22: 21,
  // langThai → smThai
  23: 3,
  // langKorean → smKorean
  24: 29,
  // langLithuanian → smCentralEuroRoman
  25: 29,
  // langPolish → smCentralEuroRoman
  26: 29,
  // langHungarian → smCentralEuroRoman
  27: 29,
  // langEstonian → smCentralEuroRoman
  28: 29,
  // langLatvian → smCentralEuroRoman
  29: 0,
  // langSami → smRoman
  30: 0,
  // langFaroese → smRoman (modified)
  31: 4,
  // langFarsi → smArabic (modified)
  32: 7,
  // langRussian → smCyrillic
  33: 25,
  // langSimpChinese → smSimpChinese
  34: 0,
  // langFlemish → smRoman
  35: 0,
  // langIrishGaelic → smRoman (modified)
  36: 0,
  // langAlbanian → smRoman
  37: 0,
  // langRomanian → smRoman (modified)
  38: 29,
  // langCzech → smCentralEuroRoman
  39: 29,
  // langSlovak → smCentralEuroRoman
  40: 0,
  // langSlovenian → smRoman (modified)
  41: 5,
  // langYiddish → smHebrew
  42: 7,
  // langSerbian → smCyrillic
  43: 7,
  // langMacedonian → smCyrillic
  44: 7,
  // langBulgarian → smCyrillic
  45: 7,
  // langUkrainian → smCyrillic (modified)
  46: 7,
  // langByelorussian → smCyrillic
  47: 7,
  // langUzbek → smCyrillic
  48: 7,
  // langKazakh → smCyrillic
  49: 7,
  // langAzerbaijani → smCyrillic
  50: 4,
  // langAzerbaijanAr → smArabic
  51: 24,
  // langArmenian → smArmenian
  52: 23,
  // langGeorgian → smGeorgian
  53: 7,
  // langMoldavian → smCyrillic
  54: 7,
  // langKirghiz → smCyrillic
  55: 7,
  // langTajiki → smCyrillic
  56: 7,
  // langTurkmen → smCyrillic
  57: 27,
  // langMongolian → smMongolian
  58: 7,
  // langMongolianCyr → smCyrillic
  59: 4,
  // langPashto → smArabic
  60: 4,
  // langKurdish → smArabic
  61: 4,
  // langKashmiri → smArabic
  62: 4,
  // langSindhi → smArabic
  63: 26,
  // langTibetan → smTibetan
  64: 9,
  // langNepali → smDevanagari
  65: 9,
  // langSanskrit → smDevanagari
  66: 9,
  // langMarathi → smDevanagari
  67: 13,
  // langBengali → smBengali
  68: 13,
  // langAssamese → smBengali
  69: 11,
  // langGujarati → smGujarati
  70: 10,
  // langPunjabi → smGurmukhi
  71: 12,
  // langOriya → smOriya
  72: 17,
  // langMalayalam → smMalayalam
  73: 16,
  // langKannada → smKannada
  74: 14,
  // langTamil → smTamil
  75: 15,
  // langTelugu → smTelugu
  76: 18,
  // langSinhalese → smSinhalese
  77: 19,
  // langBurmese → smBurmese
  78: 20,
  // langKhmer → smKhmer
  79: 22,
  // langLao → smLao
  80: 30,
  // langVietnamese → smVietnamese
  81: 0,
  // langIndonesian → smRoman
  82: 0,
  // langTagalog → smRoman
  83: 0,
  // langMalayRoman → smRoman
  84: 4,
  // langMalayArabic → smArabic
  85: 28,
  // langAmharic → smEthiopic
  86: 28,
  // langTigrinya → smEthiopic
  87: 28,
  // langOromo → smEthiopic
  88: 0,
  // langSomali → smRoman
  89: 0,
  // langSwahili → smRoman
  90: 0,
  // langKinyarwanda → smRoman
  91: 0,
  // langRundi → smRoman
  92: 0,
  // langNyanja → smRoman
  93: 0,
  // langMalagasy → smRoman
  94: 0,
  // langEsperanto → smRoman
  128: 0,
  // langWelsh → smRoman (modified)
  129: 0,
  // langBasque → smRoman
  130: 0,
  // langCatalan → smRoman
  131: 0,
  // langLatin → smRoman
  132: 0,
  // langQuechua → smRoman
  133: 0,
  // langGuarani → smRoman
  134: 0,
  // langAymara → smRoman
  135: 7,
  // langTatar → smCyrillic
  136: 4,
  // langUighur → smArabic
  137: 26,
  // langDzongkha → smTibetan
  138: 0,
  // langJavaneseRom → smRoman
  139: 0,
  // langSundaneseRom → smRoman
  140: 0,
  // langGalician → smRoman
  141: 0,
  // langAfrikaans → smRoman
  142: 0,
  // langBreton → smRoman (modified)
  143: 28,
  // langInuktitut → smEthiopic (modified)
  144: 0,
  // langScottishGaelic → smRoman (modified)
  145: 0,
  // langManxGaelic → smRoman (modified)
  146: 0,
  // langIrishGaelicScript → smRoman (modified)
  147: 0,
  // langTongan → smRoman
  148: 6,
  // langGreekAncient → smRoman
  149: 0,
  // langGreenlandic → smRoman
  150: 0,
  // langAzerbaijanRoman → smRoman
  151: 0
  // langNynorsk → smRoman
}, py = {
  1078: "af",
  1052: "sq",
  1156: "gsw",
  1118: "am",
  5121: "ar-DZ",
  15361: "ar-BH",
  3073: "ar",
  2049: "ar-IQ",
  11265: "ar-JO",
  13313: "ar-KW",
  12289: "ar-LB",
  4097: "ar-LY",
  6145: "ary",
  8193: "ar-OM",
  16385: "ar-QA",
  1025: "ar-SA",
  10241: "ar-SY",
  7169: "aeb",
  14337: "ar-AE",
  9217: "ar-YE",
  1067: "hy",
  1101: "as",
  2092: "az-Cyrl",
  1068: "az",
  1133: "ba",
  1069: "eu",
  1059: "be",
  2117: "bn",
  1093: "bn-IN",
  8218: "bs-Cyrl",
  5146: "bs",
  1150: "br",
  1026: "bg",
  1027: "ca",
  3076: "zh-HK",
  5124: "zh-MO",
  2052: "zh",
  4100: "zh-SG",
  1028: "zh-TW",
  1155: "co",
  1050: "hr",
  4122: "hr-BA",
  1029: "cs",
  1030: "da",
  1164: "prs",
  1125: "dv",
  2067: "nl-BE",
  1043: "nl",
  3081: "en-AU",
  10249: "en-BZ",
  4105: "en-CA",
  9225: "en-029",
  16393: "en-IN",
  6153: "en-IE",
  8201: "en-JM",
  17417: "en-MY",
  5129: "en-NZ",
  13321: "en-PH",
  18441: "en-SG",
  7177: "en-ZA",
  11273: "en-TT",
  2057: "en-GB",
  1033: "en",
  12297: "en-ZW",
  1061: "et",
  1080: "fo",
  1124: "fil",
  1035: "fi",
  2060: "fr-BE",
  3084: "fr-CA",
  1036: "fr",
  5132: "fr-LU",
  6156: "fr-MC",
  4108: "fr-CH",
  1122: "fy",
  1110: "gl",
  1079: "ka",
  3079: "de-AT",
  1031: "de",
  5127: "de-LI",
  4103: "de-LU",
  2055: "de-CH",
  1032: "el",
  1135: "kl",
  1095: "gu",
  1128: "ha",
  1037: "he",
  1081: "hi",
  1038: "hu",
  1039: "is",
  1136: "ig",
  1057: "id",
  1117: "iu",
  2141: "iu-Latn",
  2108: "ga",
  1076: "xh",
  1077: "zu",
  1040: "it",
  2064: "it-CH",
  1041: "ja",
  1099: "kn",
  1087: "kk",
  1107: "km",
  1158: "quc",
  1159: "rw",
  1089: "sw",
  1111: "kok",
  1042: "ko",
  1088: "ky",
  1108: "lo",
  1062: "lv",
  1063: "lt",
  2094: "dsb",
  1134: "lb",
  1071: "mk",
  2110: "ms-BN",
  1086: "ms",
  1100: "ml",
  1082: "mt",
  1153: "mi",
  1146: "arn",
  1102: "mr",
  1148: "moh",
  1104: "mn",
  2128: "mn-CN",
  1121: "ne",
  1044: "nb",
  2068: "nn",
  1154: "oc",
  1096: "or",
  1123: "ps",
  1045: "pl",
  1046: "pt",
  2070: "pt-PT",
  1094: "pa",
  1131: "qu-BO",
  2155: "qu-EC",
  3179: "qu",
  1048: "ro",
  1047: "rm",
  1049: "ru",
  9275: "smn",
  4155: "smj-NO",
  5179: "smj",
  3131: "se-FI",
  1083: "se",
  2107: "se-SE",
  8251: "sms",
  6203: "sma-NO",
  7227: "sms",
  1103: "sa",
  7194: "sr-Cyrl-BA",
  3098: "sr",
  6170: "sr-Latn-BA",
  2074: "sr-Latn",
  1132: "nso",
  1074: "tn",
  1115: "si",
  1051: "sk",
  1060: "sl",
  11274: "es-AR",
  16394: "es-BO",
  13322: "es-CL",
  9226: "es-CO",
  5130: "es-CR",
  7178: "es-DO",
  12298: "es-EC",
  17418: "es-SV",
  4106: "es-GT",
  18442: "es-HN",
  2058: "es-MX",
  19466: "es-NI",
  6154: "es-PA",
  15370: "es-PY",
  10250: "es-PE",
  20490: "es-PR",
  // Microsoft has defined two different language codes for
  // “Spanish with modern sorting” and “Spanish with traditional
  // sorting”. This makes sense for collation APIs, and it would be
  // possible to express this in BCP 47 language tags via Unicode
  // extensions (eg., es-u-co-trad is Spanish with traditional
  // sorting). However, for storing names in fonts, the distinction
  // does not make sense, so we give “es” in both cases.
  3082: "es",
  1034: "es",
  21514: "es-US",
  14346: "es-UY",
  8202: "es-VE",
  2077: "sv-FI",
  1053: "sv",
  1114: "syr",
  1064: "tg",
  2143: "tzm",
  1097: "ta",
  1092: "tt",
  1098: "te",
  1054: "th",
  1105: "bo",
  1055: "tr",
  1090: "tk",
  1152: "ug",
  1058: "uk",
  1070: "hsb",
  1056: "ur",
  2115: "uz-Cyrl",
  1091: "uz",
  1066: "vi",
  1106: "cy",
  1160: "wo",
  1157: "sah",
  1144: "ii",
  1130: "yo"
};
function JU(e, n, s) {
  switch (e) {
    case 0:
      if (n === 65535)
        return "und";
      if (s)
        return s[n];
      break;
    case 1:
      return fy[n];
    case 3:
      return py[n];
  }
}
var eg = "utf-16", $U = {
  0: "macintosh",
  // smRoman
  1: "x-mac-japanese",
  // smJapanese
  2: "x-mac-chinesetrad",
  // smTradChinese
  3: "x-mac-korean",
  // smKorean
  6: "x-mac-greek",
  // smGreek
  7: "x-mac-cyrillic",
  // smCyrillic
  9: "x-mac-devanagai",
  // smDevanagari
  10: "x-mac-gurmukhi",
  // smGurmukhi
  11: "x-mac-gujarati",
  // smGujarati
  12: "x-mac-oriya",
  // smOriya
  13: "x-mac-bengali",
  // smBengali
  14: "x-mac-tamil",
  // smTamil
  15: "x-mac-telugu",
  // smTelugu
  16: "x-mac-kannada",
  // smKannada
  17: "x-mac-malayalam",
  // smMalayalam
  18: "x-mac-sinhalese",
  // smSinhalese
  19: "x-mac-burmese",
  // smBurmese
  20: "x-mac-khmer",
  // smKhmer
  21: "x-mac-thai",
  // smThai
  22: "x-mac-lao",
  // smLao
  23: "x-mac-georgian",
  // smGeorgian
  24: "x-mac-armenian",
  // smArmenian
  25: "x-mac-chinesesimp",
  // smSimpChinese
  26: "x-mac-tibetan",
  // smTibetan
  27: "x-mac-mongolian",
  // smMongolian
  28: "x-mac-ethiopic",
  // smEthiopic
  29: "x-mac-ce",
  // smCentralEuroRoman
  30: "x-mac-vietnamese",
  // smVietnamese
  31: "x-mac-extarabic"
  // smExtArabic
}, eG = {
  15: "x-mac-icelandic",
  // langIcelandic
  17: "x-mac-turkish",
  // langTurkish
  18: "x-mac-croatian",
  // langCroatian
  24: "x-mac-ce",
  // langLithuanian
  25: "x-mac-ce",
  // langPolish
  26: "x-mac-ce",
  // langHungarian
  27: "x-mac-ce",
  // langEstonian
  28: "x-mac-ce",
  // langLatvian
  30: "x-mac-icelandic",
  // langFaroese
  37: "x-mac-romanian",
  // langRomanian
  38: "x-mac-ce",
  // langCzech
  39: "x-mac-ce",
  // langSlovak
  40: "x-mac-ce",
  // langSlovenian
  143: "x-mac-inuit",
  // langInuktitut
  146: "x-mac-gaelic"
  // langIrishGaelicScript
};
function Ey(e, n, s) {
  switch (e) {
    case 0:
      return eg;
    case 1:
      return eG[s] || $U[n];
    case 3:
      if (n === 1 || n === 10)
        return eg;
      break;
  }
}
function tG(e, n, s) {
  for (var i = {}, r = new pt.Parser(e, n), o = r.parseUShort(), a = r.parseUShort(), c = r.offset + r.parseUShort(), l = 0; l < a; l++) {
    var h = r.parseUShort(), d = r.parseUShort(), p = r.parseUShort(), E = r.parseUShort(), g = dy[E] || E, T = r.parseUShort(), A = r.parseUShort(), m = JU(h, p, s), O = Ey(h, d, p);
    if (O !== void 0 && m !== void 0) {
      var S = void 0;
      if (O === eg ? S = Gc.UTF16(e, c + A, T) : S = Gc.MACSTRING(e, c + A, T, O), S) {
        var y = i[g];
        y === void 0 && (y = i[g] = {}), y[m] = S;
      }
    }
  }
  return o === 1 && r.parseUShort(), i;
}
function Qp(e) {
  var n = {};
  for (var s in e)
    n[e[s]] = parseInt(s);
  return n;
}
function ZO(e, n, s, i, r, o) {
  return new De.Record("NameRecord", [
    { name: "platformID", type: "USHORT", value: e },
    { name: "encodingID", type: "USHORT", value: n },
    { name: "languageID", type: "USHORT", value: s },
    { name: "nameID", type: "USHORT", value: i },
    { name: "length", type: "USHORT", value: r },
    { name: "offset", type: "USHORT", value: o }
  ]);
}
function nG(e, n) {
  var s = e.length, i = n.length - s + 1;
  e:
    for (var r = 0; r < i; r++)
      for (; r < i; r++) {
        for (var o = 0; o < s; o++)
          if (n[r + o] !== e[o])
            continue e;
        return r;
      }
  return -1;
}
function qO(e, n) {
  var s = nG(e, n);
  if (s < 0) {
    s = n.length;
    for (var i = 0, r = e.length; i < r; ++i)
      n.push(e[i]);
  }
  return s;
}
function sG(e, n) {
  var s, i = [], r = {}, o = Qp(dy);
  for (var a in e) {
    var c = o[a];
    if (c === void 0 && (c = a), s = parseInt(c), isNaN(s))
      throw new Error('Name table entry "' + a + '" does not exist, see nameTableNames for complete list.');
    r[s] = e[a], i.push(s);
  }
  for (var l = Qp(fy), h = Qp(py), d = [], p = [], E = 0; E < i.length; E++) {
    s = i[E];
    var g = r[s];
    for (var T in g) {
      var A = g[T], m = 1, O = l[T], S = jU[O], y = Ey(m, S, O), v = Ae.MACSTRING(A, y);
      v === void 0 && (m = 0, O = n.indexOf(T), O < 0 && (O = n.length, n.push(T)), S = 4, v = Ae.UTF16(A));
      var R = qO(v, p);
      d.push(ZO(
        m,
        S,
        O,
        s,
        v.length,
        R
      ));
      var M = h[T];
      if (M !== void 0) {
        var L = Ae.UTF16(A), P = qO(L, p);
        d.push(ZO(
          3,
          1,
          M,
          s,
          L.length,
          P
        ));
      }
    }
  }
  d.sort(function(b, X) {
    return b.platformID - X.platformID || b.encodingID - X.encodingID || b.languageID - X.languageID || b.nameID - X.nameID;
  });
  for (var k = new De.Table("name", [
    { name: "format", type: "USHORT", value: 0 },
    { name: "count", type: "USHORT", value: d.length },
    { name: "stringOffset", type: "USHORT", value: 6 + d.length * 12 }
  ]), Q = 0; Q < d.length; Q++)
    k.fields.push({ name: "record_" + Q, type: "RECORD", value: d[Q] });
  return k.fields.push({ name: "strings", type: "LITERAL", value: p }), k;
}
var iG = { parse: tG, make: sG }, tg = [
  { begin: 0, end: 127 },
  // Basic Latin
  { begin: 128, end: 255 },
  // Latin-1 Supplement
  { begin: 256, end: 383 },
  // Latin Extended-A
  { begin: 384, end: 591 },
  // Latin Extended-B
  { begin: 592, end: 687 },
  // IPA Extensions
  { begin: 688, end: 767 },
  // Spacing Modifier Letters
  { begin: 768, end: 879 },
  // Combining Diacritical Marks
  { begin: 880, end: 1023 },
  // Greek and Coptic
  { begin: 11392, end: 11519 },
  // Coptic
  { begin: 1024, end: 1279 },
  // Cyrillic
  { begin: 1328, end: 1423 },
  // Armenian
  { begin: 1424, end: 1535 },
  // Hebrew
  { begin: 42240, end: 42559 },
  // Vai
  { begin: 1536, end: 1791 },
  // Arabic
  { begin: 1984, end: 2047 },
  // NKo
  { begin: 2304, end: 2431 },
  // Devanagari
  { begin: 2432, end: 2559 },
  // Bengali
  { begin: 2560, end: 2687 },
  // Gurmukhi
  { begin: 2688, end: 2815 },
  // Gujarati
  { begin: 2816, end: 2943 },
  // Oriya
  { begin: 2944, end: 3071 },
  // Tamil
  { begin: 3072, end: 3199 },
  // Telugu
  { begin: 3200, end: 3327 },
  // Kannada
  { begin: 3328, end: 3455 },
  // Malayalam
  { begin: 3584, end: 3711 },
  // Thai
  { begin: 3712, end: 3839 },
  // Lao
  { begin: 4256, end: 4351 },
  // Georgian
  { begin: 6912, end: 7039 },
  // Balinese
  { begin: 4352, end: 4607 },
  // Hangul Jamo
  { begin: 7680, end: 7935 },
  // Latin Extended Additional
  { begin: 7936, end: 8191 },
  // Greek Extended
  { begin: 8192, end: 8303 },
  // General Punctuation
  { begin: 8304, end: 8351 },
  // Superscripts And Subscripts
  { begin: 8352, end: 8399 },
  // Currency Symbol
  { begin: 8400, end: 8447 },
  // Combining Diacritical Marks For Symbols
  { begin: 8448, end: 8527 },
  // Letterlike Symbols
  { begin: 8528, end: 8591 },
  // Number Forms
  { begin: 8592, end: 8703 },
  // Arrows
  { begin: 8704, end: 8959 },
  // Mathematical Operators
  { begin: 8960, end: 9215 },
  // Miscellaneous Technical
  { begin: 9216, end: 9279 },
  // Control Pictures
  { begin: 9280, end: 9311 },
  // Optical Character Recognition
  { begin: 9312, end: 9471 },
  // Enclosed Alphanumerics
  { begin: 9472, end: 9599 },
  // Box Drawing
  { begin: 9600, end: 9631 },
  // Block Elements
  { begin: 9632, end: 9727 },
  // Geometric Shapes
  { begin: 9728, end: 9983 },
  // Miscellaneous Symbols
  { begin: 9984, end: 10175 },
  // Dingbats
  { begin: 12288, end: 12351 },
  // CJK Symbols And Punctuation
  { begin: 12352, end: 12447 },
  // Hiragana
  { begin: 12448, end: 12543 },
  // Katakana
  { begin: 12544, end: 12591 },
  // Bopomofo
  { begin: 12592, end: 12687 },
  // Hangul Compatibility Jamo
  { begin: 43072, end: 43135 },
  // Phags-pa
  { begin: 12800, end: 13055 },
  // Enclosed CJK Letters And Months
  { begin: 13056, end: 13311 },
  // CJK Compatibility
  { begin: 44032, end: 55215 },
  // Hangul Syllables
  { begin: 55296, end: 57343 },
  // Non-Plane 0 *
  { begin: 67840, end: 67871 },
  // Phoenicia
  { begin: 19968, end: 40959 },
  // CJK Unified Ideographs
  { begin: 57344, end: 63743 },
  // Private Use Area (plane 0)
  { begin: 12736, end: 12783 },
  // CJK Strokes
  { begin: 64256, end: 64335 },
  // Alphabetic Presentation Forms
  { begin: 64336, end: 65023 },
  // Arabic Presentation Forms-A
  { begin: 65056, end: 65071 },
  // Combining Half Marks
  { begin: 65040, end: 65055 },
  // Vertical Forms
  { begin: 65104, end: 65135 },
  // Small Form Variants
  { begin: 65136, end: 65279 },
  // Arabic Presentation Forms-B
  { begin: 65280, end: 65519 },
  // Halfwidth And Fullwidth Forms
  { begin: 65520, end: 65535 },
  // Specials
  { begin: 3840, end: 4095 },
  // Tibetan
  { begin: 1792, end: 1871 },
  // Syriac
  { begin: 1920, end: 1983 },
  // Thaana
  { begin: 3456, end: 3583 },
  // Sinhala
  { begin: 4096, end: 4255 },
  // Myanmar
  { begin: 4608, end: 4991 },
  // Ethiopic
  { begin: 5024, end: 5119 },
  // Cherokee
  { begin: 5120, end: 5759 },
  // Unified Canadian Aboriginal Syllabics
  { begin: 5760, end: 5791 },
  // Ogham
  { begin: 5792, end: 5887 },
  // Runic
  { begin: 6016, end: 6143 },
  // Khmer
  { begin: 6144, end: 6319 },
  // Mongolian
  { begin: 10240, end: 10495 },
  // Braille Patterns
  { begin: 40960, end: 42127 },
  // Yi Syllables
  { begin: 5888, end: 5919 },
  // Tagalog
  { begin: 66304, end: 66351 },
  // Old Italic
  { begin: 66352, end: 66383 },
  // Gothic
  { begin: 66560, end: 66639 },
  // Deseret
  { begin: 118784, end: 119039 },
  // Byzantine Musical Symbols
  { begin: 119808, end: 120831 },
  // Mathematical Alphanumeric Symbols
  { begin: 1044480, end: 1048573 },
  // Private Use (plane 15)
  { begin: 65024, end: 65039 },
  // Variation Selectors
  { begin: 917504, end: 917631 },
  // Tags
  { begin: 6400, end: 6479 },
  // Limbu
  { begin: 6480, end: 6527 },
  // Tai Le
  { begin: 6528, end: 6623 },
  // New Tai Lue
  { begin: 6656, end: 6687 },
  // Buginese
  { begin: 11264, end: 11359 },
  // Glagolitic
  { begin: 11568, end: 11647 },
  // Tifinagh
  { begin: 19904, end: 19967 },
  // Yijing Hexagram Symbols
  { begin: 43008, end: 43055 },
  // Syloti Nagri
  { begin: 65536, end: 65663 },
  // Linear B Syllabary
  { begin: 65856, end: 65935 },
  // Ancient Greek Numbers
  { begin: 66432, end: 66463 },
  // Ugaritic
  { begin: 66464, end: 66527 },
  // Old Persian
  { begin: 66640, end: 66687 },
  // Shavian
  { begin: 66688, end: 66735 },
  // Osmanya
  { begin: 67584, end: 67647 },
  // Cypriot Syllabary
  { begin: 68096, end: 68191 },
  // Kharoshthi
  { begin: 119552, end: 119647 },
  // Tai Xuan Jing Symbols
  { begin: 73728, end: 74751 },
  // Cuneiform
  { begin: 119648, end: 119679 },
  // Counting Rod Numerals
  { begin: 7040, end: 7103 },
  // Sundanese
  { begin: 7168, end: 7247 },
  // Lepcha
  { begin: 7248, end: 7295 },
  // Ol Chiki
  { begin: 43136, end: 43231 },
  // Saurashtra
  { begin: 43264, end: 43311 },
  // Kayah Li
  { begin: 43312, end: 43359 },
  // Rejang
  { begin: 43520, end: 43615 },
  // Cham
  { begin: 65936, end: 65999 },
  // Ancient Symbols
  { begin: 66e3, end: 66047 },
  // Phaistos Disc
  { begin: 66208, end: 66271 },
  // Carian
  { begin: 127024, end: 127135 }
  // Domino Tiles
];
function rG(e) {
  for (var n = 0; n < tg.length; n += 1) {
    var s = tg[n];
    if (e >= s.begin && e < s.end)
      return n;
  }
  return -1;
}
function oG(e, n) {
  var s = {}, i = new pt.Parser(e, n);
  s.version = i.parseUShort(), s.xAvgCharWidth = i.parseShort(), s.usWeightClass = i.parseUShort(), s.usWidthClass = i.parseUShort(), s.fsType = i.parseUShort(), s.ySubscriptXSize = i.parseShort(), s.ySubscriptYSize = i.parseShort(), s.ySubscriptXOffset = i.parseShort(), s.ySubscriptYOffset = i.parseShort(), s.ySuperscriptXSize = i.parseShort(), s.ySuperscriptYSize = i.parseShort(), s.ySuperscriptXOffset = i.parseShort(), s.ySuperscriptYOffset = i.parseShort(), s.yStrikeoutSize = i.parseShort(), s.yStrikeoutPosition = i.parseShort(), s.sFamilyClass = i.parseShort(), s.panose = [];
  for (var r = 0; r < 10; r++)
    s.panose[r] = i.parseByte();
  return s.ulUnicodeRange1 = i.parseULong(), s.ulUnicodeRange2 = i.parseULong(), s.ulUnicodeRange3 = i.parseULong(), s.ulUnicodeRange4 = i.parseULong(), s.achVendID = String.fromCharCode(i.parseByte(), i.parseByte(), i.parseByte(), i.parseByte()), s.fsSelection = i.parseUShort(), s.usFirstCharIndex = i.parseUShort(), s.usLastCharIndex = i.parseUShort(), s.sTypoAscender = i.parseShort(), s.sTypoDescender = i.parseShort(), s.sTypoLineGap = i.parseShort(), s.usWinAscent = i.parseUShort(), s.usWinDescent = i.parseUShort(), s.version >= 1 && (s.ulCodePageRange1 = i.parseULong(), s.ulCodePageRange2 = i.parseULong()), s.version >= 2 && (s.sxHeight = i.parseShort(), s.sCapHeight = i.parseShort(), s.usDefaultChar = i.parseUShort(), s.usBreakChar = i.parseUShort(), s.usMaxContent = i.parseUShort()), s;
}
function aG(e) {
  return new De.Table("OS/2", [
    { name: "version", type: "USHORT", value: 3 },
    { name: "xAvgCharWidth", type: "SHORT", value: 0 },
    { name: "usWeightClass", type: "USHORT", value: 0 },
    { name: "usWidthClass", type: "USHORT", value: 0 },
    { name: "fsType", type: "USHORT", value: 0 },
    { name: "ySubscriptXSize", type: "SHORT", value: 650 },
    { name: "ySubscriptYSize", type: "SHORT", value: 699 },
    { name: "ySubscriptXOffset", type: "SHORT", value: 0 },
    { name: "ySubscriptYOffset", type: "SHORT", value: 140 },
    { name: "ySuperscriptXSize", type: "SHORT", value: 650 },
    { name: "ySuperscriptYSize", type: "SHORT", value: 699 },
    { name: "ySuperscriptXOffset", type: "SHORT", value: 0 },
    { name: "ySuperscriptYOffset", type: "SHORT", value: 479 },
    { name: "yStrikeoutSize", type: "SHORT", value: 49 },
    { name: "yStrikeoutPosition", type: "SHORT", value: 258 },
    { name: "sFamilyClass", type: "SHORT", value: 0 },
    { name: "bFamilyType", type: "BYTE", value: 0 },
    { name: "bSerifStyle", type: "BYTE", value: 0 },
    { name: "bWeight", type: "BYTE", value: 0 },
    { name: "bProportion", type: "BYTE", value: 0 },
    { name: "bContrast", type: "BYTE", value: 0 },
    { name: "bStrokeVariation", type: "BYTE", value: 0 },
    { name: "bArmStyle", type: "BYTE", value: 0 },
    { name: "bLetterform", type: "BYTE", value: 0 },
    { name: "bMidline", type: "BYTE", value: 0 },
    { name: "bXHeight", type: "BYTE", value: 0 },
    { name: "ulUnicodeRange1", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange2", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange3", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange4", type: "ULONG", value: 0 },
    { name: "achVendID", type: "CHARARRAY", value: "XXXX" },
    { name: "fsSelection", type: "USHORT", value: 0 },
    { name: "usFirstCharIndex", type: "USHORT", value: 0 },
    { name: "usLastCharIndex", type: "USHORT", value: 0 },
    { name: "sTypoAscender", type: "SHORT", value: 0 },
    { name: "sTypoDescender", type: "SHORT", value: 0 },
    { name: "sTypoLineGap", type: "SHORT", value: 0 },
    { name: "usWinAscent", type: "USHORT", value: 0 },
    { name: "usWinDescent", type: "USHORT", value: 0 },
    { name: "ulCodePageRange1", type: "ULONG", value: 0 },
    { name: "ulCodePageRange2", type: "ULONG", value: 0 },
    { name: "sxHeight", type: "SHORT", value: 0 },
    { name: "sCapHeight", type: "SHORT", value: 0 },
    { name: "usDefaultChar", type: "USHORT", value: 0 },
    { name: "usBreakChar", type: "USHORT", value: 0 },
    { name: "usMaxContext", type: "USHORT", value: 0 }
  ], e);
}
var jO = { parse: oG, make: aG, unicodeRanges: tg, getUnicodeRange: rG };
function cG(e, n) {
  var s = {}, i = new pt.Parser(e, n);
  switch (s.version = i.parseVersion(), s.italicAngle = i.parseFixed(), s.underlinePosition = i.parseShort(), s.underlineThickness = i.parseShort(), s.isFixedPitch = i.parseULong(), s.minMemType42 = i.parseULong(), s.maxMemType42 = i.parseULong(), s.minMemType1 = i.parseULong(), s.maxMemType1 = i.parseULong(), s.version) {
    case 1:
      s.names = YO.slice();
      break;
    case 2:
      s.numberOfGlyphs = i.parseUShort(), s.glyphNameIndex = new Array(s.numberOfGlyphs);
      for (var r = 0; r < s.numberOfGlyphs; r++)
        s.glyphNameIndex[r] = i.parseUShort();
      s.names = [];
      for (var o = 0; o < s.numberOfGlyphs; o++)
        if (s.glyphNameIndex[o] >= YO.length) {
          var a = i.parseChar();
          s.names.push(i.parseString(a));
        }
      break;
    case 2.5:
      s.numberOfGlyphs = i.parseUShort(), s.offset = new Array(s.numberOfGlyphs);
      for (var c = 0; c < s.numberOfGlyphs; c++)
        s.offset[c] = i.parseChar();
      break;
  }
  return s;
}
function lG() {
  return new De.Table("post", [
    { name: "version", type: "FIXED", value: 196608 },
    { name: "italicAngle", type: "FIXED", value: 0 },
    { name: "underlinePosition", type: "FWORD", value: 0 },
    { name: "underlineThickness", type: "FWORD", value: 0 },
    { name: "isFixedPitch", type: "ULONG", value: 0 },
    { name: "minMemType42", type: "ULONG", value: 0 },
    { name: "maxMemType42", type: "ULONG", value: 0 },
    { name: "minMemType1", type: "ULONG", value: 0 },
    { name: "maxMemType1", type: "ULONG", value: 0 }
  ]);
}
var hG = { parse: cG, make: lG }, cr = new Array(9);
cr[1] = function() {
  var n = this.offset + this.relativeOffset, s = this.parseUShort();
  if (s === 1)
    return {
      substFormat: 1,
      coverage: this.parsePointer($.coverage),
      deltaGlyphId: this.parseUShort()
    };
  if (s === 2)
    return {
      substFormat: 2,
      coverage: this.parsePointer($.coverage),
      substitute: this.parseOffset16List()
    };
  lt.assert(!1, "0x" + n.toString(16) + ": lookup type 1 format must be 1 or 2.");
};
cr[2] = function() {
  var n = this.parseUShort();
  return lt.argument(n === 1, "GSUB Multiple Substitution Subtable identifier-format must be 1"), {
    substFormat: n,
    coverage: this.parsePointer($.coverage),
    sequences: this.parseListOfLists()
  };
};
cr[3] = function() {
  var n = this.parseUShort();
  return lt.argument(n === 1, "GSUB Alternate Substitution Subtable identifier-format must be 1"), {
    substFormat: n,
    coverage: this.parsePointer($.coverage),
    alternateSets: this.parseListOfLists()
  };
};
cr[4] = function() {
  var n = this.parseUShort();
  return lt.argument(n === 1, "GSUB ligature table identifier-format must be 1"), {
    substFormat: n,
    coverage: this.parsePointer($.coverage),
    ligatureSets: this.parseListOfLists(function() {
      return {
        ligGlyph: this.parseUShort(),
        components: this.parseUShortList(this.parseUShort() - 1)
      };
    })
  };
};
var yc = {
  sequenceIndex: $.uShort,
  lookupListIndex: $.uShort
};
cr[5] = function() {
  var n = this.offset + this.relativeOffset, s = this.parseUShort();
  if (s === 1)
    return {
      substFormat: s,
      coverage: this.parsePointer($.coverage),
      ruleSets: this.parseListOfLists(function() {
        var o = this.parseUShort(), a = this.parseUShort();
        return {
          input: this.parseUShortList(o - 1),
          lookupRecords: this.parseRecordList(a, yc)
        };
      })
    };
  if (s === 2)
    return {
      substFormat: s,
      coverage: this.parsePointer($.coverage),
      classDef: this.parsePointer($.classDef),
      classSets: this.parseListOfLists(function() {
        var o = this.parseUShort(), a = this.parseUShort();
        return {
          classes: this.parseUShortList(o - 1),
          lookupRecords: this.parseRecordList(a, yc)
        };
      })
    };
  if (s === 3) {
    var i = this.parseUShort(), r = this.parseUShort();
    return {
      substFormat: s,
      coverages: this.parseList(i, $.pointer($.coverage)),
      lookupRecords: this.parseRecordList(r, yc)
    };
  }
  lt.assert(!1, "0x" + n.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
};
cr[6] = function() {
  var n = this.offset + this.relativeOffset, s = this.parseUShort();
  if (s === 1)
    return {
      substFormat: 1,
      coverage: this.parsePointer($.coverage),
      chainRuleSets: this.parseListOfLists(function() {
        return {
          backtrack: this.parseUShortList(),
          input: this.parseUShortList(this.parseShort() - 1),
          lookahead: this.parseUShortList(),
          lookupRecords: this.parseRecordList(yc)
        };
      })
    };
  if (s === 2)
    return {
      substFormat: 2,
      coverage: this.parsePointer($.coverage),
      backtrackClassDef: this.parsePointer($.classDef),
      inputClassDef: this.parsePointer($.classDef),
      lookaheadClassDef: this.parsePointer($.classDef),
      chainClassSet: this.parseListOfLists(function() {
        return {
          backtrack: this.parseUShortList(),
          input: this.parseUShortList(this.parseShort() - 1),
          lookahead: this.parseUShortList(),
          lookupRecords: this.parseRecordList(yc)
        };
      })
    };
  if (s === 3)
    return {
      substFormat: 3,
      backtrackCoverage: this.parseList($.pointer($.coverage)),
      inputCoverage: this.parseList($.pointer($.coverage)),
      lookaheadCoverage: this.parseList($.pointer($.coverage)),
      lookupRecords: this.parseRecordList(yc)
    };
  lt.assert(!1, "0x" + n.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
};
cr[7] = function() {
  var n = this.parseUShort();
  lt.argument(n === 1, "GSUB Extension Substitution subtable identifier-format must be 1");
  var s = this.parseUShort(), i = new $(this.data, this.offset + this.parseULong());
  return {
    substFormat: 1,
    lookupType: s,
    extension: cr[s].call(i)
  };
};
cr[8] = function() {
  var n = this.parseUShort();
  return lt.argument(n === 1, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), {
    substFormat: n,
    coverage: this.parsePointer($.coverage),
    backtrackCoverage: this.parseList($.pointer($.coverage)),
    lookaheadCoverage: this.parseList($.pointer($.coverage)),
    substitutes: this.parseUShortList()
  };
};
function uG(e, n) {
  n = n || 0;
  var s = new $(e, n), i = s.parseVersion(1);
  return lt.argument(i === 1 || i === 1.1, "Unsupported GSUB table version."), i === 1 ? {
    version: i,
    scripts: s.parseScriptList(),
    features: s.parseFeatureList(),
    lookups: s.parseLookupList(cr)
  } : {
    version: i,
    scripts: s.parseScriptList(),
    features: s.parseFeatureList(),
    lookups: s.parseLookupList(cr),
    variations: s.parseFeatureVariationsList()
  };
}
var Xc = new Array(9);
Xc[1] = function(n) {
  return n.substFormat === 1 ? new De.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new De.Coverage(n.coverage) },
    { name: "deltaGlyphID", type: "USHORT", value: n.deltaGlyphId }
  ]) : new De.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 2 },
    { name: "coverage", type: "TABLE", value: new De.Coverage(n.coverage) }
  ].concat(De.ushortList("substitute", n.substitute)));
};
Xc[2] = function(n) {
  return lt.assert(n.substFormat === 1, "Lookup type 2 substFormat must be 1."), new De.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new De.Coverage(n.coverage) }
  ].concat(De.tableList("seqSet", n.sequences, function(s) {
    return new De.Table("sequenceSetTable", De.ushortList("sequence", s));
  })));
};
Xc[3] = function(n) {
  return lt.assert(n.substFormat === 1, "Lookup type 3 substFormat must be 1."), new De.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new De.Coverage(n.coverage) }
  ].concat(De.tableList("altSet", n.alternateSets, function(s) {
    return new De.Table("alternateSetTable", De.ushortList("alternate", s));
  })));
};
Xc[4] = function(n) {
  return lt.assert(n.substFormat === 1, "Lookup type 4 substFormat must be 1."), new De.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new De.Coverage(n.coverage) }
  ].concat(De.tableList("ligSet", n.ligatureSets, function(s) {
    return new De.Table("ligatureSetTable", De.tableList("ligature", s, function(i) {
      return new De.Table(
        "ligatureTable",
        [{ name: "ligGlyph", type: "USHORT", value: i.ligGlyph }].concat(De.ushortList("component", i.components, i.components.length + 1))
      );
    }));
  })));
};
Xc[6] = function(n) {
  if (n.substFormat === 1) {
    var s = new De.Table("chainContextTable", [
      { name: "substFormat", type: "USHORT", value: n.substFormat },
      { name: "coverage", type: "TABLE", value: new De.Coverage(n.coverage) }
    ].concat(De.tableList("chainRuleSet", n.chainRuleSets, function(o) {
      return new De.Table("chainRuleSetTable", De.tableList("chainRule", o, function(a) {
        var c = De.ushortList("backtrackGlyph", a.backtrack, a.backtrack.length).concat(De.ushortList("inputGlyph", a.input, a.input.length + 1)).concat(De.ushortList("lookaheadGlyph", a.lookahead, a.lookahead.length)).concat(De.ushortList("substitution", [], a.lookupRecords.length));
        return a.lookupRecords.forEach(function(l, h) {
          c = c.concat({ name: "sequenceIndex" + h, type: "USHORT", value: l.sequenceIndex }).concat({ name: "lookupListIndex" + h, type: "USHORT", value: l.lookupListIndex });
        }), new De.Table("chainRuleTable", c);
      }));
    })));
    return s;
  } else if (n.substFormat === 2)
    lt.assert(!1, "lookup type 6 format 2 is not yet supported.");
  else if (n.substFormat === 3) {
    var i = [
      { name: "substFormat", type: "USHORT", value: n.substFormat }
    ];
    i.push({ name: "backtrackGlyphCount", type: "USHORT", value: n.backtrackCoverage.length }), n.backtrackCoverage.forEach(function(o, a) {
      i.push({ name: "backtrackCoverage" + a, type: "TABLE", value: new De.Coverage(o) });
    }), i.push({ name: "inputGlyphCount", type: "USHORT", value: n.inputCoverage.length }), n.inputCoverage.forEach(function(o, a) {
      i.push({ name: "inputCoverage" + a, type: "TABLE", value: new De.Coverage(o) });
    }), i.push({ name: "lookaheadGlyphCount", type: "USHORT", value: n.lookaheadCoverage.length }), n.lookaheadCoverage.forEach(function(o, a) {
      i.push({ name: "lookaheadCoverage" + a, type: "TABLE", value: new De.Coverage(o) });
    }), i.push({ name: "substitutionCount", type: "USHORT", value: n.lookupRecords.length }), n.lookupRecords.forEach(function(o, a) {
      i = i.concat({ name: "sequenceIndex" + a, type: "USHORT", value: o.sequenceIndex }).concat({ name: "lookupListIndex" + a, type: "USHORT", value: o.lookupListIndex });
    });
    var r = new De.Table("chainContextTable", i);
    return r;
  }
  lt.assert(!1, "lookup type 6 format must be 1, 2 or 3.");
};
function dG(e) {
  return new De.Table("GSUB", [
    { name: "version", type: "ULONG", value: 65536 },
    { name: "scripts", type: "TABLE", value: new De.ScriptList(e.scripts) },
    { name: "features", type: "TABLE", value: new De.FeatureList(e.features) },
    { name: "lookups", type: "TABLE", value: new De.LookupList(e.lookups, Xc) }
  ]);
}
var fG = { parse: uG, make: dG };
function pG(e, n) {
  var s = new pt.Parser(e, n), i = s.parseULong();
  lt.argument(i === 1, "Unsupported META table version."), s.parseULong(), s.parseULong();
  for (var r = s.parseULong(), o = {}, a = 0; a < r; a++) {
    var c = s.parseTag(), l = s.parseULong(), h = s.parseULong(), d = Gc.UTF8(e, n + l, h);
    o[c] = d;
  }
  return o;
}
function EG(e) {
  var n = Object.keys(e).length, s = "", i = 16 + n * 12, r = new De.Table("meta", [
    { name: "version", type: "ULONG", value: 1 },
    { name: "flags", type: "ULONG", value: 0 },
    { name: "offset", type: "ULONG", value: i },
    { name: "numTags", type: "ULONG", value: n }
  ]);
  for (var o in e) {
    var a = s.length;
    s += e[o], r.fields.push({ name: "tag " + o, type: "TAG", value: o }), r.fields.push({ name: "offset " + o, type: "ULONG", value: i + a }), r.fields.push({ name: "length " + o, type: "ULONG", value: e[o].length });
  }
  return r.fields.push({ name: "stringPool", type: "CHARARRAY", value: s }), r;
}
var gG = { parse: pG, make: EG };
function JO(e) {
  return Math.log(e) / Math.log(2) | 0;
}
function l0(e) {
  for (; e.length % 4 !== 0; )
    e.push(0);
  for (var n = 0, s = 0; s < e.length; s += 4)
    n += (e[s] << 24) + (e[s + 1] << 16) + (e[s + 2] << 8) + e[s + 3];
  return n %= Math.pow(2, 32), n;
}
function $O(e, n, s, i) {
  return new De.Record("Table Record", [
    { name: "tag", type: "TAG", value: e !== void 0 ? e : "" },
    { name: "checkSum", type: "ULONG", value: n !== void 0 ? n : 0 },
    { name: "offset", type: "ULONG", value: s !== void 0 ? s : 0 },
    { name: "length", type: "ULONG", value: i !== void 0 ? i : 0 }
  ]);
}
function gy(e) {
  var n = new De.Table("sfnt", [
    { name: "version", type: "TAG", value: "OTTO" },
    { name: "numTables", type: "USHORT", value: 0 },
    { name: "searchRange", type: "USHORT", value: 0 },
    { name: "entrySelector", type: "USHORT", value: 0 },
    { name: "rangeShift", type: "USHORT", value: 0 }
  ]);
  n.tables = e, n.numTables = e.length;
  var s = Math.pow(2, JO(n.numTables));
  n.searchRange = 16 * s, n.entrySelector = JO(s), n.rangeShift = n.numTables * 16 - n.searchRange;
  for (var i = [], r = [], o = n.sizeOf() + $O().sizeOf() * n.numTables; o % 4 !== 0; )
    o += 1, r.push({ name: "padding", type: "BYTE", value: 0 });
  for (var a = 0; a < e.length; a += 1) {
    var c = e[a];
    lt.argument(c.tableName.length === 4, "Table name" + c.tableName + " is invalid.");
    var l = c.sizeOf(), h = $O(c.tableName, l0(c.encode()), o, l);
    for (i.push({ name: h.tag + " Table Record", type: "RECORD", value: h }), r.push({ name: c.tableName + " table", type: "RECORD", value: c }), o += l, lt.argument(!isNaN(o), "Something went wrong calculating the offset."); o % 4 !== 0; )
      o += 1, r.push({ name: "padding", type: "BYTE", value: 0 });
  }
  return i.sort(function(d, p) {
    return d.value.tag > p.value.tag ? 1 : -1;
  }), n.fields = n.fields.concat(i), n.fields = n.fields.concat(r), n;
}
function eI(e, n, s) {
  for (var i = 0; i < n.length; i += 1) {
    var r = e.charToGlyphIndex(n[i]);
    if (r > 0) {
      var o = e.glyphs.get(r);
      return o.getMetrics();
    }
  }
  return s;
}
function _G(e) {
  for (var n = 0, s = 0; s < e.length; s += 1)
    n += e[s];
  return n / e.length;
}
function TG(e) {
  for (var n = [], s = [], i = [], r = [], o = [], a = [], c = [], l, h = 0, d = 0, p = 0, E = 0, g = 0, T = 0; T < e.glyphs.length; T += 1) {
    var A = e.glyphs.get(T), m = A.unicode | 0;
    if (isNaN(A.advanceWidth))
      throw new Error("Glyph " + A.name + " (" + T + "): advanceWidth is not a number.");
    (l > m || l === void 0) && m > 0 && (l = m), h < m && (h = m);
    var O = jO.getUnicodeRange(m);
    if (O < 32)
      d |= 1 << O;
    else if (O < 64)
      p |= 1 << O - 32;
    else if (O < 96)
      E |= 1 << O - 64;
    else if (O < 123)
      g |= 1 << O - 96;
    else
      throw new Error("Unicode ranges bits > 123 are reserved for internal usage");
    if (A.name !== ".notdef") {
      var S = A.getMetrics();
      n.push(S.xMin), s.push(S.yMin), i.push(S.xMax), r.push(S.yMax), a.push(S.leftSideBearing), c.push(S.rightSideBearing), o.push(A.advanceWidth);
    }
  }
  var y = {
    xMin: Math.min.apply(null, n),
    yMin: Math.min.apply(null, s),
    xMax: Math.max.apply(null, i),
    yMax: Math.max.apply(null, r),
    advanceWidthMax: Math.max.apply(null, o),
    advanceWidthAvg: _G(o),
    minLeftSideBearing: Math.min.apply(null, a),
    maxLeftSideBearing: Math.max.apply(null, a),
    minRightSideBearing: Math.min.apply(null, c)
  };
  y.ascender = e.ascender, y.descender = e.descender;
  var v = UU.make({
    flags: 3,
    // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
    unitsPerEm: e.unitsPerEm,
    xMin: y.xMin,
    yMin: y.yMin,
    xMax: y.xMax,
    yMax: y.yMax,
    lowestRecPPEM: 3,
    createdTimestamp: e.createdTimestamp
  }), R = kU.make({
    ascender: y.ascender,
    descender: y.descender,
    advanceWidthMax: y.advanceWidthMax,
    minLeftSideBearing: y.minLeftSideBearing,
    minRightSideBearing: y.minRightSideBearing,
    xMaxExtent: y.maxLeftSideBearing + (y.xMax - y.xMin),
    numberOfHMetrics: e.glyphs.length
  }), M = qU.make(e.glyphs.length), L = jO.make(Object.assign({
    xAvgCharWidth: Math.round(y.advanceWidthAvg),
    usFirstCharIndex: l,
    usLastCharIndex: h,
    ulUnicodeRange1: d,
    ulUnicodeRange2: p,
    ulUnicodeRange3: E,
    ulUnicodeRange4: g,
    // See http://typophile.com/node/13081 for more info on vertical metrics.
    // We get metrics for typical characters (such as "x" for xHeight).
    // We provide some fallback characters if characters are unavailable: their
    // ordering was chosen experimentally.
    sTypoAscender: y.ascender,
    sTypoDescender: y.descender,
    sTypoLineGap: 0,
    usWinAscent: y.yMax,
    usWinDescent: Math.abs(y.yMin),
    ulCodePageRange1: 1,
    // FIXME: hard-code Latin 1 support for now
    sxHeight: eI(e, "xyvw", { yMax: Math.round(y.ascender / 2) }).yMax,
    sCapHeight: eI(e, "HIKLEFJMNTZBDPRAGOQSUVWXY", y).yMax,
    usDefaultChar: e.hasChar(" ") ? 32 : 0,
    // Use space as the default character, if available.
    usBreakChar: e.hasChar(" ") ? 32 : 0
    // Use space as the break character, if available.
  }, e.tables.os2)), P = YU.make(e.glyphs), k = rU.make(e.glyphs), Q = e.getEnglishName("fontFamily"), b = e.getEnglishName("fontSubfamily"), X = Q + " " + b, K = e.getEnglishName("postScriptName");
  K || (K = Q.replace(/\s/g, "") + "-" + b);
  var V = {};
  for (var J in e.names)
    V[J] = e.names[J];
  V.uniqueID || (V.uniqueID = { en: e.getEnglishName("manufacturer") + ":" + X }), V.postScriptName || (V.postScriptName = { en: K }), V.preferredFamily || (V.preferredFamily = e.names.fontFamily), V.preferredSubfamily || (V.preferredSubfamily = e.names.fontSubfamily);
  var ge = [], ne = iG.make(V, ge), ue = ge.length > 0 ? KU.make(ge) : void 0, te = hG.make(), ie = MU.make(e.glyphs, {
    version: e.getEnglishName("version"),
    fullName: X,
    familyName: Q,
    weightName: b,
    postScriptName: K,
    unitsPerEm: e.unitsPerEm,
    fontBBox: [0, y.yMin, y.ascender, y.advanceWidthMax]
  }), re = e.metas && Object.keys(e.metas).length > 0 ? gG.make(e.metas) : void 0, fe = [v, R, M, L, ne, k, te, ie, P];
  ue && fe.push(ue), e.tables.gsub && fe.push(fG.make(e.tables.gsub)), re && fe.push(re);
  for (var Ne = gy(fe), At = Ne.encode(), Ke = l0(At), St = Ne.fields, rn = !1, gt = 0; gt < St.length; gt += 1)
    if (St[gt].name === "head table") {
      St[gt].value.checkSumAdjustment = 2981146554 - Ke, rn = !0;
      break;
    }
  if (!rn)
    throw new Error("Could not find head table with checkSum to adjust.");
  return Ne;
}
var AG = { make: gy, fontToTable: TG, computeCheckSum: l0 };
function Zp(e, n) {
  for (var s = 0, i = e.length - 1; s <= i; ) {
    var r = s + i >>> 1, o = e[r].tag;
    if (o === n)
      return r;
    o < n ? s = r + 1 : i = r - 1;
  }
  return -s - 1;
}
function tI(e, n) {
  for (var s = 0, i = e.length - 1; s <= i; ) {
    var r = s + i >>> 1, o = e[r];
    if (o === n)
      return r;
    o < n ? s = r + 1 : i = r - 1;
  }
  return -s - 1;
}
function nI(e, n) {
  for (var s, i = 0, r = e.length - 1; i <= r; ) {
    var o = i + r >>> 1;
    s = e[o];
    var a = s.start;
    if (a === n)
      return s;
    a < n ? i = o + 1 : r = o - 1;
  }
  if (i > 0)
    return s = e[i - 1], n > s.end ? 0 : s;
}
function Ih(e, n) {
  this.font = e, this.tableName = n;
}
Ih.prototype = {
  /**
   * Binary search an object by "tag" property
   * @instance
   * @function searchTag
   * @memberof opentype.Layout
   * @param  {Array} arr
   * @param  {string} tag
   * @return {number}
   */
  searchTag: Zp,
  /**
   * Binary search in a list of numbers
   * @instance
   * @function binSearch
   * @memberof opentype.Layout
   * @param  {Array} arr
   * @param  {number} value
   * @return {number}
   */
  binSearch: tI,
  /**
   * Get or create the Layout table (GSUB, GPOS etc).
   * @param  {boolean} create - Whether to create a new one.
   * @return {Object} The GSUB or GPOS table.
   */
  getTable: function(e) {
    var n = this.font.tables[this.tableName];
    return !n && e && (n = this.font.tables[this.tableName] = this.createDefaultTable()), n;
  },
  /**
   * Returns all scripts in the substitution table.
   * @instance
   * @return {Array}
   */
  getScriptNames: function() {
    var e = this.getTable();
    return e ? e.scripts.map(function(n) {
      return n.tag;
    }) : [];
  },
  /**
   * Returns the best bet for a script name.
   * Returns 'DFLT' if it exists.
   * If not, returns 'latn' if it exists.
   * If neither exist, returns undefined.
   */
  getDefaultScriptName: function() {
    var e = this.getTable();
    if (e) {
      for (var n = !1, s = 0; s < e.scripts.length; s++) {
        var i = e.scripts[s].tag;
        if (i === "DFLT")
          return i;
        i === "latn" && (n = !0);
      }
      if (n)
        return "latn";
    }
  },
  /**
   * Returns all LangSysRecords in the given script.
   * @instance
   * @param {string} [script='DFLT']
   * @param {boolean} create - forces the creation of this script table if it doesn't exist.
   * @return {Object} An object with tag and script properties.
   */
  getScriptTable: function(e, n) {
    var s = this.getTable(n);
    if (s) {
      e = e || "DFLT";
      var i = s.scripts, r = Zp(s.scripts, e);
      if (r >= 0)
        return i[r].script;
      if (n) {
        var o = {
          tag: e,
          script: {
            defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] },
            langSysRecords: []
          }
        };
        return i.splice(-1 - r, 0, o), o.script;
      }
    }
  },
  /**
   * Returns a language system table
   * @instance
   * @param {string} [script='DFLT']
   * @param {string} [language='dlft']
   * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
   * @return {Object}
   */
  getLangSysTable: function(e, n, s) {
    var i = this.getScriptTable(e, s);
    if (i) {
      if (!n || n === "dflt" || n === "DFLT")
        return i.defaultLangSys;
      var r = Zp(i.langSysRecords, n);
      if (r >= 0)
        return i.langSysRecords[r].langSys;
      if (s) {
        var o = {
          tag: n,
          langSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }
        };
        return i.langSysRecords.splice(-1 - r, 0, o), o.langSys;
      }
    }
  },
  /**
   * Get a specific feature table.
   * @instance
   * @param {string} [script='DFLT']
   * @param {string} [language='dlft']
   * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
   * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
   * @return {Object}
   */
  getFeatureTable: function(e, n, s, i) {
    var r = this.getLangSysTable(e, n, i);
    if (r) {
      for (var o, a = r.featureIndexes, c = this.font.tables[this.tableName].features, l = 0; l < a.length; l++)
        if (o = c[a[l]], o.tag === s)
          return o.feature;
      if (i) {
        var h = c.length;
        return lt.assert(h === 0 || s >= c[h - 1].tag, "Features must be added in alphabetical order."), o = {
          tag: s,
          feature: { params: 0, lookupListIndexes: [] }
        }, c.push(o), a.push(h), o.feature;
      }
    }
  },
  /**
   * Get the lookup tables of a given type for a script/language/feature.
   * @instance
   * @param {string} [script='DFLT']
   * @param {string} [language='dlft']
   * @param {string} feature - 4-letter feature code
   * @param {number} lookupType - 1 to 9
   * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
   * @return {Object[]}
   */
  getLookupTables: function(e, n, s, i, r) {
    var o = this.getFeatureTable(e, n, s, r), a = [];
    if (o) {
      for (var c, l = o.lookupListIndexes, h = this.font.tables[this.tableName].lookups, d = 0; d < l.length; d++)
        c = h[l[d]], c.lookupType === i && a.push(c);
      if (a.length === 0 && r) {
        c = {
          lookupType: i,
          lookupFlag: 0,
          subtables: [],
          markFilteringSet: void 0
        };
        var p = h.length;
        return h.push(c), l.push(p), [c];
      }
    }
    return a;
  },
  /**
   * Find a glyph in a class definition table
   * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
   * @param {object} classDefTable - an OpenType Layout class definition table
   * @param {number} glyphIndex - the index of the glyph to find
   * @returns {number} -1 if not found
   */
  getGlyphClass: function(e, n) {
    switch (e.format) {
      case 1:
        return e.startGlyph <= n && n < e.startGlyph + e.classes.length ? e.classes[n - e.startGlyph] : 0;
      case 2:
        var s = nI(e.ranges, n);
        return s ? s.classId : 0;
    }
  },
  /**
   * Find a glyph in a coverage table
   * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
   * @param {object} coverageTable - an OpenType Layout coverage table
   * @param {number} glyphIndex - the index of the glyph to find
   * @returns {number} -1 if not found
   */
  getCoverageIndex: function(e, n) {
    switch (e.format) {
      case 1:
        var s = tI(e.glyphs, n);
        return s >= 0 ? s : -1;
      case 2:
        var i = nI(e.ranges, n);
        return i ? i.index + n - i.start : -1;
    }
  },
  /**
   * Returns the list of glyph indexes of a coverage table.
   * Format 1: the list is stored raw
   * Format 2: compact list as range records.
   * @instance
   * @param  {Object} coverageTable
   * @return {Array}
   */
  expandCoverage: function(e) {
    if (e.format === 1)
      return e.glyphs;
    for (var n = [], s = e.ranges, i = 0; i < s.length; i++)
      for (var r = s[i], o = r.start, a = r.end, c = o; c <= a; c++)
        n.push(c);
    return n;
  }
};
function Sh(e) {
  Ih.call(this, e, "gpos");
}
Sh.prototype = Ih.prototype;
Sh.prototype.init = function() {
  var e = this.getDefaultScriptName();
  this.defaultKerningTables = this.getKerningTables(e);
};
Sh.prototype.getKerningValue = function(e, n, s) {
  for (var i = 0; i < e.length; i++)
    for (var r = e[i].subtables, o = 0; o < r.length; o++) {
      var a = r[o], c = this.getCoverageIndex(a.coverage, n);
      if (!(c < 0))
        switch (a.posFormat) {
          case 1:
            for (var l = a.pairSets[c], h = 0; h < l.length; h++) {
              var d = l[h];
              if (d.secondGlyph === s)
                return d.value1 && d.value1.xAdvance || 0;
            }
            break;
          case 2:
            var p = this.getGlyphClass(a.classDef1, n), E = this.getGlyphClass(a.classDef2, s), g = a.classRecords[p][E];
            return g.value1 && g.value1.xAdvance || 0;
        }
    }
  return 0;
};
Sh.prototype.getKerningTables = function(e, n) {
  if (this.font.tables.gpos)
    return this.getLookupTables(e, n, "kern", 2);
};
function Si(e) {
  Ih.call(this, e, "gsub");
}
function mG(e, n) {
  var s = e.length;
  if (s !== n.length)
    return !1;
  for (var i = 0; i < s; i++)
    if (e[i] !== n[i])
      return !1;
  return !0;
}
function h0(e, n, s) {
  for (var i = e.subtables, r = 0; r < i.length; r++) {
    var o = i[r];
    if (o.substFormat === n)
      return o;
  }
  if (s)
    return i.push(s), s;
}
Si.prototype = Ih.prototype;
Si.prototype.createDefaultTable = function() {
  return {
    version: 1,
    scripts: [{
      tag: "DFLT",
      script: {
        defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] },
        langSysRecords: []
      }
    }],
    features: [],
    lookups: []
  };
};
Si.prototype.getSingle = function(e, n, s) {
  for (var i = [], r = this.getLookupTables(n, s, e, 1), o = 0; o < r.length; o++)
    for (var a = r[o].subtables, c = 0; c < a.length; c++) {
      var l = a[c], h = this.expandCoverage(l.coverage), d = void 0;
      if (l.substFormat === 1) {
        var p = l.deltaGlyphId;
        for (d = 0; d < h.length; d++) {
          var E = h[d];
          i.push({ sub: E, by: E + p });
        }
      } else {
        var g = l.substitute;
        for (d = 0; d < h.length; d++)
          i.push({ sub: h[d], by: g[d] });
      }
    }
  return i;
};
Si.prototype.getMultiple = function(e, n, s) {
  for (var i = [], r = this.getLookupTables(n, s, e, 2), o = 0; o < r.length; o++)
    for (var a = r[o].subtables, c = 0; c < a.length; c++) {
      var l = a[c], h = this.expandCoverage(l.coverage), d = void 0;
      for (d = 0; d < h.length; d++) {
        var p = h[d], E = l.sequences[d];
        i.push({ sub: p, by: E });
      }
    }
  return i;
};
Si.prototype.getAlternates = function(e, n, s) {
  for (var i = [], r = this.getLookupTables(n, s, e, 3), o = 0; o < r.length; o++)
    for (var a = r[o].subtables, c = 0; c < a.length; c++)
      for (var l = a[c], h = this.expandCoverage(l.coverage), d = l.alternateSets, p = 0; p < h.length; p++)
        i.push({ sub: h[p], by: d[p] });
  return i;
};
Si.prototype.getLigatures = function(e, n, s) {
  for (var i = [], r = this.getLookupTables(n, s, e, 4), o = 0; o < r.length; o++)
    for (var a = r[o].subtables, c = 0; c < a.length; c++)
      for (var l = a[c], h = this.expandCoverage(l.coverage), d = l.ligatureSets, p = 0; p < h.length; p++)
        for (var E = h[p], g = d[p], T = 0; T < g.length; T++) {
          var A = g[T];
          i.push({
            sub: [E].concat(A.components),
            by: A.ligGlyph
          });
        }
  return i;
};
Si.prototype.addSingle = function(e, n, s, i) {
  var r = this.getLookupTables(s, i, e, 1, !0)[0], o = h0(r, 2, {
    // lookup type 1 subtable, format 2, coverage format 1
    substFormat: 2,
    coverage: { format: 1, glyphs: [] },
    substitute: []
  });
  lt.assert(o.coverage.format === 1, "Single: unable to modify coverage table format " + o.coverage.format);
  var a = n.sub, c = this.binSearch(o.coverage.glyphs, a);
  c < 0 && (c = -1 - c, o.coverage.glyphs.splice(c, 0, a), o.substitute.splice(c, 0, 0)), o.substitute[c] = n.by;
};
Si.prototype.addMultiple = function(e, n, s, i) {
  lt.assert(n.by instanceof Array && n.by.length > 1, 'Multiple: "by" must be an array of two or more ids');
  var r = this.getLookupTables(s, i, e, 2, !0)[0], o = h0(r, 1, {
    // lookup type 2 subtable, format 1, coverage format 1
    substFormat: 1,
    coverage: { format: 1, glyphs: [] },
    sequences: []
  });
  lt.assert(o.coverage.format === 1, "Multiple: unable to modify coverage table format " + o.coverage.format);
  var a = n.sub, c = this.binSearch(o.coverage.glyphs, a);
  c < 0 && (c = -1 - c, o.coverage.glyphs.splice(c, 0, a), o.sequences.splice(c, 0, 0)), o.sequences[c] = n.by;
};
Si.prototype.addAlternate = function(e, n, s, i) {
  var r = this.getLookupTables(s, i, e, 3, !0)[0], o = h0(r, 1, {
    // lookup type 3 subtable, format 1, coverage format 1
    substFormat: 1,
    coverage: { format: 1, glyphs: [] },
    alternateSets: []
  });
  lt.assert(o.coverage.format === 1, "Alternate: unable to modify coverage table format " + o.coverage.format);
  var a = n.sub, c = this.binSearch(o.coverage.glyphs, a);
  c < 0 && (c = -1 - c, o.coverage.glyphs.splice(c, 0, a), o.alternateSets.splice(c, 0, 0)), o.alternateSets[c] = n.by;
};
Si.prototype.addLigature = function(e, n, s, i) {
  var r = this.getLookupTables(s, i, e, 4, !0)[0], o = r.subtables[0];
  o || (o = {
    // lookup type 4 subtable, format 1, coverage format 1
    substFormat: 1,
    coverage: { format: 1, glyphs: [] },
    ligatureSets: []
  }, r.subtables[0] = o), lt.assert(o.coverage.format === 1, "Ligature: unable to modify coverage table format " + o.coverage.format);
  var a = n.sub[0], c = n.sub.slice(1), l = {
    ligGlyph: n.by,
    components: c
  }, h = this.binSearch(o.coverage.glyphs, a);
  if (h >= 0) {
    for (var d = o.ligatureSets[h], p = 0; p < d.length; p++)
      if (mG(d[p].components, c))
        return;
    d.push(l);
  } else
    h = -1 - h, o.coverage.glyphs.splice(h, 0, a), o.ligatureSets.splice(h, 0, [l]);
};
Si.prototype.getFeature = function(e, n, s) {
  if (/ss\d\d/.test(e))
    return this.getSingle(e, n, s);
  switch (e) {
    case "aalt":
    case "salt":
      return this.getSingle(e, n, s).concat(this.getAlternates(e, n, s));
    case "dlig":
    case "liga":
    case "rlig":
      return this.getLigatures(e, n, s);
    case "ccmp":
      return this.getMultiple(e, n, s).concat(this.getLigatures(e, n, s));
    case "stch":
      return this.getMultiple(e, n, s);
  }
};
Si.prototype.add = function(e, n, s, i) {
  if (/ss\d\d/.test(e))
    return this.addSingle(e, n, s, i);
  switch (e) {
    case "aalt":
    case "salt":
      return typeof n.by == "number" ? this.addSingle(e, n, s, i) : this.addAlternate(e, n, s, i);
    case "dlig":
    case "liga":
    case "rlig":
      return this.addLigature(e, n, s, i);
    case "ccmp":
      return n.by instanceof Array ? this.addMultiple(e, n, s, i) : this.addLigature(e, n, s, i);
  }
};
function OG() {
  return typeof window < "u";
}
function IG(e) {
  for (var n = new Buffer(e.byteLength), s = new Uint8Array(e), i = 0; i < n.length; ++i)
    n[i] = s[i];
  return n;
}
function gl(e, n) {
  if (!e)
    throw n;
}
function sI(e, n, s, i, r) {
  var o;
  return (n & i) > 0 ? (o = e.parseByte(), n & r || (o = -o), o = s + o) : (n & r) > 0 ? o = s : o = s + e.parseShort(), o;
}
function _y(e, n, s) {
  var i = new pt.Parser(n, s);
  e.numberOfContours = i.parseShort(), e._xMin = i.parseShort(), e._yMin = i.parseShort(), e._xMax = i.parseShort(), e._yMax = i.parseShort();
  var r, o;
  if (e.numberOfContours > 0) {
    for (var a = e.endPointIndices = [], c = 0; c < e.numberOfContours; c += 1)
      a.push(i.parseUShort());
    e.instructionLength = i.parseUShort(), e.instructions = [];
    for (var l = 0; l < e.instructionLength; l += 1)
      e.instructions.push(i.parseByte());
    var h = a[a.length - 1] + 1;
    r = [];
    for (var d = 0; d < h; d += 1)
      if (o = i.parseByte(), r.push(o), (o & 8) > 0)
        for (var p = i.parseByte(), E = 0; E < p; E += 1)
          r.push(o), d += 1;
    if (lt.argument(r.length === h, "Bad flags."), a.length > 0) {
      var g = [], T;
      if (h > 0) {
        for (var A = 0; A < h; A += 1)
          o = r[A], T = {}, T.onCurve = !!(o & 1), T.lastPointOfContour = a.indexOf(A) >= 0, g.push(T);
        for (var m = 0, O = 0; O < h; O += 1)
          o = r[O], T = g[O], T.x = sI(i, o, m, 2, 16), m = T.x;
        for (var S = 0, y = 0; y < h; y += 1)
          o = r[y], T = g[y], T.y = sI(i, o, S, 4, 32), S = T.y;
      }
      e.points = g;
    } else
      e.points = [];
  } else if (e.numberOfContours === 0)
    e.points = [];
  else {
    e.isComposite = !0, e.points = [], e.components = [];
    for (var v = !0; v; ) {
      r = i.parseUShort();
      var R = {
        glyphIndex: i.parseUShort(),
        xScale: 1,
        scale01: 0,
        scale10: 0,
        yScale: 1,
        dx: 0,
        dy: 0
      };
      (r & 1) > 0 ? (r & 2) > 0 ? (R.dx = i.parseShort(), R.dy = i.parseShort()) : R.matchedPoints = [i.parseUShort(), i.parseUShort()] : (r & 2) > 0 ? (R.dx = i.parseChar(), R.dy = i.parseChar()) : R.matchedPoints = [i.parseByte(), i.parseByte()], (r & 8) > 0 ? R.xScale = R.yScale = i.parseF2Dot14() : (r & 64) > 0 ? (R.xScale = i.parseF2Dot14(), R.yScale = i.parseF2Dot14()) : (r & 128) > 0 && (R.xScale = i.parseF2Dot14(), R.scale01 = i.parseF2Dot14(), R.scale10 = i.parseF2Dot14(), R.yScale = i.parseF2Dot14()), e.components.push(R), v = !!(r & 32);
    }
    if (r & 256) {
      e.instructionLength = i.parseUShort(), e.instructions = [];
      for (var M = 0; M < e.instructionLength; M += 1)
        e.instructions.push(i.parseByte());
    }
  }
}
function qp(e, n) {
  for (var s = [], i = 0; i < e.length; i += 1) {
    var r = e[i], o = {
      x: n.xScale * r.x + n.scale01 * r.y + n.dx,
      y: n.scale10 * r.x + n.yScale * r.y + n.dy,
      onCurve: r.onCurve,
      lastPointOfContour: r.lastPointOfContour
    };
    s.push(o);
  }
  return s;
}
function SG(e) {
  for (var n = [], s = [], i = 0; i < e.length; i += 1) {
    var r = e[i];
    s.push(r), r.lastPointOfContour && (n.push(s), s = []);
  }
  return lt.argument(s.length === 0, "There are still points left in the current contour."), n;
}
function Ty(e) {
  var n = new jn();
  if (!e)
    return n;
  for (var s = SG(e), i = 0; i < s.length; ++i) {
    var r = s[i], o = null, a = r[r.length - 1], c = r[0];
    if (a.onCurve)
      n.moveTo(a.x, a.y);
    else if (c.onCurve)
      n.moveTo(c.x, c.y);
    else {
      var l = { x: (a.x + c.x) * 0.5, y: (a.y + c.y) * 0.5 };
      n.moveTo(l.x, l.y);
    }
    for (var h = 0; h < r.length; ++h)
      if (o = a, a = c, c = r[(h + 1) % r.length], a.onCurve)
        n.lineTo(a.x, a.y);
      else {
        var d = c;
        o.onCurve || ((a.x + o.x) * 0.5, (a.y + o.y) * 0.5), c.onCurve || (d = { x: (a.x + c.x) * 0.5, y: (a.y + c.y) * 0.5 }), n.quadraticCurveTo(a.x, a.y, d.x, d.y);
      }
    n.closePath();
  }
  return n;
}
function Ay(e, n) {
  if (n.isComposite)
    for (var s = 0; s < n.components.length; s += 1) {
      var i = n.components[s], r = e.get(i.glyphIndex);
      if (r.getPath(), r.points) {
        var o = void 0;
        if (i.matchedPoints === void 0)
          o = qp(r.points, i);
        else {
          if (i.matchedPoints[0] > n.points.length - 1 || i.matchedPoints[1] > r.points.length - 1)
            throw Error("Matched points out of range in " + n.name);
          var a = n.points[i.matchedPoints[0]], c = r.points[i.matchedPoints[1]], l = {
            xScale: i.xScale,
            scale01: i.scale01,
            scale10: i.scale10,
            yScale: i.yScale,
            dx: 0,
            dy: 0
          };
          c = qp([c], l)[0], l.dx = a.x - c.x, l.dy = a.y - c.y, o = qp(r.points, l);
        }
        n.points = n.points.concat(o);
      }
    }
  return Ty(n.points);
}
function yG(e, n, s, i) {
  for (var r = new Cr.GlyphSet(i), o = 0; o < s.length - 1; o += 1) {
    var a = s[o], c = s[o + 1];
    a !== c ? r.push(o, Cr.ttfGlyphLoader(i, o, _y, e, n + a, Ay)) : r.push(o, Cr.glyphLoader(i, o));
  }
  return r;
}
function CG(e, n, s, i) {
  var r = new Cr.GlyphSet(i);
  return i._push = function(o) {
    var a = s[o], c = s[o + 1];
    a !== c ? r.push(o, Cr.ttfGlyphLoader(i, o, _y, e, n + a, Ay)) : r.push(o, Cr.glyphLoader(i, o));
  }, r;
}
function NG(e, n, s, i, r) {
  return r.lowMemory ? CG(e, n, s, i) : yG(e, n, s, i);
}
var xG = { getPath: Ty, parse: NG }, my, Wa, Oy, ng;
function Iy(e) {
  this.font = e, this.getCommands = function(n) {
    return xG.getPath(n).commands;
  }, this._fpgmState = this._prepState = void 0, this._errorState = 0;
}
function vG(e) {
  return e;
}
function Sy(e) {
  return Math.sign(e) * Math.round(Math.abs(e));
}
function RG(e) {
  return Math.sign(e) * Math.round(Math.abs(e * 2)) / 2;
}
function wG(e) {
  return Math.sign(e) * (Math.round(Math.abs(e) + 0.5) - 0.5);
}
function DG(e) {
  return Math.sign(e) * Math.ceil(Math.abs(e));
}
function LG(e) {
  return Math.sign(e) * Math.floor(Math.abs(e));
}
var yy = function(e) {
  var n = this.srPeriod, s = this.srPhase, i = this.srThreshold, r = 1;
  return e < 0 && (e = -e, r = -1), e += i - s, e = Math.trunc(e / n) * n, e += s, e < 0 ? s * r : e * r;
}, Ir = {
  x: 1,
  y: 0,
  axis: "x",
  // Gets the projected distance between two points.
  // o1/o2 ... if true, respective original position is used.
  distance: function(e, n, s, i) {
    return (s ? e.xo : e.x) - (i ? n.xo : n.x);
  },
  // Moves point p so the moved position has the same relative
  // position to the moved positions of rp1 and rp2 than the
  // original positions had.
  //
  // See APPENDIX on INTERPOLATE at the bottom of this file.
  interpolate: function(e, n, s, i) {
    var r, o, a, c, l, h, d;
    if (!i || i === this) {
      if (r = e.xo - n.xo, o = e.xo - s.xo, l = n.x - n.xo, h = s.x - s.xo, a = Math.abs(r), c = Math.abs(o), d = a + c, d === 0) {
        e.x = e.xo + (l + h) / 2;
        return;
      }
      e.x = e.xo + (l * c + h * a) / d;
      return;
    }
    if (r = i.distance(e, n, !0, !0), o = i.distance(e, s, !0, !0), l = i.distance(n, n, !1, !0), h = i.distance(s, s, !1, !0), a = Math.abs(r), c = Math.abs(o), d = a + c, d === 0) {
      Ir.setRelative(e, e, (l + h) / 2, i, !0);
      return;
    }
    Ir.setRelative(e, e, (l * c + h * a) / d, i, !0);
  },
  // Slope of line normal to this
  normalSlope: Number.NEGATIVE_INFINITY,
  // Sets the point 'p' relative to point 'rp'
  // by the distance 'd'.
  //
  // See APPENDIX on SETRELATIVE at the bottom of this file.
  //
  // p   ... point to set
  // rp  ... reference point
  // d   ... distance on projection vector
  // pv  ... projection vector (undefined = this)
  // org ... if true, uses the original position of rp as reference.
  setRelative: function(e, n, s, i, r) {
    if (!i || i === this) {
      e.x = (r ? n.xo : n.x) + s;
      return;
    }
    var o = r ? n.xo : n.x, a = r ? n.yo : n.y, c = o + s * i.x, l = a + s * i.y;
    e.x = c + (e.y - l) / i.normalSlope;
  },
  // Slope of vector line.
  slope: 0,
  // Touches the point p.
  touch: function(e) {
    e.xTouched = !0;
  },
  // Tests if a point p is touched.
  touched: function(e) {
    return e.xTouched;
  },
  // Untouches the point p.
  untouch: function(e) {
    e.xTouched = !1;
  }
}, to = {
  x: 0,
  y: 1,
  axis: "y",
  // Gets the projected distance between two points.
  // o1/o2 ... if true, respective original position is used.
  distance: function(e, n, s, i) {
    return (s ? e.yo : e.y) - (i ? n.yo : n.y);
  },
  // Moves point p so the moved position has the same relative
  // position to the moved positions of rp1 and rp2 than the
  // original positions had.
  //
  // See APPENDIX on INTERPOLATE at the bottom of this file.
  interpolate: function(e, n, s, i) {
    var r, o, a, c, l, h, d;
    if (!i || i === this) {
      if (r = e.yo - n.yo, o = e.yo - s.yo, l = n.y - n.yo, h = s.y - s.yo, a = Math.abs(r), c = Math.abs(o), d = a + c, d === 0) {
        e.y = e.yo + (l + h) / 2;
        return;
      }
      e.y = e.yo + (l * c + h * a) / d;
      return;
    }
    if (r = i.distance(e, n, !0, !0), o = i.distance(e, s, !0, !0), l = i.distance(n, n, !1, !0), h = i.distance(s, s, !1, !0), a = Math.abs(r), c = Math.abs(o), d = a + c, d === 0) {
      to.setRelative(e, e, (l + h) / 2, i, !0);
      return;
    }
    to.setRelative(e, e, (l * c + h * a) / d, i, !0);
  },
  // Slope of line normal to this.
  normalSlope: 0,
  // Sets the point 'p' relative to point 'rp'
  // by the distance 'd'
  //
  // See APPENDIX on SETRELATIVE at the bottom of this file.
  //
  // p   ... point to set
  // rp  ... reference point
  // d   ... distance on projection vector
  // pv  ... projection vector (undefined = this)
  // org ... if true, uses the original position of rp as reference.
  setRelative: function(e, n, s, i, r) {
    if (!i || i === this) {
      e.y = (r ? n.yo : n.y) + s;
      return;
    }
    var o = r ? n.xo : n.x, a = r ? n.yo : n.y, c = o + s * i.x, l = a + s * i.y;
    e.y = l + i.normalSlope * (e.x - c);
  },
  // Slope of vector line.
  slope: Number.POSITIVE_INFINITY,
  // Touches the point p.
  touch: function(e) {
    e.yTouched = !0;
  },
  // Tests if a point p is touched.
  touched: function(e) {
    return e.yTouched;
  },
  // Untouches the point p.
  untouch: function(e) {
    e.yTouched = !1;
  }
};
Object.freeze(Ir);
Object.freeze(to);
function yh(e, n) {
  this.x = e, this.y = n, this.axis = void 0, this.slope = n / e, this.normalSlope = -e / n, Object.freeze(this);
}
yh.prototype.distance = function(e, n, s, i) {
  return this.x * Ir.distance(e, n, s, i) + this.y * to.distance(e, n, s, i);
};
yh.prototype.interpolate = function(e, n, s, i) {
  var r, o, a, c, l, h, d;
  if (a = i.distance(e, n, !0, !0), c = i.distance(e, s, !0, !0), r = i.distance(n, n, !1, !0), o = i.distance(s, s, !1, !0), l = Math.abs(a), h = Math.abs(c), d = l + h, d === 0) {
    this.setRelative(e, e, (r + o) / 2, i, !0);
    return;
  }
  this.setRelative(e, e, (r * h + o * l) / d, i, !0);
};
yh.prototype.setRelative = function(e, n, s, i, r) {
  i = i || this;
  var o = r ? n.xo : n.x, a = r ? n.yo : n.y, c = o + s * i.x, l = a + s * i.y, h = i.normalSlope, d = this.slope, p = e.x, E = e.y;
  e.x = (d * p - h * c + l - E) / (d - h), e.y = d * (e.x - p) + E;
};
yh.prototype.touch = function(e) {
  e.xTouched = !0, e.yTouched = !0;
};
function Ch(e, n) {
  var s = Math.sqrt(e * e + n * n);
  return e /= s, n /= s, e === 1 && n === 0 ? Ir : e === 0 && n === 1 ? to : new yh(e, n);
}
function io(e, n, s, i) {
  this.x = this.xo = Math.round(e * 64) / 64, this.y = this.yo = Math.round(n * 64) / 64, this.lastPointOfContour = s, this.onCurve = i, this.prevPointOnContour = void 0, this.nextPointOnContour = void 0, this.xTouched = !1, this.yTouched = !1, Object.preventExtensions(this);
}
io.prototype.nextTouched = function(e) {
  for (var n = this.nextPointOnContour; !e.touched(n) && n !== this; )
    n = n.nextPointOnContour;
  return n;
};
io.prototype.prevTouched = function(e) {
  for (var n = this.prevPointOnContour; !e.touched(n) && n !== this; )
    n = n.prevPointOnContour;
  return n;
};
var oh = Object.freeze(new io(0, 0)), MG = {
  cvCutIn: 17 / 16,
  // control value cut in
  deltaBase: 9,
  deltaShift: 0.125,
  loop: 1,
  // loops some instructions
  minDis: 1,
  // minimum distance
  autoFlip: !0
};
function Xo(e, n) {
  switch (this.env = e, this.stack = [], this.prog = n, e) {
    case "glyf":
      this.zp0 = this.zp1 = this.zp2 = 1, this.rp0 = this.rp1 = this.rp2 = 0;
    case "prep":
      this.fv = this.pv = this.dpv = Ir, this.round = Sy;
  }
}
Iy.prototype.exec = function(e, n) {
  if (typeof n != "number")
    throw new Error("Point size is not a number!");
  if (!(this._errorState > 2)) {
    var s = this.font, i = this._prepState;
    if (!i || i.ppem !== n) {
      var r = this._fpgmState;
      if (!r) {
        Xo.prototype = MG, r = this._fpgmState = new Xo("fpgm", s.tables.fpgm), r.funcs = [], r.font = s, exports.DEBUG && (console.log("---EXEC FPGM---"), r.step = -1);
        try {
          Wa(r);
        } catch (h) {
          console.log("Hinting error in FPGM:" + h), this._errorState = 3;
          return;
        }
      }
      Xo.prototype = r, i = this._prepState = new Xo("prep", s.tables.prep), i.ppem = n;
      var o = s.tables.cvt;
      if (o)
        for (var a = i.cvt = new Array(o.length), c = n / s.unitsPerEm, l = 0; l < o.length; l++)
          a[l] = o[l] * c;
      else
        i.cvt = [];
      exports.DEBUG && (console.log("---EXEC PREP---"), i.step = -1);
      try {
        Wa(i);
      } catch (h) {
        this._errorState < 2 && console.log("Hinting error in PREP:" + h), this._errorState = 2;
      }
    }
    if (!(this._errorState > 1))
      try {
        return Oy(e, i);
      } catch (h) {
        this._errorState < 1 && (console.log("Hinting error:" + h), console.log("Note: further hinting errors are silenced")), this._errorState = 1;
        return;
      }
  }
};
Oy = function(e, n) {
  var s = n.ppem / n.font.unitsPerEm, i = s, r = e.components, o, a, c;
  if (Xo.prototype = n, !r)
    c = new Xo("glyf", e.instructions), exports.DEBUG && (console.log("---EXEC GLYPH---"), c.step = -1), ng(e, c, s, i), a = c.gZone;
  else {
    var l = n.font;
    a = [], o = [];
    for (var h = 0; h < r.length; h++) {
      var d = r[h], p = l.glyphs.get(d.glyphIndex);
      c = new Xo("glyf", p.instructions), exports.DEBUG && (console.log("---EXEC COMP " + h + "---"), c.step = -1), ng(p, c, s, i);
      for (var E = Math.round(d.dx * s), g = Math.round(d.dy * i), T = c.gZone, A = c.contours, m = 0; m < T.length; m++) {
        var O = T[m];
        O.xTouched = O.yTouched = !1, O.xo = O.x = O.x + E, O.yo = O.y = O.y + g;
      }
      var S = a.length;
      a.push.apply(a, T);
      for (var y = 0; y < A.length; y++)
        o.push(A[y] + S);
    }
    e.instructions && !c.inhibitGridFit && (c = new Xo("glyf", e.instructions), c.gZone = c.z0 = c.z1 = c.z2 = a, c.contours = o, a.push(
      new io(0, 0),
      new io(Math.round(e.advanceWidth * s), 0)
    ), exports.DEBUG && (console.log("---EXEC COMPOSITE---"), c.step = -1), Wa(c), a.length -= 2);
  }
  return a;
};
ng = function(e, n, s, i) {
  for (var r = e.points || [], o = r.length, a = n.gZone = n.z0 = n.z1 = n.z2 = [], c = n.contours = [], l, h = 0; h < o; h++)
    l = r[h], a[h] = new io(
      l.x * s,
      l.y * i,
      l.lastPointOfContour,
      l.onCurve
    );
  for (var d, p, E = 0; E < o; E++)
    l = a[E], d || (d = l, c.push(E)), l.lastPointOfContour ? (l.nextPointOnContour = d, d.prevPointOnContour = l, d = void 0) : (p = a[E + 1], l.nextPointOnContour = p, p.prevPointOnContour = l);
  if (!n.inhibitGridFit) {
    if (exports.DEBUG) {
      console.log("PROCESSING GLYPH", n.stack);
      for (var g = 0; g < o; g++)
        console.log(g, a[g].x, a[g].y);
    }
    if (a.push(
      new io(0, 0),
      new io(Math.round(e.advanceWidth * s), 0)
    ), Wa(n), a.length -= 2, exports.DEBUG) {
      console.log("FINISHED GLYPH", n.stack);
      for (var T = 0; T < o; T++)
        console.log(T, a[T].x, a[T].y);
    }
  }
};
Wa = function(e) {
  var n = e.prog;
  if (n) {
    var s = n.length, i;
    for (e.ip = 0; e.ip < s; e.ip++) {
      if (exports.DEBUG && e.step++, i = my[n[e.ip]], !i)
        throw new Error(
          "unknown instruction: 0x" + Number(n[e.ip]).toString(16)
        );
      i(e);
    }
  }
};
function nf(e) {
  for (var n = e.tZone = new Array(e.gZone.length), s = 0; s < n.length; s++)
    n[s] = new io(0, 0);
}
function Cy(e, n) {
  var s = e.prog, i = e.ip, r = 1, o;
  do
    if (o = s[++i], o === 88)
      r++;
    else if (o === 89)
      r--;
    else if (o === 64)
      i += s[i + 1] + 1;
    else if (o === 65)
      i += 2 * s[i + 1] + 1;
    else if (o >= 176 && o <= 183)
      i += o - 176 + 1;
    else if (o >= 184 && o <= 191)
      i += (o - 184 + 1) * 2;
    else if (n && r === 1 && o === 27)
      break;
  while (r > 0);
  e.ip = i;
}
function iI(e, n) {
  exports.DEBUG && console.log(n.step, "SVTCA[" + e.axis + "]"), n.fv = n.pv = n.dpv = e;
}
function rI(e, n) {
  exports.DEBUG && console.log(n.step, "SPVTCA[" + e.axis + "]"), n.pv = n.dpv = e;
}
function oI(e, n) {
  exports.DEBUG && console.log(n.step, "SFVTCA[" + e.axis + "]"), n.fv = e;
}
function aI(e, n) {
  var s = n.stack, i = s.pop(), r = s.pop(), o = n.z2[i], a = n.z1[r];
  exports.DEBUG && console.log("SPVTL[" + e + "]", i, r);
  var c, l;
  e ? (c = o.y - a.y, l = a.x - o.x) : (c = a.x - o.x, l = a.y - o.y), n.pv = n.dpv = Ch(c, l);
}
function cI(e, n) {
  var s = n.stack, i = s.pop(), r = s.pop(), o = n.z2[i], a = n.z1[r];
  exports.DEBUG && console.log("SFVTL[" + e + "]", i, r);
  var c, l;
  e ? (c = o.y - a.y, l = a.x - o.x) : (c = a.x - o.x, l = a.y - o.y), n.fv = Ch(c, l);
}
function PG(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "SPVFS[]", s, i), e.pv = e.dpv = Ch(i, s);
}
function bG(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "SPVFS[]", s, i), e.fv = Ch(i, s);
}
function UG(e) {
  var n = e.stack, s = e.pv;
  exports.DEBUG && console.log(e.step, "GPV[]"), n.push(s.x * 16384), n.push(s.y * 16384);
}
function GG(e) {
  var n = e.stack, s = e.fv;
  exports.DEBUG && console.log(e.step, "GFV[]"), n.push(s.x * 16384), n.push(s.y * 16384);
}
function FG(e) {
  e.fv = e.pv, exports.DEBUG && console.log(e.step, "SFVTPV[]");
}
function kG(e) {
  var n = e.stack, s = n.pop(), i = n.pop(), r = n.pop(), o = n.pop(), a = n.pop(), c = e.z0, l = e.z1, h = c[s], d = c[i], p = l[r], E = l[o], g = e.z2[a];
  exports.DEBUG && console.log("ISECT[], ", s, i, r, o, a);
  var T = h.x, A = h.y, m = d.x, O = d.y, S = p.x, y = p.y, v = E.x, R = E.y, M = (T - m) * (y - R) - (A - O) * (S - v), L = T * O - A * m, P = S * R - y * v;
  g.x = (L * (S - v) - P * (T - m)) / M, g.y = (L * (y - R) - P * (A - O)) / M;
}
function BG(e) {
  e.rp0 = e.stack.pop(), exports.DEBUG && console.log(e.step, "SRP0[]", e.rp0);
}
function VG(e) {
  e.rp1 = e.stack.pop(), exports.DEBUG && console.log(e.step, "SRP1[]", e.rp1);
}
function HG(e) {
  e.rp2 = e.stack.pop(), exports.DEBUG && console.log(e.step, "SRP2[]", e.rp2);
}
function WG(e) {
  var n = e.stack.pop();
  switch (exports.DEBUG && console.log(e.step, "SZP0[]", n), e.zp0 = n, n) {
    case 0:
      e.tZone || nf(e), e.z0 = e.tZone;
      break;
    case 1:
      e.z0 = e.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function YG(e) {
  var n = e.stack.pop();
  switch (exports.DEBUG && console.log(e.step, "SZP1[]", n), e.zp1 = n, n) {
    case 0:
      e.tZone || nf(e), e.z1 = e.tZone;
      break;
    case 1:
      e.z1 = e.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function XG(e) {
  var n = e.stack.pop();
  switch (exports.DEBUG && console.log(e.step, "SZP2[]", n), e.zp2 = n, n) {
    case 0:
      e.tZone || nf(e), e.z2 = e.tZone;
      break;
    case 1:
      e.z2 = e.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function zG(e) {
  var n = e.stack.pop();
  switch (exports.DEBUG && console.log(e.step, "SZPS[]", n), e.zp0 = e.zp1 = e.zp2 = n, n) {
    case 0:
      e.tZone || nf(e), e.z0 = e.z1 = e.z2 = e.tZone;
      break;
    case 1:
      e.z0 = e.z1 = e.z2 = e.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function KG(e) {
  e.loop = e.stack.pop(), exports.DEBUG && console.log(e.step, "SLOOP[]", e.loop);
}
function QG(e) {
  exports.DEBUG && console.log(e.step, "RTG[]"), e.round = Sy;
}
function ZG(e) {
  exports.DEBUG && console.log(e.step, "RTHG[]"), e.round = wG;
}
function qG(e) {
  var n = e.stack.pop();
  exports.DEBUG && console.log(e.step, "SMD[]", n), e.minDis = n / 64;
}
function jG(e) {
  exports.DEBUG && console.log(e.step, "ELSE[]"), Cy(e, !1);
}
function JG(e) {
  var n = e.stack.pop();
  exports.DEBUG && console.log(e.step, "JMPR[]", n), e.ip += n - 1;
}
function $G(e) {
  var n = e.stack.pop();
  exports.DEBUG && console.log(e.step, "SCVTCI[]", n), e.cvCutIn = n / 64;
}
function e3(e) {
  var n = e.stack;
  exports.DEBUG && console.log(e.step, "DUP[]"), n.push(n[n.length - 1]);
}
function jp(e) {
  exports.DEBUG && console.log(e.step, "POP[]"), e.stack.pop();
}
function t3(e) {
  exports.DEBUG && console.log(e.step, "CLEAR[]"), e.stack.length = 0;
}
function n3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "SWAP[]"), n.push(s), n.push(i);
}
function s3(e) {
  var n = e.stack;
  exports.DEBUG && console.log(e.step, "DEPTH[]"), n.push(n.length);
}
function i3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "LOOPCALL[]", s, i);
  var r = e.ip, o = e.prog;
  e.prog = e.funcs[s];
  for (var a = 0; a < i; a++)
    Wa(e), exports.DEBUG && console.log(
      ++e.step,
      a + 1 < i ? "next loopcall" : "done loopcall",
      a
    );
  e.ip = r, e.prog = o;
}
function r3(e) {
  var n = e.stack.pop();
  exports.DEBUG && console.log(e.step, "CALL[]", n);
  var s = e.ip, i = e.prog;
  e.prog = e.funcs[n], Wa(e), e.ip = s, e.prog = i, exports.DEBUG && console.log(++e.step, "returning from", n);
}
function o3(e) {
  var n = e.stack, s = n.pop();
  exports.DEBUG && console.log(e.step, "CINDEX[]", s), n.push(n[n.length - s]);
}
function a3(e) {
  var n = e.stack, s = n.pop();
  exports.DEBUG && console.log(e.step, "MINDEX[]", s), n.push(n.splice(n.length - s, 1)[0]);
}
function c3(e) {
  if (e.env !== "fpgm")
    throw new Error("FDEF not allowed here");
  var n = e.stack, s = e.prog, i = e.ip, r = n.pop(), o = i;
  for (exports.DEBUG && console.log(e.step, "FDEF[]", r); s[++i] !== 45; )
    ;
  e.ip = i, e.funcs[r] = s.slice(o + 1, i);
}
function lI(e, n) {
  var s = n.stack.pop(), i = n.z0[s], r = n.fv, o = n.pv;
  exports.DEBUG && console.log(n.step, "MDAP[" + e + "]", s);
  var a = o.distance(i, oh);
  e && (a = n.round(a)), r.setRelative(i, oh, a, o), r.touch(i), n.rp0 = n.rp1 = s;
}
function hI(e, n) {
  var s = n.z2, i = s.length - 2, r, o, a;
  exports.DEBUG && console.log(n.step, "IUP[" + e.axis + "]");
  for (var c = 0; c < i; c++)
    r = s[c], !e.touched(r) && (o = r.prevTouched(e), o !== r && (a = r.nextTouched(e), o === a && e.setRelative(r, r, e.distance(o, o, !1, !0), e, !0), e.interpolate(r, o, a, e)));
}
function uI(e, n) {
  for (var s = n.stack, i = e ? n.rp1 : n.rp2, r = (e ? n.z0 : n.z1)[i], o = n.fv, a = n.pv, c = n.loop, l = n.z2; c--; ) {
    var h = s.pop(), d = l[h], p = a.distance(r, r, !1, !0);
    o.setRelative(d, d, p, a), o.touch(d), exports.DEBUG && console.log(
      n.step,
      (n.loop > 1 ? "loop " + (n.loop - c) + ": " : "") + "SHP[" + (e ? "rp1" : "rp2") + "]",
      h
    );
  }
  n.loop = 1;
}
function dI(e, n) {
  var s = n.stack, i = e ? n.rp1 : n.rp2, r = (e ? n.z0 : n.z1)[i], o = n.fv, a = n.pv, c = s.pop(), l = n.z2[n.contours[c]], h = l;
  exports.DEBUG && console.log(n.step, "SHC[" + e + "]", c);
  var d = a.distance(r, r, !1, !0);
  do
    h !== r && o.setRelative(h, h, d, a), h = h.nextPointOnContour;
  while (h !== l);
}
function fI(e, n) {
  var s = n.stack, i = e ? n.rp1 : n.rp2, r = (e ? n.z0 : n.z1)[i], o = n.fv, a = n.pv, c = s.pop();
  exports.DEBUG && console.log(n.step, "SHZ[" + e + "]", c);
  var l;
  switch (c) {
    case 0:
      l = n.tZone;
      break;
    case 1:
      l = n.gZone;
      break;
    default:
      throw new Error("Invalid zone");
  }
  for (var h, d = a.distance(r, r, !1, !0), p = l.length - 2, E = 0; E < p; E++)
    h = l[E], o.setRelative(h, h, d, a);
}
function l3(e) {
  for (var n = e.stack, s = e.loop, i = e.fv, r = n.pop() / 64, o = e.z2; s--; ) {
    var a = n.pop(), c = o[a];
    exports.DEBUG && console.log(
      e.step,
      (e.loop > 1 ? "loop " + (e.loop - s) + ": " : "") + "SHPIX[]",
      a,
      r
    ), i.setRelative(c, c, r), i.touch(c);
  }
  e.loop = 1;
}
function h3(e) {
  for (var n = e.stack, s = e.rp1, i = e.rp2, r = e.loop, o = e.z0[s], a = e.z1[i], c = e.fv, l = e.dpv, h = e.z2; r--; ) {
    var d = n.pop(), p = h[d];
    exports.DEBUG && console.log(
      e.step,
      (e.loop > 1 ? "loop " + (e.loop - r) + ": " : "") + "IP[]",
      d,
      s,
      "<->",
      i
    ), c.interpolate(p, o, a, l), c.touch(p);
  }
  e.loop = 1;
}
function pI(e, n) {
  var s = n.stack, i = s.pop() / 64, r = s.pop(), o = n.z1[r], a = n.z0[n.rp0], c = n.fv, l = n.pv;
  c.setRelative(o, a, i, l), c.touch(o), exports.DEBUG && console.log(n.step, "MSIRP[" + e + "]", i, r), n.rp1 = n.rp0, n.rp2 = r, e && (n.rp0 = r);
}
function u3(e) {
  for (var n = e.stack, s = e.rp0, i = e.z0[s], r = e.loop, o = e.fv, a = e.pv, c = e.z1; r--; ) {
    var l = n.pop(), h = c[l];
    exports.DEBUG && console.log(
      e.step,
      (e.loop > 1 ? "loop " + (e.loop - r) + ": " : "") + "ALIGNRP[]",
      l
    ), o.setRelative(h, i, 0, a), o.touch(h);
  }
  e.loop = 1;
}
function d3(e) {
  exports.DEBUG && console.log(e.step, "RTDG[]"), e.round = RG;
}
function EI(e, n) {
  var s = n.stack, i = s.pop(), r = s.pop(), o = n.z0[r], a = n.fv, c = n.pv, l = n.cvt[i];
  exports.DEBUG && console.log(
    n.step,
    "MIAP[" + e + "]",
    i,
    "(",
    l,
    ")",
    r
  );
  var h = c.distance(o, oh);
  e && (Math.abs(h - l) < n.cvCutIn && (h = l), h = n.round(h)), a.setRelative(o, oh, h, c), n.zp0 === 0 && (o.xo = o.x, o.yo = o.y), a.touch(o), n.rp0 = n.rp1 = r;
}
function f3(e) {
  var n = e.prog, s = e.ip, i = e.stack, r = n[++s];
  exports.DEBUG && console.log(e.step, "NPUSHB[]", r);
  for (var o = 0; o < r; o++)
    i.push(n[++s]);
  e.ip = s;
}
function p3(e) {
  var n = e.ip, s = e.prog, i = e.stack, r = s[++n];
  exports.DEBUG && console.log(e.step, "NPUSHW[]", r);
  for (var o = 0; o < r; o++) {
    var a = s[++n] << 8 | s[++n];
    a & 32768 && (a = -((a ^ 65535) + 1)), i.push(a);
  }
  e.ip = n;
}
function E3(e) {
  var n = e.stack, s = e.store;
  s || (s = e.store = []);
  var i = n.pop(), r = n.pop();
  exports.DEBUG && console.log(e.step, "WS", i, r), s[r] = i;
}
function g3(e) {
  var n = e.stack, s = e.store, i = n.pop();
  exports.DEBUG && console.log(e.step, "RS", i);
  var r = s && s[i] || 0;
  n.push(r);
}
function _3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "WCVTP", s, i), e.cvt[i] = s / 64;
}
function T3(e) {
  var n = e.stack, s = n.pop();
  exports.DEBUG && console.log(e.step, "RCVT", s), n.push(e.cvt[s] * 64);
}
function gI(e, n) {
  var s = n.stack, i = s.pop(), r = n.z2[i];
  exports.DEBUG && console.log(n.step, "GC[" + e + "]", i), s.push(n.dpv.distance(r, oh, e, !1) * 64);
}
function _I(e, n) {
  var s = n.stack, i = s.pop(), r = s.pop(), o = n.z1[i], a = n.z0[r], c = n.dpv.distance(a, o, e, e);
  exports.DEBUG && console.log(n.step, "MD[" + e + "]", i, r, "->", c), n.stack.push(Math.round(c * 64));
}
function A3(e) {
  exports.DEBUG && console.log(e.step, "MPPEM[]"), e.stack.push(e.ppem);
}
function m3(e) {
  exports.DEBUG && console.log(e.step, "FLIPON[]"), e.autoFlip = !0;
}
function O3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "LT[]", s, i), n.push(i < s ? 1 : 0);
}
function I3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "LTEQ[]", s, i), n.push(i <= s ? 1 : 0);
}
function S3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "GT[]", s, i), n.push(i > s ? 1 : 0);
}
function y3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "GTEQ[]", s, i), n.push(i >= s ? 1 : 0);
}
function C3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "EQ[]", s, i), n.push(s === i ? 1 : 0);
}
function N3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "NEQ[]", s, i), n.push(s !== i ? 1 : 0);
}
function x3(e) {
  var n = e.stack, s = n.pop();
  exports.DEBUG && console.log(e.step, "ODD[]", s), n.push(Math.trunc(s) % 2 ? 1 : 0);
}
function v3(e) {
  var n = e.stack, s = n.pop();
  exports.DEBUG && console.log(e.step, "EVEN[]", s), n.push(Math.trunc(s) % 2 ? 0 : 1);
}
function R3(e) {
  var n = e.stack.pop();
  exports.DEBUG && console.log(e.step, "IF[]", n), n || (Cy(e, !0), exports.DEBUG && console.log(e.step, "EIF[]"));
}
function w3(e) {
  exports.DEBUG && console.log(e.step, "EIF[]");
}
function D3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "AND[]", s, i), n.push(s && i ? 1 : 0);
}
function L3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "OR[]", s, i), n.push(s || i ? 1 : 0);
}
function M3(e) {
  var n = e.stack, s = n.pop();
  exports.DEBUG && console.log(e.step, "NOT[]", s), n.push(s ? 0 : 1);
}
function Jp(e, n) {
  var s = n.stack, i = s.pop(), r = n.fv, o = n.pv, a = n.ppem, c = n.deltaBase + (e - 1) * 16, l = n.deltaShift, h = n.z0;
  exports.DEBUG && console.log(n.step, "DELTAP[" + e + "]", i, s);
  for (var d = 0; d < i; d++) {
    var p = s.pop(), E = s.pop(), g = c + ((E & 240) >> 4);
    if (g === a) {
      var T = (E & 15) - 8;
      T >= 0 && T++, exports.DEBUG && console.log(n.step, "DELTAPFIX", p, "by", T * l);
      var A = h[p];
      r.setRelative(A, A, T * l, o);
    }
  }
}
function P3(e) {
  var n = e.stack, s = n.pop();
  exports.DEBUG && console.log(e.step, "SDB[]", s), e.deltaBase = s;
}
function b3(e) {
  var n = e.stack, s = n.pop();
  exports.DEBUG && console.log(e.step, "SDS[]", s), e.deltaShift = Math.pow(0.5, s);
}
function U3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "ADD[]", s, i), n.push(i + s);
}
function G3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "SUB[]", s, i), n.push(i - s);
}
function F3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "DIV[]", s, i), n.push(i * 64 / s);
}
function k3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "MUL[]", s, i), n.push(i * s / 64);
}
function B3(e) {
  var n = e.stack, s = n.pop();
  exports.DEBUG && console.log(e.step, "ABS[]", s), n.push(Math.abs(s));
}
function V3(e) {
  var n = e.stack, s = n.pop();
  exports.DEBUG && console.log(e.step, "NEG[]", s), n.push(-s);
}
function H3(e) {
  var n = e.stack, s = n.pop();
  exports.DEBUG && console.log(e.step, "FLOOR[]", s), n.push(Math.floor(s / 64) * 64);
}
function W3(e) {
  var n = e.stack, s = n.pop();
  exports.DEBUG && console.log(e.step, "CEILING[]", s), n.push(Math.ceil(s / 64) * 64);
}
function xu(e, n) {
  var s = n.stack, i = s.pop();
  exports.DEBUG && console.log(n.step, "ROUND[]"), s.push(n.round(i / 64) * 64);
}
function Y3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "WCVTF[]", s, i), e.cvt[i] = s * e.ppem / e.font.unitsPerEm;
}
function $p(e, n) {
  var s = n.stack, i = s.pop(), r = n.ppem, o = n.deltaBase + (e - 1) * 16, a = n.deltaShift;
  exports.DEBUG && console.log(n.step, "DELTAC[" + e + "]", i, s);
  for (var c = 0; c < i; c++) {
    var l = s.pop(), h = s.pop(), d = o + ((h & 240) >> 4);
    if (d === r) {
      var p = (h & 15) - 8;
      p >= 0 && p++;
      var E = p * a;
      exports.DEBUG && console.log(n.step, "DELTACFIX", l, "by", E), n.cvt[l] += E;
    }
  }
}
function X3(e) {
  var n = e.stack.pop();
  exports.DEBUG && console.log(e.step, "SROUND[]", n), e.round = yy;
  var s;
  switch (n & 192) {
    case 0:
      s = 0.5;
      break;
    case 64:
      s = 1;
      break;
    case 128:
      s = 2;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  switch (e.srPeriod = s, n & 48) {
    case 0:
      e.srPhase = 0;
      break;
    case 16:
      e.srPhase = 0.25 * s;
      break;
    case 32:
      e.srPhase = 0.5 * s;
      break;
    case 48:
      e.srPhase = 0.75 * s;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  n &= 15, n === 0 ? e.srThreshold = 0 : e.srThreshold = (n / 8 - 0.5) * s;
}
function z3(e) {
  var n = e.stack.pop();
  exports.DEBUG && console.log(e.step, "S45ROUND[]", n), e.round = yy;
  var s;
  switch (n & 192) {
    case 0:
      s = Math.sqrt(2) / 2;
      break;
    case 64:
      s = Math.sqrt(2);
      break;
    case 128:
      s = 2 * Math.sqrt(2);
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  switch (e.srPeriod = s, n & 48) {
    case 0:
      e.srPhase = 0;
      break;
    case 16:
      e.srPhase = 0.25 * s;
      break;
    case 32:
      e.srPhase = 0.5 * s;
      break;
    case 48:
      e.srPhase = 0.75 * s;
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  n &= 15, n === 0 ? e.srThreshold = 0 : e.srThreshold = (n / 8 - 0.5) * s;
}
function K3(e) {
  exports.DEBUG && console.log(e.step, "ROFF[]"), e.round = vG;
}
function Q3(e) {
  exports.DEBUG && console.log(e.step, "RUTG[]"), e.round = DG;
}
function Z3(e) {
  exports.DEBUG && console.log(e.step, "RDTG[]"), e.round = LG;
}
function q3(e) {
  var n = e.stack.pop();
  exports.DEBUG && console.log(e.step, "SCANCTRL[]", n);
}
function TI(e, n) {
  var s = n.stack, i = s.pop(), r = s.pop(), o = n.z2[i], a = n.z1[r];
  exports.DEBUG && console.log(n.step, "SDPVTL[" + e + "]", i, r);
  var c, l;
  e ? (c = o.y - a.y, l = a.x - o.x) : (c = a.x - o.x, l = a.y - o.y), n.dpv = Ch(c, l);
}
function j3(e) {
  var n = e.stack, s = n.pop(), i = 0;
  exports.DEBUG && console.log(e.step, "GETINFO[]", s), s & 1 && (i = 35), s & 32 && (i |= 4096), n.push(i);
}
function J3(e) {
  var n = e.stack, s = n.pop(), i = n.pop(), r = n.pop();
  exports.DEBUG && console.log(e.step, "ROLL[]"), n.push(i), n.push(s), n.push(r);
}
function $3(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "MAX[]", s, i), n.push(Math.max(i, s));
}
function e5(e) {
  var n = e.stack, s = n.pop(), i = n.pop();
  exports.DEBUG && console.log(e.step, "MIN[]", s, i), n.push(Math.min(i, s));
}
function t5(e) {
  var n = e.stack.pop();
  exports.DEBUG && console.log(e.step, "SCANTYPE[]", n);
}
function n5(e) {
  var n = e.stack.pop(), s = e.stack.pop();
  switch (exports.DEBUG && console.log(e.step, "INSTCTRL[]", n, s), n) {
    case 1:
      e.inhibitGridFit = !!s;
      return;
    case 2:
      e.ignoreCvt = !!s;
      return;
    default:
      throw new Error("invalid INSTCTRL[] selector");
  }
}
function vo(e, n) {
  var s = n.stack, i = n.prog, r = n.ip;
  exports.DEBUG && console.log(n.step, "PUSHB[" + e + "]");
  for (var o = 0; o < e; o++)
    s.push(i[++r]);
  n.ip = r;
}
function Ro(e, n) {
  var s = n.ip, i = n.prog, r = n.stack;
  exports.DEBUG && console.log(n.ip, "PUSHW[" + e + "]");
  for (var o = 0; o < e; o++) {
    var a = i[++s] << 8 | i[++s];
    a & 32768 && (a = -((a ^ 65535) + 1)), r.push(a);
  }
  n.ip = s;
}
function Re(e, n, s, i, r, o) {
  var a = o.stack, c = e && a.pop(), l = a.pop(), h = o.rp0, d = o.z0[h], p = o.z1[l], E = o.minDis, g = o.fv, T = o.dpv, A, m, O, S;
  m = A = T.distance(p, d, !0, !0), O = m >= 0 ? 1 : -1, m = Math.abs(m), e && (S = o.cvt[c], i && Math.abs(m - S) < o.cvCutIn && (m = S)), s && m < E && (m = E), i && (m = o.round(m)), g.setRelative(p, d, O * m, T), g.touch(p), exports.DEBUG && console.log(
    o.step,
    (e ? "MIRP[" : "MDRP[") + (n ? "M" : "m") + (s ? ">" : "_") + (i ? "R" : "_") + (r === 0 ? "Gr" : r === 1 ? "Bl" : r === 2 ? "Wh" : "") + "]",
    e ? c + "(" + o.cvt[c] + "," + S + ")" : "",
    l,
    "(d =",
    A,
    "->",
    O * m,
    ")"
  ), o.rp1 = o.rp0, o.rp2 = l, n && (o.rp0 = l);
}
my = [
  /* 0x00 */
  iI.bind(void 0, to),
  /* 0x01 */
  iI.bind(void 0, Ir),
  /* 0x02 */
  rI.bind(void 0, to),
  /* 0x03 */
  rI.bind(void 0, Ir),
  /* 0x04 */
  oI.bind(void 0, to),
  /* 0x05 */
  oI.bind(void 0, Ir),
  /* 0x06 */
  aI.bind(void 0, 0),
  /* 0x07 */
  aI.bind(void 0, 1),
  /* 0x08 */
  cI.bind(void 0, 0),
  /* 0x09 */
  cI.bind(void 0, 1),
  /* 0x0A */
  PG,
  /* 0x0B */
  bG,
  /* 0x0C */
  UG,
  /* 0x0D */
  GG,
  /* 0x0E */
  FG,
  /* 0x0F */
  kG,
  /* 0x10 */
  BG,
  /* 0x11 */
  VG,
  /* 0x12 */
  HG,
  /* 0x13 */
  WG,
  /* 0x14 */
  YG,
  /* 0x15 */
  XG,
  /* 0x16 */
  zG,
  /* 0x17 */
  KG,
  /* 0x18 */
  QG,
  /* 0x19 */
  ZG,
  /* 0x1A */
  qG,
  /* 0x1B */
  jG,
  /* 0x1C */
  JG,
  /* 0x1D */
  $G,
  /* 0x1E */
  void 0,
  // TODO SSWCI
  /* 0x1F */
  void 0,
  // TODO SSW
  /* 0x20 */
  e3,
  /* 0x21 */
  jp,
  /* 0x22 */
  t3,
  /* 0x23 */
  n3,
  /* 0x24 */
  s3,
  /* 0x25 */
  o3,
  /* 0x26 */
  a3,
  /* 0x27 */
  void 0,
  // TODO ALIGNPTS
  /* 0x28 */
  void 0,
  /* 0x29 */
  void 0,
  // TODO UTP
  /* 0x2A */
  i3,
  /* 0x2B */
  r3,
  /* 0x2C */
  c3,
  /* 0x2D */
  void 0,
  // ENDF (eaten by FDEF)
  /* 0x2E */
  lI.bind(void 0, 0),
  /* 0x2F */
  lI.bind(void 0, 1),
  /* 0x30 */
  hI.bind(void 0, to),
  /* 0x31 */
  hI.bind(void 0, Ir),
  /* 0x32 */
  uI.bind(void 0, 0),
  /* 0x33 */
  uI.bind(void 0, 1),
  /* 0x34 */
  dI.bind(void 0, 0),
  /* 0x35 */
  dI.bind(void 0, 1),
  /* 0x36 */
  fI.bind(void 0, 0),
  /* 0x37 */
  fI.bind(void 0, 1),
  /* 0x38 */
  l3,
  /* 0x39 */
  h3,
  /* 0x3A */
  pI.bind(void 0, 0),
  /* 0x3B */
  pI.bind(void 0, 1),
  /* 0x3C */
  u3,
  /* 0x3D */
  d3,
  /* 0x3E */
  EI.bind(void 0, 0),
  /* 0x3F */
  EI.bind(void 0, 1),
  /* 0x40 */
  f3,
  /* 0x41 */
  p3,
  /* 0x42 */
  E3,
  /* 0x43 */
  g3,
  /* 0x44 */
  _3,
  /* 0x45 */
  T3,
  /* 0x46 */
  gI.bind(void 0, 0),
  /* 0x47 */
  gI.bind(void 0, 1),
  /* 0x48 */
  void 0,
  // TODO SCFS
  /* 0x49 */
  _I.bind(void 0, 0),
  /* 0x4A */
  _I.bind(void 0, 1),
  /* 0x4B */
  A3,
  /* 0x4C */
  void 0,
  // TODO MPS
  /* 0x4D */
  m3,
  /* 0x4E */
  void 0,
  // TODO FLIPOFF
  /* 0x4F */
  void 0,
  // TODO DEBUG
  /* 0x50 */
  O3,
  /* 0x51 */
  I3,
  /* 0x52 */
  S3,
  /* 0x53 */
  y3,
  /* 0x54 */
  C3,
  /* 0x55 */
  N3,
  /* 0x56 */
  x3,
  /* 0x57 */
  v3,
  /* 0x58 */
  R3,
  /* 0x59 */
  w3,
  /* 0x5A */
  D3,
  /* 0x5B */
  L3,
  /* 0x5C */
  M3,
  /* 0x5D */
  Jp.bind(void 0, 1),
  /* 0x5E */
  P3,
  /* 0x5F */
  b3,
  /* 0x60 */
  U3,
  /* 0x61 */
  G3,
  /* 0x62 */
  F3,
  /* 0x63 */
  k3,
  /* 0x64 */
  B3,
  /* 0x65 */
  V3,
  /* 0x66 */
  H3,
  /* 0x67 */
  W3,
  /* 0x68 */
  xu.bind(void 0, 0),
  /* 0x69 */
  xu.bind(void 0, 1),
  /* 0x6A */
  xu.bind(void 0, 2),
  /* 0x6B */
  xu.bind(void 0, 3),
  /* 0x6C */
  void 0,
  // TODO NROUND[ab]
  /* 0x6D */
  void 0,
  // TODO NROUND[ab]
  /* 0x6E */
  void 0,
  // TODO NROUND[ab]
  /* 0x6F */
  void 0,
  // TODO NROUND[ab]
  /* 0x70 */
  Y3,
  /* 0x71 */
  Jp.bind(void 0, 2),
  /* 0x72 */
  Jp.bind(void 0, 3),
  /* 0x73 */
  $p.bind(void 0, 1),
  /* 0x74 */
  $p.bind(void 0, 2),
  /* 0x75 */
  $p.bind(void 0, 3),
  /* 0x76 */
  X3,
  /* 0x77 */
  z3,
  /* 0x78 */
  void 0,
  // TODO JROT[]
  /* 0x79 */
  void 0,
  // TODO JROF[]
  /* 0x7A */
  K3,
  /* 0x7B */
  void 0,
  /* 0x7C */
  Q3,
  /* 0x7D */
  Z3,
  /* 0x7E */
  jp,
  // actually SANGW, supposed to do only a pop though
  /* 0x7F */
  jp,
  // actually AA, supposed to do only a pop though
  /* 0x80 */
  void 0,
  // TODO FLIPPT
  /* 0x81 */
  void 0,
  // TODO FLIPRGON
  /* 0x82 */
  void 0,
  // TODO FLIPRGOFF
  /* 0x83 */
  void 0,
  /* 0x84 */
  void 0,
  /* 0x85 */
  q3,
  /* 0x86 */
  TI.bind(void 0, 0),
  /* 0x87 */
  TI.bind(void 0, 1),
  /* 0x88 */
  j3,
  /* 0x89 */
  void 0,
  // TODO IDEF
  /* 0x8A */
  J3,
  /* 0x8B */
  $3,
  /* 0x8C */
  e5,
  /* 0x8D */
  t5,
  /* 0x8E */
  n5,
  /* 0x8F */
  void 0,
  /* 0x90 */
  void 0,
  /* 0x91 */
  void 0,
  /* 0x92 */
  void 0,
  /* 0x93 */
  void 0,
  /* 0x94 */
  void 0,
  /* 0x95 */
  void 0,
  /* 0x96 */
  void 0,
  /* 0x97 */
  void 0,
  /* 0x98 */
  void 0,
  /* 0x99 */
  void 0,
  /* 0x9A */
  void 0,
  /* 0x9B */
  void 0,
  /* 0x9C */
  void 0,
  /* 0x9D */
  void 0,
  /* 0x9E */
  void 0,
  /* 0x9F */
  void 0,
  /* 0xA0 */
  void 0,
  /* 0xA1 */
  void 0,
  /* 0xA2 */
  void 0,
  /* 0xA3 */
  void 0,
  /* 0xA4 */
  void 0,
  /* 0xA5 */
  void 0,
  /* 0xA6 */
  void 0,
  /* 0xA7 */
  void 0,
  /* 0xA8 */
  void 0,
  /* 0xA9 */
  void 0,
  /* 0xAA */
  void 0,
  /* 0xAB */
  void 0,
  /* 0xAC */
  void 0,
  /* 0xAD */
  void 0,
  /* 0xAE */
  void 0,
  /* 0xAF */
  void 0,
  /* 0xB0 */
  vo.bind(void 0, 1),
  /* 0xB1 */
  vo.bind(void 0, 2),
  /* 0xB2 */
  vo.bind(void 0, 3),
  /* 0xB3 */
  vo.bind(void 0, 4),
  /* 0xB4 */
  vo.bind(void 0, 5),
  /* 0xB5 */
  vo.bind(void 0, 6),
  /* 0xB6 */
  vo.bind(void 0, 7),
  /* 0xB7 */
  vo.bind(void 0, 8),
  /* 0xB8 */
  Ro.bind(void 0, 1),
  /* 0xB9 */
  Ro.bind(void 0, 2),
  /* 0xBA */
  Ro.bind(void 0, 3),
  /* 0xBB */
  Ro.bind(void 0, 4),
  /* 0xBC */
  Ro.bind(void 0, 5),
  /* 0xBD */
  Ro.bind(void 0, 6),
  /* 0xBE */
  Ro.bind(void 0, 7),
  /* 0xBF */
  Ro.bind(void 0, 8),
  /* 0xC0 */
  Re.bind(void 0, 0, 0, 0, 0, 0),
  /* 0xC1 */
  Re.bind(void 0, 0, 0, 0, 0, 1),
  /* 0xC2 */
  Re.bind(void 0, 0, 0, 0, 0, 2),
  /* 0xC3 */
  Re.bind(void 0, 0, 0, 0, 0, 3),
  /* 0xC4 */
  Re.bind(void 0, 0, 0, 0, 1, 0),
  /* 0xC5 */
  Re.bind(void 0, 0, 0, 0, 1, 1),
  /* 0xC6 */
  Re.bind(void 0, 0, 0, 0, 1, 2),
  /* 0xC7 */
  Re.bind(void 0, 0, 0, 0, 1, 3),
  /* 0xC8 */
  Re.bind(void 0, 0, 0, 1, 0, 0),
  /* 0xC9 */
  Re.bind(void 0, 0, 0, 1, 0, 1),
  /* 0xCA */
  Re.bind(void 0, 0, 0, 1, 0, 2),
  /* 0xCB */
  Re.bind(void 0, 0, 0, 1, 0, 3),
  /* 0xCC */
  Re.bind(void 0, 0, 0, 1, 1, 0),
  /* 0xCD */
  Re.bind(void 0, 0, 0, 1, 1, 1),
  /* 0xCE */
  Re.bind(void 0, 0, 0, 1, 1, 2),
  /* 0xCF */
  Re.bind(void 0, 0, 0, 1, 1, 3),
  /* 0xD0 */
  Re.bind(void 0, 0, 1, 0, 0, 0),
  /* 0xD1 */
  Re.bind(void 0, 0, 1, 0, 0, 1),
  /* 0xD2 */
  Re.bind(void 0, 0, 1, 0, 0, 2),
  /* 0xD3 */
  Re.bind(void 0, 0, 1, 0, 0, 3),
  /* 0xD4 */
  Re.bind(void 0, 0, 1, 0, 1, 0),
  /* 0xD5 */
  Re.bind(void 0, 0, 1, 0, 1, 1),
  /* 0xD6 */
  Re.bind(void 0, 0, 1, 0, 1, 2),
  /* 0xD7 */
  Re.bind(void 0, 0, 1, 0, 1, 3),
  /* 0xD8 */
  Re.bind(void 0, 0, 1, 1, 0, 0),
  /* 0xD9 */
  Re.bind(void 0, 0, 1, 1, 0, 1),
  /* 0xDA */
  Re.bind(void 0, 0, 1, 1, 0, 2),
  /* 0xDB */
  Re.bind(void 0, 0, 1, 1, 0, 3),
  /* 0xDC */
  Re.bind(void 0, 0, 1, 1, 1, 0),
  /* 0xDD */
  Re.bind(void 0, 0, 1, 1, 1, 1),
  /* 0xDE */
  Re.bind(void 0, 0, 1, 1, 1, 2),
  /* 0xDF */
  Re.bind(void 0, 0, 1, 1, 1, 3),
  /* 0xE0 */
  Re.bind(void 0, 1, 0, 0, 0, 0),
  /* 0xE1 */
  Re.bind(void 0, 1, 0, 0, 0, 1),
  /* 0xE2 */
  Re.bind(void 0, 1, 0, 0, 0, 2),
  /* 0xE3 */
  Re.bind(void 0, 1, 0, 0, 0, 3),
  /* 0xE4 */
  Re.bind(void 0, 1, 0, 0, 1, 0),
  /* 0xE5 */
  Re.bind(void 0, 1, 0, 0, 1, 1),
  /* 0xE6 */
  Re.bind(void 0, 1, 0, 0, 1, 2),
  /* 0xE7 */
  Re.bind(void 0, 1, 0, 0, 1, 3),
  /* 0xE8 */
  Re.bind(void 0, 1, 0, 1, 0, 0),
  /* 0xE9 */
  Re.bind(void 0, 1, 0, 1, 0, 1),
  /* 0xEA */
  Re.bind(void 0, 1, 0, 1, 0, 2),
  /* 0xEB */
  Re.bind(void 0, 1, 0, 1, 0, 3),
  /* 0xEC */
  Re.bind(void 0, 1, 0, 1, 1, 0),
  /* 0xED */
  Re.bind(void 0, 1, 0, 1, 1, 1),
  /* 0xEE */
  Re.bind(void 0, 1, 0, 1, 1, 2),
  /* 0xEF */
  Re.bind(void 0, 1, 0, 1, 1, 3),
  /* 0xF0 */
  Re.bind(void 0, 1, 1, 0, 0, 0),
  /* 0xF1 */
  Re.bind(void 0, 1, 1, 0, 0, 1),
  /* 0xF2 */
  Re.bind(void 0, 1, 1, 0, 0, 2),
  /* 0xF3 */
  Re.bind(void 0, 1, 1, 0, 0, 3),
  /* 0xF4 */
  Re.bind(void 0, 1, 1, 0, 1, 0),
  /* 0xF5 */
  Re.bind(void 0, 1, 1, 0, 1, 1),
  /* 0xF6 */
  Re.bind(void 0, 1, 1, 0, 1, 2),
  /* 0xF7 */
  Re.bind(void 0, 1, 1, 0, 1, 3),
  /* 0xF8 */
  Re.bind(void 0, 1, 1, 1, 0, 0),
  /* 0xF9 */
  Re.bind(void 0, 1, 1, 1, 0, 1),
  /* 0xFA */
  Re.bind(void 0, 1, 1, 1, 0, 2),
  /* 0xFB */
  Re.bind(void 0, 1, 1, 1, 0, 3),
  /* 0xFC */
  Re.bind(void 0, 1, 1, 1, 1, 0),
  /* 0xFD */
  Re.bind(void 0, 1, 1, 1, 1, 1),
  /* 0xFE */
  Re.bind(void 0, 1, 1, 1, 1, 2),
  /* 0xFF */
  Re.bind(void 0, 1, 1, 1, 1, 3)
];
function zc(e) {
  this.char = e, this.state = {}, this.activeState = null;
}
function u0(e, n, s) {
  this.contextName = s, this.startIndex = e, this.endOffset = n;
}
function s5(e, n, s) {
  this.contextName = e, this.openRange = null, this.ranges = [], this.checkStart = n, this.checkEnd = s;
}
function lr(e, n) {
  this.context = e, this.index = n, this.length = e.length, this.current = e[n], this.backtrack = e.slice(0, n), this.lookahead = e.slice(n + 1);
}
function sf(e) {
  this.eventId = e, this.subscribers = [];
}
function i5(e) {
  var n = this, s = [
    "start",
    "end",
    "next",
    "newToken",
    "contextStart",
    "contextEnd",
    "insertToken",
    "removeToken",
    "removeRange",
    "replaceToken",
    "replaceRange",
    "composeRUD",
    "updateContextsRanges"
  ];
  s.forEach(function(r) {
    Object.defineProperty(n.events, r, {
      value: new sf(r)
    });
  }), e && s.forEach(function(r) {
    var o = e[r];
    typeof o == "function" && n.events[r].subscribe(o);
  });
  var i = [
    "insertToken",
    "removeToken",
    "removeRange",
    "replaceToken",
    "replaceRange",
    "composeRUD"
  ];
  i.forEach(function(r) {
    n.events[r].subscribe(
      n.updateContextsRanges
    );
  });
}
function Mn(e) {
  this.tokens = [], this.registeredContexts = {}, this.contextCheckers = [], this.events = {}, this.registeredModifiers = [], i5.call(this, e);
}
zc.prototype.setState = function(e, n) {
  return this.state[e] = n, this.activeState = { key: e, value: this.state[e] }, this.activeState;
};
zc.prototype.getState = function(e) {
  return this.state[e] || null;
};
Mn.prototype.inboundIndex = function(e) {
  return e >= 0 && e < this.tokens.length;
};
Mn.prototype.composeRUD = function(e) {
  var n = this, s = !0, i = e.map(function(o) {
    return n[o[0]].apply(n, o.slice(1).concat(s));
  }), r = function(o) {
    return typeof o == "object" && o.hasOwnProperty("FAIL");
  };
  if (i.every(r))
    return {
      FAIL: "composeRUD: one or more operations hasn't completed successfully",
      report: i.filter(r)
    };
  this.dispatch("composeRUD", [i.filter(function(o) {
    return !r(o);
  })]);
};
Mn.prototype.replaceRange = function(e, n, s, i) {
  n = n !== null ? n : this.tokens.length;
  var r = s.every(function(a) {
    return a instanceof zc;
  });
  if (!isNaN(e) && this.inboundIndex(e) && r) {
    var o = this.tokens.splice.apply(
      this.tokens,
      [e, n].concat(s)
    );
    return i || this.dispatch("replaceToken", [e, n, s]), [o, s];
  } else
    return { FAIL: "replaceRange: invalid tokens or startIndex." };
};
Mn.prototype.replaceToken = function(e, n, s) {
  if (!isNaN(e) && this.inboundIndex(e) && n instanceof zc) {
    var i = this.tokens.splice(e, 1, n);
    return s || this.dispatch("replaceToken", [e, n]), [i[0], n];
  } else
    return { FAIL: "replaceToken: invalid token or index." };
};
Mn.prototype.removeRange = function(e, n, s) {
  n = isNaN(n) ? this.tokens.length : n;
  var i = this.tokens.splice(e, n);
  return s || this.dispatch("removeRange", [i, e, n]), i;
};
Mn.prototype.removeToken = function(e, n) {
  if (!isNaN(e) && this.inboundIndex(e)) {
    var s = this.tokens.splice(e, 1);
    return n || this.dispatch("removeToken", [s, e]), s;
  } else
    return { FAIL: "removeToken: invalid token index." };
};
Mn.prototype.insertToken = function(e, n, s) {
  var i = e.every(
    function(r) {
      return r instanceof zc;
    }
  );
  return i ? (this.tokens.splice.apply(
    this.tokens,
    [n, 0].concat(e)
  ), s || this.dispatch("insertToken", [e, n]), e) : { FAIL: "insertToken: invalid token(s)." };
};
Mn.prototype.registerModifier = function(e, n, s) {
  this.events.newToken.subscribe(function(i, r) {
    var o = [i, r], a = n === null || n.apply(this, o) === !0, c = [i, r];
    if (a) {
      var l = s.apply(this, c);
      i.setState(e, l);
    }
  }), this.registeredModifiers.push(e);
};
sf.prototype.subscribe = function(e) {
  return typeof e == "function" ? this.subscribers.push(e) - 1 : { FAIL: "invalid '" + this.eventId + "' event handler" };
};
sf.prototype.unsubscribe = function(e) {
  this.subscribers.splice(e, 1);
};
lr.prototype.setCurrentIndex = function(e) {
  this.index = e, this.current = this.context[e], this.backtrack = this.context.slice(0, e), this.lookahead = this.context.slice(e + 1);
};
lr.prototype.get = function(e) {
  switch (!0) {
    case e === 0:
      return this.current;
    case (e < 0 && Math.abs(e) <= this.backtrack.length):
      return this.backtrack.slice(e)[0];
    case (e > 0 && e <= this.lookahead.length):
      return this.lookahead[e - 1];
    default:
      return null;
  }
};
Mn.prototype.rangeToText = function(e) {
  if (e instanceof u0)
    return this.getRangeTokens(e).map(function(n) {
      return n.char;
    }).join("");
};
Mn.prototype.getText = function() {
  return this.tokens.map(function(e) {
    return e.char;
  }).join("");
};
Mn.prototype.getContext = function(e) {
  var n = this.registeredContexts[e];
  return n || null;
};
Mn.prototype.on = function(e, n) {
  var s = this.events[e];
  return s ? s.subscribe(n) : null;
};
Mn.prototype.dispatch = function(e, n) {
  var s = this, i = this.events[e];
  i instanceof sf && i.subscribers.forEach(function(r) {
    r.apply(s, n || []);
  });
};
Mn.prototype.registerContextChecker = function(e, n, s) {
  if (this.getContext(e))
    return {
      FAIL: "context name '" + e + "' is already registered."
    };
  if (typeof n != "function")
    return {
      FAIL: "missing context start check."
    };
  if (typeof s != "function")
    return {
      FAIL: "missing context end check."
    };
  var i = new s5(
    e,
    n,
    s
  );
  return this.registeredContexts[e] = i, this.contextCheckers.push(i), i;
};
Mn.prototype.getRangeTokens = function(e) {
  var n = e.startIndex + e.endOffset;
  return [].concat(
    this.tokens.slice(e.startIndex, n)
  );
};
Mn.prototype.getContextRanges = function(e) {
  var n = this.getContext(e);
  return n ? n.ranges : { FAIL: "context checker '" + e + "' is not registered." };
};
Mn.prototype.resetContextsRanges = function() {
  var e = this.registeredContexts;
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      var s = e[n];
      s.ranges = [];
    }
};
Mn.prototype.updateContextsRanges = function() {
  this.resetContextsRanges();
  for (var e = this.tokens.map(function(i) {
    return i.char;
  }), n = 0; n < e.length; n++) {
    var s = new lr(e, n);
    this.runContextCheck(s);
  }
  this.dispatch("updateContextsRanges", [this.registeredContexts]);
};
Mn.prototype.setEndOffset = function(e, n) {
  var s = this.getContext(n).openRange.startIndex, i = new u0(s, e, n), r = this.getContext(n).ranges;
  return i.rangeId = n + "." + r.length, r.push(i), this.getContext(n).openRange = null, i;
};
Mn.prototype.runContextCheck = function(e) {
  var n = this, s = e.index;
  this.contextCheckers.forEach(function(i) {
    var r = i.contextName, o = n.getContext(r).openRange;
    if (!o && i.checkStart(e) && (o = new u0(s, null, r), n.getContext(r).openRange = o, n.dispatch("contextStart", [r, s])), o && i.checkEnd(e)) {
      var a = s - o.startIndex + 1, c = n.setEndOffset(a, r);
      n.dispatch("contextEnd", [r, c]);
    }
  });
};
Mn.prototype.tokenize = function(e) {
  this.tokens = [], this.resetContextsRanges();
  var n = Array.from(e);
  this.dispatch("start");
  for (var s = 0; s < n.length; s++) {
    var i = n[s], r = new lr(n, s);
    this.dispatch("next", [r]), this.runContextCheck(r);
    var o = new zc(i);
    this.tokens.push(o), this.dispatch("newToken", [o, r]);
  }
  return this.dispatch("end", [this.tokens]), this.tokens;
};
function Ko(e) {
  return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(e);
}
function Ny(e) {
  return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(e);
}
function $o(e) {
  return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(e);
}
function Zu(e) {
  return /[A-z]/.test(e);
}
function r5(e) {
  return /\s/.test(e);
}
function yi(e) {
  this.font = e, this.features = {};
}
function ya(e) {
  this.id = e.id, this.tag = e.tag, this.substitution = e.substitution;
}
function Nh(e, n) {
  if (!e)
    return -1;
  switch (n.format) {
    case 1:
      return n.glyphs.indexOf(e);
    case 2:
      for (var s = n.ranges, i = 0; i < s.length; i++) {
        var r = s[i];
        if (e >= r.start && e <= r.end) {
          var o = e - r.start;
          return r.index + o;
        }
      }
      break;
    default:
      return -1;
  }
  return -1;
}
function o5(e, n) {
  var s = Nh(e, n.coverage);
  return s === -1 ? null : e + n.deltaGlyphId;
}
function a5(e, n) {
  var s = Nh(e, n.coverage);
  return s === -1 ? null : n.substitute[s];
}
function eE(e, n) {
  for (var s = [], i = 0; i < e.length; i++) {
    var r = e[i], o = n.current;
    o = Array.isArray(o) ? o[0] : o;
    var a = Nh(o, r);
    a !== -1 && s.push(a);
  }
  return s.length !== e.length ? -1 : s;
}
function c5(e, n) {
  var s = n.inputCoverage.length + n.lookaheadCoverage.length + n.backtrackCoverage.length;
  if (e.context.length < s)
    return [];
  var i = eE(
    n.inputCoverage,
    e
  );
  if (i === -1)
    return [];
  var r = n.inputCoverage.length - 1;
  if (e.lookahead.length < n.lookaheadCoverage.length)
    return [];
  for (var o = e.lookahead.slice(r); o.length && $o(o[0].char); )
    o.shift();
  var a = new lr(o, 0), c = eE(
    n.lookaheadCoverage,
    a
  ), l = [].concat(e.backtrack);
  for (l.reverse(); l.length && $o(l[0].char); )
    l.shift();
  if (l.length < n.backtrackCoverage.length)
    return [];
  var h = new lr(l, 0), d = eE(
    n.backtrackCoverage,
    h
  ), p = i.length === n.inputCoverage.length && c.length === n.lookaheadCoverage.length && d.length === n.backtrackCoverage.length, E = [];
  if (p)
    for (var g = 0; g < n.lookupRecords.length; g++)
      for (var T = n.lookupRecords[g], A = T.lookupListIndex, m = this.getLookupByIndex(A), O = 0; O < m.subtables.length; O++) {
        var S = m.subtables[O], y = this.getLookupMethod(m, S), v = this.getSubstitutionType(m, S);
        if (v === "12")
          for (var R = 0; R < i.length; R++) {
            var M = e.get(R), L = y(M);
            L && E.push(L);
          }
      }
  return E;
}
function l5(e, n) {
  var s = e.current, i = Nh(s, n.coverage);
  if (i === -1)
    return null;
  for (var r, o = n.ligatureSets[i], a = 0; a < o.length; a++) {
    r = o[a];
    for (var c = 0; c < r.components.length; c++) {
      var l = e.lookahead[c], h = r.components[c];
      if (l !== h)
        break;
      if (c === r.components.length - 1)
        return r;
    }
  }
  return null;
}
function h5(e, n) {
  var s = Nh(e, n.coverage);
  return s === -1 ? null : n.sequences[s];
}
yi.prototype.getDefaultScriptFeaturesIndexes = function() {
  for (var e = this.font.tables.gsub.scripts, n = 0; n < e.length; n++) {
    var s = e[n];
    if (s.tag === "DFLT")
      return s.script.defaultLangSys.featureIndexes;
  }
  return [];
};
yi.prototype.getScriptFeaturesIndexes = function(e) {
  var n = this.font.tables;
  if (!n.gsub)
    return [];
  if (!e)
    return this.getDefaultScriptFeaturesIndexes();
  for (var s = this.font.tables.gsub.scripts, i = 0; i < s.length; i++) {
    var r = s[i];
    if (r.tag === e && r.script.defaultLangSys)
      return r.script.defaultLangSys.featureIndexes;
    var o = r.langSysRecords;
    if (o)
      for (var a = 0; a < o.length; a++) {
        var c = o[a];
        if (c.tag === e) {
          var l = c.langSys;
          return l.featureIndexes;
        }
      }
  }
  return this.getDefaultScriptFeaturesIndexes();
};
yi.prototype.mapTagsToFeatures = function(e, n) {
  for (var s = {}, i = 0; i < e.length; i++) {
    var r = e[i].tag, o = e[i].feature;
    s[r] = o;
  }
  this.features[n].tags = s;
};
yi.prototype.getScriptFeatures = function(e) {
  var n = this.features[e];
  if (this.features.hasOwnProperty(e))
    return n;
  var s = this.getScriptFeaturesIndexes(e);
  if (!s)
    return null;
  var i = this.font.tables.gsub;
  return n = s.map(function(r) {
    return i.features[r];
  }), this.features[e] = n, this.mapTagsToFeatures(n, e), n;
};
yi.prototype.getSubstitutionType = function(e, n) {
  var s = e.lookupType.toString(), i = n.substFormat.toString();
  return s + i;
};
yi.prototype.getLookupMethod = function(e, n) {
  var s = this, i = this.getSubstitutionType(e, n);
  switch (i) {
    case "11":
      return function(r) {
        return o5.apply(
          s,
          [r, n]
        );
      };
    case "12":
      return function(r) {
        return a5.apply(
          s,
          [r, n]
        );
      };
    case "63":
      return function(r) {
        return c5.apply(
          s,
          [r, n]
        );
      };
    case "41":
      return function(r) {
        return l5.apply(
          s,
          [r, n]
        );
      };
    case "21":
      return function(r) {
        return h5.apply(
          s,
          [r, n]
        );
      };
    default:
      throw new Error(
        "lookupType: " + e.lookupType + " - substFormat: " + n.substFormat + " is not yet supported"
      );
  }
};
yi.prototype.lookupFeature = function(e) {
  var n = e.contextParams, s = n.index, i = this.getFeature({
    tag: e.tag,
    script: e.script
  });
  if (!i)
    return new Error(
      "font '" + this.font.names.fullName.en + "' doesn't support feature '" + e.tag + "' for script '" + e.script + "'."
    );
  for (var r = this.getFeatureLookups(i), o = [].concat(n.context), a = 0; a < r.length; a++)
    for (var c = r[a], l = this.getLookupSubtables(c), h = 0; h < l.length; h++) {
      var d = l[h], p = this.getSubstitutionType(c, d), E = this.getLookupMethod(c, d), g = void 0;
      switch (p) {
        case "11":
          g = E(n.current), g && o.splice(s, 1, new ya({
            id: 11,
            tag: e.tag,
            substitution: g
          }));
          break;
        case "12":
          g = E(n.current), g && o.splice(s, 1, new ya({
            id: 12,
            tag: e.tag,
            substitution: g
          }));
          break;
        case "63":
          g = E(n), Array.isArray(g) && g.length && o.splice(s, 1, new ya({
            id: 63,
            tag: e.tag,
            substitution: g
          }));
          break;
        case "41":
          g = E(n), g && o.splice(s, 1, new ya({
            id: 41,
            tag: e.tag,
            substitution: g
          }));
          break;
        case "21":
          g = E(n.current), g && o.splice(s, 1, new ya({
            id: 21,
            tag: e.tag,
            substitution: g
          }));
          break;
      }
      n = new lr(o, s), !(Array.isArray(g) && !g.length) && (g = null);
    }
  return o.length ? o : null;
};
yi.prototype.supports = function(e) {
  if (!e.script)
    return !1;
  this.getScriptFeatures(e.script);
  var n = this.features.hasOwnProperty(e.script);
  if (!e.tag)
    return n;
  var s = this.features[e.script].some(function(i) {
    return i.tag === e.tag;
  });
  return n && s;
};
yi.prototype.getLookupSubtables = function(e) {
  return e.subtables || null;
};
yi.prototype.getLookupByIndex = function(e) {
  var n = this.font.tables.gsub.lookups;
  return n[e] || null;
};
yi.prototype.getFeatureLookups = function(e) {
  return e.lookupListIndexes.map(this.getLookupByIndex.bind(this));
};
yi.prototype.getFeature = function(n) {
  if (!this.font)
    return { FAIL: "No font was found" };
  this.features.hasOwnProperty(n.script) || this.getScriptFeatures(n.script);
  var s = this.features[n.script];
  return s ? s.tags[n.tag] ? this.features[n.script].tags[n.tag] : null : { FAIL: "No feature for script " + n.script };
};
function u5(e) {
  var n = e.current, s = e.get(-1);
  return (
    // ? arabic first char
    s === null && Ko(n) || // ? arabic char preceded with a non arabic char
    !Ko(s) && Ko(n)
  );
}
function d5(e) {
  var n = e.get(1);
  return (
    // ? last arabic char
    n === null || // ? next char is not arabic
    !Ko(n)
  );
}
var f5 = {
  startCheck: u5,
  endCheck: d5
};
function p5(e) {
  var n = e.current, s = e.get(-1);
  return (
    // ? an arabic char preceded with a non arabic char
    (Ko(n) || $o(n)) && !Ko(s)
  );
}
function E5(e) {
  var n = e.get(1);
  switch (!0) {
    case n === null:
      return !0;
    case (!Ko(n) && !$o(n)):
      var s = r5(n);
      if (!s)
        return !0;
      if (s) {
        var i = !1;
        if (i = e.lookahead.some(
          function(r) {
            return Ko(r) || $o(r);
          }
        ), !i)
          return !0;
      }
      break;
    default:
      return !1;
  }
}
var g5 = {
  startCheck: p5,
  endCheck: E5
};
function _5(e, n, s) {
  n[s].setState(e.tag, e.substitution);
}
function T5(e, n, s) {
  n[s].setState(e.tag, e.substitution);
}
function A5(e, n, s) {
  e.substitution.forEach(function(i, r) {
    var o = n[s + r];
    o.setState(e.tag, i);
  });
}
function m5(e, n, s) {
  var i = n[s];
  i.setState(e.tag, e.substitution.ligGlyph);
  for (var r = e.substitution.components.length, o = 0; o < r; o++)
    i = n[s + o + 1], i.setState("deleted", !0);
}
var AI = {
  11: _5,
  12: T5,
  63: A5,
  41: m5
};
function d0(e, n, s) {
  e instanceof ya && AI[e.id] && AI[e.id](e, n, s);
}
function O5(e) {
  for (var n = [].concat(e.backtrack), s = n.length - 1; s >= 0; s--) {
    var i = n[s], r = Ny(i), o = $o(i);
    if (!r && !o)
      return !0;
    if (r)
      return !1;
  }
  return !1;
}
function I5(e) {
  if (Ny(e.current))
    return !1;
  for (var n = 0; n < e.lookahead.length; n++) {
    var s = e.lookahead[n], i = $o(s);
    if (!i)
      return !0;
  }
  return !1;
}
function S5(e) {
  var n = this, s = "arab", i = this.featuresTags[s], r = this.tokenizer.getRangeTokens(e);
  if (r.length !== 1) {
    var o = new lr(
      r.map(
        function(c) {
          return c.getState("glyphIndex");
        }
      ),
      0
    ), a = new lr(
      r.map(
        function(c) {
          return c.char;
        }
      ),
      0
    );
    r.forEach(function(c, l) {
      if (!$o(c.char)) {
        o.setCurrentIndex(l), a.setCurrentIndex(l);
        var h = 0;
        O5(a) && (h |= 1), I5(a) && (h |= 2);
        var d;
        switch (h) {
          case 1:
            d = "fina";
            break;
          case 2:
            d = "init";
            break;
          case 3:
            d = "medi";
            break;
        }
        if (i.indexOf(d) !== -1) {
          var p = n.query.lookupFeature({
            tag: d,
            script: s,
            contextParams: o
          });
          if (p instanceof Error)
            return console.info(p.message);
          p.forEach(function(E, g) {
            E instanceof ya && (d0(E, r, g), o.context[g] = E.substitution);
          });
        }
      }
    });
  }
}
function mI(e, n) {
  var s = e.map(function(i) {
    return i.activeState.value;
  });
  return new lr(s, 0);
}
function y5(e) {
  var n = this, s = "arab", i = this.tokenizer.getRangeTokens(e), r = mI(i);
  r.context.forEach(function(o, a) {
    r.setCurrentIndex(a);
    var c = n.query.lookupFeature({
      tag: "rlig",
      script: s,
      contextParams: r
    });
    c.length && (c.forEach(
      function(l) {
        return d0(l, i, a);
      }
    ), r = mI(i));
  });
}
function C5(e) {
  var n = e.current, s = e.get(-1);
  return (
    // ? latin first char
    s === null && Zu(n) || // ? latin char preceded with a non latin char
    !Zu(s) && Zu(n)
  );
}
function N5(e) {
  var n = e.get(1);
  return (
    // ? last latin char
    n === null || // ? next char is not latin
    !Zu(n)
  );
}
var x5 = {
  startCheck: C5,
  endCheck: N5
};
function OI(e, n) {
  var s = e.map(function(i) {
    return i.activeState.value;
  });
  return new lr(s, 0);
}
function v5(e) {
  var n = this, s = "latn", i = this.tokenizer.getRangeTokens(e), r = OI(i);
  r.context.forEach(function(o, a) {
    r.setCurrentIndex(a);
    var c = n.query.lookupFeature({
      tag: "liga",
      script: s,
      contextParams: r
    });
    c.length && (c.forEach(
      function(l) {
        return d0(l, i, a);
      }
    ), r = OI(i));
  });
}
function dr(e) {
  this.baseDir = e || "ltr", this.tokenizer = new Mn(), this.featuresTags = {};
}
dr.prototype.setText = function(e) {
  this.text = e;
};
dr.prototype.contextChecks = {
  latinWordCheck: x5,
  arabicWordCheck: f5,
  arabicSentenceCheck: g5
};
function tE(e) {
  var n = this.contextChecks[e + "Check"];
  return this.tokenizer.registerContextChecker(
    e,
    n.startCheck,
    n.endCheck
  );
}
function R5() {
  return tE.call(this, "latinWord"), tE.call(this, "arabicWord"), tE.call(this, "arabicSentence"), this.tokenizer.tokenize(this.text);
}
function w5() {
  var e = this, n = this.tokenizer.getContextRanges("arabicSentence");
  n.forEach(function(s) {
    var i = e.tokenizer.getRangeTokens(s);
    e.tokenizer.replaceRange(
      s.startIndex,
      s.endOffset,
      i.reverse()
    );
  });
}
dr.prototype.registerFeatures = function(e, n) {
  var s = this, i = n.filter(
    function(r) {
      return s.query.supports({ script: e, tag: r });
    }
  );
  this.featuresTags.hasOwnProperty(e) ? this.featuresTags[e] = this.featuresTags[e].concat(i) : this.featuresTags[e] = i;
};
dr.prototype.applyFeatures = function(e, n) {
  if (!e)
    throw new Error(
      "No valid font was provided to apply features"
    );
  this.query || (this.query = new yi(e));
  for (var s = 0; s < n.length; s++) {
    var i = n[s];
    this.query.supports({ script: i.script }) && this.registerFeatures(i.script, i.tags);
  }
};
dr.prototype.registerModifier = function(e, n, s) {
  this.tokenizer.registerModifier(e, n, s);
};
function f0() {
  if (this.tokenizer.registeredModifiers.indexOf("glyphIndex") === -1)
    throw new Error(
      "glyphIndex modifier is required to apply arabic presentation features."
    );
}
function D5() {
  var e = this, n = "arab";
  if (this.featuresTags.hasOwnProperty(n)) {
    f0.call(this);
    var s = this.tokenizer.getContextRanges("arabicWord");
    s.forEach(function(i) {
      S5.call(e, i);
    });
  }
}
function L5() {
  var e = this, n = "arab";
  if (this.featuresTags.hasOwnProperty(n)) {
    var s = this.featuresTags[n];
    if (s.indexOf("rlig") !== -1) {
      f0.call(this);
      var i = this.tokenizer.getContextRanges("arabicWord");
      i.forEach(function(r) {
        y5.call(e, r);
      });
    }
  }
}
function M5() {
  var e = this, n = "latn";
  if (this.featuresTags.hasOwnProperty(n)) {
    var s = this.featuresTags[n];
    if (s.indexOf("liga") !== -1) {
      f0.call(this);
      var i = this.tokenizer.getContextRanges("latinWord");
      i.forEach(function(r) {
        v5.call(e, r);
      });
    }
  }
}
dr.prototype.checkContextReady = function(e) {
  return !!this.tokenizer.getContext(e);
};
dr.prototype.applyFeaturesToContexts = function() {
  this.checkContextReady("arabicWord") && (D5.call(this), L5.call(this)), this.checkContextReady("latinWord") && M5.call(this), this.checkContextReady("arabicSentence") && w5.call(this);
};
dr.prototype.processText = function(e) {
  (!this.text || this.text !== e) && (this.setText(e), R5.call(this), this.applyFeaturesToContexts());
};
dr.prototype.getBidiText = function(e) {
  return this.processText(e), this.tokenizer.getText();
};
dr.prototype.getTextGlyphs = function(e) {
  this.processText(e);
  for (var n = [], s = 0; s < this.tokenizer.tokens.length; s++) {
    var i = this.tokenizer.tokens[s];
    if (!i.state.deleted) {
      var r = i.activeState.value;
      n.push(Array.isArray(r) ? r[0] : r);
    }
  }
  return n;
};
function hn(e) {
  e = e || {}, e.tables = e.tables || {}, e.empty || (gl(e.familyName, "When creating a new Font object, familyName is required."), gl(e.styleName, "When creating a new Font object, styleName is required."), gl(e.unitsPerEm, "When creating a new Font object, unitsPerEm is required."), gl(e.ascender, "When creating a new Font object, ascender is required."), gl(e.descender <= 0, "When creating a new Font object, negative descender value is required."), this.names = {
    fontFamily: { en: e.familyName || " " },
    fontSubfamily: { en: e.styleName || " " },
    fullName: { en: e.fullName || e.familyName + " " + e.styleName },
    // postScriptName may not contain any whitespace
    postScriptName: { en: e.postScriptName || (e.familyName + e.styleName).replace(/\s/g, "") },
    designer: { en: e.designer || " " },
    designerURL: { en: e.designerURL || " " },
    manufacturer: { en: e.manufacturer || " " },
    manufacturerURL: { en: e.manufacturerURL || " " },
    license: { en: e.license || " " },
    licenseURL: { en: e.licenseURL || " " },
    version: { en: e.version || "Version 0.1" },
    description: { en: e.description || " " },
    copyright: { en: e.copyright || " " },
    trademark: { en: e.trademark || " " }
  }, this.unitsPerEm = e.unitsPerEm || 1e3, this.ascender = e.ascender, this.descender = e.descender, this.createdTimestamp = e.createdTimestamp, this.tables = Object.assign(e.tables, {
    os2: Object.assign({
      usWeightClass: e.weightClass || this.usWeightClasses.MEDIUM,
      usWidthClass: e.widthClass || this.usWidthClasses.MEDIUM,
      fsSelection: e.fsSelection || this.fsSelectionValues.REGULAR
    }, e.tables.os2)
  })), this.supported = !0, this.glyphs = new Cr.GlyphSet(this, e.glyphs || []), this.encoding = new sy(this), this.position = new Sh(this), this.substitution = new Si(this), this.tables = this.tables || {}, this._push = null, this._hmtxTableData = {}, Object.defineProperty(this, "hinting", {
    get: function() {
      if (this._hinting)
        return this._hinting;
      if (this.outlinesFormat === "truetype")
        return this._hinting = new Iy(this);
    }
  });
}
hn.prototype.hasChar = function(e) {
  return this.encoding.charToGlyphIndex(e) !== null;
};
hn.prototype.charToGlyphIndex = function(e) {
  return this.encoding.charToGlyphIndex(e);
};
hn.prototype.charToGlyph = function(e) {
  var n = this.charToGlyphIndex(e), s = this.glyphs.get(n);
  return s || (s = this.glyphs.get(0)), s;
};
hn.prototype.updateFeatures = function(e) {
  return this.defaultRenderOptions.features.map(function(n) {
    return n.script === "latn" ? {
      script: "latn",
      tags: n.tags.filter(function(s) {
        return e[s];
      })
    } : n;
  });
};
hn.prototype.stringToGlyphs = function(e, n) {
  var s = this, i = new dr(), r = function(p) {
    return s.charToGlyphIndex(p.char);
  };
  i.registerModifier("glyphIndex", null, r);
  var o = n ? this.updateFeatures(n.features) : this.defaultRenderOptions.features;
  i.applyFeatures(this, o);
  for (var a = i.getTextGlyphs(e), c = a.length, l = new Array(c), h = this.glyphs.get(0), d = 0; d < c; d += 1)
    l[d] = this.glyphs.get(a[d]) || h;
  return l;
};
hn.prototype.nameToGlyphIndex = function(e) {
  return this.glyphNames.nameToGlyphIndex(e);
};
hn.prototype.nameToGlyph = function(e) {
  var n = this.nameToGlyphIndex(e), s = this.glyphs.get(n);
  return s || (s = this.glyphs.get(0)), s;
};
hn.prototype.glyphIndexToName = function(e) {
  return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(e) : "";
};
hn.prototype.getKerningValue = function(e, n) {
  e = e.index || e, n = n.index || n;
  var s = this.position.defaultKerningTables;
  return s ? this.position.getKerningValue(s, e, n) : this.kerningPairs[e + "," + n] || 0;
};
hn.prototype.defaultRenderOptions = {
  kerning: !0,
  features: [
    /**
     * these 4 features are required to render Arabic text properly
     * and shouldn't be turned off when rendering arabic text.
     */
    { script: "arab", tags: ["init", "medi", "fina", "rlig"] },
    { script: "latn", tags: ["liga", "rlig"] }
  ]
};
hn.prototype.forEachGlyph = function(e, n, s, i, r, o) {
  n = n !== void 0 ? n : 0, s = s !== void 0 ? s : 0, i = i !== void 0 ? i : 72, r = Object.assign({}, this.defaultRenderOptions, r);
  var a = 1 / this.unitsPerEm * i, c = this.stringToGlyphs(e, r), l;
  if (r.kerning) {
    var h = r.script || this.position.getDefaultScriptName();
    l = this.position.getKerningTables(h, r.language);
  }
  for (var d = 0; d < c.length; d += 1) {
    var p = c[d];
    if (o.call(this, p, n, s, i, r), p.advanceWidth && (n += p.advanceWidth * a), r.kerning && d < c.length - 1) {
      var E = l ? this.position.getKerningValue(l, p.index, c[d + 1].index) : this.getKerningValue(p, c[d + 1]);
      n += E * a;
    }
    r.letterSpacing ? n += r.letterSpacing * i : r.tracking && (n += r.tracking / 1e3 * i);
  }
  return n;
};
hn.prototype.getPath = function(e, n, s, i, r) {
  var o = new jn();
  return this.forEachGlyph(e, n, s, i, r, function(a, c, l, h) {
    var d = a.getPath(c, l, h, r, this);
    o.extend(d);
  }), o;
};
hn.prototype.getPaths = function(e, n, s, i, r) {
  var o = [];
  return this.forEachGlyph(e, n, s, i, r, function(a, c, l, h) {
    var d = a.getPath(c, l, h, r, this);
    o.push(d);
  }), o;
};
hn.prototype.getAdvanceWidth = function(e, n, s) {
  return this.forEachGlyph(e, 0, 0, n, s, function() {
  });
};
hn.prototype.draw = function(e, n, s, i, r, o) {
  this.getPath(n, s, i, r, o).draw(e);
};
hn.prototype.drawPoints = function(e, n, s, i, r, o) {
  this.forEachGlyph(n, s, i, r, o, function(a, c, l, h) {
    a.drawPoints(e, c, l, h);
  });
};
hn.prototype.drawMetrics = function(e, n, s, i, r, o) {
  this.forEachGlyph(n, s, i, r, o, function(a, c, l, h) {
    a.drawMetrics(e, c, l, h);
  });
};
hn.prototype.getEnglishName = function(e) {
  var n = this.names[e];
  if (n)
    return n.en;
};
hn.prototype.validate = function() {
  var e = this;
  function n(i, r) {
  }
  function s(i) {
    var r = e.getEnglishName(i);
    r && r.trim().length > 0;
  }
  s("fontFamily"), s("weightName"), s("manufacturer"), s("copyright"), s("version"), this.unitsPerEm > 0;
};
hn.prototype.toTables = function() {
  return AG.fontToTable(this);
};
hn.prototype.toBuffer = function() {
  return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."), this.toArrayBuffer();
};
hn.prototype.toArrayBuffer = function() {
  for (var e = this.toTables(), n = e.encode(), s = new ArrayBuffer(n.length), i = new Uint8Array(s), r = 0; r < n.length; r++)
    i[r] = n[r];
  return s;
};
hn.prototype.download = function(e) {
  var n = this.getEnglishName("fontFamily"), s = this.getEnglishName("fontSubfamily");
  e = e || n.replace(/\s/g, "") + "-" + s + ".otf";
  var i = this.toArrayBuffer();
  if (OG())
    if (window.URL = window.URL || window.webkitURL, window.URL) {
      var r = new DataView(i), o = new Blob([r], { type: "font/opentype" }), a = document.createElement("a");
      a.href = window.URL.createObjectURL(o), a.download = e;
      var c = document.createEvent("MouseEvents");
      c.initEvent("click", !0, !1), a.dispatchEvent(c);
    } else
      console.warn("Font file could not be downloaded. Try using a different browser.");
  else {
    var l = require("fs"), h = IG(i);
    l.writeFileSync(e, h);
  }
};
hn.prototype.fsSelectionValues = {
  ITALIC: 1,
  //1
  UNDERSCORE: 2,
  //2
  NEGATIVE: 4,
  //4
  OUTLINED: 8,
  //8
  STRIKEOUT: 16,
  //16
  BOLD: 32,
  //32
  REGULAR: 64,
  //64
  USER_TYPO_METRICS: 128,
  //128
  WWS: 256,
  //256
  OBLIQUE: 512
  //512
};
hn.prototype.usWidthClasses = {
  ULTRA_CONDENSED: 1,
  EXTRA_CONDENSED: 2,
  CONDENSED: 3,
  SEMI_CONDENSED: 4,
  MEDIUM: 5,
  SEMI_EXPANDED: 6,
  EXPANDED: 7,
  EXTRA_EXPANDED: 8,
  ULTRA_EXPANDED: 9
};
hn.prototype.usWeightClasses = {
  THIN: 100,
  EXTRA_LIGHT: 200,
  LIGHT: 300,
  NORMAL: 400,
  MEDIUM: 500,
  SEMI_BOLD: 600,
  BOLD: 700,
  EXTRA_BOLD: 800,
  BLACK: 900
};
var lo = new Array(10);
lo[1] = function() {
  var n = this.offset + this.relativeOffset, s = this.parseUShort();
  if (s === 1)
    return {
      posFormat: 1,
      coverage: this.parsePointer($.coverage),
      value: this.parseValueRecord()
    };
  if (s === 2)
    return {
      posFormat: 2,
      coverage: this.parsePointer($.coverage),
      values: this.parseValueRecordList()
    };
  lt.assert(!1, "0x" + n.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.");
};
lo[2] = function() {
  var n = this.offset + this.relativeOffset, s = this.parseUShort();
  lt.assert(s === 1 || s === 2, "0x" + n.toString(16) + ": GPOS lookup type 2 format must be 1 or 2.");
  var i = this.parsePointer($.coverage), r = this.parseUShort(), o = this.parseUShort();
  if (s === 1)
    return {
      posFormat: s,
      coverage: i,
      valueFormat1: r,
      valueFormat2: o,
      pairSets: this.parseList($.pointer($.list(function() {
        return {
          // pairValueRecord
          secondGlyph: this.parseUShort(),
          value1: this.parseValueRecord(r),
          value2: this.parseValueRecord(o)
        };
      })))
    };
  if (s === 2) {
    var a = this.parsePointer($.classDef), c = this.parsePointer($.classDef), l = this.parseUShort(), h = this.parseUShort();
    return {
      // Class Pair Adjustment
      posFormat: s,
      coverage: i,
      valueFormat1: r,
      valueFormat2: o,
      classDef1: a,
      classDef2: c,
      class1Count: l,
      class2Count: h,
      classRecords: this.parseList(l, $.list(h, function() {
        return {
          value1: this.parseValueRecord(r),
          value2: this.parseValueRecord(o)
        };
      }))
    };
  }
};
lo[3] = function() {
  return { error: "GPOS Lookup 3 not supported" };
};
lo[4] = function() {
  return { error: "GPOS Lookup 4 not supported" };
};
lo[5] = function() {
  return { error: "GPOS Lookup 5 not supported" };
};
lo[6] = function() {
  return { error: "GPOS Lookup 6 not supported" };
};
lo[7] = function() {
  return { error: "GPOS Lookup 7 not supported" };
};
lo[8] = function() {
  return { error: "GPOS Lookup 8 not supported" };
};
lo[9] = function() {
  return { error: "GPOS Lookup 9 not supported" };
};
new Array(10);
var II;
(function(e) {
  e.BEFORE = "before", e.AFTER = "after";
})(II || (II = {}));
const xy = /* @__PURE__ */ new Set([
  // keep the translate here to update CS value
  "translate",
  "motionPath",
  "dimensions",
  "rotation",
  "cornerRadius",
  "contentAnchor",
  "scale",
  "skew",
  "opacity",
  "blendMode",
  "blurGaussian",
  "font"
]), P5 = /* @__PURE__ */ new Set([
  "effects"
]), vy = /* @__PURE__ */ new Set(["trimPath"]), b5 = /* @__PURE__ */ new Set([
  "width",
  "growDirection",
  "cap",
  "capSize",
  "join",
  "joinSize",
  "dash",
  "gap",
  "offset",
  "miter",
  "ends"
]), U5 = /* @__PURE__ */ new Set([
  "offsetX",
  "offsetY",
  "blur",
  "spread"
]), is = /* @__PURE__ */ new Map([
  ["ROOT", [...xy.keys(), ...o0, ...P5.keys(), "blurs", ...vy.keys(), "pathMorphing"]],
  ["dimensions", ["width", "height"]],
  ["contentAnchor", ["contentAnchorX", "contentAnchorY"]],
  ["scale", ["scaleX", "scaleY"]],
  ["skew", ["skewX", "skewY"]],
  ["opacity", ["opacity", "blendMode"]],
  ["font", ["fontSize", "lineHeight", "letterSpacing"]],
  [Ln.FILL, []],
  [Ln.STROKE, []],
  [Ln.SHADOW, []],
  [Ln.INNER_SHADOW, []],
  ["LAYER", ["blendMode", "paint", "opacity", ...b5.keys(), ...U5.keys()]],
  ["blurs", ["blurGaussian"]],
  // effects
  ["trimPath", ["trimPath.start", "trimPath.end", "trimPath.offset"]]
]), G5 = new Set(Array.from(xy).flatMap((e) => {
  const n = is.get(e) || [e];
  return [e, ...n];
}));
new Set(Array.from(vy).flatMap(
  (e) => is.get(e) || [e]
));
Array.from(is.entries()).reduce(
  (e, [n, s]) => (s.forEach((i) => {
    e.set(i, n);
  }), e),
  /* @__PURE__ */ new Map()
);
const p0 = [
  { position: 0, color: [0.85, 0.85, 0.85, 1] },
  { position: 1, color: [0.85, 0.85, 0.85, 0] }
], F5 = [
  { position: 0, color: [0, 0, 0, 1] },
  { position: 1, color: [0, 0, 0, 0] }
];
ze.FILL + "", new as([0, 0, 0, 1]), p0.map((e) => new Va(e)), new Ys(0, -1, 1, 0, 0, 1), yr.FILL;
const rf = {
  [ze.FILL]: {
    color: new as([0.85, 0.85, 0.85, 1]),
    // #D8D8D8
    gradientStops: p0.map((e) => new Va(e)),
    gradientTransform: new Ys(0, -1, 1, 0, 0, 1),
    opacity: 1,
    imageId: null,
    imageMode: yr.FILL
  },
  [ze.STROKE]: {
    color: new as([0, 0, 0, 1]),
    // #222222
    gradientStops: F5.map((e) => new Va(e)),
    gradientTransform: new Ys(0, -1, 1, 0, 0, 1),
    opacity: 1
  },
  [ze.SHADOW]: {
    color: new as([0, 0, 0, 1]),
    // #000
    opacity: 0.25
  },
  [ze.INNER_SHADOW]: {
    color: new as([1, 1, 1, 1]),
    // #fff
    opacity: 0.25
  }
};
pe.NONE;
const Ry = {
  ...rf[ze.FILL],
  layerType: ze.FILL,
  paintType: Ie.SOLID,
  blendMode: Ut.NORMAL
}, k5 = {
  ...rf[ze.STROKE],
  layerType: ze.STROKE,
  paintType: Ie.SOLID,
  blendMode: Ut.NORMAL,
  growDirection: Ic.CENTER,
  cap: cn.NONE,
  join: Us.MITER,
  ends: Ba.STRAIGHT
}, B5 = {
  ...rf[ze.SHADOW],
  layerType: ze.SHADOW,
  paintType: Ie.SOLID,
  blendMode: Ut.NORMAL
}, V5 = {
  ...rf[ze.INNER_SHADOW],
  layerType: ze.INNER_SHADOW,
  paintType: Ie.SOLID,
  blendMode: Ut.NORMAL
};
ze.FILL + "", ze.STROKE + "", ze.SHADOW + "", ze.INNER_SHADOW + "";
const wy = {
  start: 0,
  end: 100,
  offset: 0,
  mode: ar.SIMULTANEOUSLY
};
zi.TRIM_PATH + "";
zi.TRIM_PATH + "";
zi.TRIM_PATH;
const H5 = ["color"], W5 = ["gradientTransform", "gradientStops", "activeGradientStopIdx"], Y5 = ["imageId", "imageMode"], qu = {
  solid: H5,
  gradient: W5,
  image: Y5
}, Dy = ["visible", "layerType", "paintType", "blendMode", "opacity"], Ly = [
  ...Dy,
  ...qu.solid,
  ...qu.image,
  ...qu.gradient
], E0 = ["paintState", "opacityState", "blendModeState"], X5 = [
  ...Ly,
  "width",
  "growDirection",
  "offset",
  "dash",
  "gap",
  "cap",
  "capSize",
  "join",
  "joinSize",
  "miter",
  "ends"
], z5 = [
  ...E0,
  "widthState",
  "growDirectionState",
  "offsetState",
  "dashState",
  "gapState",
  "capState",
  "capSizeState",
  "joinState",
  "joinSizeState",
  "miterState",
  "endsState"
], SI = [
  ...Dy,
  ...qu.solid,
  "offsetX",
  "offsetY",
  "blur",
  "spread"
], yI = [
  ...E0,
  "offsetXState",
  "offsetYState",
  "blurState",
  "spreadState"
];
[
  ...Object.keys(wy)
];
ze.FILL + "", ze.STROKE + "", ze.SHADOW + "", ze.INNER_SHADOW + "";
ze.FILL + "", ze.STROKE + "", ze.SHADOW + "", ze.INNER_SHADOW + "";
Ie.GRADIENT_LINEAR, Ie.GRADIENT_RADIAL, Ie.GRADIENT_ANGULAR, Ie.GRADIENT_DIAMOND;
Ie.SOLID + "", Ie.IMAGE + "", Ie.GRADIENT_LINEAR + "", Ie.GRADIENT_RADIAL + "", Ie.GRADIENT_ANGULAR + "", Ie.GRADIENT_DIAMOND + "";
const Ll = [
  ["paintState", "paint"],
  ["opacityState", "opacity"],
  ["blendModeState", "blendMode"]
], vu = Ll.map((e) => [...e].reverse()), My = [
  ["widthState", "width"],
  ["growDirectionState", "growDirection"],
  ["offsetState", "offset"],
  ["dashState", "dash"],
  ["gapState", "gap"],
  ["capState", "cap"],
  ["capSizeState", "capSize"],
  ["joinState", "join"],
  ["joinSizeState", "joinSize"],
  ["miterState", "miter"],
  ["endsState", "ends"]
], K5 = My.map((e) => [...e].reverse()), sg = [
  ["offsetXState", "offsetX"],
  ["offsetYState", "offsetY"],
  ["blurState", "blur"],
  ["spreadState", "spread"]
], CI = sg.map((e) => [...e].reverse());
ze.FILL + "", new Map([
  ...Ll
]), ze.STROKE + "", new Map([
  ...Ll,
  ...My
]), ze.SHADOW + "", new Map([
  ...Ll,
  ...sg
]), ze.INNER_SHADOW + "", new Map([
  ...Ll,
  ...sg
]);
ze.FILL + "", new Map([
  ...vu
]), ze.STROKE + "", new Map([
  ...vu,
  ...K5
]), ze.SHADOW + "", new Map([
  ...vu,
  ...CI
]), ze.INNER_SHADOW + "", new Map([
  ...vu,
  ...CI
]);
const Py = [
  ["startState", "start"],
  ["endState", "end"],
  ["offsetState", "offset"]
], Q5 = Py.map((e) => [...e].reverse());
zi.TRIM_PATH + "", new Map([
  ...Py
]);
zi.TRIM_PATH + "", new Map([
  ...Q5
]);
zi.TRIM_PATH + "";
zi.TRIM_PATH + "";
const Z5 = [
  "effects"
];
Me.SCREEN + "", [...G5.keys(), ...is.get("trimPath")], Me.CONTAINER + "", [...is.get("font")], Me.NORMAL_GROUP + "", [...is.get("dimensions"), ...is.get("font")], Me.BOOLEAN_CONTAINER + "", [...is.get("dimensions"), ...is.get("font")], Me.MASK_CONTAINER + "", [...is.get("dimensions"), ...is.get("trimPath"), ...is.get("font")], Me.TEXT + "", [...is.get("trimPath")], Me.PATH + "", Me.GROUP + "";
mn.RECTANGLE + "", [...is.get("font")], mn.ELLIPSE + "", [...is.get("font")], mn.POLYGON + "", [...is.get("dimensions"), ...is.get("font")], mn.REGULAR_POLYGON + "", mn.STAR + "", mn.LINE + "", [...is.get("font")];
ks.ELEMENT, ks.COMPUTED_STYLE, ks.COMPUTED_LAYER, ks.COMPUTED_EFFECT;
const xh = [
  "translate",
  "dimensions",
  "rotation",
  "opacity",
  "referencePoint",
  "contentAnchor",
  "scale",
  "skew"
], q5 = [
  "blurGaussian"
], of = [
  "cornerRadius"
], by = [
  "overflow"
], Uy = [
  "font",
  "textAlignment",
  "textDecoration",
  "textDirection"
], vh = new Set(o0), Rh = new Set(Z5);
we.TRANSLATE, we.DIMENSIONS, we.ROTATION, we.OPACITY, we.REFERENCE_POINT, we.CONTENT_ANCHOR, we.BLUR_GAUSSIAN, we.SCALE, we.SKEW, we.CORNER_RADIUS, we.OVERFLOW, we.FONT, we.TEXT_ALIGNMENT, we.TEXT_DECORATION, we.TEXT_DIRECTION, Or.FILL, Or.STROKE, Or.SHADOW, Or.INNER_SHADOW, we.EFFECT;
[
  ...xh,
  ...vh,
  ...Rh
];
const j5 = [
  ...xh,
  ...of,
  ...vh,
  ...Rh
], NI = [
  ...xh,
  ...of,
  ...by,
  ...vh,
  ...Rh
], J5 = [
  ...xh,
  ...Uy,
  ...vh,
  ...Rh,
  ...of
];
[
  ...xh,
  ...q5,
  ...of,
  ...by,
  ...Uy,
  ...vh,
  ...Rh
];
Me.TEXT + "", Me.CONTAINER + "", Me.SCREEN + "", Me.PATH + "";
Gs.OTHER;
Ie.SOLID + "", Ie.IMAGE + "", Ie.GRADIENT_LINEAR + "", Ie.GRADIENT_RADIAL + "", Ie.GRADIENT_ANGULAR + "", Ie.GRADIENT_DIAMOND + "";
Wc({
  color: { type: as },
  gradientTransform: { type: Ys },
  gradientStops: { type: Array, itemType: Va }
});
Wc({
  dash: { type: Array },
  gap: { type: Array }
});
Wc({
  color: { type: as }
});
const $5 = { regenId: !1 };
class Cn extends F1 {
  /**
   * @param {DataStore} dataStore
   * @param {Partial<PropertyComponentData>} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, { regenId: i = !1 } = $5) {
    super(n, Rr.PROPERTY), this.dataStore = n;
    const { id: r, name: o, appliedTo: a, componentType: c } = s;
    !i && ee(r) ? (B1(r, gi.PROPERTY_COMPONENT), this.id = r) : this.id = Zr(gi.PROPERTY_COMPONENT), this.type = ks.PROP_COMPONENT, this.componentType = c || "", this.name = ee(o) ? o : "", this.appliedTo = new Map(a);
  }
  /**
   * @param {string} propName
   * @param {any} value
   */
  updateProp(n, s) {
    this.changes.update(n, new nn({
      before: this[n],
      after: s
    })), this[n] = s;
  }
  /**
   * Undo changes
   * @param {Changes} changes
   */
  undo(n) {
    n.forEach(({ before: s }, i) => {
      this[i] = s;
    }), super.undo(n);
  }
  /**
   * Redo changes
   * @param {Changes} changes
   */
  redo(n) {
    n.forEach(({ after: s }, i) => {
      this[i] = s;
    }), super.redo(n);
  }
  /**
   * @param {Partial<PropertyComponentData>} data
   */
  set(n) {
    ee(n.name) && this.updateProp("name", n.name);
  }
  /**
   * Clones this property or applies it to a new element+style+layer if it's shared
   * @param {AppliedRef} [ref]
   * @returns {PropertyComponent}
   */
  clone(n) {
    return this._clone(n);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} ref
   * @returns {PropertyComponent}
   */
  // eslint-disable-next-line no-unused-vars
  _clone(n) {
    const s = new this.constructor(this.dataStore);
    return s.type = this.type, s.componentType = this.componentType, s.name = this.name, s.appliedTo = new Map(this.appliedTo), s;
  }
  /**
   * Create reference key for appliedTo Map
   * @protected
   * @param {AppliedRef} ref
   * @returns {string} refKey
   */
  static createRefKey({ elementId: n, styleId: s, layerId: i }) {
    return `${n},${s}${i ? `,${i}` : ""}`;
  }
  /**
   * Override this in subclasses if subclass has any inner sharable PropertyComponents
   * CALL super.apply() at the top of overriden method
   * @param {AppliedRef} ref
   */
  apply(n) {
    const { elementId: s, styleId: i, layerId: r } = n;
    if (s && i) {
      const o = Cn.createRefKey({ elementId: s, styleId: i, layerId: r });
      this.appliedTo.set(o, { elementId: s, styleId: i, layerId: r });
    }
  }
  /**
   * Override this in subclasses if subclass has any inner sharable PropertyComponents
   * CALL super.cancel() at the top of overriden method
   * @param {AppliedRef} ref
   */
  cancel({ elementId: n, styleId: s, layerId: i } = {}) {
    if (this.isShared && n && s) {
      const r = Cn.createRefKey({ elementId: n, styleId: s, layerId: i });
      this.appliedTo.delete(r);
    }
  }
  /**
   * Serializes property
   * @returns {PropData}
   */
  save() {
    return this._save();
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {PropertyComponentData} data
   */
  _save() {
    const n = {};
    return n.id = this.id, n.type = this.type, n.componentType = this.componentType, n.name = this.name, n.appliedTo = [...this.appliedTo], n;
  }
  /**
   * Forces to serialize property data instead of its refId if shared
   * @returns {PropData}
   */
  forceSave() {
    return { data: this._save() };
  }
  /** @returns {boolean} check is the component is shared one */
  get isShared() {
    return this.appliedTo.size > 0;
  }
  getRef(n) {
    const s = this.dataStore.getById(n.elementId), i = s.getStyleById(n.styleId), r = { element: s, style: i };
    return n.layerId && (r.layer = i.getLayerById(n.layerId)), r;
  }
  /**
   * Propagate changes to other places this property is used in (applied to)
   * @param  {string} propName  name of the property in Style (or in Layer)
   * @param  {object} data      object with changes made to this property
   * @param  {string} refId     id of Style or Layer that started changes
   */
  propagateChanges(n, s, i) {
    if (this.isShared && !s.__id__) {
      s.__id__ = !0;
      for (const r of this.appliedTo.values()) {
        if (r.styleId === i || r.layerId === i)
          continue;
        const { style: o, layer: a } = this.getRef(r);
        a ? a.setProperty(n, s) : o.setProperty(n, s);
      }
    }
  }
  /**
   * Set nested component from data
   * @protected
   * @param {PropertyComponent} component
   * @param {Function} componentClass
   * @param {PropretyComponent | Partial<PropertyComponentData>} data
   * @returns {PropertyComponent}         either `component` (if defined) or `data` if `data` is of `componentClass` type
   */
  _setComponent(n, s, i) {
    return i instanceof s ? i : (n.set(i), n);
  }
  clearChanges() {
    this.changes.clear();
  }
}
const xI = {
  paintType: {
    default: Ie.SOLID
  },
  blendMode: {
    default: Ut.NORMAL
  },
  opacity: {
    default: 1
  },
  color: {
    default: Ry.color,
    implementation: (e) => new as(e)
  },
  gradientStops: {
    default: p0,
    implementation: (e) => e.map((n) => new Va(n))
  },
  gradientTransform: {
    default: [0, -1, 1, 0, 0, 1],
    implementation: (e) => new Ys(e)
  },
  imageId: {
    default: null
  },
  imageMode: {
    default: yr.FILL
  }
};
class eF extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {PaintComponentData} [data]
   * @param {object} [options]
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i), this.componentType = we.PAINT, this._initValues(s), this.activeGradientStopIdx = 0, this.name || (this.name = "paint");
  }
  get initValues() {
    return Object.entries(xI).reduce((n, [s, i]) => (n[s] = i.default, n), {});
  }
  _initValues(n = {}) {
    Object.entries(xI).forEach(([s, i]) => {
      const r = s in n ? n[s] : i.default;
      i.implementation ? this[s] = i.implementation(r) : this[s] = r;
    });
  }
  /** @param {Partial<PaintComponentData>} data */
  set(n) {
    super.set(n), n.paintType in Ie && this.updateProp("paintType", n.paintType), n.blendMode in Ut && this.updateProp("blendMode", n.blendMode), ee(n.opacity) && this.updateProp("opacity", n.opacity);
    const s = n.paintType || this.paintType;
    if (s === Ie.SOLID)
      ee(n.color) && this.updateProp("color", new as(n.color));
    else if (s === Ie.IMAGE)
      ee(n.imageId) && this.updateProp("imageId", n.imageId), n.imageMode in yr && this.updateProp("imageMode", n.imageMode);
    else {
      if (ee(n.gradientTransform)) {
        const i = new Ys(n.gradientTransform);
        this.updateProp("gradientTransform", i);
      }
      if (ee(n.gradientStops)) {
        const i = n.gradientStops.map((r) => new Va(r));
        this.updateProp("gradientStops", i);
      }
      ee(n.activeGradientStopIdx) && this.updateProp("activeGradientStopIdx", n.activeGradientStopIdx);
    }
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {PaintComponent} obj
   */
  _clone(n) {
    const s = super._clone(n);
    return s.paintType = this.paintType, s.blendMode = this.blendMode, s.opacity = this.opacity, s.color = new as(this.color), s.gradientTransform = new Ys(this.gradientTransform), s.gradientStops = this.gradientStops.map((i) => new Va(i)), s.imageId = this.imageId, s.imageMode = this.imageMode, s;
  }
  /*
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {PaintComponentData} data
   */
  _save() {
    const n = super._save();
    return n.paintType = this.paintType, n.blendMode = this.blendMode, n.opacity = this.opacity, this.paintType === Ie.SOLID ? n.color = [...this.color] : this.paintType === Ie.IMAGE ? (n.imageId = this.imageId, n.imageMode = this.imageMode) : (n.gradientTransform = [...this.gradientTransform], n.gradientStops = this.gradientStops.map((s) => s.save())), n;
  }
  /**
   * Override this in subclasses if subclass has any inner sharable PropertyComponents
   * CALL super.apply() at the top of overriden method
   * @param {AppliedRef} ref
   */
  apply(n) {
    super.apply(n);
  }
  /**
   * Override this in subclasses if subclass has any inner sharable PropertyComponents
   * CALL super.cancel() at the top of overriden method
   * @param {AppliedRef} ref
   */
  cancel(n) {
    super.cancel(n);
  }
}
class tF extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {BlurGaussianComponentData} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const { amount: r, visible: o } = s;
    this.componentType = we.BLUR_GAUSSIAN, this.visible = ee(o) ? o : !0, this.amount = ee(r) ? r : 10, this.name || (this.name = "blurGaussian");
  }
  /** @param {Partial<BlurGaussianComponentData>} data */
  set(n) {
    super.set(n), ee(n.amount) && this.updateProp("amount", n.amount), ee(n.visible) && this.updateProp("visible", n.visible);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {BlurGaussianComponent}
   */
  _clone(n) {
    const s = super._clone(n);
    return s.amount = this.amount, s.visible = this.visible, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {BlurGaussianComponentData}
   */
  _save() {
    const n = super._save();
    return n.amount = this.amount, n.visible = this.visible, n;
  }
}
class Gy extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {DimensionsComponentData} [data]
   * @param {object} [options]
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const {
      width: r,
      widthUnit: o,
      height: a,
      heightUnit: c
    } = s;
    this.componentType = we.DIMENSIONS, this.width = be(r) ? r : 0, this.widthUnit = o || Jt.PIXEL, this.height = be(a) ? a : 0, this.heightUnit = c || Jt.PIXEL, this.name || (this.name = "dimensions");
  }
  /**
   * @param {Partial<DimensionsComponentSetData>} data
   */
  set(n) {
    super.set(n), be(n.width) ? this.updateProp("width", n.width) : n.width === null && this.updateProp("width", void 0), be(n.height) ? this.updateProp("height", n.height) : n.height === null && this.updateProp("height", void 0), n.widthUnit in Jt && ee(this.width) && this.updateProp("widthUnit", n.widthUnit), n.heightUnit in Jt && ee(this.height) && this.updateProp("heightUnit", n.heightUnit);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {DimensionsComponent} obj
   */
  _clone(n) {
    const s = super._clone(n);
    return s.width = this.width, s.widthUnit = this.widthUnit, s.height = this.height, s.heightUnit = this.heightUnit, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {DimensionsComponentData}
   */
  _save() {
    const n = super._save();
    return ee(this.width) && (n.width = this.width, n.widthUnit = this.widthUnit), ee(this.height) && (n.height = this.height, n.heightUnit = this.heightUnit), n;
  }
}
Gy.BASE_DEFAULT_DATA = {
  width: 0,
  widthUnit: Jt.PIXEL,
  height: 0,
  heightUnit: Jt.PIXEL
};
class Fy extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {FontSetComponentData} [data]
   * @param {object} [options]
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const {
      fontFamily: r,
      fontStyle: o,
      fontWeight: a,
      fontSize: c,
      fontSizeUnit: l,
      letterSpacing: h,
      wordSpacing: d,
      lineHeight: p,
      paragraphSpacing: E,
      paragraphIndent: g
    } = s;
    this.componentType = we.FONT, this.fontFamily = rr(r) ? r : "Inter", this.fontStyle = rr(o) ? o : "Regular", this.fontWeight = be(a) ? a : 400, this.fontSize = be(c) ? c : 12, this.fontSizeUnit = rr(l) ? l : Oc.PIXEL, this.letterSpacing = be(h) ? h : 0, this.wordSpacing = be(d) ? d : 0, this.lineHeight = be(p) ? p : 1.2, this.paragraphSpacing = be(E) ? E : 0, this.paragraphIndent = be(g) ? g : 0, this.name || (this.name = "font");
  }
  /** @param {Partial<FontSetComponentSetData>} data */
  set(n) {
    super.set(n);
    const {
      fontFamily: s,
      fontStyle: i,
      fontWeight: r,
      fontSize: o,
      fontSizeUnit: a,
      letterSpacing: c,
      wordSpacing: l,
      lineHeight: h,
      paragraphSpacing: d,
      paragraphIndent: p
    } = n;
    rr(s) ? this.updateProp("fontFamily", s) : s === null && this.updateProp("fontFamily", void 0), rr(i) ? this.updateProp("fontStyle", i) : i === null && this.updateProp("fontStyle", void 0), be(r) ? this.updateProp("fontWeight", r) : r === null && this.updateProp("fontWeight", void 0), be(o) ? this.updateProp("fontSize", o) : o === null && (this.updateProp("fontSize", void 0), this.updateProp("fontSizeUnit", "px")), a in Oc && be(this.fontSize) && this.updateProp("fontSizeUnit", a), be(c) ? this.updateProp("letterSpacing", c) : c === null && this.updateProp("letterSpacing", void 0), be(l) ? this.updateProp("wordSpacing", l) : l === null && this.updateProp("wordSpacing", void 0), be(h) ? this.updateProp("lineHeight", h) : h === null && this.updateProp("lineHeight", void 0), be(d) ? this.updateProp("paragraphSpacing", d) : d === null && this.updateProp("paragraphSpacing", void 0), be(p) ? this.updateProp("paragraphIndent", p) : p === null && this.updateProp("paragraphIndent", void 0);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {FontSetComponent} obj
   */
  _clone(n) {
    const s = super._clone(n);
    return s.fontFamily = this.fontFamily, s.fontStyle = this.fontStyle, s.fontWeight = this.fontWeight, s.fontSize = this.fontSize, s.fontSizeUnit = this.fontSizeUnit, s.letterSpacing = this.letterSpacing, s.wordSpacing = this.wordSpacing, s.lineHeight = this.lineHeight, s.paragraphSpacing = this.paragraphSpacing, s.paragraphIndent = this.paragraphIndent, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {FontSetComponentData} data
   */
  _save() {
    const n = super._save();
    return rr(this.fontFamily) && (n.fontFamily = this.fontFamily), rr(this.fontStyle) && (n.fontStyle = this.fontStyle), be(this.fontSize) && (n.fontSize = this.fontSize), be(this.fontWeight) && (n.fontWeight = this.fontWeight), this.fontSizeUnit in Oc && (n.fontSizeUnit = this.fontSizeUnit), ee(this.letterSpacing) && (n.letterSpacing = this.letterSpacing), ee(this.wordSpacing) && (n.wordSpacing = this.wordSpacing), ee(this.lineHeight) && (n.lineHeight = this.lineHeight), ee(this.paragraphSpacing) && (n.paragraphSpacing = this.paragraphSpacing), ee(this.paragraphIndent) && (n.paragraphIndent = this.paragraphIndent), n;
  }
}
Fy.BASE_DEFAULT_DATA = {
  fontFamily: "Inter",
  fontStyle: "Regular",
  fontSize: 12,
  fontWeight: 400,
  fontSizeUnit: Oc.PIXEL,
  letterSpacing: 0,
  wordSpacing: 0,
  lineHeight: 1.2,
  paragraphSpacing: 0,
  paragraphIndent: 0
};
class nF extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {ScrolComponentData} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const {
      overflowX: r,
      overflowY: o,
      scrollX: a,
      scrollY: c,
      scrollBarX: l,
      scrollBarY: h
    } = s;
    this.componentType = we.OVERFLOW, this.overflowX = ee(r) ? r : !1, this.overflowY = ee(o) ? o : !1, this.scrollX = ee(a) ? a : !1, this.scrollY = ee(c) ? c : !1, this.scrollBarX = ee(l) ? l : !1, this.scrollBarY = ee(h) ? h : !1, this.name || (this.name = "overflow");
  }
  /**
   * @param {Partial<ScrollComponentData>} data
   */
  set(n) {
    super.set(n), ee(n.overflowX) && this.updateProp("overflowX", n.overflowX), ee(n.overflowY) && this.updateProp("overflowY", n.overflowY), ee(n.scrollX) && this.updateProp("scrollX", n.scrollX), ee(n.scrollY) && this.updateProp("scrollY", n.scrollY), ee(n.scrollBarX) && this.updateProp("scrollBarX", n.scrollBarX), ee(n.scrollBarY) && this.updateProp("scrollBarY", n.scrollBarY);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {ScrollComponent} obj
   */
  _clone(n) {
    const s = super._clone(n);
    return s.overflowX = this.overflowX, s.overflowY = this.overflowY, s.scrollX = this.scrollX, s.scrollY = this.scrollY, s.scrollBarX = this.scrollBarX, s.scrollBarY = this.scrollBarY, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {ScrollComponentData} data
   */
  _save() {
    const n = super._save();
    return n.overflowX = this.overflowX, n.overflowY = this.overflowY, n.scrollX = this.scrollX, n.scrollY = this.scrollY, n.scrollBarX = this.scrollBarX, n.scrollBarY = this.scrollBarY, n;
  }
}
class sF extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {OpacityComponentData} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const { opacityType: r, blendMode: o, opacity: a, opacityHandles: c, opacityStops: l } = s;
    this.componentType = we.OPACITY, this.opacityType = ee(r) ? r : ud.SOLID, this.blendMode = ee(o) ? o : Ut.PASS_THROUGH, this.opacity = ee(a) ? a : 1, this.opacityHandles = ee(c) ? c.map((h) => new se(h)) : [], this.opacityStops = ee(l) ? l.map((h) => new Wp(h)) : [], this.name || (this.name = "opacity");
  }
  /** @param {Partial<OpacityComponentData>} data */
  set(n) {
    if (super.set(n), n.opacityType in ud && this.updateProp("opacityType", n.opacityType), n.blendMode in Ut && this.updateProp("blendMode", n.blendMode), ee(n.opacity) && this.updateProp("opacity", n.opacity), ee(n.opacityHandles)) {
      const s = n.opacityHandles.map((i) => new se(i));
      this.updateProp("opacityHandles", s);
    }
    if (ee(n.opacityStops)) {
      const s = n.opacityStops.map((i) => new Wp(i));
      this.updateProp("opacityStops", s);
    }
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {OpacityComponent} obj
   */
  _clone(n) {
    const s = super._clone(n);
    return s.opacityType = this.opacityType, s.blendMode = this.blendMode, s.opacity = this.opacity, s.opacityHandles = this.opacityHandles.map((i) => new se(i)), s.opacityStops = this.opacityStops.map((i) => new Wp(i)), s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {OpacityComponentData} data
   */
  _save() {
    const n = super._save();
    return n.opacityType = this.opacityType, n.blendMode = this.blendMode, n.opacity = this.opacity, n.opacityHandles = this.opacityHandles.map((s) => [...s]), n.opacityStops = this.opacityStops.map((s) => s.save()), n;
  }
}
class ky extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {OriginComponentData} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const { originX: r, originY: o, originXUnit: a, originYUnit: c } = s;
    this.componentType = we.ORIGIN, this.originX = be(r) ? r : 50, this.originY = be(o) ? o : 50, this.originXUnit = a in Jt ? a : Jt.PERCENT, this.originYUnit = c in Jt ? c : Jt.PERCENT, this.name || (this.name = "origin");
  }
  /** @param {Partial<OriginComponentSetData>} data */
  set(n) {
    super.set(n), be(n.originX) ? this.updateProp("originX", n.originX) : n.originX === null && this.updateProp("originX", void 0), be(n.originY) ? this.updateProp("originY", n.originY) : n.originY === null && this.updateProp("originY", void 0), n.originXUnit in Jt && ee(this.originX) && this.updateProp("originXUnit", n.originXUnit), n.originYUnit in Jt && ee(this.originY) && this.updateProp("originYUnit", n.originYUnit);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {ScaleComponent}
   */
  _clone(n) {
    const s = super._clone(n);
    return s.originX = this.originX, s.originY = this.originY, s.originXUnit = this.originXUnit, s.originYUnit = this.originYUnit, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {OriginComponentData}
   */
  _save() {
    const n = super._save();
    return ee(this.originX) && (n.originX = this.originX, n.originXUnit = this.originXUnit), ee(this.originY) && (n.originY = this.originY, n.originYUnit = this.originYUnit), n;
  }
}
ky.BASE_DEFAULT_DATA = {
  componentType: we.ORIGIN,
  originX: 50,
  originY: 50,
  originXUnit: Jt.PERCENT,
  originYUnit: Jt.PERCENT
};
class By extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {ReferencePointComponentData} [data]
   * @param {object} [options]
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const { referencePointX: r, referencePointY: o } = s;
    this.componentType = we.REFERENCE_POINT, this.referencePointX = be(r) ? r : 0, this.referencePointY = be(o) ? o : 0, this.name || (this.name = "referencePoint");
  }
  /**
   * @param {Partial<ReferencePointComponentSetData>} data
   */
  set(n) {
    super.set(n), be(n.referencePointX) && this.updateProp("referencePointX", n.referencePointX), be(n.referencePointY) && this.updateProp("referencePointY", n.referencePointY);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {ReferencePointComponent} obj
   */
  _clone(n) {
    const s = super._clone(n);
    return s.referencePointX = this.referencePointX, s.referencePointY = this.referencePointY, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {ReferencePointComponentData} data
   */
  _save() {
    const n = super._save();
    return n.referencePointX = this.referencePointX, n.referencePointY = this.referencePointY, n;
  }
}
By.BASE_DEFAULT_DATA = {
  referencePointX: 0,
  referencePointY: 0
};
class Vy extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {ContentAnchorComponentData} [data]
   * @param {object} [options]
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const {
      contentAnchorX: r,
      contentAnchorY: o,
      contentAnchorXUnit: a,
      contentAnchorYUnit: c,
      contentAnchorAutoAdd: l,
      contentAnchorType: h
    } = s;
    this.componentType = we.CONTENT_ANCHOR, this.contentAnchorX = be(r) ? r : 0, this.contentAnchorY = be(o) ? o : 0, this.contentAnchorXUnit = a in Jt ? a : Jt.PIXEL, this.contentAnchorYUnit = c in Jt ? c : Jt.PIXEL, this.contentAnchorAutoAdd = ee(l) ? l : !1, this.contentAnchorType = ee(h) ? h : pd.CONTENT, this.name || (this.name = "contentAnchor");
  }
  /**
   * @param {Partial<ContentAnchorComponentSetData>} data
   */
  set(n) {
    super.set(n), be(n.contentAnchorX) ? this.updateProp("contentAnchorX", n.contentAnchorX) : n.contentAnchorX === null && this.updateProp("contentAnchorX", void 0), be(n.contentAnchorY) ? this.updateProp("contentAnchorY", n.contentAnchorY) : n.contentAnchorY === null && this.updateProp("contentAnchorY", void 0), n.contentAnchorXUnit in Jt && ee(this.contentAnchorX) && this.updateProp("contentAnchorXUnit", n.contentAnchorXUnit), n.contentAnchorYUnit in Jt && ee(this.contentAnchorY) && this.updateProp("contentAnchorYUnit", n.contentAnchorYUnit), ee(n.contentAnchorAutoAdd) && this.updateProp("contentAnchorAutoAdd", n.contentAnchorAutoAdd), ee(n.contentAnchorType) && this.updateProp("contentAnchorType", n.contentAnchorType);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {ContentAnchorComponent} obj
   */
  _clone(n) {
    const s = super._clone(n);
    return s.contentAnchorX = this.contentAnchorX, s.contentAnchorY = this.contentAnchorY, s.contentAnchorXUnit = this.contentAnchorXUnit, s.contentAnchorYUnit = this.contentAnchorYUnit, s.contentAnchorAutoAdd = this.contentAnchorAutoAdd, s.contentAnchorType = this.contentAnchorType, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {ContentAnchorComponentData} data
   */
  _save() {
    const n = super._save();
    return ee(this.contentAnchorX) && (n.contentAnchorX = this.contentAnchorX, n.contentAnchorXUnit = this.contentAnchorXUnit), ee(this.contentAnchorY) && (n.contentAnchorY = this.contentAnchorY, n.contentAnchorYUnit = this.contentAnchorYUnit), n.contentAnchorAutoAdd = this.contentAnchorAutoAdd, n.contentAnchorType = this.contentAnchorType, n;
  }
}
Vy.BASE_DEFAULT_DATA = {
  contentAnchorX: 0,
  contentAnchorY: 0,
  contentAnchorXUnit: "px",
  contentAnchorYUnit: "px",
  contentAnchorAutoAdd: !0,
  contentAnchorType: pd.CONTENT
};
class iF extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {CornerRadiusComponentData} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const { cornerRadius: r, cornerSmoothing: o } = s;
    this.componentType = we.CORNER_RADIUS, this.cornerRadius = be(r) ? r : void 0, this.cornerRadius === void 0 && (this.cornerRadius = hd(r) ? [...r] : 0), this.cornerSmoothing = ee(o) ? o : 0, this.name || (this.name = "cornerRadius");
  }
  /** @param {Partial<CornerRadiusComponentSetData>} data */
  set(n) {
    super.set(n), be(n.cornerRadius) ? this.updateProp("cornerRadius", n.cornerRadius) : hd(n.cornerRadius) ? this.updateProp("cornerRadius", [...n.cornerRadius]) : n.cornerRadius === null && this.updateProp("cornerRadius", void 0), be(n.cornerSmoothing) ? this.updateProp("cornerSmoothing", n.cornerSmoothing) : n.cornerSmoothing === null && this.updateProp("cornerSmoothing", void 0);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {CornerRadiusComponent} obj
   */
  _clone(n) {
    const s = super._clone(n);
    return ee(this.cornerRadius) && (s.cornerRadius = be(this.cornerRadius) ? this.cornerRadius : [...this.cornerRadius]), s.cornerSmoothing = this.cornerSmoothing, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {CornerRadiusComponentData} data
   */
  _save() {
    const n = super._save();
    return ee(this.cornerRadius) && (n.cornerRadius = be(this.cornerRadius) ? this.cornerRadius : [...this.cornerRadius]), n.cornerSmoothing = this.cornerSmoothing, n;
  }
}
class Hy extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {TranslateComponentData} [data]
   * @param {object} [options]
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const {
      translateX: r,
      translateY: o,
      translateXUnit: a,
      translateYUnit: c
    } = s;
    this.componentType = we.TRANSLATE, this.translateX = be(r) ? r : 0, this.translateY = be(o) ? o : 0, this.translateXUnit = a in Jt ? a : Jt.PIXEL, this.translateYUnit = c in Jt ? c : Jt.PIXEL, this.name || (this.name = "translate");
  }
  /**
   * @param {Partial<TranslateComponentSetData>} data
   */
  set(n) {
    super.set(n), be(n.translateX) ? this.updateProp("translateX", n.translateX) : n.translateX === null && this.updateProp("translateX", void 0), be(n.translateY) ? this.updateProp("translateY", n.translateY) : n.translateY === null && this.updateProp("translateY", void 0), n.translateXUnit in Jt && ee(this.translateXUnit) && this.updateProp("translateXUnit", n.translateXUnit), n.translateYUnit in Jt && ee(this.translateYUnit) && this.updateProp("translateYUnit", n.translateYUnit);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {TranslateComponent} obj
   */
  _clone(n) {
    const s = super._clone(n);
    return s.translateX = this.translateX, s.translateY = this.translateY, s.translateXUnit = this.translateXUnit, s.translateYUnit = this.translateYUnit, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {TranslateComponentData} data
   */
  _save() {
    const n = super._save();
    return ee(this.translateX) && (n.translateX = this.translateX, n.translateXUnit = this.translateXUnit), ee(this.translateY) && (n.translateY = this.translateY, n.translateYUnit = this.translateYUnit), n;
  }
}
Hy.BASE_DEFAULT_DATA = {
  translateX: 0,
  translateY: 0,
  translateXUnit: "px",
  translateYUnit: "px"
};
class rF extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {RotationComponentData} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const { rotation: r } = s;
    this.componentType = we.ROTATION, this.rotation = ee(r) ? r : 0, this.name || (this.name = "rotation");
  }
  /** @param {Partial<RotationComponentData>} data */
  set(n) {
    super.set(n), ee(n.rotation) && this.updateProp("rotation", n.rotation);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {RotationComponent}
   */
  _clone(n) {
    const s = super._clone(n);
    return s.rotation = this.rotation, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {RotationComponentData}
   */
  _save() {
    const n = super._save();
    return n.rotation = this.rotation, n;
  }
}
class oF extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {ScaleComponentData} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const { scaleX: r, scaleY: o } = s;
    this.scaleX = ee(r) ? r : 1, this.scaleY = ee(o) ? o : 1, this.componentType = we.SCALE, this.name || (this.name = "scale");
  }
  /** @param {Partial<ScaleComponentData>} data */
  set(n) {
    super.set(n), ee(n.scaleX) && this.updateProp("scaleX", n.scaleX), ee(n.scaleY) && this.updateProp("scaleY", n.scaleY);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {ScaleComponent}
   */
  _clone(n) {
    const s = super._clone(n);
    return s.scaleX = this.scaleX, s.scaleY = this.scaleY, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {ScaleComponentData}
   */
  _save() {
    const n = super._save();
    return n.scaleX = this.scaleX, n.scaleY = this.scaleY, n;
  }
}
class Wy extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {SkewComponentData} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const { skewX: r, skewY: o } = s;
    this.skewX = ee(r) ? r : 0, this.skewY = ee(o) ? o : 0, this.componentType = we.SKEW, this.name || (this.name = "skew");
  }
  /** @param {Partial<SkewComponentSetData>} data */
  set(n) {
    super.set(n), ee(n.skewX) ? this.updateProp("skewX", n.skewX) : n.skewX === null && this.updateProp("skewX", void 0), ee(n.skewY) ? this.updateProp("skewY", n.skewY) : n.skewY === null && this.updateProp("skewY", void 0);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {SkewComponent}
   */
  _clone(n) {
    const s = super._clone(n);
    return s.skewX = this.skewX, s.skewY = this.skewY, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {SkewComponentData}
   */
  _save() {
    const n = super._save();
    return n.skewX = this.skewX, n.skewY = this.skewY, n;
  }
}
Wy.BASE_DEFAULT_DATA = {
  skewX: 0,
  skewY: 0
};
class af extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {LayerComponentData} [data]
   * @param {object} [options]
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const { layerType: r, layers: o } = s;
    this.layerType = ee(r) ? r : "LAYER", this.layers = ee(o) ? o : [], this.name || (this.name = "layer");
  }
  /**
   * @param {Partial<LayerComponentData>} data
   */
  set(n) {
    super.set(n), ee(n.layers) && this.updateProp("layers", n.layers);
  }
  /**
   * Add Layer to LayerComponent
   * @param {string} layerId
   * @param {number} [index=-1]
   */
  addLayer(n, s = -1) {
    if (this.layers.includes(n))
      return;
    const i = s === -1 ? this.layers.length : s, r = this.layers.slice();
    r.splice(i, 0, n), this.set({ layers: r });
  }
  /**
   * Remove Layer to LayerComponent
   * @param {string} layerId
   */
  removeLayer(n) {
    const s = this.layers.findIndex((r) => r === n);
    if (s === -1)
      return;
    const i = this.layers.slice();
    i.splice(s, 1), this.set({ layers: i });
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {PropertyComponent}
   */
  _clone(n) {
    const s = super._clone(n);
    return s.layerType = this.layerType, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {LayerComponentData} data
   */
  _save() {
    const n = super._save();
    return n.layerType = this.layerType, n.layers = this.layers, n;
  }
  /**
   * Override this in subclasses if subclass has any inner sharable PropertyComponents
   * CALL super.apply() at the top of overriden method
   * @param {AppliedRef} ref
   */
  apply(n) {
    super.apply(n), this.layers.forEach((s) => {
      this.dataStore.library.getLayer(s).apply(n);
    });
  }
  /**
   * Override this in subclasses if subclass has any inner sharable PropertyComponents
   * CALL super.cancel() at the top of overriden method
   * @param {AppliedRef} ref
   */
  cancel(n) {
    super.cancel(n), this.layers.forEach((s) => {
      this.dataStore.library.getLayer(s).cancel(n);
    });
  }
}
class aF extends af {
  /**
   * @param {DataStore} dataStore
   * @param {FillComponentData} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i), this.componentType = Or.FILL, (!this.name || this.name === "layer") && (this.name = "fill"), (!this.layerType || this.layerType === "LAYER") && (this.layerType = ze.FILL);
  }
}
class cF extends af {
  /**
   * @param {DataStore} dataStore
   * @param {StrokeComponentData} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i), this.componentType = Or.STROKE, (!this.name || this.name === "layer") && (this.name = "stroke"), (!this.layerType || this.layerType === "LAYER") && (this.layerType = ze.STROKE);
  }
}
class lF extends af {
  /**
   * @param {DataStore} dataStore
   * @param {ShadowComponentData} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i), this.componentType = Or.SHADOW, (!this.name || this.name === "layer") && (this.name = "shadow"), (!this.layerType || this.layerType === "LAYER") && (this.layerType = ze.SHADOW);
  }
}
class hF extends af {
  /**
   * @param {DataStore} dataStore
   * @param {InnerShadowComponentData} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i), this.componentType = Or.INNER_SHADOW, (!this.name || this.name === "layer") && (this.name = "inner-shadow"), (!this.layerType || this.layerType === "LAYER") && (this.layerType = ze.INNER_SHADOW);
  }
}
class Yy extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {TextAlignmentComponentData} [data]
   * @param {object} [options]
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const { horizontalAlignment: r, verticalAlignment: o } = s;
    this.horizontalAlignment = r in Yi ? r : Yi.LEFT, this.verticalAlignment = o in Fs ? o : Fs.TOP, this.componentType = we.TEXT_ALIGNMENT, this.name || (this.name = "text-alignment");
  }
  /** @param {Partial<TextAlignmentComponentSetData>} data */
  set(n) {
    super.set(n);
    const { horizontalAlignment: s, verticalAlignment: i } = n;
    s in Yi ? this.updateProp("horizontalAlignment", s) : s === null && this.updateProp("horizontalAlignment", void 0), i in Fs ? this.updateProp("verticalAlignment", i) : i === null && this.updateProp("verticalAlignment", void 0);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {TextAlignmentComponentData} obj
   */
  _clone(n) {
    const s = super._clone(n);
    return s.horizontalAlignment = this.horizontalAlignment, s.verticalAlignment = this.verticalAlignment, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {TextAlignmentComponentData} data
   */
  _save() {
    const n = super._save();
    return this.horizontalAlignment in Yi && (n.horizontalAlignment = this.horizontalAlignment), this.verticalAlignment in Fs && (n.verticalAlignment = this.verticalAlignment), n;
  }
}
Yy.BASE_DEFAULT_DATA = {
  horizontalAlignment: Yi.LEFT,
  verticalAlignment: Fs.TOP
};
class Xy extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {TextDecorationComponentData} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const { underline: r, strikethrough: o, cases: a, subSuper: c } = s;
    this.underline = typeof r == "boolean" ? r : !1, this.strikethrough = typeof o == "boolean" ? o : !1, this.cases = rr(a) ? a : "NORMAL", this.subSuper = rr(c) ? c : "NORMAL", this.componentType = we.TEXT_DECORATION, this.name || (this.name = "text-decoration");
  }
  /** @param {Partial<TextDecorationComponentData>} data */
  set(n) {
    super.set(n);
    const {
      underline: s,
      strikethrough: i,
      cases: r,
      subSuper: o
    } = n;
    typeof s == "boolean" ? this.updateProp("underline", n.underline) : s === null && this.updateProp("underline", void 0), typeof i == "boolean" ? this.updateProp("strikethrough", n.strikethrough) : i === null && this.updateProp("strikethrough", void 0), rr(r) ? this.updateProp("cases", n.cases) : r === null && this.updateProp("cases", void 0), rr(o) ? this.updateProp("subSuper", n.subSuper) : o === null && this.updateProp("subSuper", void 0);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {TextDecorationComponentData} obj
   */
  _clone(n) {
    const s = super._clone(n);
    return s.underline = this.underline, s.strikethrough = this.strikethrough, s.cases = this.cases, s.subSuper = this.subSuper, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {TextDecorationComponentData} data
   */
  _save() {
    const n = super._save();
    return ee(this.underline) && (n.underline = this.underline), ee(this.strikethrough) && (n.strikethrough = this.strikethrough), ee(this.cases) && (n.cases = this.cases), ee(this.subSuper) && (n.subSuper = this.subSuper), n;
  }
}
Xy.BASE_DEFAULT_DATA = {
  underline: !1,
  strikethrough: !1,
  cases: "NORMAL",
  subSuper: "NORMAL"
};
class uF extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {TextDirectionComponentData} [data]
   * @param {object} [options] 
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const { textDirection: r } = s;
    this.textDirection = ee(r) ? r : dd.LTR, this.componentType = we.TEXT_DIRECTION, this.name || (this.name = "text-direction");
  }
  /** @param {Partial<TextDirectionComponentData>} data */
  set(n) {
    super.set(n), n.textDirection in dd && this.updateProp("textDirection", n.textDirection);
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {TextDirectionComponentData} obj
   */
  _clone(n) {
    const s = super._clone(n);
    return s.textDirection = this.textDirection, s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {TextDirectionComponentData} data
   */
  _save() {
    const n = super._save();
    return n.textDirection = this.textDirection, n;
  }
}
class dF extends Cn {
  /**
   * @param {DataStore} dataStore
   * @param {EffectComponentData} [data]
   * @param {object} [options]
   * @param {bool} [options.regenId=false]   if set to true, will generate new ID
   */
  constructor(n, s = {}, i) {
    super(n, s, i);
    const { effects: r, effectsTypeSet: o } = s;
    this.componentType = we.EFFECT, this.effects = ee(r) ? r : [], this.effectsTypeSet = ee(r) ? new Set(o) : /* @__PURE__ */ new Set(), this.name || (this.name = "effect");
  }
  /**
   * @param {Partial<EffectComponentData>} data
   */
  set(n) {
    super.set(n), ee(n.effects) && this.updateProp("effects", n.effects), ee(n.effectsTypeSet) && this.updateProp("effectsTypeSet", n.effectsTypeSet);
  }
  /**
   * Check if already has the effect
   * @param {EffectType} effectType
   * @returns {bool}
   */
  hasEffectType(n) {
    return this.effectsTypeSet.has(n);
  }
  /**
   * Add Effect to EffectComponent
   * @param {string} effectId
   * @param {number} [index=-1]
   */
  addEffect(n, s = -1) {
    if (this.effects.includes(n))
      return;
    const i = s === -1 ? this.effects.length : s, r = this.effects.slice();
    r.splice(i, 0, n);
    const o = this.dataStore.library.getEffect(n);
    this.set({
      effects: r,
      effectsTypeSet: new Set(this.effectsTypeSet).add(o.effectType)
    });
  }
  /**
   * Remove Effet from EffectComponent
   * @param {string} effectId
   */
  removeEffect(n) {
    const s = this.effects.findIndex((a) => a === n);
    if (s === -1)
      return;
    const i = this.dataStore.library.getEffect(n), r = this.effects.slice();
    r.splice(s, 1);
    const o = new Set(this.effectsTypeSet);
    o.delete(i.effectType), this.set({
      effects: r,
      effectsTypeSet: o
    });
  }
  /**
   * Override this in subclasses
   * CALL super._clone() at the top of overriden method
   * @protected
   * @param {AppliedRef} [ref]
   * @returns {PropertyComponent}
   */
  _clone(n) {
    const s = super._clone(n), i = this.dataStore.library.cloneComponentList(this.effects.map((r) => this.dataStore.library.getComponent(r)));
    return s.effects = [...i.values()], s.effectsTypeSet = new Set(this.effectsTypeSet), s;
  }
  /**
   * Override this in subclasses
   * CALL super._save() at the top of overriden method
   * @protected
   * @returns {EffectComponentData} data
   */
  _save() {
    const n = super._save();
    return n.effects = this.effects, n.effectsTypeSet = [...this.effectsTypeSet], n;
  }
  /**
   * Override this in subclasses if subclass has any inner sharable PropertyComponents
   * CALL super.apply() at the top of overriden method
   * @param {AppliedRef} ref
   */
  apply(n) {
    super.apply(n), this.effects.forEach((s) => {
      this.dataStore.library.getEffect(s).apply(n);
    });
  }
  /**
   * Override this in subclasses if subclass has any inner sharable PropertyComponents
   * CALL super.cancel() at the top of overriden method
   * @param {AppliedRef} ref
   */
  cancel(n) {
    super.cancel(n), this.effects.forEach((s) => {
      this.dataStore.library.getEffect(s).cancel(n);
    });
  }
}
we.TRANSLATE, we.DIMENSIONS, we.ROTATION, we.OPACITY, we.FILL, we.STROKE, we.SHADOW, we.INNER_SHADOW, we.FONT, we.TEXT_ALIGNMENT, we.TEXT_DECORATION, we.TEXT_DIRECTION, we.SCALE, we.SKEW, we.ORIGIN, we.REFERENCE_POINT, we.CONTENT_ANCHOR, we.OVERFLOW, we.BLUR_GAUSSIAN, we.PAINT, we.CORNER_RADIUS, we.EFFECT, we.IMAGE;
Ic.INSIDE, Ic.CENTER, Ic.OUTSIDE;
cn.NONE, cn.ROUND, cn.LINE_ARROW, cn.TRIANGLE_ARROW_SOLID, cn.TRIANGLE_ARROW_OUTLINE, cn.CIRCLE_SOLID, cn.CIRCLE_OUTLINE, cn.SQUARE_SOLID, cn.SQUARE_OUTLINE;
Us.MITER, Us.CONCAVE, Us.ROUND, Us.BEVEL, Us.NONE;
Ba.STRAIGHT, Ba.ROUND;
Wc({
  position: { type: se },
  translate: { type: se },
  referencePoint: { type: se },
  contentAnchor: { type: se },
  size: { type: se },
  scale: { type: se },
  skew: { type: se }
});
or.FROM_MESH_CHANGE, or.FROM_CHILDREN_CHANGE, or.FROM_PARENT_EDIT, or.FROM_CHANGE_CONTAINER_TYPE, or.FROM_TEXT_EDIT;
const fF = (e) => e / 180 * Math.PI;
function ju(e, n, s, i) {
  return Math.hypot(e - s, n - i);
}
function zy(e, n, s, i, r, o) {
  return e === s && n === i || e === r && n === o ? 0 : s === r && i === o ? Math.sqrt((e - s) ** 2 + (n - i) ** 2) : Math.abs((i - o) * e + (r - s) * n + (s * o - r * i)) / Math.sqrt((i - o) ** 2 + (r - s) ** 2);
}
function Ky(e, n, s, i, r, o, a) {
  const c = i - o, l = r - s, h = s * o - r * i, d = (c * e + l * n + h) / (c ** 2 + l ** 2);
  return a.set(e - c * d, n - l * d), d;
}
function pF(e, n, s, i, r) {
  let o = Math.atan2(-s.x, s.y);
  o < 0 && (o += Math.PI * 2);
  const a = r.rotate(o);
  a.affine_inverse().xform(e, e), e.multiply(1, -1);
  const l = n.length(), h = s.length(), d = e.y / e.x, p = l * h * Math.sqrt(1 / (h ** 2 + l ** 2 * d ** 2)), E = d * p, { pos: g, dis: T } = EF(
    e,
    [
      [p, E],
      [-p, -E]
    ]
  ), A = a.xform({ x: g[0], y: g[1] }), m = A.set(A.x + i.x, -A.y + i.y);
  let O = Math.atan2(-g[0] * h / l, -g[1]);
  return O < 0 && (O += Math.PI * 2), {
    pos: m,
    dis: T,
    per: O / Math.PI / 2
  };
}
function EF(e, n) {
  let s = null, i = Number.MAX_SAFE_INTEGER;
  for (let r = 0; r < n.length; r++) {
    const o = ju(e.x, e.y, n[r][0], n[r][1]);
    o < i && (i = o, s = n[r]);
  }
  return { pos: s, dis: i };
}
function gF(e, n, s, i, r) {
  return Math.pow(e - s, 2) + Math.pow(n - i, 2) <= Math.pow(r, 2);
}
const Qy = new Int8Array(4), _F = new Int32Array(Qy.buffer, 0, 1), TF = new Float32Array(Qy.buffer, 0, 1), AF = (e) => (_F[0] = e, TF[0]), mF = (e) => AF(e & 4278190079);
function OF(e, n, s, i) {
  const r = (i * 255 | 0) << 24 | (s * 255 | 0) << 16 | (n * 255 | 0) << 8 | (e * 255 | 0);
  return mF(r);
}
function ei(e = 1, n = 1, s = 1, i = 1) {
  this.r = e, this.g = n, this.b = s, this.a = i, this._rgba = null;
}
ei.prototype = {
  constructor: ei,
  /**
   * @param {number} r
   * @param {number} g
   * @param {number} b
   * @param {number} [a]
   * @returns {this}
   */
  set(e, n, s, i = 1) {
    return this.r = e, this.g = n, this.b = s, this.a = i, this;
  },
  /**
   * @param {number} hex
   * @returns {this}
   */
  set_with_hex(e) {
    const [n, s, i] = Zy(e);
    return this.r = n, this.g = s, this.b = i, this;
  },
  /**
   * @param {number[]} arr
   * @returns {this}
   */
  set_with_array(e) {
    return this.r = e[0], this.g = e[1], this.b = e[2], this.a = e[3], this;
  },
  /**
   * @param {ColorLike} c
   * @returns {this}
   */
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this;
  },
  clone() {
    return new ei().copy(this);
  },
  to_linear() {
    return new ei().set(
      this.r < 0.04045 ? this.r * (1 / 12.92) : Math.pow((this.r + 0.055) * (1 / (1 + 0.055)), 2.4),
      this.g < 0.04045 ? this.g * (1 / 12.92) : Math.pow((this.g + 0.055) * (1 / (1 + 0.055)), 2.4),
      this.b < 0.04045 ? this.b * (1 / 12.92) : Math.pow((this.b + 0.055) * (1 / (1 + 0.055)), 2.4),
      this.a
    );
  },
  to_srgb() {
    return new ei().set(
      this.r < 31308e-7 ? 12.92 * this.r : (1 + 0.055) * Math.pow(this.r, 1 / 2.4) - 0.055,
      this.g < 31308e-7 ? 12.92 * this.g : (1 + 0.055) * Math.pow(this.g, 1 / 2.4) - 0.055,
      this.b < 31308e-7 ? 12.92 * this.b : (1 + 0.055) * Math.pow(this.b, 1 / 2.4) - 0.055,
      this.a
    );
  },
  /**
   * @param {ColorLike} c
   * @returns {this}
   */
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this.a *= e.a, this;
  },
  /**
   * @param {ColorLike} p_over
   * @returns {this}
   */
  blend(e) {
    let n = 0;
    const s = 1 - e.a;
    return n = this.a * s + e.a, n === 0 ? this.set(0, 0, 0, 0) : this.set(
      (this.r * this.a * s + e.r * e.a) / n,
      (this.g * this.a * s + e.g * e.a) / n,
      (this.b * this.a * s + e.b * e.a) / n,
      n
    );
  },
  /**
   * @param {ColorLike} p_b
   * @param {number} p_t
   * @param {Color} [r_out]
   * @returns {Color}
   */
  linear_interpolate(e, n, s = new ei()) {
    return s.copy(this), s.r += n * (e.r - this.r), s.g += n * (e.g - this.g), s.b += n * (e.b - this.b), s.a += n * (e.a - this.a), s;
  },
  as_hex() {
    return this._rgba || (this._rgba = Array(4)), this._rgba[0] = this.r, this._rgba[1] = this.g, this._rgba[2] = this.b, this._rgba[3] = this.a, g0(this._rgba);
  },
  as_rgba8() {
    return OF(this.r, this.g, this.b, this.a);
  },
  /**
   * @param {number[]} [out]
   * @returns {number[]}
   */
  as_array(e) {
    if (!e && !this._rgba)
      return this._rgba = [this.r, this.g, this.b, this.a], this._rgba;
    const n = e || this._rgba;
    return n[0] = this.r, n[1] = this.g, n[2] = this.b, n[3] = this.a, n;
  },
  /**
   * @param {ColorLike} value
   * @returns {boolean}
   */
  equals(e) {
    return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }
};
ei.hex = (e) => {
  const n = Zy(e);
  return new ei(n[0], n[1], n[2]);
};
ei.html = (e) => ei.hex(parseInt(e.replace(/^#/, "0x"), 16));
function Zy(e, n = []) {
  return n[0] = (e >> 16 & 255) / 255, n[1] = (e >> 8 & 255) / 255, n[2] = (e & 255) / 255, n;
}
function g0(e) {
  return (e[0] * 255 << 16) + (e[1] * 255 << 8) + (e[2] * 255 | 0);
}
const vI = new N();
function ye(e = 0, n = 0, s = 0, i = 0) {
  this.x = e, this.y = n, this.width = s, this.height = i;
}
ye.prototype = {
  constructor: ye,
  /**
   * @param {number} p_x
   * @param {number} p_y
   * @param {number} p_width
   * @param {number} p_height
   * @returns {Rect2}
   */
  set(e = 0, n = 0, s = 0, i = 0) {
    return this.x = e, this.y = n, this.width = s, this.height = i, this;
  },
  /**
   * @param {Generator<Rect2>} generator
   * @returns {Rect2}
   */
  setFrom(e) {
    this.set(0, 0, 0, 0);
    const n = e.next().value;
    n && this.copy(n);
    for (const s of e)
      this.merge_with(s);
    return this;
  },
  get left() {
    return this.x;
  },
  get right() {
    return this.x + this.width;
  },
  get top() {
    return this.y;
  },
  get bottom() {
    return this.y + this.height;
  },
  get center() {
    return new N(this.x + this.width / 2, this.y + this.height / 2);
  },
  get topCenter() {
    return new N(this.x + this.width / 2, this.y);
  },
  get leftCenter() {
    return new N(this.x, this.y + this.height / 2);
  },
  get rightCenter() {
    return new N(this.x + this.width, this.y + this.height / 2);
  },
  get bottomCenter() {
    return new N(this.x + this.width / 2, this.y + this.height);
  },
  get topLeft() {
    return new N(this.x, this.y);
  },
  get topRight() {
    return new N(this.x + this.width, this.y);
  },
  get bottomLeft() {
    return new N(this.x, this.y + this.height);
  },
  get bottomRight() {
    return new N(this.x + this.width, this.y + this.height);
  },
  get w() {
    return this.width;
  },
  set w(e) {
    this.width = e;
  },
  get h() {
    return this.height;
  },
  set h(e) {
    this.height = e;
  },
  getCenter() {
    return new N(this.x + this.width * 0.5, this.y + this.height * 0.5);
  },
  clone() {
    return new ye(this.x, this.y, this.width, this.height);
  },
  /**
   * Copies another rectangle to this one.
   * @param {Rect2} rectangle - The rectangle to copy.
   * @returns {Rect2}
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
  },
  is_zero() {
    return this.x === 0 && this.y === 0 && this.width === 0 && this.height === 0;
  },
  /**
   * @param {Rect2} rect
   * @returns {boolean}
   */
  equals(e) {
    return this.x === e.x && this.y === e.y && this.width === e.width && this.height === e.height;
  },
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   *
   * @param {number | Vector2Like} x - The X coordinate of the point to test
   * @param {number} y - The Y coordinate of the point to test
   * @returns {boolean}
   */
  contains(e, n) {
    let s, i;
    return n === void 0 ? (s = e.x, i = e.y) : (s = e, i = n), this.width <= 0 || this.height <= 0 ? !1 : s >= this.x && s <= this.x + this.width && i >= this.y && i <= this.y + this.height;
  },
  /**
   * @param {Rect2} rect
   * @returns {boolean}
   */
  containsRect(e) {
    const n = e.x, s = e.y;
    return n >= this.x && s >= this.y && n + e.width <= this.x + this.width && s + e.height <= this.y + this.height;
  },
  has_no_area() {
    return this.width <= 0 || this.height <= 0;
  },
  /**
   * @param {Vector2Like} p_point
   * @returns {boolean}
   */
  has_point(e) {
    return !(e.x < this.x || e.y < this.y || e.x >= this.x + this.width || e.y >= this.y + this.height);
  },
  get_area() {
    return this.width * this.height;
  },
  /**
   * Returns new Rect2 with absolute values.
   * @returns {Rect2}
   */
  abs() {
    return this.clone().abs_to();
  },
  /**
   * @returns {Rect2}
   */
  abs_to() {
    return this.x += Math.min(this.width, 0), this.y += Math.min(this.height, 0), this.width = Math.abs(this.width), this.height = Math.abs(this.height), this;
  },
  /**
   * Returns new Rect2.
   * @param {Rect2} rect
   * @returns {Rect2}
   */
  clip(e) {
    return this.clone().clip_by(e);
  },
  /**
   * @param {Rect2} rect
   * @returns {Rect2}
   */
  clip_by(e) {
    if (!this.intersects(e))
      return this.set(0, 0, 0, 0);
    const n = Math.max(e.x, this.x), s = Math.max(e.y, this.y), i = e.x + e.width, r = e.y + e.height, o = this.x + this.width, a = this.y + this.height;
    return this.x = n, this.y = s, this.width = Math.min(i, o) - n, this.height = Math.min(r, a) - s, this;
  },
  /**
   * @param {Rect2} rect
   * @returns {boolean}
   */
  encloses(e) {
    return e.x >= this.x && e.y >= this.y && e.x + e.width < this.x + this.width && e.y + e.height < this.y + this.height;
  },
  /**
   * Pads the rectangle making it grow in all directions.
   * Returns new Rect2.
   *
   * @param {number} p_by - The horizontal padding amount.
   * @returns {Rect2}
   */
  grow(e) {
    return this.clone().grow_to(e);
  },
  /**
   * Pads the rectangle making it grow in all directions.
   *
   * @param {number} p_by - The horizontal padding amount.
   * @returns {Rect2}
   */
  grow_to(e) {
    return this.x -= e, this.y -= e, this.width += e * 2, this.height += e * 2, this;
  },
  /**
   * @param {number} p_left
   * @param {number} p_top
   * @param {number} p_right
   * @param {number} p_bottom
   * @returns {Rect2}
   */
  grow_individual(e, n, s, i) {
    const r = this.clone();
    return r.x -= e, r.y -= n, r.width += e + s, r.height += n + i, r;
  },
  /**
   * Returns new Rect2.
   * @param {Vector2Like} p_vector
   * @returns {Rect2}
   */
  expand(e) {
    return this.clone().expand_to(e);
  },
  /**
   * Returns new Rect2.
   * @param {number} x
   * @param {number} y
   * @returns {Rect2}
   */
  expand_n(e, n) {
    return this.clone().expand_to(vI.set(e, n));
  },
  /**
   * @param {Vector2Like} p_vector
   * @returns {Rect2}
   */
  expand_to(e) {
    const n = IF.set(this.x, this.y), s = SF.set(this.x + this.width, this.y + this.height);
    return e.x < n.x && (n.x = e.x), e.y < n.y && (n.y = e.y), e.x > s.x && (s.x = e.x), e.y > s.y && (s.y = e.y), this.x = n.x, this.y = n.y, this.width = s.x - n.x, this.height = s.y - n.y, this;
  },
  /**
   * @param {number} x
   * @param {number} y
   * @returns {Rect2}
   */
  expand_to_n(e, n) {
    return this.expand_to(vI.set(e, n));
  },
  /**
   * @param {number} x
   * @param {number} y
   * @returns {Rect2}
   */
  offset(e, n) {
    return this.x += e, this.y += n, this;
  },
  /**
   * Fits this rectangle around the passed one.
   *
   * @param {Rect2} p_rect - The rectangle to fit.
   * @returns {Rect2}
   */
  fit_to(e) {
    return this.x < e.x && (this.width += this.x, this.width < 0 && (this.width = 0), this.x = e.x), this.y < e.y && (this.height += this.y, this.height < 0 && (this.height = 0), this.y = e.y), this.x + this.width > e.x + e.width && (this.width = e.width - this.x, this.width < 0 && (this.width = 0)), this.y + this.height > e.y + e.height && (this.height = e.height - this.y, this.height < 0 && (this.height = 0)), this;
  },
  /**
   * Merge the given rectangle and return a new one.
   * Returns new Rect2.
   *
   * @param {Rect2} p_rect - The rectangle to merge.
   * @returns {Rect2}
   */
  merge(e) {
    return this.clone().merge_with(e);
  },
  /**
   * Merge this rectangle with the passed rectangle
   *
   * @param {Rect2} p_rect - The rectangle to merge.
   * @returns {Rect2}
   */
  merge_with(e) {
    const n = Math.min(this.x, e.x), s = Math.max(this.x + this.width, e.x + e.width), i = Math.min(this.y, e.y), r = Math.max(this.y + this.height, e.y + e.height);
    return this.x = n, this.width = s - n, this.y = i, this.height = r - i, this;
  },
  /**
   * @param {Rect2} rect
   * @param {number} eps
   * @returns {boolean}
   */
  intersects(e, n = 0) {
    return e.x + e.width > this.x - n && e.y + e.height > this.y - n && e.x < this.x + this.width + n && e.y < this.y + this.height + n;
  },
  /**
   * @param {Vector2} p_from
   * @param {Vector2} p_to
   * @param {Vector2} [r_pos]
   * @param {Vector2} [r_normal]
   * @returns {boolean}
   */
  intersects_segment(e, n, s, i) {
    let r = 0, o = 1, a = 0, c = 0;
    {
      const h = e.x, d = n.x, p = this.x, E = p + this.width;
      let g = 0, T = 0, A = 0;
      if (h < d) {
        if (h > E || d < p)
          return !1;
        const m = d - h;
        g = h < p ? (p - h) / m : 0, T = d > E ? (E - h) / m : 1, A = -1;
      } else {
        if (d > E || h < p)
          return !1;
        const m = d - h;
        g = h > E ? (E - h) / m : 0, T = d < p ? (p - h) / m : 1, A = 1;
      }
      if (g > r && (r = g, a = 0, c = A), T < o && (o = T), o < r)
        return !1;
    }
    {
      const h = e.y, d = n.y, p = this.y, E = p + this.height;
      let g = 0, T = 0, A = 0;
      if (h < d) {
        if (h > E || d < p)
          return !1;
        const m = d - h;
        g = h < p ? (p - h) / m : 0, T = d > E ? (E - h) / m : 1, A = -1;
      } else {
        if (d > E || h < p)
          return !1;
        const m = d - h;
        g = h > E ? (E - h) / m : 0, T = d < p ? (p - h) / m : 1, A = 1;
      }
      if (g > r && (r = g, a = 1, c = A), T < o && (o = T), o < r)
        return !1;
    }
    const l = n.clone().subtract(e);
    return i && (i.set(0, 0), a === 0 ? i.x = c : i.y = c), s && s.copy(e).add(l.scale(r)), !0;
  },
  /**
   * @param {Rect2} other
   * @param {number} eps
   * @returns {boolean}
   */
  overlaps(e, n = 0) {
    return !(this.actualBottom() <= e.actualTop() + n || this.actualTop() >= e.actualBottom() - n || this.actualLeft() >= e.actualRight() + n || this.actualRight() <= e.actualLeft() - n);
  },
  actualLeft() {
    return Math.min(this.x, this.x + this.w);
  },
  actualTop() {
    return Math.min(this.y, this.y + this.h);
  },
  actualRight() {
    return Math.max(this.x, this.x + this.w);
  },
  actualBottom() {
    return Math.max(this.y, this.y + this.h);
  },
  actualTopLeft() {
    return new N(this.actualLeft(), this.actualTop());
  },
  actualTopRight() {
    return new N(this.actualRight(), this.actualTop());
  },
  actualBottomLeft() {
    return new N(this.actualLeft(), this.actualBottom());
  },
  actualBottomRight() {
    return new N(this.actualRight(), this.actualBottom());
  },
  hash(e = 1e-5) {
    const n = 1 / e;
    return `${Math.round(this.x * n)}-${Math.round(this.y * n)}-${Math.round(this.width * n)}-${Math.round(this.height * n)}`;
  }
};
const IF = new N(), SF = new N();
function Ce(e = 1, n = 0, s = 0, i = 1, r = 0, o = 0) {
  this.a = e, this.b = n, this.c = s, this.d = i, this.tx = r, this.ty = o, this._array = null;
}
Ce.prototype = {
  constructor: Ce,
  /**
   * returns new Vector2
   * @param {Vector2} [r_out]
   * @returns {Vector2}
   */
  get_origin(e = new N()) {
    return e.set(this.tx, this.ty);
  },
  /**
   * @param {Vector2Like} value
   * @returns {this}
   */
  set_origin(e) {
    return this.tx = e.x, this.ty = e.y, this;
  },
  /**
   * @param {number} x
   * @param {number} y
   * @returns {this}
   */
  set_origin_n(e, n) {
    return this.tx = e, this.ty = n, this;
  },
  get_rotation() {
    return Math.atan2(this.b, this.a);
  },
  /**
   * @param {number} value
   * @returns {this}
   */
  set_rotation(e) {
    const n = Math.cos(e), s = Math.sin(e);
    return this.a = n, this.b = s, this.c = -s, this.d = n, this;
  },
  /**
   * returns new Vector2
   * @param {Vector2} [r_out]
   * @returns {Vector2}
   */
  get_scale(e = new N()) {
    const n = Math.sign(this.a * this.d - this.b * this.c);
    return e.x = Math.sqrt(this.a * this.a + this.b * this.b), e.y = Math.sqrt(this.c * this.c + this.d * this.d) * n, e;
  },
  /**
   * @param {Vector2Like} scale
   * @returns {this}
   */
  set_scale(e) {
    const n = new N();
    return n.set(this.a, this.b).normalize(), this.a = n.x * e.x, this.b = n.y * e.x, n.set(this.c, this.d).normalize(), this.c = n.x * e.y, this.d = n.y * e.y, this;
  },
  /**
   * @param {number} x
   * @param {number} y
   * @returns {this}
   */
  set_scale_n(e, n) {
    const s = new N();
    return s.set(this.a, this.b).normalize(), this.a = s.x * e, this.b = s.y * e, s.set(this.c, this.d).normalize(), this.c = s.x * n, this.d = s.y * n, this;
  },
  /**
   * @param {number} p_rot
   * @param {Vector2Like} p_scale
   * @returns {this}
   */
  set_rotation_and_scale(e, n) {
    const s = Math.cos(e), i = Math.sin(e);
    return this.a = s * n.x, this.d = s * n.y, this.c = -i * n.y, this.b = i * n.x, this;
  },
  /**
   * @param {number} rot
   * @param {Vector2Like} pos
   * @returns {this}
   */
  set_rotation_and_origin(e, n) {
    const s = Math.cos(e), i = Math.sin(e);
    return this.a = s, this.b = i, this.c = -i, this.d = s, this.tx = n.x, this.ty = n.y, this;
  },
  get_skew() {
    const e = vF, n = RF, s = this.basis_determinant();
    return Math.acos(
      e.set(this.a, this.b).normalize().dot(
        n.set(this.c, this.d).normalize().scale(Math.sign(s))
      )
    ) - Math.PI * 0.5;
  },
  /**
   * @param {number} p_angle
   * @returns {this}
   */
  set_skew(e) {
    const n = wF, s = this.basis_determinant();
    return n.set(this.a, this.b).rotate(Math.PI * 0.5 + e).normalize().scale(Math.sign(s) * Math.hypot(this.c, this.d)), this.c = n.x, this.d = n.y, this;
  },
  /**
   * @param {number} p_rot
   * @param {Vector2Like} p_scale
   * @param {number} p_skew
   * @returns {this}
   */
  set_rotation_scale_and_skew(e, n, s) {
    return this.a = Math.cos(e) * n.x, this.d = Math.cos(e + s) * n.y, this.c = -Math.sin(e + s) * n.y, this.b = Math.sin(e) * n.x, this;
  },
  /**
   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
   *
   * a = array[0]
   * b = array[1]
   * c = array[3]
   * d = array[4]
   * tx = array[2]
   * ty = array[5]
   *
   * @param {number[]} array - The array that the matrix will be populated from.
   * @returns {this}
   */
  fromArray(e) {
    return this.a = e[0], this.b = e[1], this.c = e[2], this.d = e[3], this.tx = e[4], this.ty = e[5], this;
  },
  /**
   * @returns {this}
   */
  reset() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  },
  /**
   * sets the matrix properties
   *
   * @param {number} [a] - Matrix component
   * @param {number} [b] - Matrix component
   * @param {number} [c] - Matrix component
   * @param {number} [d] - Matrix component
   * @param {number} [tx] - Matrix component
   * @param {number} [ty] - Matrix component
   *
   * @returns {this}
   */
  set(e = 1, n = 0, s = 0, i = 1, r = 0, o = 0) {
    return this.a = e, this.b = n, this.c = s, this.d = i, this.tx = r, this.ty = o, this;
  },
  /**
   * Creates an array from the current Matrix object.
   *
   * @param {boolean} [p_transpose=false] - Whether we need to transpose the matrix or not
   * @param {number[]} [out] - If provided the array will be assigned to out
   * @returns {number[]} the newly created array which contains the matrix
   */
  to_array(e = !1, n) {
    !n && !this._array && (this._array = new Array(9));
    const s = n || this._array;
    return e ? (s[0] = this.a, s[1] = this.c, s[2] = this.tx, s[3] = this.b, s[4] = this.d, s[5] = this.ty, s[6] = 0, s[7] = 0, s[8] = 1) : (s[0] = this.a, s[1] = this.b, s[2] = 0, s[3] = this.c, s[4] = this.d, s[5] = 0, s[6] = this.tx, s[7] = this.ty, s[8] = 1), s;
  },
  /**
   * @param {number} p_row
   * @returns {Vector2}
   */
  get_elements(e) {
    switch (e) {
      case 0:
        return new N(this.a, this.b);
      case 1:
        return new N(this.c, this.d);
      case 2:
        return new N(this.tx, this.ty);
    }
  },
  /**
   * @param {number} p_axis
   * @returns {Vector2}
   */
  get_axis(e) {
    switch (e) {
      case 0:
        return new N(this.a, this.b);
      case 1:
        return new N(this.c, this.d);
      case 2:
        return new N(this.tx, this.ty);
    }
  },
  basis_determinant() {
    return this.a * this.d - this.b * this.c;
  },
  /**
   * @param {Transform2D} p_xform
   * @returns {boolean}
   */
  equals(e) {
    return this.a === e.a && this.b === e.b && this.c === e.c && this.d === e.d && this.tx === e.tx && this.ty === e.ty;
  },
  /**
   * @param {Vector2Like} p_vec - The origin
   * @param {Vector2} [r_out] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {Vector2} The new point, transformed through this matrix
   */
  basis_xform(e, n = new N()) {
    const s = this.a * e.x + this.c * e.y, i = this.b * e.x + this.d * e.y;
    return n.set(s, i);
  },
  /**
   * @param {Vector2Like} p_vec - The origin
   * @param {Vector2} [r_out] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {Vector2} The new point, inverse-transformed through this matrix
   */
  basis_xform_inv(e, n = new N()) {
    const s = this.a * e.x + this.b * e.y, i = this.c * e.x + this.d * e.y;
    return n.set(s, i);
  },
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   *
   * @param {Vector2Like} p_vec - The origin
   * @param {Vector2} [r_out] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {Vector2} The new point, transformed through this matrix
   */
  xform(e, n = new N()) {
    const s = this.a * e.x + this.c * e.y + this.tx, i = this.b * e.x + this.d * e.y + this.ty;
    return n.set(s, i);
  },
  /**
   * Get a new Vector with the current transformation applied.
   *
   * @param {Vector2Like} p_vec - The vector
   * @param {Vector2} [r_out] - The vector that the new position is assigned to (allowed to be same as input)
   * @returns {Vector2} The new point, transformed through this matrix
   */
  xform_vec(e, n = new N()) {
    const s = this.xform(N.ZERO), i = this.xform(e, n);
    return i.sub(s), i;
  },
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   *
   * @param {Vector2Like} p_vec - The origin
   * @param {Vector2} [r_out] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {Vector2} The new point, inverse-transformed through this matrix
   */
  xform_inv(e, n = new N()) {
    const s = this.a * (e.x - this.tx) + this.b * (e.y - this.ty), i = this.c * (e.x - this.tx) + this.d * (e.y - this.ty);
    return n.set(s, i);
  },
  /**
   * @param {Rect2} p_rect
   * @param {Rect2} [r_out]
   * @returns {Rect2}
   */
  xform_rect(e, n = new ye()) {
    n.set(0, 0, 0, 0);
    const s = yF.set(this.a * e.width, this.b * e.width), i = CF.set(this.c * e.height, this.d * e.height), r = NF.set(e.x, e.y);
    this.xform(r, r), n.x = r.x, n.y = r.y;
    const o = xF.set(0, 0);
    return n.expand_to(o.copy(r).add(s)), n.expand_to(o.copy(r).add(i)), n.expand_to(o.copy(r).add(s).add(i)), n;
  },
  /**
   * @param {Rect2} p_rect
   * @param {Rect2} [r_out]
   * @returns {Rect2}
   */
  xform_inv_rect(e, n = new ye()) {
    const s = DF.set(e.x, e.y), i = LF.set(e.x, e.y + e.height), r = MF.set(e.x + e.width, e.y + e.height), o = PF.set(e.x + e.width, e.y);
    return this.xform_inv(s, s), this.xform_inv(i, i), this.xform_inv(r, r), this.xform_inv(o, o), n.x = s.x, n.y = s.y, n.expand_to(i), n.expand_to(r), n.expand_to(o), n;
  },
  /**
   * Translates the matrix on the x and y.
   *
   * @param {number} x How much to translate x by
   * @param {number} y How much to translate y by
   * @returns {this}
   */
  translate(e, n) {
    return this.tx += e, this.ty += n, this;
  },
  /**
   * Return a new Matrix that not translated.
   * @returns {Transform2D}
   */
  untranslated() {
    const e = this.clone();
    return e.tx = 0, e.ty = 0, e;
  },
  /**
   * Applies a scale transformation to the matrix.
   *
   * @param {number} x The amount to scale horizontally
   * @param {number} y The amount to scale vertically
   * @returns {this}
   */
  scale(e, n) {
    return this.a *= e, this.d *= n, this.c *= e, this.b *= n, this.tx *= e, this.ty *= n, this;
  },
  /**
   * @param {number} x
   * @param {number} y
   * @returns {this}
   */
  scale_basis(e, n) {
    return this.a *= e, this.b *= n, this.c *= e, this.d *= n, this;
  },
  /**
   * Warning! This function calculation has a bug, it's not working as expected.
   * Skews the matrix on the x and y
   *
   * @param {number} x
   * @param {number} y
   * @returns {this}
   */
  // skew(x, y) {
  //     const tX = Math.tan(y)
  //     const tY = Math.tan(x)
  //     this.b += tX
  //     this.c += tY
  //     this.tx += this.ty * tY
  //     this.ty += this.tx * tX
  //     return this
  // },
  /**
   * Applies a rotation transformation to the matrix.
   *
   * @param {number} angle - The angle in radians.
   * @returns {this}
   */
  rotate(e) {
    const n = Math.cos(e), s = Math.sin(e), i = this.a, r = this.c, o = this.tx;
    return this.a = i * n - this.b * s, this.b = i * s + this.b * n, this.c = r * n - this.d * s, this.d = r * s + this.d * n, this.tx = o * n - this.ty * s, this.ty = o * s + this.ty * n, this;
  },
  rotate_basis(e) {
    const n = Math.cos(e), s = Math.sin(e);
    return this.a = n * this.a + s * this.c, this.b = n * this.b + s * this.d, this.c = -s * this.a + n * this.c, this.d = -s * this.b + n * this.d, this;
  },
  /** Right Multiplication (Column Space) - start */
  /**
   * Translate current matrix accumulative.
   * Notice that it should only chain with other right multiplication, or it might not work as expected.
   * @param {number} tx - translation for x
   * @param {number} ty - translation for y
   * @returns {this}
   */
  translate_right(e, n) {
    return this.append(new Ce(1, 0, 0, 1, e, n)), this;
  },
  /**
   * Apply scale to the current matrix accumulative.
   * Notice that it should only chain with other right multiplication, or it might not work as expected.
   * @param {number} sx - scale factor x (1 does nothing)
   * @param {number} sy - scale factor y (1 does nothing)
   * @returns {this}
   */
  scale_right(e, n) {
    return this.append(new Ce(e, 0, 0, n, 0, 0)), this;
  },
  /**
   * Apply skew to the current matrix accumulative.
   * Notice that it should only chain with other right multiplication, or it might not work as expected.
   * @param {number} sx - amount of skew for x
   * @param {number} sy - amount of skew for y
   * @returns {this}
   * */
  skew_right(e, n) {
    return this.append(new Ce(1, Math.tan(n), Math.tan(e), 1, 0, 0)), this;
  },
  /**
   * Apply rotate to current matrix accumulative.
   * Notice that it should only chain with other right multiplication, or it might not work as expected.
   * @param {number} angle - angle in radians
   * @returns {this}
   */
  rotate_right(e) {
    const n = Math.cos(e), s = Math.sin(e);
    return this.append(new Ce(n, s, -s, n, 0, 0)), this;
  },
  /** Right Multiplication (Column Space) - end */
  /**
   * Invert this matrix.
   * This method assumes the basis is a rotation matrix, with no scaling.
   * Use affine_inverse instead if scaling is required.
   * @returns {this}
   */
  invert() {
    const e = this.b;
    this.b = this.c, this.c = e;
    const n = this.a * -this.tx + this.c * -this.ty, s = this.b * -this.tx + this.d * -this.ty;
    return this.tx = n, this.ty = s, this;
  },
  /**
   * Return a inverted matrix
   * @returns {Transform2D}
   */
  inverse() {
    return this.clone().invert();
  },
  /**
   * @returns {this}
   */
  orthonormalize() {
    const e = new N(this.a, this.b), n = new N(this.c, this.d);
    return e.normalize(), this.a = e.x, this.b = e.y, n.subtract(e.scale(e.dot(n))), n.normalize(), this.c = n.x, this.d = n.y, this;
  },
  orthonormalized() {
    return this.clone().orthonormalize();
  },
  /**
   * @param {Transform2D} matrix
   * @returns {this}
   * */
  append(e) {
    const n = this.a, s = this.b, i = this.c, r = this.d;
    return this.a = e.a * n + e.b * i, this.b = e.a * s + e.b * r, this.c = e.c * n + e.d * i, this.d = e.c * s + e.d * r, this.tx = e.tx * n + e.ty * i + this.tx, this.ty = e.tx * s + e.ty * r + this.ty, this;
  },
  /**
   * Sets the matrix based on all the available properties
   *
   * @param {number} x - Position on the x axis
   * @param {number} y - Position on the y axis
   * @param {number} pivot_x - Pivot on the x axis
   * @param {number} pivot_y - Pivot on the y axis
   * @param {number} scale_x - Scale on the x axis
   * @param {number} scale_y - Scale on the y axis
   * @param {number} rotation - Rotation in radians
   * @param {number} skew_x - Skew on the x axis
   * @param {number} skew_y - Skew on the y axis
   * @returns {this}
   */
  set_transform(e, n, s, i, r, o, a, c, l) {
    return this.a = Math.cos(a + l) * r, this.b = Math.sin(a + l) * r, this.c = -Math.sin(a - c) * o, this.d = Math.cos(a - c) * o, this.tx = e - (s * this.a + i * this.c), this.ty = n - (s * this.b + i * this.d), this;
  },
  /**
   * Prepends the given Matrix to this Matrix (`Matrix_A *= Matrix_B` in Godot)
   *
   * @param {Transform2D} xform - The matrix to prepend
   * @returns {this}
   */
  prepend(e) {
    const n = this.tx;
    if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
      const s = this.a, i = this.c;
      this.a = s * e.a + this.b * e.c, this.b = s * e.b + this.b * e.d, this.c = i * e.a + this.d * e.c, this.d = i * e.b + this.d * e.d;
    }
    return this.tx = n * e.a + this.ty * e.c + e.tx, this.ty = n * e.b + this.ty * e.d + e.ty, this;
  },
  /**
   * Inverts this matrix
   *
   * @returns {this}
   */
  affine_inverse() {
    const e = this.a * this.d - this.b * this.c;
    if (e === 0)
      return this.pseudoInverseAffine();
    const n = 1 / e, s = this.d;
    this.d = this.a, this.a = s, this.a *= n, this.b *= -n, this.c *= -n, this.d *= n;
    const i = this.a * -this.tx + this.c * -this.ty, r = this.b * -this.tx + this.d * -this.ty;
    return this.tx = i, this.ty = r, this;
  },
  /**
   * Return Pseudo-inverse ( Moore-Penrose inverse ) when the matrix is uninvertible
   * It is the closest to an inverse, even for non-square matrices.
   * @returns {this}
   */
  pseudoInverseAffine() {
    const e = this.a * this.a + this.b * this.b, n = this.c * this.c + this.d * this.d;
    if (e === 0 && n === 0)
      return this.tx *= -1, this.ty *= -1, this;
    e === 0 ? (this.a = 0, this.b /= n, this.c = 0, this.d /= n) : (this.a /= e, this.b = 0, this.c /= e, this.d = 0);
    const s = this.a * -this.tx + this.c * -this.ty, i = this.b * -this.tx + this.d * -this.ty;
    return this.tx = s, this.ty = i, this;
  },
  /**
   * Resets this Matix to an identity (default) matrix.
   *
   * @returns {this}
   */
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  },
  /**
   * @param {Transform2D} p_transform
   * @param {number} p_c
   * @returns {Transform2D}
   */
  interpolate(e, n) {
    const s = Ss.lerp(this.get_scale().x, e.get_scale().x, n), i = Ss.lerp(this.get_scale().y, e.get_scale().y, n), r = Ss.lerp_angle(this.get_rotation(), e.get_rotation(), n), o = Ss.lerp(this.get_origin().x, e.get_origin().x, n), a = Ss.lerp(this.get_origin().y, e.get_origin().y, n);
    return this.set_transform(o, a, 0, 0, s, i, r, 0, 0), this;
  },
  /**
   * Creates a new Matrix object with the same values as this one.
   *
   * @returns {Transform2D}
   */
  clone() {
    return new Ce(
      this.a,
      this.b,
      this.c,
      this.d,
      this.tx,
      this.ty
    );
  },
  /**
   * Copy the values of given matrix to this one.
   *
   * @param {Transform2D} matrix - The matrix to copy from.
   * @returns {this}
   */
  copy(e) {
    return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this;
  },
  /**
   * Works only when transforms are applied in this order: scale, skew, rotate, translate
   * Reference: https://stackoverflow.com/a/45392997
   *
   * @returns {DecomposeResult}
   */
  decompose2() {
    const e = this;
    let n = 0;
    const s = new N(), i = new N();
    n = Math.atan2(this.b, this.a);
    const r = Math.atan2(this.d, this.c) - Math.PI / 2 - n;
    return i.set(-r, 0), s.set(Math.sqrt(this.a * this.a + this.b * this.b), Math.sqrt(this.c * this.c + this.d * this.d) * Math.cos(r)), {
      translation: new N(e.tx, e.ty),
      rotation: n,
      scale: s,
      skew: i
    };
  },
  /**
   * @returns {DecomposeResult}
   */
  decompose() {
    const e = this.a, n = this.b, s = this.c, i = this.d, r = this.tx, o = this.ty, a = e * i - n * s, c = Math.sqrt(e * e + n * n), l = {
      translation: new N(r, o),
      rotation: 0,
      scale: new N(1, 1),
      skew: new N(0, 0)
    };
    return e === n && n === s && s === i ? (l.rotation = 0, l.skew.x = 0, l.scale.x = 0, l.scale.y = 0) : e === 0 && n === 0 ? (l.rotation = -Math.atan2(s, i), l.skew.x = 0, l.scale.x = 0, l.scale.y = Math.sqrt(s * s + i * i)) : s === 0 && i === 0 ? (l.rotation = -Math.atan2(-n, e), l.skew.x = 0, l.scale.x = c, l.scale.y = 0) : (l.rotation = -Math.atan2(-n, e), l.skew.x = Math.atan2(e * s + n * i, a), l.scale.x = c, l.scale.y = a / c), l;
  }
};
Ce.IDENTITY = new Ce();
const yF = new N(), CF = new N(), NF = new N(), xF = new N(), vF = new N(), RF = new N(), wF = new N(), DF = new N(), LF = new N(), MF = new N(), PF = new N();
function bF(e, n, s, i, r, o, a, c) {
  const l = [
    e.clone().sub(n),
    e.clone().sub(s),
    o.clone().sub(c),
    o.clone().sub(r)
  ];
  let h = !0;
  for (const d of l)
    h && !UF(
      d,
      e,
      n,
      s,
      i,
      r,
      o,
      a,
      c
    ) && (h = !1);
  return h;
}
function UF(e, n, s, i, r, o, a, c, l) {
  const h = 1 / e.length_squared(), d = e.dot(n) * h, p = e.dot(s) * h, E = e.dot(i) * h, g = e.dot(r) * h, T = e.dot(o) * h, A = e.dot(a) * h, m = e.dot(c) * h, O = e.dot(l) * h, S = Math.min(d, p, E, g), y = Math.max(d, p, E, g), v = Math.min(T, A, m, O), R = Math.max(T, A, m, O);
  return S <= R && y >= v;
}
const GF = 0.02, FF = 256, nE = 1e-3, Qt = 0.1, Es = Qt * 0.9995, Ru = 1e3, RI = {
  color: 8947848,
  padding: 5
}, kF = 65535, Os = {
  line: 1,
  quadratic: 2,
  serpentine: 3,
  cusp: 4,
  loop: 5,
  arch: 6
}, BF = 1e-8;
function wu(e, n, s, i) {
  return e[0] = n, e[1] = s, e[2] = i, e;
}
function sE(e, n, s) {
  const i = n[0], r = n[1], o = n[2], a = s[0], c = s[1], l = s[2];
  return e[0] = r * l - o * c, e[1] = o * a - i * l, e[2] = i * c - r * a, e;
}
function iE(e, n) {
  return e[0] * n[0] + e[1] * n[1] + e[2] * n[2];
}
function _l(e) {
  return e >= 0 ? e < BF : e > -1e-8;
}
const Du = [0, 0, 0], rE = [0, 0, 0], oE = [0, 0, 0], aE = [0, 0, 0], wI = [0, 0], DI = [0, 0], LI = [0, 0];
function VF(e, n, s, i, r, o, a, c) {
  wu(Du, e, n, 1), wu(rE, s, i, 1), wu(oE, r, o, 1), wu(aE, a, c, 1), sE(wI, aE, oE), sE(DI, Du, aE), sE(LI, rE, Du);
  const l = iE(Du, wI), h = iE(rE, DI), d = iE(oE, LI), p = l - 2 * h + 3 * d, E = -h + 3 * d, g = 3 * d, T = 3 * E * E - 4 * p * g, A = p * p * T;
  return _l(A) ? _l(p) && _l(E) ? _l(g) ? Os.line : Os.quadratic : _l(p) ? T < 0 ? Os.loop : Os.serpentine : Os.cusp : A > 0 ? Os.serpentine : Os.loop;
}
const HF = [
  [0.5773502691896257],
  [0, 0.7745966692414834],
  [0.33998104358485626, 0.8611363115940526],
  [0, 0.5384693101056831, 0.906179845938664],
  [0.2386191860831969, 0.6612093864662645, 0.932469514203152],
  [0, 0.4058451513773972, 0.7415311855993945, 0.9491079123427585],
  [0.1834346424956498, 0.525532409916329, 0.7966664774136267, 0.9602898564975363],
  [0, 0.3242534234038089, 0.6133714327005904, 0.8360311073266358, 0.9681602395076261],
  [0.14887433898163122, 0.4333953941292472, 0.6794095682990244, 0.8650633666889845, 0.9739065285171717],
  [0, 0.26954315595234496, 0.5190961292068118, 0.7301520055740494, 0.8870625997680953, 0.978228658146057],
  [0.1252334085114689, 0.3678314989981802, 0.5873179542866175, 0.7699026741943047, 0.9041172563704749, 0.9815606342467192],
  [0, 0.2304583159551348, 0.44849275103644687, 0.6423493394403402, 0.8015780907333099, 0.9175983992229779, 0.9841830547185881],
  [0.10805494870734367, 0.31911236892788974, 0.5152486363581541, 0.6872929048116855, 0.827201315069765, 0.9284348836635735, 0.9862838086968123],
  [0, 0.20119409399743451, 0.3941513470775634, 0.5709721726085388, 0.7244177313601701, 0.8482065834104272, 0.937273392400706, 0.9879925180204854],
  [0.09501250983763744, 0.2816035507792589, 0.45801677765722737, 0.6178762444026438, 0.755404408355003, 0.8656312023878318, 0.9445750230732326, 0.9894009349916499]
], WF = [
  [1],
  [0.8888888888888888, 0.5555555555555556],
  [0.6521451548625461, 0.34785484513745385],
  [0.5688888888888889, 0.47862867049936647, 0.23692688505618908],
  [0.46791393457269104, 0.3607615730481386, 0.17132449237917036],
  [0.4179591836734694, 0.3818300505051189, 0.27970539148927664, 0.1294849661688697],
  [0.362683783378362, 0.31370664587788727, 0.22238103445337448, 0.10122853629037626],
  [0.3302393550012598, 0.31234707704000286, 0.26061069640293544, 0.1806481606948574, 0.08127438836157441],
  [0.29552422471475287, 0.26926671930999635, 0.21908636251598204, 0.1494513491505806, 0.06667134430868814],
  [0.2729250867779006, 0.26280454451024665, 0.23319376459199048, 0.18629021092773426, 0.1255803694649046, 0.05566856711617366],
  [0.24914704581340277, 0.2334925365383548, 0.20316742672306592, 0.16007832854334622, 0.10693932599531843, 0.04717533638651183],
  [0.2325515532308739, 0.22628318026289723, 0.2078160475368885, 0.17814598076194574, 0.13887351021978725, 0.09212149983772845, 0.04048400476531588],
  [0.2152638534631578, 0.2051984637212956, 0.18553839747793782, 0.15720316715819355, 0.12151857068790319, 0.08015808715976021, 0.03511946033175186],
  [0.2025782419255613, 0.19843148532711158, 0.1861610000155622, 0.16626920581699392, 0.13957067792615432, 0.10715922046717194, 0.07036604748810812, 0.03075324199611727],
  [0.1894506104550685, 0.18260341504492358, 0.16915651939500254, 0.14959598881657674, 0.12462897125553388, 0.09515851168249279, 0.062253523938647894, 0.027152459411754096]
], $n = Math.abs, MI = Math.sqrt, PI = Math.pow, YF = Math.log2 || function(e) {
  return Math.log(e) * Math.LOG2E;
}, Tl = (e, n, s) => e < n ? n : e > s ? s : e, Zn = {
  getDiscriminant(e, n, s) {
    function i(a) {
      const c = a * 134217729, h = a - c + c, d = a - h;
      return [h, d];
    }
    let r = n * n - e * s;
    const o = n * n + e * s;
    if ($n(r) * 3 < o) {
      const a = i(e), c = i(n), l = i(s), h = n * n, d = c[0] * c[0] - h + 2 * c[0] * c[1] + c[1] * c[1], p = e * s, E = a[0] * l[0] - p + a[0] * l[1] + a[1] * l[0] + a[1] * l[1];
      r = h - p + (d - E);
    }
    return r;
  },
  getNormalizationFactor(...e) {
    const n = Math.max(...e);
    return n && (n < 1e-8 || n > 1e8) ? PI(2, -Math.round(YF(n))) : 0;
  },
  /**
   * Checks if the value is 0, within a tolerance defined by
   * EPSILON.
   * @param {number} val
   * @returns {boolean}
   */
  isZero: function(e) {
    return e >= -1e-12 && e <= Qn;
  },
  isMachineZero: function(e) {
    return e >= -112e-18 && e <= Bp;
  },
  /**
   * Returns a number whose value is clamped by the given range.
   *
   * @param {number} value the value to be clamped
   * @param {number} min the lower boundary of the range
   * @param {number} max the upper boundary of the range
   * @returns {number} a number in the range of [min, max]
   */
  clamp: Tl,
  /**
   * Gauss-Legendre Numerical Integration.
   *
   * @param {Function} f
   * @param {number} a
   * @param {number} b
   * @param {Function} n
   */
  integrate: function(e, n, s, i) {
    let r = 0;
    const o = HF[i - 2], a = WF[i - 2], c = (s - n) * 0.5, l = c + n, h = i + 1 >> 1;
    let d = i & 1 ? a[r++] * e(l) : 0;
    for (; r < h; ) {
      const p = c * o[r];
      d += a[r++] * (e(l + p) + e(l - p));
    }
    return c * d;
  },
  /**
   * Root finding using Newton-Raphson Method combined with Bisection.
   * @param {(t: number) => number} f
   * @param {(t: number) => number} df
   * @param {number} x
   * @param {number} a
   * @param {number} b
   * @param {number} n
   * @param {number} tolerance
   */
  findRoot: function(e, n, s, i, r, o, a) {
    for (let c = 0; c < o; c++) {
      const l = e(s), h = l / n(s), d = s - h;
      if ($n(h) < a) {
        s = d;
        break;
      }
      l > 0 ? (r = s, s = d <= i ? (i + r) * 0.5 : d) : (i = s, s = d >= r ? (i + r) * 0.5 : d);
    }
    return Tl(s, i, r);
  },
  /**
   * Solve a quadratic equation in a numerically robust manner;
   * given a quadratic equation ax² + bx + c = 0, find the values of x.
   *
   * References:
   *  Kahan W. - "To Solve a Real Cubic Equation"
   *  http://www.cs.berkeley.edu/~wkahan/Math128/Cubic.pdf
   *  Blinn J. - "How to solve a Quadratic Equation"
   *  Harikrishnan G.
   *  https://gist.github.com/hkrish/9e0de1f121971ee0fbab281f5c986de9
   *
   * @param {number} a the quadratic term
   * @param {number} b the linear term
   * @param {number} c the constant term
   * @param {number[]} roots the array to store the roots in
   * @param {number} [min] the lower bound of the allowed roots
   * @param {number} [max] the upper bound of the allowed roots
   * @returns {number} the number of real roots found, or -1 if there are
   * infinite solutions
   *
   * @author Harikrishnan Gopalakrishnan <hari.exeption@gmail.com>
   */
  solveQuadratic: function(e, n, s, i, r, o) {
    let a, c = 1 / 0;
    if ($n(e) < Qn) {
      if ($n(n) < Qn)
        return $n(s) < Qn ? -1 : 0;
      a = -s / n;
    } else {
      n *= -0.5;
      let E = Zn.getDiscriminant(e, n, s);
      if (E && $n(E) < Bp) {
        const g = Zn.getNormalizationFactor($n(e), $n(n), $n(s));
        g && (e *= g, n *= g, s *= g, E = Zn.getDiscriminant(e, n, s));
      }
      if (E >= -112e-18) {
        const g = E < 0 ? 0 : MI(E), T = n + (n < 0 ? -g : g);
        T === 0 ? (a = s / e, c = -a) : (a = T / e, c = s / T);
      }
    }
    let l = 0;
    const h = r == null, d = r - Qn, p = o + Qn;
    return isFinite(a) && (h || a > d && a < p) && (i[l++] = h ? a : Tl(a, r, o)), c !== a && isFinite(c) && (h || c > d && c < p) && (i[l++] = h ? c : Tl(c, r, o)), l;
  },
  /**
   * Solve a cubic equation, using numerically stable methods,
   * given an equation of the form ax³ + bx² + cx + d = 0.
   *
   * This algorithm avoids the trigonometric/inverse trigonometric
   * calculations required by the "Italins"' formula. Cardano's method
   * works well enough for exact computations, this method takes a
   * numerical approach where the double precision error bound is kept
   * very low.
   *
   * References:
   *  Kahan W. - "To Solve a Real Cubic Equation"
   *   http://www.cs.berkeley.edu/~wkahan/Math128/Cubic.pdf
   *  Harikrishnan G.
   *  https://gist.github.com/hkrish/9e0de1f121971ee0fbab281f5c986de9
   *
   * W. Kahan's paper contains inferences on accuracy of cubic
   * zero-finding methods. Also testing methods for robustness.
   *
   * @param {number} a the cubic term (x³ term)
   * @param {number} b the quadratic term (x² term)
   * @param {number} c the linear term (x term)
   * @param {number} d the constant term
   * @param {number[]} roots the array to store the roots in
   * @param {number} [min] the lower bound of the allowed roots
   * @param {number} [max] the upper bound of the allowed roots
   * @returns {number} the number of real roots found, or -1 if there are
   * infinite solutions
   *
   * @author Harikrishnan Gopalakrishnan <hari.exeption@gmail.com>
   */
  solveCubic: function(e, n, s, i, r, o, a) {
    const c = Zn.getNormalizationFactor($n(e), $n(n), $n(s), $n(i));
    let l, h, d, p, E;
    c && (e *= c, n *= c, s *= c, i *= c);
    function g(m) {
      l = m;
      const O = e * l;
      h = O + n, d = h * l + s, p = (O + h) * l + d, E = d * l + i;
    }
    if ($n(e) < Qn)
      e = n, h = s, d = i, l = 1 / 0;
    else if ($n(i) < Qn)
      h = n, d = s, l = 0;
    else {
      g(-(n / e) / 3);
      const m = E / e, O = PI($n(m), 1 / 3), S = m < 0 ? -1 : 1, y = -p / e, v = y > 0 ? 1.324717957244746 * Math.max(O, MI(y)) : O;
      let R = l - S * v;
      if (R !== l) {
        do
          g(R), R = p === 0 ? l : l - E / p / (1 + Bp);
        while (S * R > S * l);
        $n(e) * l * l > $n(i / l) && (d = -i / l, h = (d - s) / l);
      }
    }
    let T = Zn.solveQuadratic(e, h, d, r, o, a);
    const A = o == null;
    return isFinite(l) && (T === 0 || T > 0 && l !== r[0] && l !== r[1]) && (A || l > o - Qn && l < a + Qn) && (r[T++] = A ? l : Tl(l, o, a)), T;
  }
};
function qn() {
  this._px = void 0, this._py = void 0, this._vx = void 0, this._vy = void 0;
}
qn.intersect = (e, n, s, i, r, o, a, c, l, h) => {
  l || (s -= e, i -= n, a -= r, c -= o);
  const d = s * c - i * a;
  if (!Zn.isMachineZero(d)) {
    const p = e - r, E = n - o;
    let g = (a * E - c * p) / d;
    const T = (s * E - i * p) / d, A = Qn, m = -1e-12, O = 1 + A;
    if (h || m < g && g < O && m < T && T < O)
      return h || (g = g <= 0 ? 0 : g >= 1 ? 1 : g), new N(
        e + g * s,
        n + g * i
      );
  }
};
qn.getSide = (e, n, s, i, r, o, a, c) => {
  a || (s -= e, i -= n);
  const l = r - e, h = o - n;
  let d = l * i - h * s;
  return !c && Zn.isMachineZero(d) && (d = (l * s + l * s) / (s * s + i * i), d >= 0 && d <= 1 && (d = 0)), d < 0 ? -1 : d > 0 ? 1 : 0;
};
qn.getSignedDistance = (e, n, s, i, r, o, a) => (a || (s -= e, i -= n), s === 0 ? i > 0 ? r - e : e - r : i === 0 ? s < 0 ? o - n : n - o : ((r - e) * i - (o - n) * s) / (i > s ? i * bI(1 + s * s / (i * i)) : s * bI(1 + i * i / (s * s))));
qn.getDistance = (e, n, s, i, r, o, a) => qy(qn.getSignedDistance(e, n, s, i, r, o, a));
qn.prototype = {
  constructor: qn,
  /**
   * @param {number} p0x
   * @param {number} p0y
   * @param {number} p1x
   * @param {number} p1y
   */
  initN(e, n, s, i) {
    return this._px = e, this._py = n, this._vx = s - e, this._vy = i - n, this;
  },
  /**
   * @param {Vector2Like} p0
   * @param {Vector2Like} p1
   */
  initP(e, n) {
    return this.initN(e.x, e.y, n.x, n.y);
  },
  /**
   * The start point of the line.
   */
  getP0() {
    return new N(this._px, this._py);
  },
  /**
   * The end point of the line.
   */
  getP1() {
    return new N(this._px + this._vx, this._py + this._vy);
  },
  /**
   * The direction of the line as a vector.
   */
  getVector() {
    return new N(this._vx, this._vy);
  },
  /**
   * The length of the line.
   */
  getLength() {
    return this.getVector().length();
  },
  /**
   * @param {Line} line
   * @param {boolean} [isInfinite=false]
   * @returns the intersection point of the lines, `undefined` if the
   *     two lines are collinear, or `null` if they don't intersect.
   */
  intersect(e, n) {
    return qn.intersect(
      this._px,
      this._py,
      this._vx,
      this._vy,
      e._px,
      e._py,
      e._vx,
      e._vy,
      !0,
      n
    );
  },
  /**
   * @param {Vector2} point
   * @param {boolean} [isInfinite=false]
   */
  getSide(e, n) {
    return qn.getSide(
      this._px,
      this._py,
      this._vx,
      this._vy,
      e.x,
      e.y,
      !0,
      n
    );
  },
  /**
   * @param {Vector2} point
   */
  getDistance(e) {
    return qy(this.getSignedDistance(e));
  },
  /**
   * @param {Vector2} point
   */
  getSignedDistance(e) {
    return qn.getSignedDistance(
      this._px,
      this._py,
      this._vx,
      this._vy,
      e.x,
      e.y,
      !0
    );
  },
  /**
   * @param {Line} line
   */
  isCollinear(e) {
    return N.isCollinear(this._vx, this._vy, e._vx, e._vy);
  },
  /**
   * @param {Line} line
   */
  isOrthogonal(e) {
    return N.isOrthogonal(this._vx, this._vy, e._vx, e._vy);
  },
  /**
   * @param {number} t
   */
  eval(e) {
    return new N(
      this._px + Ss.lerp(0, this._vx, e),
      this._py + Ss.lerp(0, this._vy, e)
    );
  },
  /**
   * @param {Vector2} p
   * @param {number} _accuracy
   */
  // eslint-disable-next-line no-unused-vars
  nearest(e, n) {
    const s = this.getP0(), i = this.getVector(), r = s.clone().add(i), o = i.dot(e.clone().sub(s)), a = i.dot(i);
    let c = 0, l = 0;
    return o <= 0 ? (c = 0, l = e.distance_squared_to(s)) : o >= a ? (c = 1, l = e.distance_squared_to(r)) : (c = o / a, l = this.eval(c).sub(e).length_squared()), { distance_sq: l, t: c };
  }
};
const qy = Math.abs, bI = Math.sqrt, UI = Math.min, GI = Math.max;
function XF(e, n, s) {
  function i(a) {
    const c = new Array(a.length);
    for (let l = 0; l < a.length; l++) {
      const h = a[l].getBounds();
      c[l] = [h.left, h.top, h.right, h.bottom];
    }
    return c;
  }
  const r = i(e);
  return Ju(r, r, s);
}
function jy(e, n, s, i) {
  const r = (c) => {
    const l = Array(c.length);
    for (let h = 0; h < c.length; h++) {
      const d = c[h];
      l[h] = [
        UI(d[0], d[2], d[4], d[6]),
        UI(d[1], d[3], d[5], d[7]),
        GI(d[0], d[2], d[4], d[6]),
        GI(d[1], d[3], d[5], d[7])
      ];
    }
    return l;
  }, o = r(e), a = !n || n === e ? o : r(n);
  if (i) {
    const c = Ju(
      o,
      a,
      s || 0,
      !1,
      !0
    ), l = Ju(
      o,
      a,
      s || 0,
      !0,
      !0
    ), h = [];
    for (let d = 0, p = c.length; d < p; d++)
      h[d] = { hor: c[d], ver: l[d] };
    return h;
  }
  return Ju(o, a, s || 0);
}
function Ju(e, n, s, i, r) {
  const o = !n || e === n, a = o ? e : e.concat(n), c = e.length, l = a.length, h = (O, S, y) => {
    let v = 0, R = O.length;
    for (; v < R; ) {
      const M = R + v >>> 1;
      a[O[M]][S] < y ? v = M + 1 : R = M;
    }
    return v - 1;
  }, d = i ? 1 : 0, p = d + 2, E = i ? 0 : 1, g = E + 2, T = Array(l);
  for (let O = 0; O < l; O++)
    T[O] = O;
  T.sort(function(O, S) {
    return a[O][d] - a[S][d];
  });
  const A = [], m = Array(c);
  for (let O = 0; O < l; O++) {
    const S = T[O], y = a[S], v = o ? S : S - c, R = S < c, M = o || !R;
    let L = R ? [] : null;
    if (A.length) {
      const P = h(
        A,
        p,
        y[d] - s
      ) + 1;
      if (A.splice(0, P), o && r) {
        L = L.concat(A);
        for (let k = 0; k < A.length; k++) {
          const Q = A[k];
          m[Q].push(v);
        }
      } else {
        const k = y[g], Q = y[E];
        for (let b = 0; b < A.length; b++) {
          const X = A[b], K = a[X], V = X < c, J = o || X >= c;
          // eslint-disable-next-line no-mixed-operators
          (r || (R && J || M && V) && k >= K[E] - s && Q <= K[g] + s) && (R && J && L.push(o ? X : X - c), M && V && m[X].push(v));
        }
      }
    }
    if (R && (e === n && L.push(S), m[S] = L), A.length) {
      const P = y[p], k = h(A, p, P);
      A.splice(k + 1, 0, S);
    } else
      A.push(S);
  }
  for (let O = 0; O < m.length; O++) {
    const S = m[O];
    S && S.sort(function(y, v) {
      return y - v;
    });
  }
  return m;
}
const Ca = {
  // Anything affecting the appearance of an item, including GEOMETRY,
  // STROKE, STYLE and ATTRIBUTE (except for the invisible ones: locked, name)
  APPEARANCE: 1,
  // Item geometry (path, bounds)
  GEOMETRY: 8,
  // Only segment(s) have changed, and affected curves have already been
  // notified. This is to implement an optimization in _changed() calls
  SEGMENTS: 32
  // // Stroke geometry (excluding color)
  // STROKE: 0x40,
  // // Fill style or stroke color / dash
  // STYLE: 0x80,
  // // Item attributes: visible, blendMode, locked, name, opacity, clipMask ...
  // ATTRIBUTE: 0x100,
  // // Text content
  // CONTENT: 0x200,
  // // Raster pixels
  // PIXELS: 0x400,
  // // Clipping in one of the child items
  // CLIPPING: 0x800,
  // // The view has been transformed
  // VIEW: 0x1000
}, Ml = {
  GEOMETRY: Ca.GEOMETRY | Ca.APPEARANCE,
  SEGMENTS: Ca.SEGMENTS | Ca.GEOMETRY | Ca.APPEARANCE
  // STROKE: ChangeFlag.STROKE | ChangeFlag.STYLE | ChangeFlag.APPEARANCE,
  // STYLE: ChangeFlag.STYLE | ChangeFlag.APPEARANCE,
  // ATTRIBUTE: ChangeFlag.ATTRIBUTE | ChangeFlag.APPEARANCE,
  // CONTENT: ChangeFlag.CONTENT | ChangeFlag.GEOMETRY | ChangeFlag.APPEARANCE,
  // PIXELS: ChangeFlag.PIXELS | ChangeFlag.APPEARANCE,
  // VIEW: ChangeFlag.VIEW | ChangeFlag.APPEARANCE
};
function Fe() {
  this._point = new N(), this._handleIn = new N(), this._handleOut = new N(), this._path = null, this._intersection = null, this._index = null, this._winding = null, this._visited = null;
}
Fe.prototype = {
  constructor: Fe,
  /**
   * @param {Vector2Like} point
   */
  initP(e) {
    return this.initN(e.x, e.y);
  },
  /**
   * @param {number} x
   * @param {number} y
   */
  initN(e, n) {
    return this._point.set(e, n), this._handleIn.set(0, 0), this._handleOut.set(0, 0), this._changed(this._point), this._changed(this._handleIn), this._changed(this._handleOut), this;
  },
  /**
   * @param {Vector2Like} point
   * @param {Vector2Like | null} handleIn
   * @param {Vector2Like | null} handleOut
   */
  initWithPoints(e, n, s) {
    return this._point.set(e.x, e.y), this._changed(this._point), n && (this._handleIn.set(n.x, n.y), this._changed(this._handleIn)), s && (this._handleOut.set(s.x, s.y), this._changed(this._handleOut)), this;
  },
  /**
   * @param {number} x
   * @param {number} y
   * @param {number} inX
   * @param {number} inY
   * @param {number} outX
   * @param {number} outY
   */
  initWithPointsN(e, n, s, i, r, o) {
    return this._point.set(e, n), this._handleIn.set(s, i), this._handleOut.set(r, o), this._changed(this._point), this._changed(this._handleIn), this._changed(this._handleOut), this;
  },
  /**
   * @param {Vector2Like} point
   */
  setPoint(e) {
    this._point.set(e.x, e.y), this._changed(this._point);
  },
  /**
   * @param {Vector2Like} handleIn
   */
  setHandleIn(e) {
    this._handleIn.set(e.x, e.y), this._changed(this._handleIn);
  },
  /**
   * @param {number} x
   * @param {number} y
   */
  setHandleInN(e, n) {
    this._handleIn.set(e, n), this._changed(this._handleIn);
  },
  /**
   * @param {Vector2Like} handleOut
   */
  setHandleOut(e) {
    this._handleOut.set(e.x, e.y), this._changed(this._handleOut);
  },
  /**
   * @param {number} x
   * @param {number} y
   */
  setHandleOutN(e, n) {
    this._handleOut.set(e, n), this._changed(this._handleOut);
  },
  /**
   * @param {Segment} other
   */
  copy(e) {
    return this.initWithPoints(e._point, e._handleIn, e._handleOut);
  },
  clone() {
    return new Fe().initWithPoints(this._point, this._handleIn, this._handleOut);
  },
  remove() {
    return this._path ? !!this._path.removeSegment(this._index) : !1;
  },
  isFirst() {
    return !this._index;
  },
  isLast() {
    const e = this._path;
    return e && this._index === e._segments.length - 1 || !1;
  },
  getPrevious() {
    const e = this._path && this._path._segments;
    return e && (e[this._index - 1] || this._path._closed && e[e.length - 1]) || null;
  },
  getNext() {
    const e = this._path && this._path._segments;
    return e && (e[this._index + 1] || this._path._closed && e[0]) || null;
  },
  /**
   * The curve that the segment belongs to. For the last segment of an open
   * path, the previous segment is returned.
   */
  getCurve() {
    const e = this._path;
    let n = this._index;
    return e ? (n > 0 && !e._closed && n === e._segments.length - 1 && n--, e.getCurves()[n] || null) : null;
  },
  /**
   * @param {number} tolerance
   */
  hasHandles(e) {
    return !this._handleIn.is_zero(e) || !this._handleOut.is_zero(e);
  },
  /**
   * @param {number[]} coords
   */
  _transformCoordinates(e) {
    const n = this._point.x, s = this._point.y;
    let i = 2;
    return e[0] = n, e[1] = s, this._handleIn && (e[i++] = this._handleIn.x + n, e[i++] = this._handleIn.y + s), this._handleOut && (e[i++] = this._handleOut.x + n, e[i++] = this._handleOut.y + s), e;
  },
  /**
   * If segment's _point, _handlIn or _handleOut updated, should trigger this to refresh relate cache data
   * @param {Vector2} point
   */
  _changed(e) {
    const n = this._path;
    if (!n) return;
    const s = n._curves, i = this._index;
    let r;
    s && ((!e || e === this._point || e === this._handleIn) && (r = i > 0 ? s[i - 1] : n._closed ? s[s.length - 1] : null) && r._changed(), (!e || e === this._point || e === this._handleOut) && (r = s[i]) && r._changed()), n._changed(Ml.SEGMENTS);
  },
  toString() {
    return `Segment{ p:[${this._point.x}, ${this._point.y}], i:[${this._handleIn.x}, ${this._handleIn.y}], o:[${this._handleOut.x}, ${this._handleOut.y}] }`;
  }
};
function wd() {
  this.p0 = new N(), this.p1 = new N(), this.p2 = new N(), this._bounds = null;
}
wd.prototype = {
  constructor: wd,
  /**
   * @param {number} p0x
   * @param {number} p0y
   * @param {number} cx
   * @param {number} cy
   * @param {number} p1x
   * @param {number} p1y
   */
  initN(e, n, s, i, r, o) {
    return this.p0.set(e, n), this.p1.set(s, i), this.p2.set(r, o), this;
  },
  /**
   * @param {number} t
   */
  eval(e) {
    const n = 1 - e;
    return this.p0.clone().scale(n * n).add(
      this.p1.clone().scale(n * 2).add(
        this.p2.clone().scale(e)
      ).scale(e)
    );
  },
  deriv() {
    return new qn().initN(
      2 * (this.p1.x - this.p0.x),
      2 * (this.p1.y - this.p0.y),
      2 * (this.p2.x - this.p1.x),
      2 * (this.p2.y - this.p1.y)
    );
  },
  /**
   * @param {Vector2Like} p
   * @param {number} _accuracy
   */
  // eslint-disable-next-line no-unused-vars
  nearest(e, n) {
    const s = this.p1.clone().sub(this.p0), i = this.p1.clone().scale(-2).add(this.p0).add(this.p2), r = this.p0.clone().sub(e), o = r.dot(s), a = 2 * s.length_squared() + r.dot(i), c = 3 * i.dot(s), l = i.length_squared(), h = T0(o, a, c, l), d = { r_best: null, t_best: 0 };
    let p = !1;
    for (let E = 0, g = h.length; E < g; E++)
      p |= zF(this, e, d, h[E]);
    return p && (ig(e, d, 0, this.p0), ig(e, d, 1, this.p2)), {
      t: d.t_best,
      distance_sq: d.r_best
    };
  },
  getBounds() {
    if (this._bounds == null) {
      const e = [this.p0, this.p1, this.p2];
      let n = e[0].x, s = e[0].y, i = e[0].x, r = e[0].y;
      for (let o = 1; o < 3; o++) {
        const { x: a, y: c } = e[o];
        n = Math.min(n, a), s = Math.min(s, c), i = Math.max(i, a), r = Math.max(r, c);
      }
      this._bounds = new ye(n, s, i - n, r - s);
    }
    return this._bounds;
  }
};
function ig(e, n, s, i) {
  const r = i.distance_squared_to(e);
  (Number.isFinite(n.r_best) ? r < n.r_best : !0) && (n.r_best = r, n.t_best = s);
}
function zF(e, n, s, i) {
  return i < 0 || i > 1 ? !0 : (ig(n, s, i, e.eval(i)), !1);
}
const Jy = {
  [ln.SUBTRACT]: "subtract",
  [ln.INTERSECT]: "intersect",
  [ln.DIFFERENCE]: "exclude",
  [ln.UNION]: "union"
};
function xt() {
  this._closed = !1, this._segments = [], this._curves = null, this._bounds = null, this._version = 0, this._length = null, this._area = null, this._overlapsOnly = !1, this._id = $y++;
}
xt.prototype = {
  constructor: xt,
  toPathData() {
    const e = this._segments, n = e.length, s = Array(6);
    let i = !0, r = 0, o = 0, a = 0, c = 0, l = 0, h = 0, d = 0, p = 0;
    const E = {
      commands: [],
      vertices: []
    };
    function g(A, m) {
      const { x: O, y: S } = A._point;
      m[0] = O, m[1] = S, m[2] = A._handleIn.x + O, m[3] = A._handleIn.y + S, m[4] = A._handleOut.x + O, m[5] = A._handleOut.y + S;
    }
    function T(A, m) {
      g(A, s), r = s[0], o = s[1], i ? (E.commands.push(1), E.vertices.push(r, o), i = !1) : (l = s[2], h = s[3], l === r && h === o && d === a && p === c ? (E.commands.push(2), E.vertices.push(r, o)) : (E.commands.push(4), E.vertices.push(
        d,
        p,
        l,
        h,
        r,
        o
      ))), a = r, c = o, d = s[4], p = s[5];
    }
    if (!n)
      return E;
    for (let A = 0; A < n; A++)
      T(e[A]);
    return this._closed && n > 0 && T(e[0]), this._closed && E.commands.push(5), E;
  },
  /**
   * @param {boolean} absolute
   * @param {number} precision
   */
  toSVG(e = !1, n = 5) {
    bi.setup(n);
    const s = this._segments, i = s.length, r = Array(6);
    let o = !0, a = 0, c = 0, l = 0, h = 0, d = 0, p = 0, E = 0, g = 0;
    const T = [];
    function A(O, S) {
      const { x: y, y: v } = O._point;
      S[0] = y, S[1] = v, S[2] = O._handleIn.x + y, S[3] = O._handleIn.y + v, S[4] = O._handleOut.x + y, S[5] = O._handleOut.y + v;
    }
    function m(O, S) {
      if (A(O, r), a = r[0], c = r[1], o)
        T.push("M" + bi.pair(a, c)), o = !1;
      else if (d = r[2], p = r[3], d === a && p === c && E === l && g === h) {
        if (!S)
          if (e)
            T.push(`L${bi.pair(a, c)}`);
          else {
            const y = a - l, v = c - h;
            T.push(
              // eslint-disable-next-line no-nested-ternary
              y === 0 ? `v${bi.number(v)}` : v === 0 ? `h${bi.number(y)}` : `l${bi.pair(y, v)}`
            );
          }
      } else
        e ? T.push(
          "C" + bi.pair(E, g) + " " + bi.pair(d, p) + " " + bi.pair(a, c)
        ) : T.push(
          "c" + bi.pair(E - l, g - h) + " " + bi.pair(d - l, p - h) + " " + bi.pair(a - l, c - h)
        );
      l = a, h = c, E = r[4], g = r[5];
    }
    if (!i)
      return "";
    for (let O = 0; O < i; O++)
      m(s[O], !1);
    return this._closed && i > 0 && m(s[0], !0), this._closed && T.push("z"), T.join("");
  },
  toString() {
    return this._segments.join(", ");
  },
  clear() {
    return this._closed = !1, this._segments.length = 0, this._curves = null, this._bounds = null, this._version = 0, this._length = null, this._area = null, this._overlapsOnly = !1, this._id = $y++, this;
  },
  /**
   * @param {number} tolerance
   */
  close(e = 0) {
    this.setClosed(!0), this.join(this, e);
  },
  /**
   * Joins the path with the other specified path, which will be removed in
   * the process. They can be joined if the first or last segments of either
   * path lie in the same location. Locations are optionally compare with a
   * provide `tolerance` value.
   *
   * If `null` or `this` is passed as the other path, the path will be joined
   * with itself if the first and last segment are in the same location.
   *
   * @param {BezierPath} path
   * @param {number} tolerance
   * @returns {-1 | 1 | 2} -1: failed, +1: joined, +2: joined and closed the path
   */
  join(e, n = 0) {
    const s = n || 0;
    if (e && e !== this) {
      const o = e._segments, a = this.getLastSegment();
      let c = e.getLastSegment();
      if (!c)
        return -1;
      a && a._point.isClose(c._point, s) && e.reverse();
      const l = e.getFirstSegment();
      if (a && a._point.isClose(l._point, s))
        a.setHandleOut(l._handleOut), this._add(o.slice(1));
      else {
        const h = this.getFirstSegment();
        h && h._point.isClose(l._point, s) && e.reverse(), c = e.getLastSegment(), h && h._point.isClose(c._point, s) ? (h.setHandleIn(c._handleIn), this._add(o.slice(0, o.length - 1), 0)) : this._add(o.slice());
      }
      e._closed && this._add([o[0]]), e.remove();
    }
    const i = this.getFirstSegment(), r = this.getLastSegment();
    return i !== r && i._point.isClose(r._point, s) ? (i.setHandleIn(r._handleIn), r.remove(), this.setClosed(!0), 2) : 1;
  },
  /**
   * @param {BezierPath} path
   */
  compare(e) {
    const n = this.getCurves(), s = e.getCurves(), i = n.length, r = s.length;
    if (!i || !r)
      return i === r;
    let o = n[0].getValues();
    const a = [];
    let c = 0, l = 0, h, d;
    for (let T = 0; T < r; T++) {
      const A = s[T].getValues();
      a.push(A);
      const m = ug(o, A);
      if (m) {
        h = !T && m[0][0] > 0 ? r - 1 : T, d = m[0][1];
        break;
      }
    }
    const p = Bs;
    let E = a[h], g;
    for (; o && E; ) {
      const T = ug(o, E);
      if (T) {
        const A = T[0][0];
        if (_i(A - l) < p) {
          l = T[1][0], l === 1 && (o = ++c < i ? n[c].getValues() : null, l = 0);
          const m = T[0][1];
          if (_i(m - d) < p) {
            if (g || (g = [h, m]), d = T[1][1], d === 1 && (++h >= r && (h = 0), E = a[h] || s[h].getValues(), d = 0), !o)
              return g[0] === h && g[1] === d;
            continue;
          }
        }
      }
      break;
    }
    return !1;
  },
  /**
   * @param {Segment[]} segments
   */
  setSegments(e) {
    let n = e.length;
    if (this._segments.length = 0, this._curves = null, n > 0) {
      const s = e[n - 1];
      typeof s == "boolean" && (this.setClosed(s), n--), this._add(e);
    }
    return this;
  },
  /**
   * @param {number} index
   */
  removeSegment(e) {
    return this.removeSegments(e, e + 1)[0] || null;
  },
  /**
   * @param {number} start
   * @param {number} end
   * @param {boolean} _includeCurves
   */
  removeSegments(e, n, s = !1) {
    e = e || 0, n = n || this._segments.length;
    const i = this._segments;
    let r = this._curves;
    const o = i.length, a = i.splice(e, n - e), c = a.length;
    if (!c)
      return a;
    for (let l = 0; l < c; l++) {
      const h = a[l];
      h._index = null, h._path = null;
    }
    for (let l = e, h = i.length; l < h; l++)
      i[l]._index = l;
    if (r) {
      const l = e > 0 && n === o + (this._closed ? 1 : 0) ? e - 1 : e;
      r = r.splice(l, c);
      for (let h = r.length - 1; h >= 0; h--)
        r[h]._path = null;
      s && (a._curves = r.slice(1)), this._adjustCurves(l, l);
    }
    return this._changed(Ml.SEGMENTS), a;
  },
  /**
   * @param {boolean} closed
   */
  setClosed(e) {
    if (this._closed != (e = !!e)) {
      if (this._closed = e, this._curves) {
        const n = this._countCurves();
        this._curves.length = n, e && (this._curves[n - 1] = new ae().initWithPathAndSegments(
          this,
          this._segments[n - 1],
          this._segments[0]
        ));
      }
      this._changed(Ml.SEGMENTS);
    }
  },
  /**
   * Specifies whether the path as a whole is oriented clock-wise, by looking
   * at the path's area.
   * Note that self-intersecting paths and sub-paths of different orientation
   * can result in areas that cancel each other out.
   */
  isClockwise() {
    return this.getArea() >= 0;
  },
  /**
   * @param {boolean} clockwise
   */
  setClockwise(e) {
    this.isClockwise() !== !!e && this.reverse();
  },
  isEmpty() {
    return this._segments.length === 0;
  },
  /**
   * The approximate length of the path.
   */
  getLength() {
    if (this._length == null) {
      const e = this.getCurves();
      let n = 0;
      for (let s = 0, i = e.length; s < i; s++)
        n += e[s].getLength();
      this._length = n;
    }
    return this._length;
  },
  /**
   * The area that the path's geometry is covering. Self-intersecting paths
   * can contain sub-areas that cancel each other out.
   */
  getArea() {
    let e = this._area;
    if (e == null) {
      e = 0;
      const n = this._segments, s = this._closed;
      for (let i = 0, r = n.length; i < r; i++) {
        const o = i + 1 === r;
        e += ae.getArea(
          ae.getValues(
            n[i],
            n[o ? 0 : i + 1],
            // If this is the last curve and the last is not closed,
            // connect with a straight curve and ignore the handles.
            o && !s
          )
        );
      }
      this._area = e;
    }
    return e;
  },
  getFillRule() {
    return "nonzero";
  },
  getFirstSegment() {
    return this._segments[0];
  },
  getLastSegment() {
    return this._segments[this._segments.length - 1];
  },
  /**
   * The curves contained within the path.
   * @returns {CubicBez[]}
   */
  getCurves() {
    if (!this._curves) {
      const e = this._countCurves();
      this._curves = new Array(e);
      for (let n = 0; n < e; n++)
        this._curves[n] = new ae().initWithPathAndSegments(
          this,
          this._segments[n],
          this._segments[n + 1] || this._segments[0]
        );
    }
    return this._curves;
  },
  getLastCurve() {
    const e = this.getCurves();
    return e[e.length - 1];
  },
  getPointAt(e) {
    const n = this.getLocationAt(e);
    return n && n.getPoint();
  },
  /**
   * Returns the curve location of the specified offset on the path.
   *
   * @param {number} offset the offset on the path, where `0` is at
   * the beginning of the path and {@link BezierPath#length} at the end
   * @return {CurveLocation} the curve location at the specified offset
   */
  getLocationAt(e) {
    if (typeof e == "number") {
      const n = this.getCurves();
      let s = 0;
      for (let i = 0, r = n.length; i < r; i++) {
        const o = s, a = n[i];
        if (s += a.getLength(), s > e)
          return a.getLocationAt(e - o);
      }
      if (n.length > 0 && e <= this.getLength())
        return new ii().init(n[n.length - 1], 1);
    } else if (e && e.getPath && e.getPath() === this)
      return e;
    return null;
  },
  getBounds() {
    return this._bounds == null && (this._bounds = xt.getBounds(this._segments, this._closed)), this._bounds;
  },
  getHandleBounds() {
    return xt.getHandleBounds(this._segments, this._closed);
  },
  getInteriorPoint() {
    return rC(this);
  },
  /**
   * @param {Vector2} point
   */
  _contains(e) {
    const n = e.isInside(this.getHandleBounds()) ? this._getWinding(e) : {};
    return n.onPath || !!(this.getFillRule() === "evenodd" ? n.windingL & 1 || n.windingR & 1 : n.winding);
  },
  /**
   * @param {Vector2Like} point
   */
  contains(e) {
    return !!this._contains(e);
  },
  /**
   * @param {boolean} simplify
   * @returns {BezierPath}
   */
  reduce(e = !1) {
    const n = this.getCurves(), s = e ? hr : 0;
    for (let i = n.length - 1; i >= 0; i--) {
      const r = n[i];
      !r.hasHandles() && (!r.hasLength(s) || e && r.isCollinear(r.getNext())) && r.remove();
    }
    return this;
  },
  /**
   * @checked
   */
  reverse() {
    this._segments.reverse();
    for (let e = 0, n = this._segments.length; e < n; e++) {
      const s = this._segments[e], i = s._handleIn;
      s._handleIn = s._handleOut, s._handleOut = i, s._index = e;
    }
    this._curves = null, this._changed(Ml.GEOMETRY);
  },
  /**
   * @param {Transform2D} t
   */
  transform(e) {
    for (let n = 0, s = this._segments.length; n < s; n++) {
      const i = this._segments[n];
      e.xform(i._point, i._point), e.basis_xform(i._handleIn, i._handleIn), e.basis_xform(i._handleOut, i._handleOut);
    }
    return this;
  },
  clone() {
    return _0(this);
  },
  /**
   * @param {BezierPath} path
   * @param {(loc: CurveLocation) => boolean} filterer
   */
  getIntersections(e, n) {
    return nC(this, e, n);
  },
  resolveCrossings() {
    return sC(this);
  },
  reorient(e, n) {
    return iC(this, e, n);
  },
  /**
   * @param {number} index
   * @param {Segment} segment1
   */
  insert(e, n) {
    return this._add([n], e);
  },
  /**
   * @param {Segment} segment1
   */
  add(e) {
    return this._add([e])[0];
  },
  /**
   * @param {Segment[]} segs
   * @param {number} [index]
   */
  _add(e, n) {
    const s = !Number.isFinite(n);
    s && (n = this._segments.length);
    const i = e.length;
    for (let r = 0; r < i; r++) {
      let o = e[r];
      o._path && (o = o.clone(), e[r] = o), o._path = this, o._index = n + r;
    }
    if (s)
      Ya(this._segments, e);
    else {
      this._segments.splice.apply(this._segments, [n, 0].concat(e));
      for (let r = n + i, o = this._segments.length; r < o; r++)
        this._segments[r]._index = r;
    }
    if (this._curves) {
      const r = this._countCurves(), o = n > 0 && n + i - 1 === r ? n - 1 : n;
      let a = o;
      const c = Math.min(o + i, r);
      e._curves && (this.curves.splice.apply(this._curves, [o, 0].concat(e._curves)), a += e._curves.length);
      for (let l = a; l < c; l++)
        this._curves.splice(l, 0, new ae().initWithPathAndSegments(this, null, null));
      this._adjustCurves(o, c);
    }
    return this._changed(Ml.SEGMENTS), e;
  },
  _remove() {
    return og(this);
  },
  remove() {
    return og(this);
  },
  _countCurves() {
    const e = this._segments.length;
    return !this._closed && e > 0 ? e - 1 : e;
  },
  /**
   * @param {number} start
   * @param {number} end
   */
  _adjustCurves(e, n) {
    const s = this._segments, i = this._curves;
    let r;
    for (let o = e; o < n; o++)
      r = i[o], r._path = this, r._segment1 = s[o], r._segment2 = s[o + 1] || s[0], r._changed();
    (r = i[this._closed && !e ? s.length - 1 : e - 1]) && (r._segment2 = s[e] || s[0], r._changed()), (r = i[n]) && (r._segment1 = s[n], r._changed());
  },
  /**
   * Returns the winding contribution number of the given point in respect
   * to this PathItem.
   *
   * @param {Vector2} point the location for which to determine the winding
   *     contribution
   * @param {number} [dir=0] the direction in which to determine the
   *     winding contribution, `0`: in x-direction, `1`: in y-direction
   * @param {boolean} closed
   */
  _getWinding(e, n, s) {
    return cf(e, this.getCurves(), n, s);
  },
  /**
   * @param {ChangeFlag} flags
   */
  _changed(e) {
    if (e & Ca.GEOMETRY) {
      if (this._bounds = null, this._length = null, this._area = null, e & Ca.SEGMENTS)
        this._version++;
      else if (this._curves)
        for (let n = 0, s = this._curves.length; n < s; n++)
          this._curves[n]._changed();
    }
  },
  /** trim path */
  /**
   * @param {number} s start
   * @param {number} e end
   * @param {boolean} [isTrimEndWrapped = false]
   * @returns {BezierPath[]}
   */
  trim(e, n, s = !1) {
    const i = this.getCurves();
    if (i.length === 0)
      return this;
    const r = [];
    let o = 0;
    for (let T = 0; T < i.length; T++) {
      const A = i[T].getLength();
      r.push(A), o += A;
    }
    const a = e * o, c = n * o;
    let l = 0, h = 0, d = 0, p = 0, E = 0;
    for (let T = 0; T < i.length && (E < a && (l = T, d = a - E), E < c && (h = T, p = c - E), !(E >= a && E >= c)); T++)
      E += r[T];
    const g = [];
    if (s) {
      const T = [], A = [], m = i[l].getValues(), O = i[h].getValues(), S = ae.subdivide(m, ae.getTimeAt(m, d))[1], y = ae.subdivide(O, ae.getTimeAt(O, p))[0];
      T.push(
        new Fe().initWithPointsN(S[0], S[1], S[0] - S[2], S[1] - S[3], S[2] - S[0], S[3] - S[1]),
        new Fe().initWithPointsN(S[6], S[7], S[4] - S[6], S[5] - S[7], 0, 0)
      );
      let v = !0;
      for (let R = l + 1; R < i.length; R++)
        v && (i[R]._segment1._handleIn = T.pop()._handleIn, T.push(i[R]._segment1), v = !1), T.push(i[R]._segment2);
      if (this._closed) {
        for (let M = 0; M <= h - 1; M++)
          v && (i[M]._segment1._handleIn = T.pop()._handleIn, T.push(i[M]._segment1), v = !1), T.push(i[M]._segment2);
        const R = T.pop();
        T.push(
          new Fe().initWithPointsN(y[0], y[1], R._handleIn.x, R._handleIn.y, y[2] - y[0], y[3] - y[1])
        ), T.push(
          new Fe().initWithPointsN(y[6], y[7], y[4] - y[6], y[5] - y[7], 0, 0)
        ), g.push(new xt().setSegments(T));
      } else {
        let R = !0;
        for (let M = 0; M <= h - 1; M++)
          R && (A.push(i[M]._segment1), R = !1), A.push(i[M]._segment2);
        if (R)
          A.push(
            new Fe().initWithPointsN(y[0], y[1], 0, 0, y[2] - y[0], y[3] - y[1])
          );
        else {
          const M = A.pop();
          A.push(
            new Fe().initWithPointsN(y[0], y[1], M._handleIn.x, M._handleIn.y, y[2] - y[0], y[3] - y[1])
          );
        }
        A.push(
          new Fe().initWithPointsN(y[6], y[7], y[4] - y[6], y[5] - y[7], y[6] - y[4], y[7] - y[5])
        ), g.push(new xt().setSegments(T)), g.push(new xt().setSegments(A));
      }
    } else {
      const T = [];
      if (l === h) {
        const A = i[l].getValues(), m = ae.getPart(A, ae.getTimeAt(A, d), ae.getTimeAt(A, p));
        T.push(
          new Fe().initWithPointsN(m[0], m[1], m[0] - m[2], m[1] - m[3], m[2] - m[0], m[3] - m[1]),
          new Fe().initWithPointsN(m[6], m[7], m[4] - m[6], m[5] - m[7], 0, 0)
        );
      } else {
        const A = i[l].getValues(), m = i[h].getValues(), O = ae.subdivide(A, ae.getTimeAt(A, d))[1], S = ae.subdivide(m, ae.getTimeAt(m, p))[0];
        T.push(
          new Fe().initWithPointsN(O[0], O[1], O[0] - O[2], O[1] - O[3], O[2] - O[0], O[3] - O[1]),
          new Fe().initWithPointsN(O[6], O[7], O[4] - O[6], O[5] - O[7], 0, 0)
        );
        let y = !0;
        for (let R = l + 1; R <= h - 1; R++)
          y && (i[R]._segment1._handleIn = T.pop()._handleIn, T.push(i[R]._segment1), y = !1), T.push(i[R]._segment2);
        const v = T.pop();
        T.push(
          new Fe().initWithPointsN(S[0], S[1], v._handleIn.x, v._handleIn.y, S[2] - S[0], S[3] - S[1])
        ), T.push(
          new Fe().initWithPointsN(S[6], S[7], S[4] - S[6], S[5] - S[7], S[6] - S[4], S[7] - S[5])
        );
      }
      g.push(new xt().setSegments(T));
    }
    return g;
  },
  /**
   * @param {number} x
   * @param {number} y
   */
  moveTo(e, n) {
    return this._segments.length === 1 && this.removeSegment(0), this._segments.length === 0 && this._add([
      new Fe().initN(e, n)
    ]), this;
  },
  /**
   * @param {number} x
   * @param {number} y
   */
  lineTo(e, n) {
    this._add([
      new Fe().initN(e, n)
    ]);
  },
  /**
   * @param {number} h1x
   * @param {number} h1y
   * @param {number} h2x
   * @param {number} h2y
   * @param {number} x
   * @param {number} y
   */
  cubicCurveTo(e, n, s, i, r, o) {
    const a = this.getLastSegment();
    a.setHandleOut(new N(e, n).subtract(a._point)), this._add([
      new Fe().initWithPointsN(r, o, s - r, i - o)
    ]);
  },
  /**
   * @param {number} hx
   * @param {number} hy
   * @param {number} x
   * @param {number} y
   */
  quadraticCurveTo(e, n, s, i) {
    const r = this.getLastSegment()._point, o = new N(e, n), a = new N(s, i), c = o.clone().add(r.clone().subtract(o).multiply(1 / 3, 1 / 3)), l = o.clone().add(a.clone().subtract(o).multiply(1 / 3, 1 / 3)), h = a;
    this.cubicCurveTo(
      c.x,
      c.y,
      l.x,
      l.y,
      h.x,
      h.y
    );
  },
  /**
   * @param {number} px
   * @param {number} py
   * @param {{ width: number, height: number }} radius
   * @param {number} rotation
   * @param {number} clockwise
   * @param {number} large
   */
  arcTo(e, n, s, i, r, o) {
    const a = new N(e, n);
    i *= Math.PI / 180;
    const c = this.getLastSegment(), l = c._point, h = Zn.isZero;
    if (h(s.width) || h(s.height))
      return this.lineTo(a.x, a.y);
    const d = l.clone().add(a.x, a.y).divide(2, 2), p = l.clone().subtract(d.x, d.y).rotate(-i), E = p.x, g = p.y;
    let T = _i(s.width), A = _i(s.height), m = T * T, O = A * A;
    const S = E * E, y = g * g;
    let v = HI(S / m + y / O);
    if (v > 1 && (T *= v, A *= v, m = T * T, O = A * A), v = (m * O - m * y - O * S) / (m * y + O * S), _i(v) < Qn && (v = 0), v < 0)
      throw new Error("Cannot create an arc with the given arguments");
    const R = (o === r ? -1 : 1) * HI(v), M = new N(T * g / A, -A * E / T).multiply(R, R).rotate(i).clone().add(d), L = new Ce().translate(M.x, M.y).rotate_basis(i).scale_basis(T, A), P = new N();
    new Ce().copy(L).affine_inverse().xform(l, P);
    const k = new N();
    new Ce().copy(L).affine_inverse().xform(a, k);
    let Q = P.angle_to(k) * 180 / Math.PI;
    if (!r && Q > 0 ? Q -= 360 : r && Q < 0 && (Q += 360), Q) {
      const b = LP, X = _i(Q), K = X >= 360 ? 4 : Math.ceil((X - b) / 90), V = Q / K, J = V * Math.PI / 360, ge = 4 / 3 * Math.sin(J) / (1 + Math.cos(J)), ne = [];
      let ue = new N();
      for (let te = 0; te <= K; te++) {
        ue.copy(a);
        let ie = null;
        if (te < K && (ie = P.clone().rotate(90 * Math.PI / 180).multiply(ge, ge), L ? (L.xform(P, ue), L.xform(P.clone().add(ie), ie), ie.subtract(ue)) : ue = M.clone().add(P)), !te)
          c.setHandleOut(ie);
        else {
          const re = P.clone().rotate(-90 * Math.PI / 180).multiply(ge, ge);
          L && (L.xform(P.clone().add(re), re), re.subtract(ue)), ne.push(new Fe().initWithPoints(ue, re, ie));
        }
        P.rotate(V * Math.PI / 180);
      }
      this._add(ne);
    }
  }
};
xt.createPath = (e, n) => {
  const s = new xt();
  return s._add(e), s._closed = n, s;
};
xt.makeRectN = (e, n, s, i) => {
  const r = s / 2, o = i / 2;
  return xt.createPath([
    new Fe().initWithPointsN(e - r, n + o, 0, 0, 0, 0),
    new Fe().initWithPointsN(e - r, n - o, 0, 0, 0, 0),
    new Fe().initWithPointsN(e + r, n - o, 0, 0, 0, 0),
    new Fe().initWithPointsN(e + r, n + o, 0, 0, 0, 0)
  ], !0).transform(new Ce().translate(r, o));
};
xt.makeCircleN = (e, n, s) => {
  const r = s * 0.55228475;
  return xt.createPath([
    new Fe().initWithPointsN(e - s, n, 0, r, 0, -r),
    new Fe().initWithPointsN(e, n - s, -r, 0, r, 0),
    new Fe().initWithPointsN(e + s, n, 0, -r, 0, r),
    new Fe().initWithPointsN(e, n + s, r, 0, -r, 0)
  ], !0);
};
xt.getBounds = (e, n) => {
  const s = e[0];
  if (!s)
    return new ye();
  const i = new Array(6), r = s._transformCoordinates(new Array(6)), o = r.slice(0, 2), a = o.slice(), c = new Array(2);
  for (let l = 1, h = e.length; l < h; l++)
    kI(e[l], i, r, o, a, c);
  return n && kI(s, i, r, o, a, c), new ye(o[0], o[1], a[0] - o[0], a[1] - o[1]);
};
xt.getHandleBounds = (e, n) => {
  const s = new Array(6);
  let i = 1 / 0, r = -i, o = i, a = r;
  for (let c = 0, l = e.length; c < l; c++) {
    e[c]._transformCoordinates(s);
    for (let d = 0; d < 6; d += 2) {
      const p = s[d], E = s[d + 1], g = p, T = p, A = E, m = E;
      g < i && (i = g), T > r && (r = T), A < o && (o = A), m > a && (a = m);
    }
  }
  return new ye(i, o, r - i, a - o);
};
function qe() {
  this._children = [], this._bounds = new ye(), this.version = 0, this._currentPoint = null;
}
qe.prototype = {
  constructor: qe,
  /**
   * @param {boolean} absolute
   * @param {number} precision
   */
  toSVG(e, n) {
    let s = "";
    for (let i = 0, r = this._children.length; i < r; i++) {
      const o = this._children[i];
      s += o.toSVG(e, n);
    }
    return s;
  },
  toPathData() {
    const e = new Vs();
    for (let n = 0, s = this._children.length; n < s; n++) {
      const r = this._children[n].toPathData();
      e.commands = e.commands.concat(r.commands), e.vertices = e.vertices.concat(r.vertices);
    }
    return e;
  },
  /**
   * @param {Transform2D} t
   */
  transform(e) {
    for (let n = 0, s = this._children.length; n < s; n++)
      this._children[n].transform(e);
    return this;
  },
  /**
   * @param {BezierShape} shape
   */
  copy(e) {
    return this.setChildren(e._children), this.version = e.version, this._bounds = e._bounds, this;
  },
  /**
   * @returns {BezierShape}
   */
  clone() {
    return _0(this);
  },
  isEmpty() {
    for (let e = 0, n = this._children.length; e < n; e++)
      if (!this._children[e].isEmpty())
        return !1;
    return !0;
  },
  remove() {
    return og(this);
  },
  /**
   * @param {BezierPath} item
   */
  addChild(e) {
    return this.insertChild(void 0, e), this;
  },
  /**
   * @param {number} index
   * @param {BezierPath} item
   */
  insertChild(e, n) {
    return this.insertChildren(e, [n])[0];
  },
  /**
   * @param {BezierPath[]} items
   */
  addChildren(e) {
    return this.insertChildren(this._children.length, e), this;
  },
  /**
   * @param {number} index
   * @param {BezierPath[]} items
   */
  insertChildren(e, n) {
    const s = this._children;
    if (s && n && n.length > 0) {
      n = n.slice();
      const i = {};
      for (let r = n.length - 1; r >= 0; r--) {
        const o = n[r], a = o && o._id;
        !o || i[a] ? n.splice(r, 1) : (o._remove(), i[a] = !0);
      }
      rg(s, n, e, 0);
      for (let r = 0, o = n.length; r < o; r++) {
        const a = n[r];
        a._parent = this;
      }
    } else
      n = null;
    return n;
  },
  /**
   * @param {boolean} simplify
   */
  reduce(e = !1) {
    for (let n = this._children.length - 1; n >= 0; n--) {
      const s = this._children[n].reduce(e);
      s.isEmpty() && s._remove();
    }
    if (!this._children.length) {
      const n = new qe();
      return this.remove(), n;
    }
    return this;
  },
  getIntersections(e, n) {
    return nC(this, e, n);
  },
  resolveCrossings() {
    return sC(this);
  },
  reorient(e, n) {
    return iC(this, e, n);
  },
  /**
   * @param {BezierPath[]} items
   */
  setChildren(e) {
    this.removeChildren(), this.addChildren(e);
  },
  /**
   * @param {number} start
   * @param {number} end
   */
  removeChildren(e, n) {
    if (!this._children) return null;
    e = e || 0, n = n !== void 0 ? n : this._children.length;
    const s = rg(this._children, null, e, n - e);
    for (let i = s.length - 1; i >= 0; i--)
      s[i]._remove();
    return s;
  },
  /**
   * Specifies whether the path as a whole is oriented clock-wise, by looking
   * at the path's area.
   * Note that self-intersecting paths and sub-paths of different orientation
   * can result in areas that cancel each other out.
   */
  isClockwise() {
    return this.getArea() >= 0;
  },
  /**
   * @param {boolean} clockwise
   */
  setClockwise(e) {
    this.isClockwise() !== !!e && this.reverse();
  },
  /**
   * @returns {number}
   */
  getLength() {
    const e = this._children;
    let n = 0;
    for (let s = 0, i = e.length; s < i; s++)
      n += e[s].getLength();
    return n;
  },
  /**
   * The area that the compound-path's geometry is covering, calculated by
   * getting the area of each sub-path and it adding up.
   * Note that self-intersecting paths and sub-paths of different orientation
   * can result in areas that cancel each other out.
   */
  getArea() {
    const e = this._children;
    let n = 0;
    for (let s = 0, i = e.length; s < i; s++)
      n += e[s].getArea();
    return n;
  },
  /**
   * All the curves contained within the compound-path, from all its child items.
   */
  getCurves() {
    const e = this._children, n = [];
    for (let s = 0, i = e.length; s < i; s++)
      Ya(n, e[s].getCurves());
    return n;
  },
  getFillRule() {
    return "nonzero";
  },
  reverse() {
    const e = this._children;
    for (let n = 0, s = e.length; n < s; n++)
      e[n].reverse();
  },
  getInteriorPoint() {
    return rC(this);
  },
  /**
   * @param {Vector2} point
   */
  _contains(e) {
    const n = e.isInside(this.getBounds()) ? this._getWinding(e) : {};
    return n.onPath || !!(this.getFillRule() === "evenodd" ? n.windingL & 1 || n.windingR & 1 : n.winding);
  },
  /**
   * @param {Vector2Like} point
   */
  contains(e) {
    return !!this._contains(e);
  },
  /**
   * Gets the combined bounds of all specified items.
   * @returns {Rect2}
   */
  getBounds() {
    const e = this.toPathData();
    this._bounds.set(0, 0, 0, 0);
    const { commands: n, vertices: s } = e;
    let i = Number.MAX_SAFE_INTEGER, r = Number.MIN_SAFE_INTEGER, o = Number.MAX_SAFE_INTEGER, a = Number.MIN_SAFE_INTEGER, c = 0, l = 0, h = 0, d = 0, p = 0, E = 0, g = 0, T = 0, A = 0, m = 0, O = 0;
    const S = () => {
      const y = new ye(i, o, r - i, a - o);
      this._bounds.merge_with(y), i = Number.MAX_SAFE_INTEGER, r = Number.MIN_SAFE_INTEGER, o = Number.MAX_SAFE_INTEGER, a = Number.MIN_SAFE_INTEGER;
    };
    for (const y of n)
      switch (l = d, h = p, y) {
        case ve.M:
          l = s[c++], h = s[c++], d = l, p = h, i = Math.min(i, l), o = Math.min(o, h), r = Math.max(r, l), a = Math.max(a, h), c === 2 ? this._bounds.set(l, h, 0, 0) : S();
          break;
        case ve.L:
          d = s[c++], p = s[c++], i = Math.min(i, d), o = Math.min(o, p), r = Math.max(r, d), a = Math.max(a, p);
          break;
        case ve.Q:
          {
            E = s[c++], g = s[c++], d = s[c++], p = s[c++];
            const v = new wd().initN(l, h, E, g, d, p).getBounds();
            i = Math.min(i, v.x), o = Math.min(o, v.y), r = Math.max(r, v.x + v.width), a = Math.max(a, v.y + v.height);
          }
          break;
        case ve.C:
          {
            T = s[c++], A = s[c++], m = s[c++], O = s[c++], d = s[c++], p = s[c++];
            const R = new ae().initWith4PointsN(l, h, T, A, m, O, d, p).getBounds();
            i = Math.min(i, R.x), o = Math.min(o, R.y), r = Math.max(r, R.x + R.width), a = Math.max(a, R.y + R.height);
          }
          break;
      }
    return c > 2 && S(), this._bounds;
  },
  _getWinding(e, n, s) {
    return cf(e, this.getCurves(), n, s);
  },
  /** boolean */
  /**
   * @param {BezierShape} path
   * @returns {BezierShape}
   */
  union(e) {
    return Mu(this, e, ln.UNION);
  },
  /**
   * @param {BezierShape} path
   * @returns {BezierShape}
   */
  intersect(e) {
    return Mu(this, e, ln.INTERSECT);
  },
  /**
   * @param {BezierShape} path
   * @returns {BezierShape}
   */
  subtract(e) {
    return Mu(this, e, ln.SUBTRACT);
  },
  /**
   * @param {BezierShape} path
   * @returns {BezierShape}
   */
  difference(e) {
    return Mu(this, e, ln.DIFFERENCE);
  },
  exclude(e) {
    return this.difference(e);
  },
  /** trim path */
  /**
   * @param {number} start
   * @param {number} end
   * @param {number} offset
   * @param {TrimPathMode} mode
   * @returns {BezierShape}
   */
  trim(e, n, s, i) {
    if (this._children.length === 0)
      return this;
    const [r, o, a] = eC(e, n, s);
    if (uC(r, o) && !a)
      return this._children = [], this._bounds = null, this;
    switch (i) {
      case ar.SIMULTANEOUSLY:
        return this._trimSimultaneously(r, o, a);
      case ar.INDIVIDUALLY:
      default:
        return this._trimIndividually(r, o, a);
    }
  },
  /**
   * @param {number} start
   * @param {number} end
   * @param {number} offset
   * @param {number} mode
   * @returns {BezierShape}
   */
  trimmed(e, n, s, i) {
    return this.clone().trim(e, n, s, i);
  },
  /**
   * @param {number} s start
   * @param {number} e end
   * @param {boolean} [isTrimEndWrapped = false]
   * @returns {BezierShape}
   */
  // eslint-disable-next-line no-unused-vars
  _trimIndividually(e, n, s = !1) {
    if (this._children.length === 1)
      return this._children = this._children[0].trim(e, n, s), this.reduce(), this;
    const i = [], r = [];
    let o = 0;
    for (let T = 0; T < this._children.length; T++) {
      const m = this._children[T].getCurves();
      for (let O = 0; O < m.length; O++) {
        const S = m[O].getLength();
        S > 0 && (o += S, i.push(S), r.push([T, O]));
      }
    }
    if (r.length === 0)
      return this;
    const a = e * o, c = n * o;
    let l = 0, h = 0, d = 0, p = 0, E = 0;
    for (let T = 0; T < i.length && (E < a && (l = T, d = a - E), E < c && (h = T, p = c - E), !(E >= a && E >= c)); T++)
      E += i[T];
    const g = this._children;
    if (this._children = [], s) {
      const [T, A] = r[l], [m, O] = r[h], S = g[T].getCurves()[A].getValues(), y = g[m].getCurves()[O].getValues(), v = ae.subdivide(S, ae.getTimeAt(S, d))[1], R = ae.subdivide(y, ae.getTimeAt(y, p))[0];
      let M = T, L = [];
      L.push(
        new Fe().initWithPointsN(v[0], v[1], v[0] - v[2], v[1] - v[3], v[2] - v[0], v[3] - v[1]),
        new Fe().initWithPointsN(v[6], v[7], v[4] - v[6], v[5] - v[7], 0, 0)
      );
      let P = !0;
      for (let Q = l + 1; Q <= i.length + h - 1; Q++) {
        const [b, X] = r[Q % i.length], K = g[b].getCurves()[X];
        M !== b ? (this.addChild(xt.createPath(L, !1)), M = b, L = [
          K._segment1
        ]) : P && (K._segment1._handleIn = L.pop()._handleIn, L.push(K._segment1), P = !1), L.push(K._segment2);
      }
      M !== m && (this.addChild(xt.createPath(L, !1)), M = m, L = [
        new Fe().initWithPointsN(R[0], R[1], 0, 0, R[2] - R[0], R[3] - R[1])
      ]);
      const k = L.pop();
      L.push(
        new Fe().initWithPointsN(R[0], R[1], k._handleIn.x, k._handleIn.y, R[2] - R[0], R[3] - R[1])
      ), L.push(
        new Fe().initWithPointsN(R[6], R[7], R[4] - R[6], R[5] - R[7], R[6] - R[4], R[7] - R[5])
      ), this.addChild(xt.createPath(L, !1));
    } else if (l === h) {
      const [T, A] = r[l], m = g[T].getCurves()[A].getValues(), O = ae.getPart(m, ae.getTimeAt(m, d), ae.getTimeAt(m, p));
      this.addChild(xt.createPath([
        new Fe().initWithPointsN(O[0], O[1], 0, 0, O[2] - O[0], O[3] - O[1]),
        new Fe().initWithPointsN(O[6], O[7], O[4] - O[6], O[5] - O[7], 0, 0)
      ], !1));
    } else {
      const [T, A] = r[l], [m, O] = r[h], S = g[T].getCurves()[A].getValues(), y = g[m].getCurves()[O].getValues(), v = ae.subdivide(S, ae.getTimeAt(S, d))[1], R = ae.subdivide(y, ae.getTimeAt(y, p))[0];
      let M = T, L = [];
      L.push(
        new Fe().initWithPointsN(v[0], v[1], S[0] - S[2], S[1] - S[3], v[2] - v[0], v[3] - v[1]),
        new Fe().initWithPointsN(v[6], v[7], v[4] - v[6], v[5] - v[7], 0, 0)
      );
      let P = !0;
      for (let Q = l + 1; Q < h; Q++) {
        const [b, X] = r[Q % i.length], K = g[b].getCurves()[X];
        M !== b ? (this.addChild(xt.createPath(L, !1)), M = b, L = [
          K._segment1
        ]) : P && (K._segment1._handleIn = L.pop()._handleIn, L.push(K._segment1), P = !1), L.push(K._segment2);
      }
      M !== m && (this.addChild(xt.createPath(L, !1)), M = m, L = [
        new Fe().initWithPointsN(R[0], R[1], 0, 0, R[2] - R[0], R[3] - R[1])
      ]);
      const k = L.pop();
      L.push(
        new Fe().initWithPointsN(R[0], R[1], k._handleIn.x, k._handleIn.y, R[2] - R[0], R[3] - R[1])
      ), L.push(
        new Fe().initWithPointsN(R[6], R[7], R[4] - R[6], R[5] - R[7], R[6] - R[4], R[7] - R[5])
      ), this.addChild(xt.createPath(L, !1));
    }
    return this.reduce(), this;
  },
  /**
   * @param {number} s start
   * @param {number} e end
   * @param {boolean} [isTrimEndWrapped = false]
   * @returns {BezierPath}
   */
  _trimSimultaneously(e, n, s = !1) {
    return this._children = this._children.flatMap(
      (i) => (
        // TODO: might need to update _closed for the trimmed paths
        i.trim(e, n, s)
      )
    ), this.reduce(), this;
  },
  /** drawing */
  /**
   * @param {number} x
   * @param {number} y
   */
  moveTo(e, n) {
    return this.addChild(
      xt.createPath([
        new Fe().initWithPointsN(e, n, 0, 0, 0, 0)
      ]),
      !1
    );
  },
  /**
   * @param {number} x
   * @param {number} y
   */
  lineTo(e, n) {
    return this.getCurrentPath().lineTo(e, n), this;
  },
  /**
   * @param {number} hx
   * @param {number} hy
   * @param {number} x
   * @param {number} y
   */
  quadraticCurveTo(e, n, s, i) {
    return this.getCurrentPath().quadraticCurveTo(e, n, s, i), this;
  },
  /**
   * @param {number} h1x
   * @param {number} h1y
   * @param {number} h2x
   * @param {number} h2y
   * @param {number} x
   * @param {number} y
   */
  cubicCurveTo(e, n, s, i, r, o) {
    return this.getCurrentPath().cubicCurveTo(e, n, s, i, r, o), this;
  },
  /**
   * @param {number} px
   * @param {number} py
   * @param {{ width: number, height: number }} radius
   * @param {number} rotation
   * @param {number} clockwise
   * @param {number} large
   */
  arcTo(e, n, s, i, r, o) {
    return this.getCurrentPath().arcTo(e, n, s, i, r, o), this;
  },
  /**
   * @param {number} tolerance
   * @returns {BezierShape}
   */
  close(e = 0) {
    return this.getCurrentPath().close(e), this;
  },
  /**
   * @returns {BezierPath}
   */
  getFirstPath() {
    return this._children.length === 0 ? null : this._children[0];
  },
  /**
   * @returns {BezierPath}
   */
  getCurrentPath() {
    return this._children.length === 0 ? null : this._children[this._children.length - 1];
  }
};
qe.create = () => new qe();
qe.destroy = (e) => {
  e._children.length = 0, e.version = 0, e._bounds = null;
};
qe.createFromPathData = (e) => {
  const { commands: n, vertices: s } = e, i = new qe();
  let r = ve.M;
  const o = new N(), a = new N(), c = new N();
  i.removeChildren();
  for (let l = 0, h = n.length, d = 0; l < h; l++) {
    const p = n[l];
    switch (r === ve.Z && !(p === ve.M || p === ve.Z) && i.moveTo(c.x, c.y), p) {
      case ve.M: {
        c.x = s[d++], c.y = s[d++], i.moveTo(c.x, c.y);
        break;
      }
      case ve.L: {
        c.x = s[d++], c.y = s[d++], i.lineTo(c.x, c.y);
        break;
      }
      case ve.Q: {
        o.x = s[d++], o.y = s[d++], c.x = s[d++], c.y = s[d++], i.quadraticCurveTo(o.x, o.y, c.x, c.y);
        break;
      }
      case ve.C: {
        o.x = s[d++], o.y = s[d++], a.x = s[d++], a.y = s[d++], c.x = s[d++], c.y = s[d++], i.cubicCurveTo(o.x, o.y, a.x, a.y, c.x, c.y);
        break;
      }
      case ve.Z: {
        i.close(Qn);
        break;
      }
    }
    r = p;
  }
  return i;
};
qe.createFromSVG = (e) => {
  const n = new qe(), s = e && e.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig);
  let i, r = !1, o, a, c = new N(), l = new N();
  function h(p, E) {
    let g = +i[p];
    return r && (g += c[E]), g;
  }
  function d(p) {
    return new N(
      h(p, "x"),
      h(p + 1, "y")
    );
  }
  n.removeChildren();
  for (let p = 0, E = s && s.length; p < E; p++) {
    const g = s[p], T = g[0], A = T.toLowerCase();
    i = g.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
    const m = i && i.length;
    switch (r = T === A, o === "z" && !/[mz]/.test(A) && n.moveTo(c.x, c.y), A) {
      case "m":
      case "l":
        let O = A === "m";
        for (let y = 0; y < m; y += 2)
          c = d(y), n[O ? "moveTo" : "lineTo"](c.x, c.y), O && (l = c, O = !1);
        a = c;
        break;
      case "h":
      case "v":
        const S = A === "h" ? "x" : "y";
        c = c.clone();
        for (let y = 0; y < m; y++)
          c[S] = h(y, S), n.lineTo(c.x, c.y);
        a = c;
        break;
      case "c":
        for (let y = 0; y < m; y += 6) {
          const v = d(y);
          a = d(y + 2), c = d(y + 4), n.cubicCurveTo(
            v.x,
            v.y,
            a.x,
            a.y,
            c.x,
            c.y
          );
        }
        break;
      case "s":
        for (let y = 0; y < m; y += 4) {
          const v = /[cs]/.test(o) ? c.multiply(2, 2).subtract(a) : c;
          a = d(y), c = d(y + 2), n.cubicCurveTo(
            v.x,
            v.y,
            a.x,
            a.y,
            c.x,
            c.y
          ), o = A;
        }
        break;
      case "q":
        for (let y = 0; y < m; y += 4)
          a = d(y), c = d(y + 2), n.quadraticCurveTo(
            a.x,
            a.y,
            c.x,
            c.y
          );
        break;
      case "t":
        for (let y = 0; y < m; y += 2)
          a = /[qt]/.test(o) ? c.multiply(2, 2).subtract(a) : c, c = d(y), n.quadraticCurveTo(
            a.x,
            a.y,
            c.x,
            c.y
          ), o = A;
        break;
      case "a":
        for (let y = 0; y < m; y += 7)
          c = d(y + 5), n.arcTo(
            c.x,
            c.y,
            { width: +i[y], height: +i[y + 1] },
            +i[y + 2],
            +i[y + 4],
            +i[y + 3]
          );
        break;
      case "z":
        n.close(Qn), c = l;
        break;
    }
    o = A;
  }
  return n;
};
qe.trimMultiple = (e, n, s, i) => {
  if (i.length === 0)
    return i;
  const [r, o, a] = eC(e, n, s);
  if (uC(r, o) && !a)
    return Array(i.length).fill(new qe());
  let c = 0;
  const l = [];
  for (let m = 0; m < i.length; m++)
    l.push(i[m].getLength()), c += l[m];
  const h = r * c, d = o * c;
  let p = 0, E = 0, g = 0, T = 0, A = 0;
  for (let m = 0; m < i.length && (A < h && (p = m, g = h - A), A < d && (E = m, T = d - A), !(A >= h && A >= d)); m++)
    A += l[m];
  return p === E ? l.map((m, O) => O !== p ? a ? i[O].clone() : new qe() : i[O].clone()._trimIndividually(g / m, T / m, a)) : l.map((m, O) => (a ? O > E && O < p : O < p || O > E) ? new qe() : O === p ? i[O].clone()._trimIndividually(g / m, 1) : O === E ? i[O].clone()._trimIndividually(0, T / m) : i[O]);
};
function ii() {
  this._time = null, this._point = new N(), this._overlap = !1, this._distance = null, this._offset = null, this._curveOffset = null, this._path = null, this._curve = null, this._segment = null, this._segment1 = null, this._segment2 = null, this._version = 0, this._intersection = null, this._previous = null, this._next = null;
}
ii.prototype = {
  constructor: ii,
  /**
   * @param {CubicBez} curve
   * @param {number} time
   * @param {Vector2} point
   * @param {number} [_overlap]
   * @param {number} [_distance]
   */
  init(e, n, s, i, r) {
    if (n >= 1 - Bs) {
      const o = e.getNext();
      o && (n = 0, e = o);
    }
    return this._setCurve(e), this._time = n, this._point = s || e.getPointAtTime(n), this._overlap = i, this._distance = r, this._intersection = null, this._next = null, this._previous = null, this;
  },
  getPoint() {
    return this._point;
  },
  /**
   * The curve that this location belongs to.
   */
  getCurve() {
    const e = this._path;
    return e && e._version !== this._version && (this._time = null, this._offset = null, this._curveOffset = null, this._curve = null), this._curve || this.trySegment(this._segment) || this.trySegment(this._segment1) || this.trySegment(this._segment2.getPrevious());
  },
  /**
   * If path is out of sync, access current curve objects through segment1
   * segment2. Since path splitting or dividing might have happened in
   * the meantime, try segment1's curve, and see if _point lies on it
   * still, otherwise assume it's the curve before segment2.
   * @param {Segment} segment
   */
  trySegment(e) {
    const n = e && e.getCurve();
    if (n && (this._time = n.getTimeOf(this._point)) !== null)
      return this._setCurve(n), n;
  },
  /**
   * The segment of the curve which is closer to the described location.
   */
  getSegment() {
    let e = this._segment;
    if (!e) {
      const n = this.getCurve(), s = this.getTime();
      s === 0 ? e = n._segment1 : s === 1 ? e = n._segment2 : s != null && (e = n.getPartLength(0, s) < n.getPartLength(s, 1) ? n._segment1 : n._segment2), this._segment = e;
    }
    return e;
  },
  getPath() {
    const e = this.getCurve();
    return e && e._path;
  },
  getIndex() {
    const e = this.getCurve();
    return e && e.getIndex();
  },
  getTime() {
    const e = this.getCurve(), n = this._time;
    return e && n == null ? this._time = e.getTimeOf(this._point) : n;
  },
  /**
   * The length of the path from its beginning up to the location described
   * by this object. If the curve is not part of a path, then the length
   * within the curve is returned instead.
   */
  getOffset() {
    let e = this._offset;
    if (e == null) {
      e = 0;
      const n = this.getPath(), s = this.getIndex();
      if (n && s != null) {
        const i = n.getCurves();
        for (let r = 0; r < s; r++)
          e += i[r].getLength();
      }
      this._offset = e += this.getCurveOffset();
    }
    return e;
  },
  /**
   * The length of the curve from its beginning up to the location described
   * by this object.
   */
  getCurveOffset() {
    let e = this._curveOffset;
    if (e == null) {
      const n = this.getCurve(), s = this.getTime();
      this._curveOffset = e = s != null && n && n.getPartLength(0, s);
    }
    return e;
  },
  getTangent() {
    const e = this.getCurve(), n = this.getTime();
    return n != null && e && e.getTangentAt(n, !0);
  },
  hasOverlap() {
    return !!this._overlap;
  },
  /**
   * Checks if the location is an intersection with another curve and is
   * merely touching the other curve, as opposed to crossing it.
   */
  isTouching() {
    const e = this._intersection;
    if (e && this.getTangent().isCollinear(e.getTangent())) {
      const n = this.getCurve(), s = e.getCurve();
      return !(n.isStraight() && s.isStraight() && n.getLine().intersect(s.getLine()));
    }
    return !1;
  },
  isCrossing() {
    var M, L, P, k;
    const e = this._intersection;
    if (!e)
      return !1;
    const n = this.getTime(), s = e.getTime(), i = Bs, r = 1 - i, o = n >= i && n <= r, a = s >= i && s <= r;
    if (o && a)
      return !this.isTouching();
    let c = this.getCurve();
    const l = c && n < i ? c.getPrevious() : c;
    let h = e.getCurve();
    const d = h && s < i ? h.getPrevious() : h;
    if (n > r && (c = c.getNext()), s > r && (h = h.getNext()), !l || !c || !d || !h)
      return !1;
    const p = [];
    o || (Lu(p, l, !0), Lu(p, c, !1)), a || (Lu(p, d, !0), Lu(p, h, !1));
    const E = this.getPoint(), g = Math.min.apply(Math, p), T = o ? c.getTangentAtTime(n) : (M = c.getPointAt(g)) == null ? void 0 : M.clone().subtract(E), A = o ? T == null ? void 0 : T.clone().negate() : (L = l.getPointAt(-g)) == null ? void 0 : L.clone().subtract(E), m = a ? h.getTangentAtTime(s) : (P = h.getPointAt(g)) == null ? void 0 : P.clone().subtract(E), O = a ? m == null ? void 0 : m.clone().negate() : (k = d.getPointAt(-g)) == null ? void 0 : k.clone().subtract(E), S = (A == null ? void 0 : A.angle()) * 180 / Math.PI, y = (T == null ? void 0 : T.angle()) * 180 / Math.PI, v = (O == null ? void 0 : O.angle()) * 180 / Math.PI, R = (m == null ? void 0 : m.angle()) * 180 / Math.PI;
    return !!(o ? wo(S, v, R) ^ wo(y, v, R) && wo(S, R, v) ^ wo(y, R, v) : wo(v, S, y) ^ wo(R, S, y) && wo(v, y, S) ^ wo(R, y, S));
  },
  /**
   * Checks whether tow CurveLocation objects are describing the same location
   * on a path, by applying the same tolerances as elsewhere when dealing with
   * curve-time parameters.
   *
   * @param {CurveLocation} loc
   * @param {boolean} _ignoreOther true if the locations are equal
   * @returns {boolean}
   */
  equals(e, n) {
    let s = this === e;
    if (!s && e instanceof ii) {
      const i = this.getCurve(), r = e.getCurve(), o = i._path, a = r._path;
      if (o === a) {
        const c = hr, l = _i(this.getOffset() - e.getOffset()), h = !n && this._intersection, d = !n && e._intersection;
        s = (l < c || o && _i(o.getLength() - l) < c) && (!h && !d || h && d && h.equals(d, !0));
      }
    }
    return s;
  },
  /**
   * @param {Segment} segment
   */
  _setSegment(e) {
    const n = e.getCurve();
    n ? this._setCurve(n) : (this._setPath(e._path), this._segment1 = e, this._segment2 = null), this._segment = e, this._time = e === this._segment1 ? 0 : 1, this._point = e._point.clone();
  },
  /**
   * @param {BezierPath} path
   */
  _setPath(e) {
    this._path = e, this._version = e ? e._version : 0;
  },
  /**
   * @param {CubicBez} curve
   */
  _setCurve(e) {
    this._setPath(e._path), this._curve = e, this._segment = null, this._segment1 = e._segment1, this._segment2 = e._segment2;
  }
};
ii.insert = (e, n, s) => {
  const i = e.length;
  let r = 0, o = i - 1;
  for (; r <= o; ) {
    const a = r + o >>> 1, c = e[a];
    let l = null;
    if (s && (l = n.equals(c) ? c : FI(e, n, i, a, -1) || FI(e, n, i, a, 1)))
      return n._overlap && (l._overlap = !0, l._intersection._overlap = !0), l;
    const h = n.getPath(), d = c.getPath();
    (h !== d ? h._id - d._id : n.getIndex() + n.getTime() - (c.getIndex() + c.getTime())) < 0 ? o = a - 1 : r = a + 1;
  }
  return e.splice(r, 0, n), n;
};
ii.expand = (e) => {
  const n = e.slice();
  for (let s = e.length - 1; s >= 0; s--)
    ii.insert(n, e[s]._intersection, !1);
  return n;
};
function Lu(e, n, s) {
  const i = n.getValues(), r = ae.classify(i).roots || ae.getPeaks(i), o = r.length, a = ae.getLength(
    i,
    s && o ? r[o - 1] : 0,
    !s && o ? r[0] : 1
  );
  e.push(o ? a : a / 32);
}
function wo(e, n, s) {
  return typeof e != "number" || typeof n != "number" || typeof s != "number" ? !1 : n < s ? e > n && e < s : e > n || e < s;
}
function FI(e, n, s, i, r) {
  for (let o = i + r; o >= -1 && o <= s; o += r) {
    const a = e[(o % s + s) % s];
    if (!n.getPoint().isClose(a.getPoint(), hr))
      break;
    if (n.equals(a))
      return a;
  }
  return null;
}
let $y = 1;
const bi = {
  precision: 5,
  multiplier: 1,
  /**
   * @param {number} precision
   */
  setup(e = 5) {
    this.precision = e | 0, this.multiplier = Math.pow(10, this.precision);
  },
  /**
   * Utility function for rendering numbers as strings at a precision of
   * up to the amount of fractional digits.
   * @param {number} val the number to be converted to a string
   */
  number(e) {
    return this.precision < 16 ? Math.round(e * this.multiplier) / this.multiplier : e;
  },
  /**
   * @param {number} val1
   * @param {number} val2
   * @param {string} separator
   */
  pair(e, n, s = ",") {
    return this.number(e) + s + this.number(n);
  }
};
function kI(e, n, s, i, r, o) {
  e._transformCoordinates(n);
  for (let c = 0; c < 2; c++)
    ae._addBounds(
      s[c],
      // prev.point
      s[c + 4],
      // prev.handleOut
      n[c + 2],
      // segment.handleIn
      n[c],
      // segment.point,
      c,
      i,
      r,
      o
    );
  const a = s;
  s = n, n = a;
}
function eC(e, n, s) {
  const i = cE(s);
  let [r, o] = [e, n];
  r > o && ([r, o] = [o, r]), r = BI(r), o = BI(o), r = Math.round((r + i) * 1e4) * 1e-4, o = Math.round((o + i) * 1e4) * 1e-4;
  let a = !1;
  return r > 1 && (r = cE(r), a = !a), o > 1 && (o = cE(o), a = !a), [r, o, a];
}
function BI(e) {
  return KF(0, 1, e);
}
function cE(e) {
  return e - Math.floor(e);
}
function KF(e, n, s) {
  return Math.min(n, Math.max(s, e));
}
function Ya(e, n) {
  const s = e, i = n.length;
  if (i < 4096)
    s.push.apply(s, n);
  else {
    const r = s.length;
    s.length += i;
    for (let o = 0; o < i; o++)
      s[r + o] = n[o];
  }
  return s;
}
function rg(e, n, s, i) {
  const r = n && n.length, o = s === void 0;
  s = o ? e.length : s, s > e.length && (s = e.length);
  for (let a = 0; a < r; a++)
    n[a]._index = s + a;
  if (o)
    return Ya(e, n), [];
  {
    const a = [s, i];
    n && Ya(a, n);
    const c = e.splice.apply(e, a);
    for (let l = 0, h = c.length; l < h; l++)
      c[l]._index = void 0;
    for (let l = s + r, h = e.length; l < h; l++)
      e[l]._index = l;
    return c;
  }
}
function tC(e, n, s) {
  for (let i = 0, r = e.length; i < r; i++)
    n.call(s, e[i], i);
  return s;
}
function og(e) {
  const n = e._parent, s = e._index;
  return n ? (Number.isFinite(s) && rg(n._children, null, s, 1), e._parent = null, !0) : !1;
}
function _0(e) {
  if (e._children) {
    const n = new qe();
    for (let s = 0, i = e._children.length; s < i; s++)
      n.addChild(_0(e._children[s]), !0);
    return n.version = e.version, n;
  } else {
    const n = new xt();
    return n.setSegments(e._segments.slice()), n._closed = e._closed, n;
  }
}
function nC(e, n, s, i) {
  const r = e === n || !n;
  return r || e.getBounds().intersects(n.getBounds(), Qn) ? ae.getIntersections(
    e.getCurves(),
    !r && n.getCurves(),
    s,
    i
  ) : [];
}
function VI(e, n) {
  const s = e && e._intersection;
  return s && s._overlap && s._path === n;
}
const sC = (e) => {
  const n = e._children;
  let s = n || [e], i = !1, r = !1, o = e.getIntersections(null, function(h) {
    return (
      // eslint-disable-next-line no-mixed-operators
      h.hasOverlap() && (i = !0) || h.isCrossing() && (r = !0)
    );
  });
  const a = i && r && [];
  if (o = ii.expand(o), i) {
    const h = Ld(
      o,
      (d) => d.hasOverlap(),
      a
    );
    for (let d = h.length - 1; d >= 0; d--) {
      const p = h[d], E = p._path, g = p._segment, T = g.getPrevious(), A = g.getNext();
      VI(T, E) && VI(A, E) && (g.remove(), T._handleOut.set(0, 0), A._handleIn.set(0, 0), T._changed(T._handleOut), A._changed(A._handleIn), T !== g && !T.getCurve().hasLength() && (A._handleIn.set(T._handleIn.x, T._handleIn.y), A._changed(A._handleIn), T.remove()));
    }
  }
  r && (Ld(
    o,
    i && ((h) => {
      const d = h.getCurve(), p = h.getSegment(), E = h._intersection, g = E._curve, T = E._segment;
      if (d && g && d._path && g._path)
        return !0;
      p && (p._intersection = null), T && (T._intersection = null);
    }),
    a
  ), a && oC(a), s = aC(
    tC(
      s,
      function(h) {
        Ya(this, h._segments);
      },
      []
    )
  ));
  const c = s.length;
  let l;
  return c > 1 && n ? (s !== n && e.setChildren(s), l = e) : c === 1 && !n && (s[0] !== e && e.setSegments(s[0].removeSegments()), l = e), l || (l = new qe(), l.addChildren(s), l = l.reduce()), l;
};
function iC(e, n, s) {
  const i = e._children;
  return i && i.length ? e.setChildren(
    cC(
      e.removeChildren(),
      // Handle both even-odd and non-zero rule.
      (r) => !!(n ? r : r & 1),
      s
    )
  ) : s !== void 0 && e.setClockwise(s), e;
}
function rC(e) {
  const s = e.getBounds().getCenter();
  if (!e.contains(s)) {
    const i = e.getCurves(), r = s.y, o = [], a = [];
    for (let c = 0, l = i.length; c < l; c++) {
      const h = i[c].getValues(), d = h[1], p = h[3], E = h[5], g = h[7];
      if (r >= Pl(d, p, E, g) && r <= Ec(d, p, E, g)) {
        const T = ae.getMonoCurves(h);
        for (let A = 0, m = T.length; A < m; A++) {
          const O = T[A], S = O[1], y = O[7];
          if (S !== y && (r >= S && r <= y || r >= y && r <= S)) {
            const v = r === S ? O[0] : r === y ? O[6] : ae.solveCubic(O, 1, r, a, 0, 1) === 1 ? ae.getPoint(O, a[0]).x : (O[0] + O[6]) / 2;
            o.push(v);
          }
        }
      }
    }
    o.length > 1 && (o.sort((c, l) => c - l), s.x = (o[0] + o[1]) / 2);
  }
  return s;
}
function oC(e) {
  for (let n = e.length - 1; n >= 0; n--)
    e[n].clearHandles();
}
const Pl = Math.min, Ec = Math.max, _i = Math.abs, HI = Math.sqrt, QF = {
  [ln.UNION]: { 1: !0, 2: !0 },
  [ln.INTERSECT]: { 2: !0 },
  [ln.SUBTRACT]: { 1: !0 },
  // exclude only needs -1 to support reorientPaths() when there are
  // no crossings. The actual boolean code uses unsigned winding.
  [ln.DIFFERENCE]: { 1: !0, "-1": !0 }
};
function ZF(e, n) {
  const s = new qe();
  s.moveTo(0, 0), s.lineTo(n.width, 0), s.lineTo(n.width, n.height), s.lineTo(0, n.height), s.close();
  const i = Dd(e, !1), r = Dd(s, !0), a = ii.expand(i.getIntersections(r, lC)).filter((d) => d._curve._path !== r.getCurrentPath()), c = n.clone();
  if (c.x -= Bs, c.y -= Bs, c.width += Bs * 2, c.height += Bs * 2, !a.length)
    return null;
  const l = new qe(), h = Ld(a);
  for (const d of e._children)
    c.containsRect(d.getBounds()) && l.addChild(d.clone());
  for (let d = 0; d < h.length; d++) {
    let p = [];
    const E = h[d]._path._segments;
    for (let g = 0; g < E.length - 1; g++) {
      const T = E[g], A = E[g + 1];
      c.contains(T._point) && c.contains(A._point) ? (p.length === 0 && p.push(T), p.push(A)) : (p.length >= 2 && l.addChild(xt.createPath(p, !1)), p = []);
    }
    p.length >= 2 && l.addChild(xt.createPath(p, !1));
  }
  return l;
}
function Mu(e, n, s) {
  const i = Dd(e, !0), r = n && e !== n && Dd(n, !0), o = QF[s];
  o[s - 10] = !0, r && (o[ln.SUBTRACT - 10] || o[ln.DIFFERENCE - 10]) ^ (r.isClockwise() ^ i.isClockwise()) && r.reverse();
  const a = ii.expand(
    i.getIntersections(r, lC)
  ), c = Ld(a), l = ag(i), h = r && ag(r), d = [], p = [];
  let E;
  if (c.length) {
    WI(l, d, p), h && WI(h, d, p);
    const g = Array(p.length);
    for (let m = 0, O = p.length; m < O; m++)
      g[m] = p[m].getValues();
    const T = jy(
      g,
      g,
      0,
      !0
    ), A = {};
    for (let m = 0; m < p.length; m++) {
      const O = p[m], S = O._path._id;
      A[S] = A[S] || {};
      const y = A[S];
      y[O.getIndex()] = {
        hor: YI(T[m].hor, p),
        ver: YI(T[m].ver, p)
      };
    }
    for (let m = 0, O = c.length; m < O; m++)
      KI(
        c[m]._segment,
        i,
        r,
        A,
        o
      );
    for (let m = 0, O = d.length; m < O; m++) {
      const S = d[m], y = S._intersection;
      S._winding || KI(
        S,
        i,
        r,
        A,
        o
      ), y && y._overlap || (S._path._overlapsOnly = !1);
    }
    E = aC(d, o);
  } else
    E = cC(
      // Make sure reorientPaths() never works on original
      // _children arrays by calling paths1.slice()
      h ? l.concat(h) : l.slice(),
      (g) => !!o[g]
    );
  return jF(E, !0);
}
function WI(e, n, s) {
  for (let i = 0, r = e.length; i < r; i++) {
    const o = e[i];
    Ya(n, o._segments), Ya(s, o.getCurves()), o._overlapsOnly = !0;
  }
}
function YI(e, n) {
  const s = [];
  for (let i = 0, r = e && e.length; i < r; i++)
    s.push(n[e[i]]);
  return s;
}
function Dd(e, n) {
  let s = e, i = s.clone(!1).reduce(!0);
  if (n) {
    const r = ag(i);
    for (let o = 0, a = r.length; o < a; o++)
      s = r[o], !s._closed && !s.isEmpty() && (s.close(Qn), s.getFirstSegment().setHandleIn(new N(0, 0)), s.getLastSegment().setHandleOut(new N(0, 0)));
    i = i.resolveCrossings().reorient(i.getFillRule() === "nonzero", !0);
  }
  return i;
}
function Ld(e, n, s) {
  const i = n && [], r = Bs, o = 1 - r;
  let a = !1;
  const c = s || [], l = s && {};
  let h, d, p;
  for (let E = (s && s.length) - 1; E >= 0; E--) {
    const g = s[E];
    g._path && (l[XI(g)] = !0);
  }
  for (let E = e.length - 1; E >= 0; E--) {
    const g = e[E];
    let T = g._time;
    const A = T, m = n && !n(g), O = g._curve;
    let S;
    if (O && (O !== d ? (a = !O.hasHandles() || l && l[XI(O)], h = [], p = null, d = O) : p >= r && (T /= p)), m) {
      h && h.push(g);
      continue;
    } else n && i.unshift(g);
    if (p = A, T < r)
      S = O._segment1;
    else if (T > o)
      S = O._segment2;
    else {
      const R = O.divideAtTime(T, !0);
      a && c.push(O, R), S = R._segment1;
      for (let M = h.length - 1; M >= 0; M--) {
        const L = h[M];
        L._time = (L._time - T) / (1 - T);
      }
    }
    g._setSegment(S);
    const y = S._intersection, v = g._intersection;
    if (y) {
      zI(y, v);
      let R = y;
      for (; R; )
        zI(R._intersection, y), R = R._next;
    } else
      S._intersection = v;
  }
  return s || oC(c), i || e;
}
function XI(e) {
  return e._path._id + "." + e._segment1._index;
}
function zI(e, n) {
  let s = e;
  for (; s; ) {
    if (s === n)
      return;
    s = s._previous;
  }
  for (; e._next && e._next !== n; )
    e = e._next;
  if (!e._next) {
    for (; n._previous; )
      n = n._previous;
    e._next = n, n._previous = e;
  }
}
function cf(e, n, s, i, r) {
  const o = Array.isArray(n) ? n : n[s ? "hor" : "ver"], a = s ? 1 : 0, c = a ^ 1, l = [e.x, e.y], h = l[a], d = l[c], p = 1e-9, E = 1e-6, g = h - p, T = h + p;
  let A = 0, m = 0, O = 0, S = 0, y = !1, v = !1, R = 1;
  const M = [];
  let L, P;
  function k(b) {
    const X = b[c + 0], K = b[c + 6];
    if (d < Pl(X, K) || d > Ec(X, K))
      return;
    const V = b[a + 0], J = b[a + 2], ge = b[a + 4], ne = b[a + 6];
    if (X === K) {
      (V < T && ne > g || ne < T && V > g) && (y = !0);
      return;
    }
    const ue = d === X ? 0 : d === K || g > Ec(V, J, ge, ne) || T < Pl(V, J, ge, ne) ? 1 : ae.solveCubic(b, c, d, M, 0, 1) > 0 ? M[0] : 1, te = ue === 0 ? V : ue === 1 ? ne : ae.getPoint(b, ue)[s ? "y" : "x"], ie = X > K ? 1 : -1, re = L[c] > L[c + 6] ? 1 : -1, fe = L[a + 6];
    return d !== X ? (te < g ? O += ie : te > T ? S += ie : y = !0, te > h - E && te < h + E && (R /= 2)) : (ie !== re ? V < g ? O += ie : V > T && (S += ie) : V !== fe && (fe < T && te > T ? (S += ie, y = !0) : fe > g && te < g && (O += ie, y = !0)), R /= 4), L = b, !r && te > g && te < T && ae.getTangent(b, ue)[s ? "x" : "y"] === 0 && cf(e, n, !s, i, !0);
  }
  function Q(b) {
    const X = b[c + 0], K = b[c + 2], V = b[c + 4], J = b[c + 6];
    if (d <= Ec(X, K, V, J) && d >= Pl(X, K, V, J)) {
      const ge = b[a + 0], ne = b[a + 2], ue = b[a + 4], te = b[a + 6], ie = g > Ec(ge, ne, ue, te) || T < Pl(ge, ne, ue, te) ? [b] : ae.getMonoCurves(b, s);
      let re;
      for (let fe = 0, Ne = ie.length; fe < Ne; fe++)
        if (re = k(ie[fe]), re)
          return re;
    }
  }
  for (let b = 0, X = o.length; b < X; b++) {
    const K = o[b], V = K._path, J = K.getValues();
    let ge;
    if ((!b || o[b - 1]._path !== V) && (L = null, V._closed || (P = ae.getValues(
      V.getLastCurve().getSegment2(),
      K.getSegment1(),
      !i
    ), P[c] !== P[c + 6] && (L = P)), !L)) {
      L = J;
      let ne = V.getLastCurve();
      for (; ne && ne !== K; ) {
        const ue = ne.getValues();
        if (ue[c] !== ue[c + 6]) {
          L = ue;
          break;
        }
        ne = ne.getPrevious();
      }
    }
    if (ge = Q(J), ge)
      return ge;
    if (b + 1 === X || o[b + 1]._path !== V) {
      if (P && (ge = Q(P)))
        return ge;
      y && !O && !S && (O = V.isClockwise(i) ^ s ? 1 : -1, S = O), A += O, m += S, O = 0, S = 0, y && (v = !0, y = !1), P = null;
    }
  }
  return A = _i(A), m = _i(m), {
    winding: Ec(A, m),
    windingL: A,
    windingR: m,
    quality: R,
    onPath: v
  };
}
function KI(e, n, s, i, r) {
  const o = [], a = e;
  let c = 0, l;
  do {
    const E = e.getCurve();
    if (E) {
      const g = E.getLength();
      o.push({ segment: e, curve: E, length: g }), c += g;
    }
    e = e.getNext();
  } while (e && !e._intersection && e !== a);
  const h = [0.5, 0.25, 0.75];
  l = { winding: 0, quality: -1 };
  const d = 1e-3, p = 1 - d;
  for (let E = 0; E < h.length && l.quality < 0.5; E++) {
    let g = c * h[E];
    for (let T = 0, A = o.length; T < A; T++) {
      const m = o[T], O = m.length;
      if (g <= O) {
        const S = m.curve, y = S._path, v = y._parent, R = v instanceof qe ? v : y, M = Zn.clamp(S.getTimeAt(g), d, p), L = S.getPointAtTime(M), P = _i(S.getTangentAtTime(M).y) < Math.SQRT1_2;
        let k = null;
        if (r[ln.SUBTRACT - 10] && s) {
          const b = (R === n ? s : n)._getWinding(L, P, !0);
          if (R === n && b.winding || R === s && !b.winding) {
            if (b.quality < 1)
              continue;
            k = { winding: 0, quality: 1 };
          }
        }
        k = k || cf(
          L,
          i[y._id][S.getIndex()],
          P,
          !0
        ), k.quality > l.quality && (l = k);
        break;
      }
      g -= O;
    }
  }
  for (let E = o.length - 1; E >= 0; E--)
    o[E].segment._winding = l;
}
function aC(e, n) {
  const s = [], i = [];
  e.sort(function(r, o) {
    const a = r._intersection, c = o._intersection, l = !!(a && a._overlap), h = !!(c && c._overlap), d = r._path, p = o._path;
    return l ^ h ? l ? 1 : -1 : !a ^ !c ? a ? 1 : -1 : d !== p ? d._id - p._id : r._index - o._index;
  });
  for (let r = 0, o = e.length; r < o; r++) {
    let a = e[r], c = Cc(a, n), l = null, h = !1, d = !0;
    const p = [];
    let E, g, T;
    if (c && a._path._overlapsOnly) {
      const A = a._path, m = a._intersection._segment._path;
      A.compare(m) && (A.getArea() && s.push(A.clone(!1)), QI(A), QI(m), c = !1);
    }
    for (; c; ) {
      const A = !l, m = qF(a, A, i, n), O = m.shift();
      h = !A && (Md(a, i) || Md(O, i));
      const S = !h && O;
      if (A && (l = new xt(), E = null), h) {
        (a.isFirst() || a.isLast()) && (d = a._path._closed), a._visited = !0;
        break;
      }
      if (S && E && (p.push(E), E = null), E || (S && m.push(a), E = {
        start: l._segments.length,
        crossings: m,
        visited: g = [],
        handleIn: T
      }), S && (a = O), !Cc(a, n)) {
        l.removeSegments(E.start);
        for (let v = 0, R = g.length; v < R; v++)
          g[v]._visited = !1;
        g.length = 0;
        do
          a = E && E.crossings.shift(), (!a || !a._path) && (a = null, E = p.pop(), E && (g = E.visited, T = E.handleIn));
        while (E && !Cc(a, n));
        if (!a)
          break;
      }
      const y = a.getNext();
      l.add(
        new Fe().initWithPoints(
          a._point,
          T,
          y && a._handleOut
        )
      ), a._visited = !0, g.push(a), a = y || a._path.getFirstSegment(), T = y && y._handleIn;
    }
    h && (d && (l.getFirstSegment().setHandleIn(T), l.setClosed(d)), l.getArea() !== 0 && s.push(l));
  }
  return s;
}
function Cc(e, n) {
  let s;
  return !!(e && !e._visited && (!n || n[(s = e._winding || {}).winding] && !(n[ln.UNION - 10] && s.winding === 2 && s.windingL && s.windingR)));
}
function Md(e, n) {
  if (e) {
    for (let s = 0, i = n.length; s < i; s++)
      if (e === n[s])
        return !0;
  }
  return !1;
}
function QI(e) {
  const n = e._segments;
  for (let s = 0, i = n.length; s < i; s++)
    n[s]._visited = !0;
}
function qF(e, n, s, i) {
  let r = e._intersection;
  const o = r, a = [];
  if (n && (s.length = 0, s[0] = e), r) {
    for (ZI(r, null, e, a, n, s, i); r && r._previous; )
      r = r._previous;
    ZI(r, o, e, a, n, s, i);
  }
  return a;
}
function ZI(e, n, s, i, r, o, a) {
  for (; e && e !== n; ) {
    const c = e._segment, l = c && c._path;
    if (l) {
      const h = c.getNext() || l.getFirstSegment(), d = h._intersection;
      c !== s && (Md(c, o) || Md(h, o) || h && Cc(c, a) && (Cc(h, a) || d && Cc(d._segment, a))) && i.push(c), r && o.push(c);
    }
    e = e._next;
  }
}
function cC(e, n, s) {
  const i = e && e.length;
  if (i) {
    const r = tC(e, function(l, h) {
      this[l._id] = {
        container: null,
        winding: l.isClockwise() ? 1 : -1,
        index: h
      };
    }, {}), o = e.slice().sort((l, h) => _i(h.getArea()) - _i(l.getArea())), a = o[0], c = XF(
      o,
      null,
      hr
    );
    s == null && (s = a.isClockwise());
    for (let l = 0; l < i; l++) {
      const h = o[l], d = r[h._id];
      let p = 0;
      const E = c[l];
      if (E) {
        let g = null;
        for (let T = E.length - 1; T >= 0; T--)
          if (E[T] < l) {
            g = g || h.getInteriorPoint();
            const A = o[E[T]];
            if (A.contains(g)) {
              const m = r[A._id];
              p = m.winding, d.winding += p, d.container = m.exclude ? m.container : A;
              break;
            }
          }
      }
      if (n(d.winding) === n(p))
        d.exclude = !0, e[d.index] = null;
      else {
        const g = d.container;
        h.setClockwise(
          g ? !g.isClockwise() : s
        );
      }
    }
  }
  return e;
}
function jF(e, n) {
  let s = new qe();
  return s.addChildren(e, !0), s = s.reduce(n), s;
}
function lC(e) {
  return e.hasOverlap() || e.isCrossing();
}
function ag(e) {
  return e._children || [e];
}
const hC = 1e-10;
function JF(e, n, s = hC) {
  return e - n >= 0 ? e - n <= s : n - e <= s;
}
function uC(e, n) {
  return JF(e, n, hC);
}
function ae() {
  this._path = null, this._segment1 = null, this._segment2 = null, this._length = null, this._bounds = null;
}
ae.prototype = {
  constructor: ae,
  /**
   * @param {Segment} seg1
   * @param {Segment} seg2
   */
  initWithSegments(e, n) {
    return this._segment1 = new Fe().copy(e), this._segment2 = new Fe().copy(n), this;
  },
  /**
   * @param {BezierPath} path
   * @param {Segment} seg1
   * @param {Segment} seg2
   */
  initWithPathAndSegments(e, n, s) {
    return this._path = e, this._segment1 = n, this._segment2 = s, this;
  },
  /**
   * initialize with 4 absoluate points
   * @param {Vector2Like} point1
   * @param {Vector2Like} control1
   * @param {Vector2Like} control2
   * @param {Vector2Like} point2
   */
  initWith4Points(e, n, s, i) {
    return this._segment1 = new Fe().initWithPointsN(
      e.x,
      e.y,
      0,
      0,
      n.x - e.x,
      n.y - e.y
    ), this._segment2 = new Fe().initWithPointsN(
      i.x,
      i.y,
      s.x - i.x,
      s.y - i.y,
      0,
      0
    ), this;
  },
  /**
   * initialize with 4 points (2 relative handle)
   * @param {Vector2Like} point1
   * @param {Vector2Like} handle1
   * @param {Vector2Like} handle2
   * @param {Vector2Like} point2
   */
  initWithPointsAndHandles(e, n, s, i) {
    return this._segment1 = new Fe().initWithPoints(e, null, n), this._segment2 = new Fe().initWithPoints(i, s, null), this;
  },
  /**
   * initialize with 4 numbered points
   * @param {number} x1
   * @param {number} y1
   * @param {number} hx1
   * @param {number} hy1
   * @param {number} hx2
   * @param {number} hy2
   * @param {number} x2
   * @param {number} y2
   */
  initWith4PointsN(e, n, s, i, r, o, a, c) {
    return this._segment1 = new Fe().initWithPointsN(e, n, 0, 0, s - e, i - n), this._segment2 = new Fe().initWithPointsN(a, c, r - a, o - c, 0, 0), this;
  },
  /**
   * initialize with 4 numbered points (2 relative handle)
   * @param {number} x1
   * @param {number} y1
   * @param {number} hx1
   * @param {number} hy1
   * @param {number} hx2
   * @param {number} hy2
   * @param {number} x2
   * @param {number} y2
   */
  initWithPointsAndHandlesN(e, n, s, i, r, o, a, c) {
    return this._segment1 = new Fe().initWithPointsN(e, n, 0, 0, s, i), this._segment2 = new Fe().initWithPointsN(a, c, r, o, 0, 0), this;
  },
  /**
   * @param {number} dimension
   */
  regularize(e) {
    const n = this.getP0(), s = this.getP1(), i = this.getP2(), r = this.getP3(), o = e * e;
    if (n.distance_squared_to(s) < o) {
      const c = n.distance_squared_to(i);
      if (c >= o)
        s.copy(n).linear_interpolate(i, Qo(o / c));
      else
        return s.copy(n).linear_interpolate(r, 1 / 3), i.copy(r).linear_interpolate(n, 1 / 3), this.initWith4Points(n, s, i, r);
    }
    if (r.distance_squared_to(i) < o) {
      const c = s.distance_squared_to(i);
      if (c >= o)
        i.copy(r).linear_interpolate(s, Qo(o / c));
      else
        return s.copy(n).linear_interpolate(r, 1 / 3), i.copy(r).linear_interpolate(n, 1 / 3), this.initWith4Points(n, s, i, r);
    }
    const a = this.detectCusp(e);
    if (a !== hc.None) {
      const c = s.clone().sub(n), l = c.length(), h = r.clone().sub(i), d = h.length();
      switch (a) {
        case hc.Loop: {
          s.add(c.scale(e / l)), i.sub(h.scale(e / d));
          break;
        }
        case hc.DoubleInflection: {
          l > 2 * e && s.sub(c.scale(e / l)), d > 2 * e && i.add(h.scale(e / d));
          break;
        }
      }
    }
    return this.initWith4Points(n, s, i, r);
  },
  /**
   * @param {number} dimension
   */
  detectCusp(e) {
    const n = this.getP0(), s = this.getP1(), i = this.getP2(), r = this.getP3(), o = s.clone().sub(n), a = i.clone().sub(n), c = r.clone().sub(n), l = i.clone().sub(s), h = r.clone().sub(i), d = o.cross(a), p = l.cross(h), E = o.cross(c), g = a.cross(c);
    if (d * p > 0 && d * E < 0 && d * g < 0) {
      const T = this.deriv(), A = T.nearest(N.ZERO, 1e-9), m = T.eval(A.t), O = T.deriv().eval(A.t), S = m.cross(O);
      if (lg(A.distance_sq, 3) < lg(S * e, 2)) {
        const y = 3 * d + g - 2 * E, v = -3 * d + E, R = d;
        return v * v - 4 * y * R > 0 ? hc.DoubleInflection : hc.Loop;
      }
    }
    return hc.None;
  },
  deriv() {
    const e = this.getP0(), n = this.getP1(), s = this.getP2(), i = this.getP3();
    return new wd().initN(
      3 * (n.x - e.x),
      3 * (n.y - e.y),
      3 * (s.x - n.x),
      3 * (s.y - n.y),
      3 * (i.x - s.x),
      3 * (i.y - s.y)
    );
  },
  /**
   * @param {number} t
   */
  eval(e) {
    const n = this.getP0(), s = this.getP1(), i = this.getP2(), r = this.getP3(), o = 1 - e, a = new N();
    return a.copy(n).scale(o * o * o).add(
      s.clone().scale(o * o * 3).add(
        i.clone().scale(o * 3).add(
          r.clone().scale(e)
        ).scale(e)
      ).scale(e)
    ), a;
  },
  /**
   * @param {number} w0
   * @param {number} w1
   * @param {number} w2
   * @param {number} w3
   */
  weightsum(e, n, s, i) {
    const r = this.getP0(), o = this.getP1(), a = this.getP2(), c = this.getP3(), l = e * r.x + n * o.x + s * a.x + i * c.x, h = e * r.y + n * o.y + s * a.y + i * c.y;
    return new N(l, h);
  },
  /**
   * @param {number} param
   */
  getDerivativeAt(e) {
    const [n, s] = [e, 1 - e], i = -3 * s * s, r = 3 * s * s - 6 * n * s, o = -3 * n * n + 6 * n * s, a = 3 * n * n;
    return this.weightsum(i, r, o, a);
  },
  /**
   * @param {number} param
   */
  getSecondDerivativeAt(e) {
    const [n, s] = [e, 1 - e], i = 6 * s, r = -12 * s + 6 * n, o = -12 * n + 6 * s, a = 6 * n;
    return this.weightsum(i, r, o, a);
  },
  /**
   * The arc length of the curve
   * @param {number} accuracy
   */
  arclen(e) {
    return Pd(this.getValues(), e, 0);
  },
  /**
   * Solve for the parameter that has the given arc length from the start
   * @param {number} arclen
   * @param {number} accuracy
   */
  invArclen(e, n) {
    if (e <= 0)
      return 0;
    const s = this.arclen(n);
    if (e >= s)
      return 1;
    const i = n / s, r = this.getValues();
    return gC((a) => Pd(ae.getPart(r, 0, a), n, 0) - e, 0, 1, i, 1, 2, -e, s - e);
  },
  clone() {
    return new ae().initWithSegments(this._segment1.clone(), this._segment2.clone());
  },
  remove() {
    let e = !1;
    if (this._path) {
      const n = this._segment2, s = n._handleOut;
      e = n.remove(), e && (this._segment1._handleOut.set(s.x, s.y), this._segment1._changed(this._segment1._handleOut));
    }
    return e;
  },
  /**
   * Divides the curve into two curves at the given curve-time parameter. The
   * curve itself is modified and becomes the first part, the second part is
   * returned as a new curve. If the modified curve belongs to a path item,
   * the second part is also added to the path.
   *
   * @param {number} time the curve-time parameter on the curve at which to
   *     divide
   * @param {boolean} _setHandles
   * @returns the second part of the divided curve, if the offset is
   *     within the valid range, {code null} otherwise.
   */
  divideAtTime(e, n) {
    const s = Bs, i = 1 - s;
    let r = null;
    if (e >= s && e <= i) {
      const o = ae.subdivide(this.getValues(), e), a = o[0], c = o[1], l = n || this.hasHandles(), h = this._segment1, d = this._segment2, p = this._path;
      l && (h._handleOut.set(a[2] - a[0], a[3] - a[1]), d._handleIn.set(c[4] - c[6], c[5] - c[7]), h._changed(h._handleOut), d._changed(d._handleIn));
      const E = a[6], g = a[7], T = new Fe().initWithPoints(
        new N(E, g),
        l && new N(a[4] - E, a[5] - g),
        l && new N(c[2] - E, c[3] - g)
      );
      p ? (p.insert(h._index + 1, T), r = this.getNext()) : (this._segment2 = T, this._changed(), r = new ae().initWithSegments(T, d));
    }
    return r;
  },
  /**
   * Clears the curve's handles by setting their coordinates to zero,
   * turning the curve into a straight line.
   */
  clearHandles() {
    this._segment1._handleOut.set(0, 0), this._segment2._handleIn.set(0, 0), this._segment1._changed(this._segment1._handleOut), this._segment2._changed(this._segment2._handleIn);
  },
  getIndex() {
    return this._segment1._index;
  },
  getPrevious() {
    const e = this._path && this._path._curves;
    return e && (e[this._segment1._index - 1] || this._path._closed && e[e.length - 1]) || null;
  },
  getNext() {
    const e = this._path && this._path._curves;
    return e && (e[this._segment1._index + 1] || this._path._closed && e[0]) || null;
  },
  getPoint1() {
    return this._segment1._point;
  },
  getHandle1() {
    return this._segment1._handleOut;
  },
  getHandle2() {
    return this._segment2._handleIn;
  },
  getPoint2() {
    return this._segment2._point;
  },
  getP0() {
    return this._segment1._point;
  },
  getP1() {
    return this._segment1._handleOut.clone().add(this._segment1._point);
  },
  getP2() {
    return this._segment2._handleIn.clone().add(this._segment2._point);
  },
  getP3() {
    return this._segment2._point;
  },
  getLength() {
    return this._length == null && (this._length = ae.getLength(this.getValues(), 0, 1)), this._length;
  },
  getSegment1() {
    return this._segment1;
  },
  getSegment2() {
    return this._segment2;
  },
  /**
   * @param {number} from
   * @param {number} to
   */
  getPartLength(e, n) {
    return ae.getLength(this.getValues(), e, n);
  },
  /**
   * Returns the curve-time parameter of the specified point if it lies on the
   * curve, `null` otherwise.
   * Note that if there is more than one possible solution in a
   * self-intersecting curve, the first found result is returned.
   *
   * @param {Vector2} point the point on the curve
   * @returns {number} the curve-time parameter of the specified point
   */
  getTimeOf(e) {
    return ae.getTimeOf(this.getValues(), e);
  },
  /**
   * @param {number} location
   * @param {boolean} _isTime
   */
  getPointAt(e, n) {
    const s = this.getValues();
    return ae.getPoint(
      s,
      n ? e : ae.getTimeAt(s, e)
    );
  },
  /**
   * Calculates the point on the curve at the given location.
   * @param {number} time curve-time, a value between 0 and 1
   */
  getPointAtTime(e) {
    return ae.getPoint(this.getValues(), e);
  },
  /**
   * Calculates the normalized tangent vector of the curve at the given
   * location.
   * @param {number} time curve-time, a value between 0 and 1
   */
  getTangentAtTime(e) {
    return ae.getTangent(this.getValues(), e);
  },
  /**
   * @param {number} location
   * @param {boolean} _isTime
   */
  getTangentAt(e, n) {
    const s = this.getValues();
    return ae.getTangent(
      s,
      n ? e : ae.getTimeAt(s, e)
    );
  },
  /**
   * Calculates the curve offset at the specified curve-time parameter on
   * the curve.
   *
   * @param {number} t the curve-time parameter on the curve
   * returns the curve offset at the specified the location
   */
  getOffsetAtTime(e) {
    return this.getPartLength(0, e);
  },
  /**
   * Calculates the curve location at the specified offset on the curve.
   *
   * @param {number} offset the offset on the curve
   * @param {boolean} _isTime
   */
  getLocationAt(e, n) {
    return this.getLocationAtTime(n ? e : this.getTimeAt(e));
  },
  /**
   * Calculates the curve location at the specified curve-time parameter on
   * the curve.
   *
   * @param {number} t the curve-time parameter on the curve
   * @returns the curve location at the specified the location
   */
  getLocationAtTime(e) {
    return e != null && e >= 0 && e <= 1 ? new ii().init(this, e) : null;
  },
  /**
   * Calculates the curve-time parameter of the specified offset on the path,
   * relative to the provided start parameter. If offset is a negative value,
   * the parameter is searched to the left of the start parameter. If no start
   * parameter is provided, a default of `0` for positive values of `offset`
   * and `1` for negative values of `offset`.
   *
   * @param {number} offset the offset at which to find the curve-time, in
   *     curve length units
   * @param {number} [start] the curve-time in relation to which the offset is
   *     determined
   * @returns the curve-time parameter at the specified location
   */
  getTimeAt(e, n) {
    return ae.getTimeAt(this.getValues(), e, n);
  },
  /**
   * @param {CubicBez} curve
   */
  getIntersections(e) {
    const n = this.getValues(), s = e && e !== this && e.getValues();
    return s ? fC(n, s, this, e, []) : dC(n, this, []);
  },
  /**
   * Checks if this curve has any curve handles set.
   */
  hasHandles() {
    return !this._segment1._handleOut.is_zero(ms) || !this._segment2._handleIn.is_zero(ms);
  },
  /**
   * Checks if this curve has any length.
   * @param {number} [epsilon=0] the epsilon against which to compare the curve's length
   * @returns true if the curve is longer than the given epsilon
   */
  hasLength(e) {
    return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles()) && this.getLength() > (e || 0);
  },
  /**
   * @param {CubicBez} curve
   */
  isCollinear(e) {
    return e && this.isStraight() && e.isStraight() && this.getLine().isCollinear(e.getLine());
  },
  isStraight() {
    return ae.isStraight(this.getValues(), hr);
  },
  getValues() {
    return ae.getValues(this._segment1, this._segment2);
  },
  getBounds() {
    if (this._bounds == null) {
      const e = this.getValues();
      this._bounds = ae.getBounds(e);
    }
    return this._bounds;
  },
  /**
   * @returns {Line}
   */
  getLine() {
    return new qn().initP(this._segment1._point, this._segment2._point);
  },
  /**
   * Determines the type of cubic Bézier curve via discriminant
   * classification, as well as the curve-time parameters of the associated
   * points of inflection, loops, cusps, etc.
   */
  classify() {
    return ae.classify(this.getValues());
  },
  _changed() {
    this._length = null, this._bounds = null;
  },
  toString() {
    return `CubicBez{ s1: ${this._segment1.toString()}, s2: ${this._segment2.toString()} }`;
  }
};
ae.getLength = (e, n = 0, s = 1, i) => {
  if (ae.isStraight(e)) {
    let r = e;
    s < 1 && (r = ae.subdivide(r, s)[0], n /= s), n > 0 && (r = ae.subdivide(r, n)[1]);
    const o = r[6] - r[0], a = r[7] - r[1];
    return Qo(o * o + a * a);
  }
  return Zn.integrate(i || pC(e), n, s, EC(n, s));
};
ae.getPart = (e, n, s) => {
  let i = e, r = n, o = s;
  const a = r > o;
  if (a) {
    const c = r;
    r = o, o = c;
  }
  return r > 0 && (i = ae.subdivide(i, r)[1]), o < 1 && (i = ae.subdivide(i, (o - r) / (1 - r))[0]), a ? [i[6], i[7], i[4], i[5], i[2], i[3], i[0], i[1]] : i;
};
ae.getPoint = (e, n) => Kc(e, n, 0, !1);
ae.getTangent = (e, n) => Kc(e, n, 1, !0);
ae.getWeightedTangent = (e, n) => Kc(e, n, 1, !1);
ae.getNormal = (e, n) => Kc(e, n, 2, !0);
ae.getWeightedNormal = (e, n) => Kc(e, n, 2, !1);
ae.getCurvature = (e, n) => Kc(e, n, 3, !1).x;
ae.getTimeOf = (e, n) => {
  const s = new N(e[0], e[1]), i = new N(e[6], e[7]), r = Qn, o = hr;
  if ((n.isClose(s, r) ? 0 : n.isClose(i, r) ? 1 : null) === null) {
    const c = [n.x, n.y], l = [];
    for (let h = 0; h < 2; h++) {
      const d = ae.solveCubic(e, h, c[h], l, 0, 1);
      for (let p = 0; p < d; p++) {
        const E = l[p];
        if (n.isClose(ae.getPoint(e, E), o))
          return E;
      }
    }
  }
  return n.isClose(s, o) ? 0 : n.isClose(i, o) ? 1 : null;
};
ae.getTimeAt = (e, n, s) => {
  if (s === void 0 && (s = n < 0 ? 1 : 0), n === 0)
    return s;
  const i = hr, r = n > 0, o = r ? s : 0, a = r ? 1 : s, c = pC(e), l = ae.getLength(e, o, a, c), h = cg(n) - l;
  if (cg(h) < i)
    return r ? a : o;
  if (h > i)
    return null;
  const d = n / l;
  let p = 0;
  function E(g) {
    return p += Zn.integrate(
      c,
      s,
      g,
      EC(s, g)
    ), s = g, p - n;
  }
  return Zn.findRoot(
    E,
    c,
    s + d,
    o,
    a,
    32,
    Qn
  );
};
ae.getPeaks = (e) => {
  const n = e[0], s = e[1], i = e[2], r = e[3], o = e[4], a = e[5], c = e[6], l = e[7], h = -n + 3 * i - 3 * o + c, d = 3 * n - 6 * i + 3 * o, p = -3 * n + 3 * i, E = -s + 3 * r - 3 * a + l, g = 3 * s - 6 * r + 3 * a, T = -3 * s + 3 * r, A = Bs, m = 1 - A, O = [];
  return Zn.solveCubic(
    9 * (h * h + E * E),
    9 * (h * d + g * E),
    2 * (d * d + g * g) + 3 * (p * h + T * E),
    p * d + g * T,
    // Exclude 0 and 1 as we don't count them as peaks.
    O,
    A,
    m
  ), O.sort();
};
ae.getIntersections = (e, n, s, i) => {
  const r = hr, o = !n;
  o && (n = e);
  const a = e.length, c = n.length, l = Array(a), h = o ? l : Array(c), d = [];
  for (let E = 0; E < a; E++)
    l[E] = e[E].getValues();
  if (!o)
    for (let E = 0; E < c; E++)
      h[E] = n[E].getValues();
  const p = jy(l, h, r);
  for (let E = 0; E < a; E++) {
    const g = e[E], T = l[E];
    o && dC(T, g, d, s);
    const A = p[E];
    if (A)
      for (let m = 0; m < A.length; m++) {
        if (i && d.length)
          return d;
        const O = A[m];
        if (!o || O > E) {
          const S = n[O], y = h[O];
          fC(T, y, g, S, d, s);
        }
      }
  }
  return d;
};
ae.isStraight = (e) => {
  const n = e[0], s = e[1], i = e[6], r = e[7], o = new N(n, s), a = new N(e[2] - n, e[3] - s), c = new N(e[4] - i, e[5] - r), l = new N(i, r);
  if (a.is_zero(ms) && c.is_zero(ms))
    return !0;
  {
    const h = l.clone().subtract(o);
    if (h.is_zero(ms))
      return !1;
    if (h.isCollinear(a) && h.isCollinear(c)) {
      const d = new qn().initP(o, l), p = hr;
      if (d.getDistance(o.clone().add(a.x, a.y)) < p && d.getDistance(l.clone().add(c.x, c.y)) < p) {
        const E = h.clone().dot(h), g = h.clone().dot(a) / E, T = h.clone().dot(c) / E;
        return g >= 0 && g <= 1 && T <= 0 && T >= -1;
      }
    }
  }
  return !1;
};
ae.subdivide = (e, n = 0.5) => {
  const s = e[0], i = e[1], r = e[2], o = e[3], a = e[4], c = e[5], l = e[6], h = e[7], d = 1 - n, p = d * s + n * r, E = d * i + n * o, g = d * r + n * a, T = d * o + n * c, A = d * a + n * l, m = d * c + n * h, O = d * p + n * g, S = d * E + n * T, y = d * g + n * A, v = d * T + n * m, R = d * O + n * y, M = d * S + n * v;
  return [
    [s, i, p, E, O, S, R, M],
    // left
    [R, M, y, v, A, m, l, h]
    // right
  ];
};
ae.getValues = (e, n, s) => {
  const i = e._point, r = e._handleOut, o = n._handleIn, a = n._point, c = i.x, l = i.y, h = a.x, d = a.y;
  return s ? [
    c,
    l,
    c,
    l,
    h,
    d,
    h,
    d
  ] : [
    c,
    l,
    c + r.x,
    l + r.y,
    h + o.x,
    d + o.y,
    h,
    d
  ];
};
ae.getArea = (e) => {
  const n = e[0], s = e[1], i = e[2], r = e[3], o = e[4], a = e[5], c = e[6], l = e[7];
  return 3 * ((l - s) * (i + o) - (c - n) * (r + a) + r * (n - o) - i * (s - a) + l * (o + n / 3) - c * (a + s / 3)) / 20;
};
ae.getBounds = (e) => {
  const n = e.slice(0, 2), s = n.slice(), i = [0, 0];
  for (let r = 0; r < 2; r++)
    ae._addBounds(e[r], e[r + 2], e[r + 4], e[r + 6], r, n, s, i);
  return new ye(n[0], n[1], s[0] - n[0], s[1] - n[1]);
};
ae._addBounds = (e, n, s, i, r, o, a, c) => {
  const l = o[r], h = a[r];
  if (e < l || n < l || s < l || i < l || e > h || n > h || s > h || i > h)
    if (n < e != n < i && s < e != s < i)
      bu(e, r, o, a), bu(i, r, o, a);
    else {
      const d = 3 * (n - s) - e + i, p = 2 * (e + s) - 4 * n, E = n - e, g = Zn.solveQuadratic(d, p, E, c), T = Bs, A = 1 - T;
      bu(i, r, o, a);
      for (let m = 0; m < g; m++) {
        const O = c[m], S = 1 - O;
        T <= O && O <= A && bu(
          S * S * S * e + 3 * S * S * O * n + 3 * S * O * O * s + O * O * O * i,
          r,
          o,
          a
        );
      }
    }
};
ae.solveCubic = (e, n, s, i, r, o) => {
  const a = e[n], c = e[n + 2], l = e[n + 4], h = e[n + 6];
  let d = 0;
  if (!(a < s && h < s && c < s && l < s || a > s && h > s && c > s && l > s)) {
    const p = 3 * (c - a), E = 3 * (l - c) - p, g = h - a - p - E;
    d = Zn.solveCubic(g, E, p, a - s, i, r, o);
  }
  return d;
};
ae.getMonoCurves = (e, n) => {
  const s = [], i = n ? 0 : 1, r = e[i + 0], o = e[i + 2], a = e[i + 4], c = e[i + 6];
  if (r >= o == o >= a && o >= a == a >= c || ae.isStraight(e))
    s.push(e);
  else {
    const l = 3 * (o - a) - r + c, h = 2 * (r + a) - 4 * o, d = o - r, p = Bs, E = 1 - p, g = [], T = Zn.solveQuadratic(l, h, d, g, p, E);
    if (!T)
      s.push(e);
    else {
      g.sort();
      let A = g[0], m = ae.subdivide(e, A);
      s.push(m[0]), T > 1 && (A = (g[1] - A) / (1 - A), m = ae.subdivide(m[1], A), s.push(m[0])), s.push(m[1]);
    }
  }
  return s;
};
ae.classify = (e) => {
  const n = e[0], s = e[1], i = e[2], r = e[3], o = e[4], a = e[5], c = e[6], l = e[7], h = n * (l - a) + s * (o - c) + c * a - l * o, d = i * (s - l) + r * (c - n) + n * l - s * c;
  let E = 3 * (o * (r - s) + a * (n - i) + i * s - r * n), g = E - d, T = g - d + h;
  const A = Qo(T * T + g * g + E * E), m = A === 0 ? 0 : 1 / A, O = Zn.isZero;
  if (T *= m, g *= m, E *= m, O(T))
    return O(g) ? Pu(O(E) ? Os.line : Os.quadratic) : Pu(Os.serpentine, E / (3 * g));
  const S = 3 * g * g - 4 * T * E;
  if (O(S))
    return Pu(Os.cusp, g / (2 * T));
  const y = S > 0 ? Qo(S / 3) : Qo(-S), v = 2 * T;
  return Pu(
    S > 0 ? Os.serpentine : Os.loop,
    // 1. / 2.
    (g + y) / v,
    (g - y) / v
  );
};
const Tc = Math.min, Da = Math.max, cg = Math.abs, $F = Math.ceil, lg = Math.pow, Qo = Math.sqrt, ek = Math.atan2;
function Pu(e, n, s) {
  const i = n !== void 0;
  let r = i && n > 0 && n < 1, o = i && s > 0 && s < 1, a = e;
  i && (!(r || o) || a === Os.loop) && !(r && o) && (a = Os.arch, r = !1, o = !1);
  let c = null;
  return (r || o) && (r && o ? c = n < s ? [n, s] : [s, n] : c = [r ? n : s]), {
    type: a,
    roots: c
  };
}
function Fc(e, n, s, i, r, o, a) {
  const c = !a && s.getPrevious() === r, l = !a && s !== r && s.getNext() === r, h = Bs, d = 1 - h;
  if (i !== null && i >= (c ? h : 0) && i <= (l ? d : 1) && o !== null && o >= (l ? h : 0) && o <= (c ? d : 1)) {
    const p = new ii().init(s, i, null, a), E = new ii().init(r, o, null, a);
    p._intersection = E, E._intersection = p, (!n || n(p)) && ii.insert(e, p, !0);
  }
}
function tk(e, n, s, i, r, o) {
  const a = qn.intersect(
    e[0],
    e[1],
    e[6],
    e[7],
    n[0],
    n[1],
    n[6],
    n[7]
  );
  a && Fc(
    r,
    o,
    s,
    ae.getTimeOf(e, a),
    i,
    ae.getTimeOf(n, a)
  );
}
function dC(e, n, s, i) {
  const r = ae.classify(e);
  if (r.type === Os.loop) {
    const o = r.roots;
    Fc(
      s,
      i,
      n,
      o[0],
      n,
      o[1]
    );
  }
  return s;
}
function fC(e, n, s, i, r, o) {
  const a = Qn;
  if (Da(e[0], e[2], e[4], e[6]) + a > Tc(n[0], n[2], n[4], n[6]) && Tc(e[0], e[2], e[4], e[6]) - a < Da(n[0], n[2], n[4], n[6]) && Da(e[1], e[3], e[5], e[7]) + a > Tc(n[1], n[3], n[5], n[7]) && Tc(e[1], e[3], e[5], e[7]) - a < Da(n[1], n[3], n[5], n[7])) {
    const c = ug(e, n);
    if (c)
      for (let l = 0; l < 2; l++) {
        const h = c[l];
        Fc(
          r,
          o,
          s,
          h[0],
          i,
          h[1],
          !0
        );
      }
    else {
      const l = ae.isStraight(e), h = ae.isStraight(n), d = l && h, p = l && !h, E = r.length;
      if ((d ? tk : l || h ? sk : ma)(
        p ? n : e,
        p ? e : n,
        p ? i : s,
        p ? s : i,
        r,
        o,
        p,
        // Define the defaults for these parameters of
        // addCurveIntersections():
        // recursion, calls, tMin, tMax, uMin, uMax
        0,
        0,
        0,
        1,
        0,
        1
      ), !d || r.length === E)
        for (let g = 0; g < 4; g++) {
          const T = g >> 1, A = g & 1, m = T * 6, O = A * 6, S = new N(e[m], e[m + 1]), y = new N(n[O], n[O + 1]);
          S.isClose(y, a) && Fc(
            r,
            o,
            s,
            T,
            i,
            A
          );
        }
    }
  }
  return r;
}
function bu(e, n, s, i) {
  const r = e, o = e;
  r < s[n] && (s[n] = r), o > i[n] && (i[n] = o);
}
function Kc(e, n, s, i) {
  if (n == null || n < 0 || n > 1)
    return null;
  const r = e[0], o = e[1];
  let a = e[2], c = e[3], l = e[4], h = e[5];
  const d = e[6], p = e[7], E = Zn.isZero;
  E(a - r) && E(c - o) && (a = r, c = o), E(l - d) && E(h - p) && (l = d, h = p);
  const g = 3 * (a - r), T = 3 * (l - a) - g, A = d - r - g - T, m = 3 * (c - o), O = 3 * (h - c) - m, S = p - o - m - O;
  let y, v;
  if (s === 0)
    y = n === 0 ? r : n === 1 ? d : ((A * n + T) * n + g) * n + r, v = n === 0 ? o : n === 1 ? p : ((S * n + O) * n + m) * n + o;
  else {
    const R = Bs, M = 1 - R;
    if (n < R ? (y = g, v = m) : n > M ? (y = 3 * (d - l), v = 3 * (p - h)) : (y = (3 * A * n + 2 * T) * n + g, v = (3 * S * n + 2 * O) * n + m), i) {
      y === 0 && v === 0 && (n < R || n > M) && (y = l - a, v = h - c);
      const L = Qo(y * y + v * v);
      L && (y /= L, v /= L);
    }
    if (s === 3) {
      const L = 6 * A * n + 2 * T, P = 6 * S * n + 2 * O, k = lg(y * y + v * v, 3 / 2);
      y = k === 0 ? 0 : (y * P - v * L) / k, v = 0;
    }
  }
  return s === 2 ? new N(v, -y) : new N(y, v);
}
function ma(e, n, s, i, r, o, a, c, l, h, d, p, E) {
  if (++l >= 4096 || ++c >= 40)
    return l;
  const g = 1e-9, T = n[0], A = n[1], m = n[6], O = n[7], S = qn.getSignedDistance, y = S(T, A, m, O, n[2], n[3]), v = S(T, A, m, O, n[4], n[5]), R = y * v > 0 ? 3 / 4 : 4 / 9, M = R * Tc(0, y, v), L = R * Da(0, y, v), P = S(T, A, m, O, e[0], e[1]), k = S(T, A, m, O, e[2], e[3]), Q = S(T, A, m, O, e[4], e[5]), b = S(T, A, m, O, e[6], e[7]), X = nk(P, k, Q, b), K = X[0], V = X[1];
  let J, ge;
  if (y === 0 && v === 0 && P === 0 && k === 0 && Q === 0 && b === 0 || (J = qI(K, V, M, L)) == null || (ge = qI(K.reverse(), V.reverse(), M, L)) == null)
    return l;
  const ne = h + (d - h) * J, ue = h + (d - h) * ge;
  let te, ie;
  if (Da(E - p, ue - ne) < g)
    te = (ne + ue) / 2, ie = (p + E) / 2, Fc(
      r,
      o,
      a ? i : s,
      a ? ie : te,
      a ? s : i,
      a ? te : ie
    );
  else {
    e = ae.getPart(e, J, ge);
    const re = E - p;
    if (ge - J > 0.8)
      if (ue - ne > re) {
        const fe = ae.subdivide(e, 0.5);
        te = (ne + ue) / 2, l = ma(
          n,
          fe[0],
          i,
          s,
          r,
          o,
          !a,
          c,
          l,
          p,
          E,
          ne,
          te
        ), l = ma(
          n,
          fe[1],
          i,
          s,
          r,
          o,
          !a,
          c,
          l,
          p,
          E,
          te,
          ue
        );
      } else {
        const fe = ae.subdivide(n, 0.5);
        ie = (p + E) / 2, l = ma(
          fe[0],
          e,
          i,
          s,
          r,
          o,
          !a,
          c,
          l,
          p,
          ie,
          ne,
          ue
        ), l = ma(
          fe[1],
          e,
          i,
          s,
          r,
          o,
          !a,
          c,
          l,
          ie,
          E,
          ne,
          ue
        );
      }
    else
      re === 0 || re >= g ? l = ma(
        n,
        e,
        i,
        s,
        r,
        o,
        !a,
        c,
        l,
        p,
        E,
        ne,
        ue
      ) : l = ma(
        e,
        n,
        s,
        i,
        r,
        o,
        a,
        c,
        l,
        ne,
        ue,
        p,
        E
      );
  }
  return l;
}
function nk(e, n, s, i) {
  const r = [0, e], o = [1 / 3, n], a = [2 / 3, s], c = [1, i], l = n - (2 * e + i) / 3, h = s - (e + 2 * i) / 3;
  let d;
  if (l * h < 0)
    d = [[r, o, c], [r, a, c]];
  else {
    const p = l / h;
    d = [
      // p2 is inside, the hull is a triangle.
      // eslint-disable-next-line no-nested-ternary
      p >= 2 ? [r, o, c] : p <= 0.5 ? [r, a, c] : [r, o, a, c],
      // Line [p0, p3] is part of the hull.
      [r, c]
    ];
  }
  return (l || h) < 0 ? d.reverse() : d;
}
function qI(e, n, s, i) {
  return e[0][1] < s ? jI(e, !0, s) : n[0][1] > i ? jI(n, !1, i) : e[0][0];
}
function jI(e, n, s) {
  let i = e[0][0], r = e[0][1];
  for (let o = 1, a = e.length; o < a; o++) {
    const c = e[o][0], l = e[o][1];
    if (n ? l >= s : l <= s)
      return l === s ? c : i + (s - r) * (c - i) / (l - r);
    i = c, r = l;
  }
  return null;
}
const pC = (e) => {
  const n = e[0], s = e[1], i = e[2], r = e[3], o = e[4], a = e[5], c = e[6], l = e[7], h = 9 * (i - o) + 3 * (c - n), d = 6 * (n + o) - 12 * i, p = 3 * (i - n), E = 9 * (r - a) + 3 * (l - s), g = 6 * (s + a) - 12 * r, T = 3 * (r - s);
  return function(A) {
    const m = (h * A + d) * A + p, O = (E * A + g) * A + T;
    return Qo(m * m + O * O);
  };
}, EC = (e, n) => Da(2, Tc(16, $F(cg(n - e) * 32)));
function sk(e, n, s, i, r, o, a) {
  const c = n[0], l = n[1], h = n[6], d = n[7], p = ik(e, c, l, h - c, d - l);
  for (let E = 0, g = p.length; E < g; E++) {
    const T = p[E], A = ae.getPoint(e, T), m = ae.getTimeOf(n, A);
    m !== null && Fc(
      r,
      o,
      a ? i : s,
      a ? m : T,
      a ? s : i,
      a ? T : m
    );
  }
}
function ik(e, n, s, i, r) {
  const o = Zn.isZero;
  if (o(i) && o(r)) {
    const p = ae.getTimeOf(e, new N(n, s));
    return p === null ? [] : [p];
  }
  const a = ek(-r, i), c = Math.sin(a), l = Math.cos(a), h = [], d = [];
  for (let p = 0; p < 8; p += 2) {
    const E = e[p] - n, g = e[p + 1] - s;
    h.push(
      E * l - g * c,
      E * c + g * l
    );
  }
  return ae.solveCubic(h, 1, 0, d, 0, 1), d;
}
const rk = [
  0.362683783378362,
  -0.1834346424956498,
  0.362683783378362,
  0.1834346424956498,
  0.3137066458778873,
  -0.525532409916329,
  0.3137066458778873,
  0.525532409916329,
  0.2223810344533745,
  -0.7966664774136267,
  0.2223810344533745,
  0.7966664774136267,
  0.1012285362903763,
  -0.9602898564975363,
  0.1012285362903763,
  0.9602898564975363
], ok = [
  0.362683783378362,
  0.1834346424956498,
  0.3137066458778873,
  0.525532409916329,
  0.2223810344533745,
  0.7966664774136267,
  0.1012285362903763,
  0.9602898564975363
], ak = [
  0.1894506104550685,
  0.0950125098376374,
  0.1826034150449236,
  0.2816035507792589,
  0.1691565193950025,
  0.4580167776572274,
  0.1495959888165767,
  0.6178762444026438,
  0.1246289712555339,
  0.755404408355003,
  0.0951585116824928,
  0.8656312023878318,
  0.0622535239386479,
  0.9445750230732326,
  0.0271524594117541,
  0.9894009349916499
], ck = [
  0.1279381953467522,
  0.0640568928626056,
  0.1258374563468283,
  0.1911188674736163,
  0.1216704729278034,
  0.3150426796961634,
  0.1155056680537256,
  0.4337935076260451,
  0.1074442701159656,
  0.5454214713888396,
  0.0976186521041139,
  0.6480936519369755,
  0.0861901615319533,
  0.7401241915785544,
  0.0733464814110803,
  0.820001985973903,
  0.0592985849154368,
  0.8864155270044011,
  0.0442774388174198,
  0.9382745520027328,
  0.0285313886289337,
  0.9747285559713095,
  0.0123412297999872,
  0.9951872199970213
];
function Pd(e, n, s) {
  const [
    i,
    r,
    o,
    a,
    c,
    l,
    h,
    d
  ] = e, p = h - i, E = d - r, g = o - i, T = a - r, A = c - o, m = l - a, O = h - c, S = d - l, y = Math.hypot(g, T) + Math.hypot(A, m) + Math.hypot(O, S) - Math.hypot(p, E), v = A - g, R = m - T, M = O - A, L = S - m, P = 0.25 * (g + O) + 0.5 * A, k = 0.25 * (T + S) + 0.5 * m, Q = 0.5 * (M + v), b = 0.5 * (L + R), X = 0.25 * (M - v), K = 0.25 * (L - R), V = rk;
  let J = 0;
  for (let te = 0; te < V.length; te += 2) {
    const ie = V[te + 1], re = P + Q * ie + X * (ie * ie), fe = k + b * ie + K * (ie * ie), Ne = Q + X * (2 * ie), At = b + K * (2 * ie);
    J += V[te] * (Ne * Ne + At * At) / (re * re + fe * fe);
  }
  const ge = J * J * J;
  let ne = null;
  if (Math.min(ge * 25e-7, 0.03) * y < n)
    ne = ok;
  else if (Math.min(ge * ge * 15e-12, 9e-3) * y < n)
    ne = ak;
  else if (Math.min(ge * ge * ge * 35e-17, 35e-4) * y < n || s >= 20)
    ne = ck;
  else {
    const [te, ie] = ae.subdivide(e, 0.5);
    return Pd(te, n * 0.5, s + 1) + Pd(ie, n * 0.5, s + 1);
  }
  let ue = 0;
  for (let te = 0; te < ne.length; te += 2) {
    const ie = ne[te + 1], re = ne[te], fe = P + X * (ie * ie), Ne = k + K * (ie * ie), At = Math.hypot(fe + Q * ie, Ne + b * ie), Ke = Math.hypot(fe - Q * ie, Ne - b * ie);
    ue += re * (At + Ke);
  }
  return 1.5 * ue;
}
const hc = {
  None: 0,
  Loop: 1,
  DoubleInflection: 2
};
function Zo(e, n) {
  const s = Lt(e);
  return n < 0 ? -s : s;
}
function gC(e, n, s, i, r, o, a, c) {
  const l = Math.max(Math.ceil(Math.log2((s - n) / i)) - 1, 0), h = r + l;
  let d = i * Math.exp(h * Math.LN2);
  for (; s - n > 2 * i; ) {
    const p = 0.5 * (n + s), E = d - 0.5 * (s - n), g = (c * n - a * s) / (c - a), T = p - g, A = o * (s - n) * (s - n), m = A <= Math.abs(p - g) ? g + Zo(A, T) : p, O = Math.abs(m - p) <= E ? m : p - Zo(E, T), S = e(O);
    if (S > 0)
      s = O, c = S;
    else if (S < 0)
      n = O, a = S;
    else
      return O;
    d *= 0.5;
  }
  return 0.5 * (n + s);
}
function hg(e, n, s) {
  const i = e / s, r = n / s;
  if (!(isFinite(i) && isFinite(r))) {
    const l = -e / n;
    return isFinite(l) ? [l] : e == 0 && n == 0 ? [0] : [];
  }
  const o = r * r - 4 * i;
  let a = 0;
  if (isFinite(o)) {
    if (o < 0)
      return [];
    if (o == 0)
      return [-0.5 * r];
    a = -0.5 * (r + Zo(os(o), r));
  } else
    a = -r;
  const c = i / a;
  return isFinite(c) ? c > a ? [a, c] : [c, a] : [a];
}
function T0(e, n, s, i) {
  const r = s / (3 * i), o = n / (3 * i), a = e / i;
  if (!(isFinite(a) && isFinite(o) && isFinite(r)))
    return hg(e, n, s);
  const c = -r * r + o, l = -o * r + a, h = r * a - o * o, d = 4 * c * h - l * l, p = -2 * r * c + l;
  if (d < 0) {
    const E = os(-0.25 * d), g = -0.5 * p;
    return [dg(g + E) + dg(g - E) - r];
  } else if (d == 0) {
    const E = Zo(os(-c), p);
    return [E - r, -2 * E - r];
  } else {
    const E = pk(os(d), -p) / 3, g = _C(E), T = dk(E) * os(3), A = 0.5 * (-g + T), m = 0.5 * (-g - T), O = 2 * os(-c);
    return [O * g - r, O * A - r, O * m - r];
  }
}
function lk(e, n, s, i, r) {
  function o(ne, ue, te, ie) {
    const re = pa(ne + te, e), fe = pa(ue + ne * te + ie, n), Ne = pa(ue * te + ne * ie, s);
    return re + fe + Ne;
  }
  function a(ne, ue, te, ie) {
    return o(ne, ue, te, ie) + pa(ue * ie, i);
  }
  const c = 9 * e * e - 24 * n, l = c >= 0 ? -2 * n / (3 * e + Zo(os(c), e)) : -0.25 * e, h = e + 4 * l, d = n + 3 * l * (e + 2 * l), p = s + l * (2 * n + l * (3 * e + 4 * l)), E = i + l * (s + l * (n + l * (e + l)));
  let g = 0, T = 0;
  if (g = h * p - 4 * E - 1 / 3 * d * d, T = (h * p + 8 * E - 2 / 9 * d * d) * (1 / 3) * d - p * p - h * h * E, !isFinite(g) && isFinite(T))
    return null;
  let A = hk(g, T);
  const m = e * 0.5, O = 1 / 6 * n + 0.5 * A, S = s - e * O, y = 2 / 3 * n - A - m * m, v = 0.5 * S / y, R = 2 * (i - O * O) / S, M = 0.5 * S / R;
  let L = 0, P = 0, k = 1 / 0;
  for (let ne = 0; ne < 3; ne++) {
    const ue = ne == 1 ? M : y, te = ne == 0 ? v : R, ie = pa(ue + m * m + 2 * O, n), re = pa(2 * (ue * te + m * O), s), fe = pa(ue * te * te + O * O, i), Ne = ie + re + fe;
    (ne == 0 || Ne < k) && (L = ue, P = te, k = Ne);
  }
  const Q = L, b = P;
  let X = 0, K = 0, V = 0, J = 0;
  if (Q < 0) {
    const ne = os(-Q);
    if (X = m + ne, K = O + ne * b, V = m - ne, J = O - ne * b, Lt(J) < Lt(K) ? J = i / K : Lt(J) > Lt(K) && (K = i / J), Lt(X) != Lt(V)) {
      let ue = null, te = null;
      if (Lt(X) < Lt(V)) {
        const re = (s - K * V) / J, fe = (n - J - K) / V;
        ue = [e - V, re, fe], te = [V, V, V];
      } else {
        const re = (s - X * J) / K, fe = (n - J - K) / X, Ne = e - X;
        ue = [X, X, X], te = [Ne, re, fe];
      }
      let ie = 0;
      for (let re = 0; re < 3; re++) {
        const fe = ue[re], Ne = te[re];
        if (isFinite(fe) && isFinite(Ne)) {
          const At = o(fe, K, Ne, J);
          (re == 0 || At < ie) && (X = fe, V = Ne, ie = At);
        }
      }
    }
  } else if (Q == 0) {
    const ne = i - O * O;
    X = m, K = O + os(-ne), V = m, J = O - os(-ne), Lt(K) > Lt(J) ? J = i / K : Lt(J) > Lt(K) && (K = i / J);
  } else
    return [];
  let ge = a(X, K, V, J);
  for (let ne = 0; ne < 8 && ge != 0; ne++) {
    const ue = K * J - i, te = K * V + X * J - s, ie = K + X * V + J - n, re = X + V - e, fe = X - V, Ne = K * K - K * (V * fe + 2 * J) + J * (X * fe + J);
    if (Ne == 0)
      break;
    const At = 1 / Ne, Ke = J - K, St = K * V - X * J, rn = fe * ue + Ke * te + St * ie - (K * Ke + X * St) * re, gt = (X * fe + Ke) * ue - K * (fe * te + Ke * ie + St * re), Wn = -fe * ue - Ke * te - St * ie + (V * St + J * Ke) * re, Xs = -(V * fe + Ke) * ue + J * (fe * te + Ke * ie + St * re), ls = X - At * rn, Ci = K - At * gt, ho = V - At * Wn, Yn = J - At * Xs, En = a(ls, Ci, ho, Yn);
    if (En < ge)
      X = ls, K = Ci, V = ho, J = Yn, ge = En;
    else
      break;
  }
  return [X, K, V, J];
}
function ug(e, n) {
  const s = qn.getDistance, i = Bs, r = hr;
  let o = ae.isStraight(e), a = ae.isStraight(n), c = o && a;
  const l = JI(e) < JI(n), h = l ? n : e, d = l ? e : n, p = h[0], E = h[1], g = h[6] - p, T = h[7] - E;
  if (s(p, E, g, T, d[0], d[1], !0) < r && s(p, E, g, T, d[6], d[7], !0) < r)
    !c && s(p, E, g, T, h[2], h[3], !0) < r && s(p, E, g, T, h[4], h[5], !0) < r && s(p, E, g, T, d[2], d[3], !0) < r && s(p, E, g, T, d[4], d[5], !0) < r && (o = !0, a = !0, c = !0);
  else if (c)
    return null;
  if (o ^ a)
    return null;
  const A = [e, n];
  let m = [];
  for (let O = 0; O < 4 && m.length < 2; O++) {
    const S = O & 1, y = S ^ 1, v = O >> 1, R = ae.getTimeOf(
      A[S],
      new N(
        A[y][v ? 6 : 0],
        A[y][v ? 7 : 1]
      )
    );
    if (R != null) {
      const M = S ? [v, R] : [R, v];
      // eslint-disable-next-line no-mixed-operators
      (!m.length || // eslint-disable-next-line no-mixed-operators
      Lt(M[0] - m[0][0]) > i && Lt(M[1] - m[0][1]) > i) && m.push(M);
    }
    if (O > 2 && !m.length)
      break;
  }
  if (m.length !== 2)
    m = null;
  else if (!c) {
    const O = ae.getPart(e, m[0][0], m[1][0]), S = ae.getPart(n, m[0][1], m[1][1]);
    (Lt(S[2] - O[2]) > r || Lt(S[3] - O[3]) > r || Lt(S[4] - O[4]) > r || Lt(S[5] - O[5]) > r) && (m = null);
  }
  return m;
}
function pa(e, n) {
  return n == 0 ? Lt(e) : Lt((e - n) / n);
}
function hk(e, n) {
  const s = -0.3333333333333333 * e, i = 0.5 * n;
  let r, o = null;
  if ((Lt(s) >= 1e102 || Lt(i) >= 1e164) && (Lt(s) < Lt(i) ? o = 1 - s * (s / i) * (s / i) : o = Math.sign(s) * (i / s * (i / s) / s - 1)), o !== null && i == 0)
    e > 0 ? r = 0 : r = os(-e);
  else if (o !== null ? o < 0 : i * i < s * s * s) {
    const h = o !== null ? i / s / os(s) : i / os(s * s * s);
    r = -2 * os(s) * Zo(_C(fk(Lt(h)) * (1 / 3)), h);
  } else {
    let h;
    o !== null ? Lt(s) < Lt(i) ? h = -i * (1 + os(o)) : h = -i - Zo(os(Lt(s)) * s * os(o), i) : h = dg(-i - Zo(os(i * i - s * s * s), i));
    const d = h == 0 ? 0 : s / h;
    r = h + d;
  }
  let a = r, c = (a * a + e) * a + n;
  if (Lt(c) < 222045e-21 * uk(a * a * a, e * a, n))
    return a;
  for (let h = 0; h < 8; h++) {
    const d = 3 * a * a + e;
    if (d == 0)
      break;
    const p = a - c / d, E = (p * p + e) * p + n;
    if (E == 0)
      return p;
    if (Lt(E) >= Lt(c))
      break;
    a = p, c = E;
  }
  return a;
}
function JI(e) {
  const n = e[6] - e[0], s = e[7] - e[1];
  return n * n + s * s;
}
const uk = Math.max, Lt = Math.abs, os = Math.sqrt, dk = Math.sin, _C = Math.cos, fk = Math.acos, pk = Math.atan2, dg = Math.cbrt;
function Ek() {
  this.width = 1, this.join = Us.BEVEL, this.miterLimit = 4, this.startCap = cn.NONE, this.endCap = cn.NONE, this.dashPattern = [0, 0, 0, 0], this.scale = !1;
}
function gk(e, n, s = 1e-3) {
  if (!Array.isArray(n.dashPattern) || n.dashPattern.length <= 1)
    return $I(e, n, s);
  {
    const i = n.startCap === cn.ROUND || n.endCap === cn.ROUND, r = Nk(e, n.dashPattern, i);
    return r.isEmpty() ? r : $I(r, n, s);
  }
}
function $I(e, n, s = 1e-3) {
  const i = new fg();
  i.join_thresh = 2 * s / n.width;
  const r = new N(), o = new N(), a = new N(), c = new N(), l = new ae();
  for (let h = 0, d = e._children.length; h < d; h++) {
    const p = e._children[h];
    if (p.isEmpty()) continue;
    const E = p._segments;
    i.finish(n);
    const g = E[0];
    r.copy(g._point), o.copy(g._point).add(g._handleOut), i.last_pt.copy(r), i.start_pt.copy(r);
    for (let T = 1, A = E.length, m = p._closed ? A + 1 : A; T < m; T++) {
      const O = E[T % A];
      if (a.copy(O._point).add(O._handleIn), c.copy(O._point), VF(
        r.x,
        r.y,
        o.x,
        o.y,
        a.x,
        a.y,
        c.x,
        c.y
      ) === Os.line) {
        if (!c.equals(r)) {
          const y = c.clone().sub(r);
          i.doJoin(n, y, !!O._path._closed), i.last_tan.copy(y), i.doLine(n, y, c);
        }
      } else if (!o.equals(r) || !a.equals(r) || !c.equals(r)) {
        l.initWith4Points(r, o, a, c);
        const [y, v] = Ck(r, o, a, c);
        i.doJoin(n, y, !!O._path._closed), i.last_tan.copy(v), i.doCubic(n, l, s);
      }
      r.copy(O._point), o.copy(O._point).add(O._handleOut), i.last_pt.copy(r);
    }
    p._closed && i.finishClosed(n);
  }
  return i.finish(n), i.output.reduce(), i.output.isEmpty() || i.output.close(), i.output;
}
function fg() {
  this.output = new qe(), this.forward_path = new xt(), this.backward_path = new xt(), this.start_pt = new N(), this.start_norm = new N(), this.start_tan = new N(), this.last_pt = new N(), this.last_tan = new N(), this.join_thresh = 0;
}
fg.prototype = {
  constructor: fg,
  /**
   * @param {StrokeStyle} style
   */
  finish(e) {
    if (this.forward_path.isEmpty())
      return;
    const n = 1e-3, s = this.backward_path.getLastSegment()._point, i = this.last_pt.clone().sub(s);
    switch (pg(this.output, this.forward_path), e.endCap) {
      case cn.ROUND: {
        nS(this.output, n, this.last_pt, i);
        break;
      }
      case cn.SQUARE: {
        sS(this.output, !1, this.last_pt, i);
        break;
      }
      default: {
        this.output.lineTo(s.x, s.y);
        break;
      }
    }
    switch (eS(this.output, this.backward_path, !0), e.startCap) {
      case cn.ROUND: {
        nS(this.output, n, this.start_pt, this.start_norm);
        break;
      }
      case cn.SQUARE: {
        sS(this.output, !0, this.start_pt, this.start_norm);
        break;
      }
      default: {
        this.output.close();
        break;
      }
    }
    this.forward_path.clear(), this.backward_path.clear();
  },
  /**
   * @param {StrokeStyle} style
   */
  finishClosed(e) {
    this.doJoin(e, this.start_tan), pg(this.output, this.forward_path), this.output.close(1e-3);
    const s = this.backward_path.getLastSegment();
    this.output.moveTo(s._point.x, s._point.y), eS(this.output, this.backward_path), this.output.close(1e-3), this.forward_path.clear(), this.backward_path.clear();
  },
  /**
   * @param {StrokeStyle} style
   * @param {Vector2} tan0
   * @param {boolean} closed
   */
  doJoin(e, n, s = !0) {
    const r = n.length() === 0 ? 0 : 0.5 * e.width / n.length(), o = new N(-n.y, n.x).scale(r), a = this.last_pt;
    if (this.forward_path.isEmpty())
      this.forward_path.moveTo(a.x - o.x, a.y - o.y), this.backward_path.moveTo(a.x + o.x, a.y + o.y), this.start_tan.copy(n), this.start_norm.copy(o);
    else {
      const c = this.last_tan, l = n, h = c.cross(l), d = c.dot(l), p = Math.hypot(h, d);
      if (!s || Math.abs(h) >= p * this.join_thresh)
        switch (e.join) {
          case Us.MITER: {
            if (p * 2 < (p + d) * (e.miterLimit * e.miterLimit)) {
              const E = c.length() === 0 ? 0 : 0.5 * e.width / c.length(), g = new N(-c.y, c.x).scale(E);
              if (h > 0) {
                const T = a.clone().sub(g), A = a.clone().sub(o), m = c.cross(A.clone().sub(T)) / h, O = l.clone().scale(-m).add(A);
                this.forward_path.lineTo(O.x, O.y);
              } else if (h < 0) {
                const T = a.clone().add(g), A = a.clone().add(o), m = c.cross(A.clone().sub(T)) / h, O = l.clone().scale(-m).add(A);
                this.backward_path.lineTo(O.x, O.y);
              }
            }
            this.forward_path.lineTo(a.x - o.x, a.y - o.y), this.backward_path.lineTo(a.x + o.x, a.y + o.y);
            break;
          }
          case Us.ROUND: {
            const E = Math.atan2(h, d);
            h > 0 ? (this.backward_path.lineTo(a.x + o.x, a.y + o.y), Eg(this.forward_path, 1e-3, a, o, E)) : h < 0 ? (this.forward_path.lineTo(a.x - o.x, a.y - o.y), tS(this.backward_path, 1e-3, a, o.negate(), -E)) : E <= 0 ? (this.forward_path.lineTo(a.x - o.x, a.y - o.y), tS(this.backward_path, 1e-3, a, o.negate(), -E)) : (this.backward_path.lineTo(a.x + o.x, a.y + o.y), Eg(this.forward_path, 1e-3, a, o, E));
            break;
          }
          default: {
            this.forward_path.lineTo(a.x - o.x, a.y - o.y), this.backward_path.lineTo(a.x + o.x, a.y + o.y);
            break;
          }
        }
    }
  },
  /**
   * @param {StrokeStyle} style
   * @param {Vector2} tangent
   * @param {Vector2} p1
   */
  doLine(e, n, s) {
    const i = 0.5 * e.width / n.length(), r = new N(-n.y, n.x).scale(i);
    this.forward_path.lineTo(s.x - r.x, s.y - r.y), this.backward_path.lineTo(s.x + r.x, s.y + r.y), this.last_pt.copy(s);
  },
  /**
   * @param {StrokeStyle} style
   * @param {CubicBez} c
   * @param {number} tolerance
   */
  doCubic(e, n, s) {
    const r = s * 0.25;
    let o = null;
    o = kc.regularized(n, -0.5 * e.width, r);
    const a = oS(o, s);
    this.forward_path.join(a), o = kc.regularized(n, 0.5 * e.width, r);
    const c = oS(o, s);
    this.backward_path.join(c), this.last_pt.copy(n.getP3());
  }
};
function pg(e, n, s = !1) {
  if (n.isEmpty())
    return e;
  if (!s || e.isEmpty())
    return e.addChild(n.clone());
  const i = e._children[e._children.length - 1], r = i.getLastSegment(), o = n.getFirstSegment();
  if (o._point.isClose(r._point, hr)) {
    r.setHandleOut(o._handleOut);
    for (let a = 1, c = n._segments.length; a < c; a++)
      i.add(n._segments[a]);
  } else
    e.addChild(n.clone());
  return e;
}
function eS(e, n, s) {
  return n.reverse(), pg(e, n, s);
}
function Eg(e, n, s, i, r) {
  const o = new Ws([i.x, i.y, -i.y, i.x, s.x, s.y]), c = new bd(new N(0, 0), new N(1, 1), Math.PI - r, r, 0).toCubicBeziers(n);
  for (let l = 0; l < c.length; l += 3) {
    const h = c[l], d = c[l + 1], p = c[l + 2];
    o.applyPoint(h, h), o.applyPoint(d, d), o.applyPoint(p, p), e.cubicCurveTo(
      h.x,
      h.y,
      d.x,
      d.y,
      p.x,
      p.y
    );
  }
}
function tS(e, n, s, i, r) {
  const o = new Ws([i.x, i.y, i.y, -i.x, s.x, s.y]), c = new bd(new N(0, 0), new N(1, 1), Math.PI - r, r, 0).toCubicBeziers(n);
  for (let l = 0; l < c.length; l += 3) {
    const h = c[l], d = c[l + 1], p = c[l + 2];
    o.applyPoint(h, h), o.applyPoint(d, d), o.applyPoint(p, p), e.cubicCurveTo(
      h.x,
      h.y,
      d.x,
      d.y,
      p.x,
      p.y
    );
  }
}
function nS(e, n, s, i) {
  Eg(e, n, s, i, Math.PI);
}
function sS(e, n, s, i) {
  const r = new Ws([i.x, i.y, -i.y, i.x, s.x, s.y]), o = new N();
  r.applyPoint(o.set(1, 1), o), e.lineTo(o.x, o.y), r.applyPoint(o.set(-1, 1), o), e.lineTo(o.x, o.y), n ? e.close() : (r.applyPoint(o.set(-1, 0), o), e.lineTo(o.x, o.y));
}
function Uu(e, n, s) {
  const i = Math.sin(s), r = Math.cos(s), o = e.x * r, a = e.y * i;
  return _k(o, a, n);
}
function _k(e, n, s) {
  const i = Math.sin(s), r = Math.cos(s);
  return new N(
    e * r - n * i,
    e * i + n * r
  );
}
function Tk(e, n, s, i) {
  const [r, o] = [Math.cos(e), Math.sin(e)], [a, c] = [Math.cos(n), Math.sin(n)], l = -9 * r * (((2 * c * a * r + o * (2 * a * a - 1)) * r - 2 * c * a) * r - a * a * o), h = 12 * ((((a * (30 * s * a - c) - 15 * s) * r + 2 * o - a * o * (a + 30 * s * c)) * r + a * (c - 15 * s * a)) * r - o * a * a), d = 12 * ((((70 * i + 15 * s) * c * c + a * (9 * c - 70 * a * i - 5 * a * s)) * r - 5 * o * c * (3 * c - 4 * a * (7 * i + s))) * r - a * (9 * c - 70 * a * i - 5 * a * s)), p = 16 * (((12 * o - 5 * r * (42 * i - 17 * s)) * c - 70 * a * (3 * i - s) * o - 75 * r * a * s * s) * c - 75 * a * a * s * s * o), E = 80 * c * (42 * c * i - 25 * s * (c - a * s));
  let g = [];
  const T = 1e-12;
  if (Math.abs(l) > T) {
    const O = h / l, S = d / l, y = p / l, v = E / l, R = lk(O, S, y, v);
    if (R !== null)
      for (let M = 0; M < R.length; M += 2) {
        const L = R[M], P = R[M + 1], k = hg(P, L, 1);
        k.length > 0 ? g = g.concat(k) : g.push(-0.5 * L);
      }
  } else Math.abs(h) > T ? g = g.concat(T0(E, p, d, h)) : g = g.concat(hg(E, p, d));
  const A = o * a + c * r, m = [];
  for (let O = 0, S = g.length; O < S; O++) {
    let y = g[O], v = 0;
    y > 0 ? (v = (y * o - s * (10 / 3)) / (0.5 * y * A - c), v <= 0 && (y = c / A, v = 0)) : (y = 0, v = o / A), y >= 0 && v >= 0 && m.push({
      cand: new ae().initWith4PointsN(
        0,
        0,
        y * r,
        y * o,
        1 - v * a,
        v * c,
        1,
        0
      ),
      d0: y,
      d1: v
    });
  }
  return m;
}
const TC = Math.PI * 2, iS = (e) => {
  const n = e * Ik * 0.5;
  return TC * (n - Math.round(n));
}, Ak = 0.65, mk = 2, rS = (e) => 1 + Math.max(e - Ak, 0) * mk;
function Ok(e, n, s, i) {
  const r = e.samplePointTangent(n, 1), o = e.samplePointTangent(s, -1), a = o.p.clone().sub(r.p), c = a.length_squared(), l = i * i;
  if (c <= l)
    return AC(e, i, n, s, r.p, o.p);
  const h = a.angle(), d = iS(r.tangent.angle() - h), p = iS(h - o.tangent.angle());
  let { area: E, x: g, y: T } = e.momentIntegrals(n, s);
  const [A, m] = [r.p.x, r.p.y], [O, S] = [a.x, a.y];
  E -= O * (m + 0.5 * S);
  const y = S * (1 / 3);
  g -= O * (A * m + 0.5 * (A * S + m * O) + y * O), T -= O * (m * m + m * S + y * S), g -= A * E, T = 0.5 * T - m * E;
  const v = a.x * g + a.y * T, R = 1 / c, M = E * R, L = v * R * R, P = Math.sqrt(c), k = Ws.translate(r.p).multiply(Ws.rotate(h)).multiply(Ws.scale(P)), Q = new _g(e, n, s);
  let b = null, X = null;
  const K = Tk(d, p, M, L);
  for (let V = 0, J = K.length; V < J; V++) {
    const { cand: ge, d0: ne, d1: ue } = K[V], te = k.applyCubic(ge);
    let ie = Q.evalDist(e, te, l);
    if (ie !== null) {
      const re = Math.pow(Math.max(rS(ne), rS(ue)), 2);
      ie *= re, ie < l && (X !== null && ie < X || X === null) && (b = te, X = ie);
    }
  }
  return b !== null && X !== null ? { c: b, err: X } : null;
}
function oS(e, n) {
  const s = new xt();
  return bl(e, 0, 1, n, s), s;
}
function AC(e, n, s, i, r, o) {
  const a = n * n, c = new qn().initP(r, o), l = 7;
  let h = 0;
  const d = (i - s) / (l + 1);
  for (let T = 0; T < l; T++) {
    const A = s + (T + 1) * d, m = e.samplePointDeriv(A).p, O = c.nearest(m, n).distance_sq;
    if (O > a)
      return null;
    h = O > h ? O : h;
  }
  const p = r.clone().linear_interpolate(o, 1 / 3), E = o.clone().linear_interpolate(r, 1 / 3);
  return { c: new ae().initWith4Points(r, p, E, o), err: h };
}
function bl(e, n, s, i, r) {
  const o = n, a = s, c = e.samplePointTangent(n, 1).p, l = e.samplePointTangent(s, -1).p;
  if (c.distance_squared_to(l) <= i * i) {
    const d = AC(e, i, n, s, c, l);
    if (d) {
      const p = d.c;
      if (r.isEmpty()) {
        const A = p.getP0();
        r.moveTo(A.x, A.y);
      }
      const E = p.getP1(), g = p.getP2(), T = p.getP3();
      r.cubicCurveTo(
        E.x,
        E.y,
        g.x,
        g.y,
        T.x,
        T.y
      );
      return;
    }
  }
  let h = e.breakCusp(n, s);
  if (h !== null)
    bl(e, o, h, i, r), bl(e, h, a, i, r);
  else {
    const d = Ok(e, n, s, i);
    if (d !== null) {
      if (r.isEmpty()) {
        const T = d.c.getP0();
        r.moveTo(T.x, T.y);
      }
      const p = d.c.getP1(), E = d.c.getP2(), g = d.c.getP3();
      r.cubicCurveTo(
        p.x,
        p.y,
        E.x,
        E.y,
        g.x,
        g.y
      );
    } else
      h = 0.5 * (o + a), bl(e, o, h, i, r), bl(e, h, a, i, r);
  }
}
function Ws(e) {
  this.c = e;
}
Ws.prototype = {
  constructor: Ws,
  /**
   * @param {Vector2} p
   * @param {Vector2} out
   */
  applyPoint(e, n = new N()) {
    const s = this.c, i = s[0] * e.x + s[2] * e.y + s[4], r = s[1] * e.x + s[3] * e.y + s[5];
    return n.set(i, r);
  },
  /**
   * @param {CubicBez} cu
   * @returns {CubicBez}
   */
  applyCubic(e) {
    const n = this.c, s = e.getP0(), i = e.getP1(), r = e.getP2(), o = e.getP3();
    return new ae().initWith4PointsN(
      n[0] * s.x + n[2] * s.y + n[4],
      n[1] * s.x + n[3] * s.y + n[5],
      n[0] * i.x + n[2] * i.y + n[4],
      n[1] * i.x + n[3] * i.y + n[5],
      n[0] * r.x + n[2] * r.y + n[4],
      n[1] * r.x + n[3] * r.y + n[5],
      n[0] * o.x + n[2] * o.y + n[4],
      n[1] * o.x + n[3] * o.y + n[5]
    );
  },
  /**
   * @param {Affine} other
   * @returns {Affine}
   */
  multiply(e) {
    const n = this.c, s = e.c;
    return new Ws([
      n[0] * s[0] + n[2] * s[1],
      n[1] * s[0] + n[3] * s[1],
      n[0] * s[2] + n[2] * s[3],
      n[1] * s[2] + n[3] * s[3],
      n[0] * s[4] + n[2] * s[5] + n[4],
      n[1] * s[4] + n[3] * s[5] + n[5]
    ]);
  }
};
Ws.translate = (e) => new Ws([1, 0, 0, 1, e.x, e.y]);
Ws.rotate = (e) => {
  const n = Math.cos(e), s = Math.sin(e);
  return new Ws([n, s, -s, n, 0, 0]);
};
Ws.scale = (e) => new Ws([e, 0, 0, e, 0, 0]);
const aS = Math.PI * 0.5, Ik = 1 / Math.PI;
function bd(e, n, s, i, r) {
  this.center = e, this.radii = n, this.start_angle = s, this.sweep_angle = i, this.x_rotation = r;
}
bd.prototype = {
  constructor: bd,
  /**
   * @param {number} tolerance
   */
  toCubicBeziers(e) {
    const n = {
      idx: 0,
      center: new N().copy(this.center),
      radii: new N().copy(this.radii),
      x_rotation: this.x_rotation,
      n: 0,
      arm_len: 0,
      angle_step: 0,
      p0: new N(),
      angle0: 0
    }, s = Math.sign(this.sweep_angle), i = Math.max(this.radii.x, this.radii.y) / e, r = Math.max(Math.pow(1.1163 * i, 1 / 6), 3.999999);
    n.n = Math.ceil(r * Math.abs(this.sweep_angle) * (1 / TC)), n.angle_step = this.sweep_angle / n.n, n.arm_len = Math.tan(Math.abs(4 / 3 * (0.25 * n.angle_step))) * s, n.angle0 = this.start_angle, n.p0 = Uu(this.radii, this.x_rotation, n.angle0);
    const o = [];
    for (; n.idx < n.n; ) {
      const a = n.angle0 + n.angle_step, l = n.p0.clone().clone().add(Uu(n.radii, n.x_rotation, n.angle0 + aS).scale(n.arm_len)), h = Uu(n.radii, n.x_rotation, a), d = h.clone().sub(Uu(n.radii, n.x_rotation, a + aS).scale(n.arm_len));
      n.angle0 = a, n.p0 = h, n.idx += 1, o.push(
        l.clone().add(n.center),
        d.clone().add(n.center),
        h.clone().add(n.center)
      );
    }
    return o;
  }
};
const Sk = [
  0.1894506104550685,
  -0.0950125098376374,
  0.1894506104550685,
  0.0950125098376374,
  0.1826034150449236,
  -0.2816035507792589,
  0.1826034150449236,
  0.2816035507792589,
  0.1691565193950025,
  -0.4580167776572274,
  0.1691565193950025,
  0.4580167776572274,
  0.1495959888165767,
  -0.6178762444026438,
  0.1495959888165767,
  0.6178762444026438,
  0.1246289712555339,
  -0.755404408355003,
  0.1246289712555339,
  0.755404408355003,
  0.0951585116824928,
  -0.8656312023878318,
  0.0951585116824928,
  0.8656312023878318,
  0.0622535239386479,
  -0.9445750230732326,
  0.0622535239386479,
  0.9445750230732326,
  0.0271524594117541,
  -0.9894009349916499,
  0.0271524594117541,
  0.9894009349916499
], yk = [
  0.0965400885147278,
  -0.0483076656877383,
  0.0965400885147278,
  0.0483076656877383,
  0.0956387200792749,
  -0.1444719615827965,
  0.0956387200792749,
  0.1444719615827965,
  0.0938443990808046,
  -0.2392873622521371,
  0.0938443990808046,
  0.2392873622521371,
  0.0911738786957639,
  -0.3318686022821277,
  0.0911738786957639,
  0.3318686022821277,
  0.0876520930044038,
  -0.4213512761306353,
  0.0876520930044038,
  0.4213512761306353,
  0.0833119242269467,
  -0.5068999089322294,
  0.0833119242269467,
  0.5068999089322294,
  0.0781938957870703,
  -0.5877157572407623,
  0.0781938957870703,
  0.5877157572407623,
  0.0723457941088485,
  -0.6630442669302152,
  0.0723457941088485,
  0.6630442669302152,
  0.0658222227763618,
  -0.7321821187402897,
  0.0658222227763618,
  0.7321821187402897,
  0.0586840934785355,
  -0.7944837959679424,
  0.0586840934785355,
  0.7944837959679424,
  0.0509980592623762,
  -0.84936761373257,
  0.0509980592623762,
  0.84936761373257,
  0.0428358980222267,
  -0.8963211557660521,
  0.0428358980222267,
  0.8963211557660521,
  0.0342738629130214,
  -0.9349060759377397,
  0.0342738629130214,
  0.9349060759377397,
  0.0253920653092621,
  -0.9647622555875064,
  0.0253920653092621,
  0.9647622555875064,
  0.0162743947309057,
  -0.9856115115452684,
  0.0162743947309057,
  0.9856115115452684,
  0.0070186100094701,
  -0.9972638618494816,
  0.0070186100094701,
  0.9972638618494816
];
function kc(e, n) {
  this.c = e, this.d = n, this.q = e.deriv();
  const s = this.q.p0.clone(), i = this.q.p1.clone().sub(this.q.p0).scale(2), r = this.q.p0.clone().sub(this.q.p1.clone().scale(2)).add(this.q.p2);
  this.c0 = n * i.cross(s), this.c1 = n * 2 * r.cross(s), this.c2 = n * r.cross(i);
}
kc.prototype = {
  constructor: kc,
  /**
   * @param {number} t
   * @returns {Vector2}
   */
  evalOffset(e) {
    const n = this.q.eval(e), s = new N(-n.y, n.x);
    return n.length() === 0 ? new N(0, 0) : s.scale(this.d / n.length());
  },
  /**
   * @param {number} t
   * @returns {Vector2}
   */
  eval(e) {
    return this.c.eval(e).add(this.evalOffset(e));
  },
  /**
   * @param {number} t
   * @returns {Vector2}
   */
  evalDeriv(e) {
    return this.q.eval(e).scale(this.cuspSign(e));
  },
  /**
   * @param {number} n
   * @returns {{ arclen: number, p: Vector2, d: Vector2}[]}
   */
  samplePoints(e) {
    const n = [];
    let s = 0;
    const i = yk, r = 1 / (e + 1);
    for (let o = 0; o < e; o++) {
      for (let h = 0; h < i.length; h += 2) {
        const d = r * (o + 0.5 + 0.5 * i[h + 1]);
        s += i[h] * this.evalDeriv(d).length();
      }
      const a = r * (o + 1), c = this.evalOffset(a), l = this.c.eval(a).add(c);
      n.push({ arclen: s * 0.5 * r, p: l, d: c });
    }
    return n;
  },
  /**
   * @param {number} t
   * @returns {number}
   */
  cuspSign(e) {
    const n = this.q.eval(e).length_squared();
    return (n === 0 ? 1 / 0 : ((this.c2 * e + this.c1) * e + this.c0) / (n * Math.sqrt(n))) + 1;
  },
  /**
   * @param {number} t
   * @param {number} sign
   * @returns {CurveFitSample}
   */
  samplePointTangent(e, n) {
    const s = this.eval(e), i = 1e-8;
    let r = this.cuspSign(e);
    Math.abs(r) < i && (r = n * (this.cuspSign(e + i) - this.cuspSign(e - i)));
    const o = this.q.eval(e).scale(Math.sign(r));
    return new gg(s, o);
  },
  /**
   * @param {number} t
   * @returns {{ p: Vector2, dp: Vector2 }}
   */
  samplePointDeriv(e) {
    return { p: this.eval(e), dp: this.evalDeriv(e) };
  },
  /**
   * @param {number} rangeStart
   * @param {number} rangeEnd
   * @returns {{ area: number, x: number, y: number }}
   */
  momentIntegrals(e, n) {
    const s = 0.5 * (e + n), i = 0.5 * (n - e);
    let r = 0, o = 0, a = 0;
    const c = Sk;
    for (let l = 0; l < c.length; l += 2) {
      const [h, d] = [c[l], c[l + 1]], p = s + d * i, { p: E, dp: g } = this.samplePointDeriv(p), T = h * g.x * E.y, A = E.x * T, m = E.y * T;
      r += T, o += A, a += m;
    }
    return { area: r * i, x: o * i, y: a * i };
  },
  /**
   * @param {number} rangeStart
   * @param {number} rangeEnd
   * @returns {number | null}
   */
  breakCusp(e, n) {
    const i = (E, g) => {
      let T = this.cuspSign(E);
      for (; Math.abs(T) < 1e-8 && g < 1; ) {
        E += g;
        const A = T;
        if (T = this.cuspSign(E), Math.abs(T) > Math.abs(A))
          break;
        g *= 2;
      }
      return [E, T];
    }, [r, o] = i(e, 1e-12), [a, c] = i(n, -1e-12);
    if (r >= a || o * c >= 0)
      return null;
    const l = Math.sign(c), h = (E) => l * this.cuspSign(E), d = 0.2 / (a - r);
    return gC(h, r, a, 1e-12, 1, d, l * o, l * c);
  }
};
kc.regularized = (e, n, s) => new kc(e.clone().regularize(s), n);
function gg(e, n) {
  this.p = e, this.tangent = n;
}
gg.prototype = {
  constructor: gg,
  /**
   * @param {CubicBez} c
   * @returns {number[]}
   */
  intersect(e) {
    const n = e.getP1().clone().sub(e.getP0()).scale(3), s = e.getP2().clone().scale(3).sub(e.getP1().clone().scale(6)).add(e.getP0().clone().scale(3)), i = e.getP3().clone().sub(e.getP0()).sub(e.getP2().clone().sub(e.getP1()).scale(3)), r = e.getP0().clone().sub(this.p).dot(this.tangent), o = n.dot(this.tangent), a = s.dot(this.tangent), c = i.dot(this.tangent), l = T0(r, o, a, c), h = [];
    for (let d = 0; d < l.length; d++) {
      const p = l[d];
      p >= 0 && p <= 1 && h.push(p);
    }
    return h;
  }
};
const Nc = 20;
function _g(e, n, s) {
  this.samples = [], this.arcparams = [], this.rangeStart = n, this.rangeEnd = s, this.spicy = !1;
  const i = (s - n) * (1 / (Nc + 1));
  let r = null;
  const o = 0.2;
  for (let a = 0; a < Nc + 2; a++) {
    const c = e.samplePointTangent(n + a * i, 1);
    if (r !== null) {
      const l = c.tangent.cross(r), h = c.tangent.dot(r);
      Math.abs(l) > o * Math.abs(h) && (this.spicy = !0);
    }
    c.tangent && (r = c.tangent), a > 0 && a < Nc + 1 && this.samples.push(c);
  }
}
_g.prototype = {
  constructor: _g,
  /**
   * @param {CubicOffset} src
   */
  computeArcParams(e) {
    const [s, i] = [this.rangeStart, this.rangeEnd], r = (i - s) * (1 / ((Nc + 1) * 10));
    let o = 0;
    for (let c = 0; c < Nc + 1; c++) {
      for (let l = 0; l < 10; l++) {
        const h = s + r * (c * 10 + l + 0.5);
        o += e.samplePointDeriv(h).dp.length();
      }
      c < Nc && this.arcparams.push(o);
    }
    const a = 1 / o;
    for (let c = 0; c < this.arcparams.length; c++)
      this.arcparams[c] *= a;
  },
  /**
   * Arclength of a cubic bezier curve
   * @param {CubicBez} c
   * @param {number} acc2 accuracy
   * @returns {number | null}
   */
  evalArc(e, n) {
    const i = e.arclen(1e-9);
    let r = 0;
    for (let o = 0; o < this.samples.length; o++) {
      const a = this.samples[o], c = this.arcparams[o], l = e.invArclen(i * c, 1e-9), h = a.p.distance_squared_to(e.eval(l));
      if (r = Math.max(h, r), r > n)
        return null;
    }
    return r;
  },
  /**
   * Evaluate distance to a cubic approximation.
   * @param {CubicBez} c
   * @param {number | null} acc2
   */
  evalRay(e, n) {
    let s = 0;
    for (let i = 0, r = this.samples.length; i < r; i++) {
      const o = this.samples[i];
      let a = n + 1;
      const c = o.intersect(e);
      for (let l = 0, h = c.length; l < h; l++) {
        const d = c[l], p = o.p.distance_squared_to(e.eval(d));
        a = Math.min(a, p);
      }
      if (s = Math.max(a, s), s > n)
        return null;
    }
    return s;
  },
  /**
   * @param {CubicOffset} src
   * @param {CubicBez} c
   * @param {number} acc2
   * @returns {number | null}
   */
  evalDist(e, n, s) {
    const i = this.evalRay(n, s);
    if (i === null)
      return null;
    if (!this.spicy)
      return i;
    this.arcparams.length === 0 && this.computeArcParams(e), this.evalArc(n, s);
  }
};
function Ck(e, n, s, i) {
  const o = new N(), a = new N(), c = n.clone().sub(e);
  if (c.length_squared() > 1e-12)
    o.copy(c);
  else {
    const h = s.clone().sub(e);
    h.length_squared() > 1e-12 ? o.copy(h) : o.copy(i).sub(e);
  }
  const l = i.clone().sub(s);
  if (l.length_squared() > 1e-12)
    a.copy(l);
  else {
    const h = i.clone().sub(n);
    h.length_squared() > 1e-12 ? a.copy(h) : a.copy(i).sub(e);
  }
  return [o, a];
}
function Nk(e, n, s) {
  var a;
  const i = n.length % 2 ? n.slice(0, n.length - 1) : n, r = 0.1;
  if (i.every((c) => c < r))
    return e;
  for (let c = 0; c < i.length; c += 2)
    i[c] < r && (i[c + 1] >= r && s ? i[c] = r : (i.splice(c, 2), c -= 2));
  const o = new qe();
  if (i.length === 0)
    return o;
  for (let c = 0, l = e._children.length; c < l; c++) {
    const h = e._children[c];
    if (h.isEmpty()) continue;
    const d = h.getCurves();
    let p = 0;
    const E = d.length - 1;
    let g = h.getLength(), T = (a = d[p]) == null ? void 0 : a.clone(), A = 0, m = i[A];
    for (; g > 0 && T; ) {
      const O = A % 2 === 0;
      T || (T = d[p++].clone());
      const S = O ? [T._segment1] : null;
      let y = m, v = T.getLength();
      for (; v < y; )
        if (O && S.push(T._segment2), y -= v, p >= E) {
          T = null;
          break;
        } else
          p += 1, T = d[p].clone(), v = T.getLength(), O && T && S.pop();
      if (T && y > 0) {
        const R = ae.getTimeAt(T.getValues(), y), M = T.divideAtTime(R, !0);
        O && S.push(T._segment2), T = M;
      }
      if (O && S.length > 1) {
        const R = new xt();
        R.setSegments(S), o.addChild(R);
      }
      g -= m, A = (A + 1) % i.length, m = i[A];
    }
  }
  return o;
}
function cS(e, n, s) {
  var a;
  const i = n.length % 2 ? n.slice(0, n.length - 1) : n, r = 0.1;
  if (i.every((c) => c < r))
    return e;
  for (let c = 0; c < i.length; c += 2)
    i[c] < r && (i[c + 1] >= r && s || (i.splice(c, 2), c -= 2));
  const o = new qe();
  if (i.length === 0)
    return o;
  for (let c = 0, l = e._children.length; c < l; c++) {
    const h = e._children[c];
    if (h.isEmpty()) continue;
    const d = h.getCurves();
    let p = 0;
    const E = d.length - 1;
    let g = h.getLength(), T = (a = d[p]) == null ? void 0 : a.clone(), A = 0, m = i[A];
    for (; g > 0 && T; ) {
      const O = A % 2 === 0;
      T || (T = d[p++].clone());
      const S = O ? [T._segment1] : null;
      let y = m, v = T.getLength();
      for (; v < y; )
        if (O && S.push(T._segment2), y -= v, p >= E) {
          T = null;
          break;
        } else
          p += 1, T = d[p].clone(), v = T.getLength(), O && T && (S[0].hasHandles() || S[1].hasHandles()) && S.pop();
      if (T && y > 0) {
        const R = ae.getTimeAt(T.getValues(), y), M = T.divideAtTime(R, !1);
        O && S.push(T._segment2), T = M;
      }
      if (O && S.length > 1) {
        const R = new xt();
        R.setSegments(S), o.addChild(R);
      }
      g -= m, A = (A + 1) % i.length, m = i[A];
    }
  }
  return o;
}
const xk = new Ce(
  0,
  -1,
  1,
  0,
  0,
  1
);
function Tg() {
  this.visible = !0, this.bounds = new ye(), this.paint = null, this.effect = null, this.blendMode = Ut.PASS_THROUGH, this.storage = null;
}
Tg.prototype = {
  constructor: Tg,
  clear() {
    return this.visible = !0, this.vectorData = null, this.textData = null, this.bounds.set(0, 0, 0, 0), this.paint && (this.paint.gradient && this.storage.destroyGradientResource(this.paint.gradient.id), this.paint = null), this.effect = null, this.blendMode = Ut.PASS_THROUGH, this.storage = null, !0;
  },
  /* fill */
  /**
   * @param {Color} color
   * @param {number} opacity
   * @returns {this}
   */
  solid(e, n) {
    const s = this.paint || new xc();
    return this.paint = s, s.type = Ie.SOLID, s.params.opacity = s.params.opacity || [1], s.params.opacity[0] = n, s.params.fill_color = e.as_array(s.params.fill_color || [1, 1, 1, 1]), s.params.fill_color[3] = 1, this;
  },
  /**
   * @param {PaintType} type
   * @param {GradientResource} gradient
   * @param {Transform2D} [transform]
   * @param {number} [opacity]
   * @returns {this}
   */
  gradient(e, n, s = xk, i = 1) {
    const r = this.paint || new xc();
    return this.paint = r, r.type = e, r.params.opacity = r.params.opacity || [1], r.params.opacity[0] = i, r.gradient = n, r.transform.copy(s), this;
  },
  /**
   * @param {string} imageID
   * @param {ImageOptions} options
   * @param {number} [opacity]
   * @returns {this}
   */
  image(e, n, s = 1) {
    const i = this.paint || new xc();
    return this.paint = i, i.type = Ie.IMAGE, i.params.opacity = i.params.opacity || [1], i.params.opacity[0] = s, i.image = this.storage.getImageResource(e), i.imageOptions = n, this;
  },
  isPaintable() {
    if (!this.paint) return !1;
    switch (this.paint.type) {
      case Ie.GRADIENT_LINEAR:
      case Ie.GRADIENT_RADIAL:
      case Ie.GRADIENT_ANGULAR:
      case Ie.GRADIENT_DIAMOND:
        return !0;
      case Ie.IMAGE:
        return this.paint.image && this.paint.image.texture_id !== null;
      case Ie.SOLID:
      default:
        return !0;
    }
  },
  /* effect */
  /**
   * @param {number} x
   * @param {number} y
   * @param {number} blur
   * @param {Color} color
   */
  dropShadow(e, n, s, i) {
    const r = this.effect || new zl();
    this.effect = r, r.type = "drop_shadow", r.params.blur = r.params.blur || [1], r.params.blur[0] = s, r.params.offset = r.params.offset || { x: e, y: n }, r.params.offset.x = e, r.params.offset.y = n, r.params.color = i.as_array(r.params.color || [1, 1, 1, 1]);
    const o = new ei().set_with_array(r.params.color);
    this.solid(o, r.params.color[3]);
  },
  /**
   * @param {number} x
   * @param {number} y
   * @param {number} blur
   * @param {Color} color
   */
  innerShadow(e, n, s, i) {
    const r = this.effect || new zl();
    this.effect = r, r.type = "inner_shadow", r.params.blur = r.params.blur || [1], r.params.blur[0] = s, r.params.offset = r.params.offset || { x: e, y: n }, r.params.offset.x = e, r.params.offset.y = n, r.params.color = i.as_array(r.params.color || [1, 1, 1, 1]);
  }
};
function xc() {
  this.type = Ie.SOLID, this.params = /* @__PURE__ */ Object.create(null), this.transform = new Ce(), this.gradient = null, this.image = null, this.imageOptions = null;
}
xc.prototype = {
  constructor: xc,
  clone() {
    const e = new xc();
    return e.type = this.type, e.params = Object.assign(/* @__PURE__ */ Object.create(null), this.params), e.transform.copy(this.transform), e.gradient = this.gradient, e.image = this.image, e.imageOptions = this.imageOptions, e;
  }
};
function zl() {
  this.type = "drop_shadow", this.params = /* @__PURE__ */ Object.create(null);
}
zl.prototype = {
  constructor: zl,
  clone() {
    const e = new zl();
    return e.type = this.type, e.params = Object.assign(/* @__PURE__ */ Object.create(null), this.params), e;
  }
};
class Ud extends Oh.EventEmitter {
  /**
   * @param {Transform} [refTransform]
   */
  constructor(n = void 0) {
    super(), this._ref = n, this._init();
  }
  get ref() {
    return this._ref;
  }
  /**
   * Connect the reference transform.
   * When reference transform is connected all values are taken from reference transform
   * @param {Transform} refTransform
   */
  connectRef(n) {
    n && (this._ref !== n && this._clean(), this._ref = n);
  }
  /**
   * Disconnect the reference transform.
   * When reference transform is connected all values are taken from reference transform
   */
  disconnectRef() {
    this._ref && (this._ref = void 0, this._init());
  }
  _init() {
    this._ref || (this._local = new Ce(), this._world = new Ce(), this._worldInv = new Ce(), this._parent = new Ce(), this._saveLocal = new Ce(), this._saveWorld = new Ce(), this._data = {
      referencePoint: new N(0, 0),
      contentAnchor: new N(0, 0),
      translate: new N(),
      size: new N(),
      // for skew, scale and rotation
      scale: new N(1, 1),
      skew: new N(0, 0),
      rotation: 0,
      orient: 0
    }, this._dirty = !0);
  }
  reset() {
    return this.removeAllListeners(), this._local.identity(), this._world.identity(), this._worldInv.identity(), this._parent.identity(), this._saveLocal.identity(), this._saveWorld.identity(), this._data.referencePoint.set(0, 0), this._data.contentAnchor.set(0, 0), this._data.translate.set(0, 0), this._data.size.set(0, 0), this._data.scale.set(1, 1), this._data.skew.set(0, 0), this._data.rotation = 0, this._dirty = !0, !0;
  }
  clean() {
    this.removeAllListeners(), this._clean();
  }
  _clean() {
    return this._local = void 0, this._world = void 0, this._worldInv = void 0, this._parent = void 0, this._saveLocal = void 0, this._saveWorld = void 0, this._data = void 0, this._dirty = !0, !0;
  }
  /**
   * @readonly
   * @returns {Transform2D}
   */
  get local() {
    return this._ref ? this._ref.local : this._local;
  }
  /**
   * @readonly
   * @returns {Transform2D}
   */
  get world() {
    return this._ref ? this._ref.world : this._world;
  }
  /**
   * @readonly
   * @returns {Transform2D}
   */
  get saveLocal() {
    return this._ref ? this._ref.saveLocal : this._saveLocal;
  }
  /**
   * @readonly
   * @returns {Transform2D}
   */
  get saveWorld() {
    return this._ref ? this._ref.saveWorld : this._saveWorld;
  }
  /**
   * @readonly
   * @returns {Transform2D}
   */
  get worldInv() {
    return this._ref ? this._ref.worldInv : this._worldInv;
  }
  /**
   * @readonly
   * @returns {Transform2D}
   */
  get parent() {
    return this._ref ? this._ref.parent : this._parent;
  }
  /**
   * @readonly
   * @returns {Vector2}
   */
  get position() {
    return this._ref ? this._ref.position : this._data.position;
  }
  /**
   * @readonly
   * @returns {Vector2}
   */
  get size() {
    return this._ref ? this._ref.size : this._data.size;
  }
  /**
   * @readonly
   * @returns {Vector2}
   */
  get scale() {
    return this._ref ? this._ref.scale : this._data.scale;
  }
  /**
   * @readonly
   * @returns {Vector2}
   */
  get skew() {
    return this._ref ? this._ref.skew : this._data.skew;
  }
  /**
   * @readonly
   * @returns {Vector2}
   */
  get referencePoint() {
    return this._ref ? this._ref.referencePoint : this._data.referencePoint;
  }
  /**
   * (aka origin, aka anchor in lottie)
   * @readonly
   * @returns {Vector2}
   */
  get contentAnchor() {
    return this._ref ? this._ref.contentAnchor : this._data.contentAnchor;
  }
  /** @returns {number} */
  get rotation() {
    return this._ref ? this._ref.rotation : this._data.rotation;
  }
  /**
   * @readonly
   * @returns {Vector2}
   */
  get translate() {
    return this._ref ? this._ref.translate : this._data.translate;
  }
  /**
   * Generates pooled Vector2 pivot offset
   * @returns {Vector2} offset
   */
  getPivotOffset() {
    return this.referencePoint.clone().add(this.contentAnchor);
  }
  get worldPivot() {
    const n = this.translate.clone();
    return this.parent.xform(n, n);
  }
  /** @param {number} value */
  setTranslateX(n) {
    this._data.translate.x = n, this._dirty = !0;
  }
  /** @param {number} value */
  setTranslateY(n) {
    this._data.translate.y = n, this._dirty = !0;
  }
  /** @param {Vector2Like} value */
  setReferencePoint(n) {
    this._data.referencePoint.copy(n), this._dirty = !0;
  }
  /** @param {Vector2Like} value */
  setContentAnchor(n) {
    this._data.contentAnchor.copy(n), this._dirty = !0;
  }
  /** @param {Vector2Like} value */
  setScale(n) {
    this._data.scale.copy(n), this._dirty = !0;
  }
  /** @param {Vector2Like} value */
  setSkew(n) {
    this._data.skew.copy(n), this._dirty = !0;
  }
  /** @param {number} value */
  setRotation(n) {
    this._data.rotation = n, this._dirty = !0;
  }
  /** @param {number} value */
  setOrient(n) {
    this._data.orient = n, this._dirty = !0;
  }
  /** @param {Vector2Like} value */
  setSize(n) {
    this._data.size.copy(n), this._dirty = !0;
  }
  /**
   * @todo #transform Replace it by matrix operation
   * @param {Transform2D} [out]
   * @returns {Transform2D} the transform before origin translation
   */
  getInnerT(n = new Ce()) {
    const { rotation: s, scale: i, skew: r } = this;
    return n.reset().rotate_right(s).skew_right(Rt(r.x), Rt(r.y)).scale_right(i.x, i.y);
  }
  /**
   * @returns {boolean}
   */
  update() {
    if (this._ref || !this._dirty)
      return !1;
    this._dirty = !1;
    const { translate: n, rotation: s, scale: i, skew: r } = this, o = this.getPivotOffset();
    return this._local.reset().translate_right(n.x, n.y).rotate_right(s).skew_right(Rt(r.x), Rt(r.y)).scale_right(i.x, i.y).translate_right(-o.x, -o.y), this._saveLocal.reset().translate_right(n.x, n.y).rotate_right(s).skew_right(
      Math.abs(r.x + Math.PI * 0.5) % Math.PI === 0 ? 0 : r.x,
      Math.abs(r.y + Math.PI * 0.5) % Math.PI === 0 ? 0 : r.y
    ).scale_right(i.x === 0 ? 1 : i.x, i.y === 0 ? 1 : i.y).translate_right(-o.x, -o.y), !0;
  }
  /**
   * @param {Transform} parentTransform
   * @returns {boolean}
   */
  updateWorld(n) {
    return this._ref ? !1 : (this.parent.copy(n.world), this.world.copy(n.world).append(this.local), this.worldInv.copy(this.world).affine_inverse(), this.saveWorld.copy(n.saveWorld).append(this.saveLocal), this.emit("updateWorld"), !0);
  }
}
const lS = Math.PI / 2, lE = 1e-3;
function Rt(e) {
  const n = Math.sign(e);
  let s = Math.abs(e) % Math.PI;
  return (Math.abs(s / lS - 1) < lE || Math.abs(s / lS - 3) < lE) && (s += lE / 180 * Math.PI), s * n;
}
class vk extends Oh.EventEmitter {
  constructor() {
    super(), this.rect = new ye(), this.local = new ye(), this.world = new ye(), this.visual = new ye(), this.visualWorld = new ye(), this._data = {
      size: new N()
    }, this._dirty = !0;
  }
  get calcFromContent() {
    return this._data.size === null;
  }
  reset() {
    return this.rect.set(0, 0, 0, 0), this.world.set(0, 0, 0, 0), this.visual.set(0, 0, 0, 0), this.visualWorld.set(0, 0, 0, 0), this._data.size ? this._data.size.set(0, 0) : this._data.size = new N(0, 0), this._dirty = !0, !0;
  }
  recalculateFromContent() {
    this.calcFromContent && (this._dirty = !0);
  }
  /**
   * @param {Vector2Like|null} size
   */
  setSize(n) {
    n === null ? this._data.size = null : this._data.size.copy(n), this._dirty = !0;
  }
  updateLocal(n) {
    n.xform_rect(this.rect, this.local), this.emit("updateLocal");
  }
  /**
   * @param {Transform2D} transform
   */
  updateWorld(n) {
    n.xform_rect(this.rect, this.world), n.xform_rect(this.visual, this.visualWorld), this.emit("updateWorld");
  }
  /**
   * @param {Vector2} p
   * @param {Transform2D} transform
   * @returns {boolean}
   */
  containsPoint(n, s) {
    const i = s.xform(n);
    return this.rect.has_point(i);
  }
  /**
   * @param {Rect2} rect
   * @param {Transform2D} transform
   * @returns {boolean}
   */
  intersectWith(n, s) {
    const [i, r, o, a] = hS(this.rect), c = s.xform_rect(n), [l, h, d, p] = hS(c);
    return bF(
      o,
      i,
      a,
      r,
      d,
      l,
      p,
      h
    );
  }
}
const hS = (e) => {
  const n = new N(e.x, e.y), s = new N(e.x, e.y + e.height), i = new N(e.x + e.width, e.y), r = new N(e.x + e.width, e.y + e.height);
  return [n, s, i, r];
};
function Gd() {
  this.id = 0, this.geo_type = 0, this.data = { type: "RAW" }, this.path = null, this.vertices = null, this.triangles = null, this.bounds = new ye(), this.rect = null;
}
Gd.prototype = {
  constructor: Gd,
  getData() {
    return this.triangles;
  },
  setDataType(e) {
    this.data.type = e;
  },
  /**
   * @param {PathData} data
   */
  setPathDirectly(e) {
    this.path = e, this._dirty = !0;
  },
  clear() {
    this.vertices = null, this.triangles = null, this.buffer && (this.gfx.destroyBuffer(this.buffer), this.buffer = null, this.vertLen = 0), this.bounds.set(0, 0, 0, 0);
  },
  free() {
    this.clear(), this.path = null;
  }
};
const Ea = {};
class Rk extends Ud {
  /**
   * @param {object} options
   * @param {number} [options.translateX]
   * @param {number} [options.translateY]
   */
  setTranslate({ translateX: n, translateY: s } = Ea) {
    const i = this._data.translate;
    ee(n) && (i.x = n), ee(s) && (i.y = s), this._dirty = !0;
  }
  /**
   * @param {object} options
   * @param {number} [options.referencePointX]
   * @param {number} [options.referencePointY]
   */
  setReferencePoint({ referencePointX: n, referencePointY: s } = Ea) {
    if (!this._data) return;
    const i = this._data.referencePoint;
    ee(n) && (i.x = n), ee(s) && (i.y = s), this._dirty = !0;
  }
  /**
   * @param {object} options
   * @param {number} [options.contentAnchorX]
   * @param {number} [options.contentAnchorY]
   */
  setContentAnchor({ contentAnchorX: n, contentAnchorY: s } = Ea) {
    const i = this._data.contentAnchor;
    ee(n) && (i.x = n), ee(s) && (i.y = s), this._dirty = !0;
  }
  /**
   * @param {object} options
   * @param {number} [options.scaleX]
   * @param {number} [options.scaleY]
   */
  setScale({ scaleX: n, scaleY: s } = Ea) {
    const i = this._data.scale;
    ee(n) && (i.x = n), ee(s) && (i.y = s), this._dirty = !0;
  }
  /**
   * @param {object} options
   * @param {number} [options.skewX]
   * @param {number} [options.skewY]
   */
  setSkew({ skewX: n, skewY: s } = Ea) {
    const i = this._data.skew;
    ee(n) && (i.x = n), ee(s) && (i.y = s), this._dirty = !0;
  }
  /**
   * @param {object} options
   * @param {number} [options.width]
   * @param {number} [options.height]
   */
  setSize({ width: n, height: s } = Ea) {
    const i = this._data.size;
    ee(n) && (i.x = n), ee(s) && (i.y = s), this._dirty = !0;
  }
  /**
   * @param {object} options
   * @param {number} options.rotation
   */
  setRotation({ rotation: n } = Ea) {
    ee(n) && (this._data.rotation = n), this._dirty = !0;
  }
}
const Z = {
  TRANSFORM: 1,
  GEOMETRY: 2,
  STYLE: 4,
  NODE_SETTING: 8
}, Na = {
  NONE: 0,
  ALPHA: 1,
  INV_ALPHA: 2,
  LUMEN: 3,
  INV_LUMEN: 4
}, Tt = {
  BASE: "BASE",
  CORNER: "CORNER",
  SELF_TRIM: "SELF_TRIM",
  PARENT_TRIM: "PARENT_TRIM"
}, uS = [
  Tt.BASE,
  Tt.CORNER,
  Tt.SELF_TRIM,
  Tt.PARENT_TRIM
];
function ah() {
  this.id = "", this.shape = null, this.vector = new Gd(), this.modVector = null, this.mods = [], this.style = new Ek();
}
ah.prototype = {
  constructor: ah,
  /**
   * @param {number} relativeDepth // the depth we're looking for
   * @param {string} type // the return path will become to this type of path
   * @returns {BezierShape}
   */
  getFinalShape(e = 1, n = Tt.PARENT_TRIM) {
    for (let s = this.mods.length - 1; s >= 0; s--) {
      if (!this.mods[s]) continue;
      if (e === 1) return this.mods[s][2];
      if (this.mods[s][0] >= e) {
        if (e === 0) {
          const r = uS.indexOf(n) - 1;
          if (r >= 0) {
            for (let o = r; o >= 0; o--)
              if (this.mods[o]) return this.mods[o][2];
          }
          return this.mods[0][2];
        }
        return this.mods[s][2];
      }
    }
  },
  /**
   * @param {number} depth
   * @param {ShapeType} type
   * @param {BezierShape} shape
   */
  setShape(e, n, s) {
    switch (n) {
      case Tt.BASE:
        this.mods[0] = [0, n, s];
        break;
      case Tt.CORNER:
        this.mods[1] = [0, n, s];
        break;
      case Tt.SELF_TRIM:
        this.mods[2] = [0, n, s];
        break;
      case Tt.PARENT_TRIM:
        this.mods[2 - e] = [e, n, s];
        break;
      default:
        console.error("setShape() get wrong path type");
        break;
    }
  },
  /**
   * @param {ShapeType} type
   * @param {number} depth
   */
  deleteShape(e, n) {
    if (e === Tt.PARENT_TRIM)
      this.mods[2 - n] = null;
    else {
      const s = uS.indexOf(e);
      this.mods[s] = null;
    }
    this.modVector = null;
  },
  getFinalVector() {
    return this.getFinalShape() === this.shape ? this.vector : (this.modVector || (this.modVector = new Gd(), this.modVector.geo_type = 1), this.modVector);
  },
  hasMods() {
    for (let e = this.mods.length - 1; e >= 0; e--)
      if (this.mods[e]) return !0;
    return !1;
  }
};
class Fd {
  constructor() {
    /**
     * Scene node id
     * @type {NodeID}
     */
    je(this, "id", "");
    /**
     * root node id
     * @type {DinoID}
     */
    je(this, "root_id", 0);
    /** @type {DinoSubTree} */
    je(this, "fills", new Xi());
    /** @type {DinoSubTree} */
    je(this, "strokes", new Xi());
    /** @type {DinoSubTree} */
    je(this, "children", new Xi());
    /**
     * base path id, not used for rendering, just for a path reference for all fill & stroke layers
     * @type {DinoID}
     */
    je(this, "path_id", 0);
    /** @type {DinoID} */
    je(this, "base_path_id", 0);
    /** @type {DinoID} */
    je(this, "text_node_id", 0);
    /** @type {DinoID} */
    je(this, "text_doc_id", 0);
  }
}
class Xi {
  constructor() {
    /** @type {DinoID} */
    je(this, "id", 0);
    /** @type {DinoSubTree[]} */
    je(this, "children", []);
    /** @type {DinoID} */
    je(this, "text_doc_id", 0);
    /** @type {DinoID} */
    je(this, "path_id", 0);
    /** @type {DinoID} */
    je(this, "fill_id", 0);
    /** @type {DinoID} */
    je(this, "fill_tag", 0);
    /** @type {DinoID} */
    je(this, "stroke_id", 0);
    /** @type {DinoID} */
    je(this, "stroke_tag", 0);
    /** @type {DinoID} */
    je(this, "stroke_data_id", 0);
    /** @type {DinoID} */
    je(this, "comp_id", 0);
    /**
     * 0 -> clip
     * 1 -> mask
     * @todo separate clip and mask, no need to be an array
     * @type {DinoSubTree[]}
     * */
    je(this, "compose", [null, null]);
  }
}
function Ag(e) {
  this.id = e, this.name = "", this.type = "group", this.maskType = Na.NONE, this.booleanType = ln.NONE, this.depth = 0, this.childUnionBounds = new ye(), this.events = new Oh.EventEmitter(), this.transform = new Ud(), this.baseTransform = new Rk(this.transform), this.bounds = new vk(), this.bbox = new ye(), this.blendMode = Ut.NORMAL, this.trim = {
    get enabled() {
      return this.begin !== 0 || this.end !== 1 || this.offset !== 0;
    },
    offset: 0,
    begin: 0,
    end: 1,
    mode: ar.SIMULTANEOUSLY,
    version: 0
  }, this.blur = {
    visible: !1,
    amount: 0
  }, this.opacity = 1, this.base = new ah(), this.strokes = [], this.fillLayers = [], this.strokeLayers = [], this.innerShadows = [], this.dropShadows = [], this.sizeFlag = {
    /** @type {'!0' | 't0' | 'f0'} */
    w: "!0",
    /** @type {'!0' | 't0' | 'f0'} */
    h: "!0"
  }, this.scaleFlag = {
    /** @type {'!0' | '0'} */
    x: "!0",
    /** @type {'!0' | '0'} */
    y: "!0"
  }, this.visible = !0, this.locked = !1, this.freed = !1, this.clipping = !1, this.autoOrient = !1, this.orientRotation = 0, this.isEmpty = !1, this.version = 0, this.updateFlags = 0, this.visualServer = null, this.content = null, this.fontFamily = null, this.fontStyle = null, this.fontWeight = null, this.fontSize = null, this.letterSpacing = null, this.lineSpacing = null, this.paragraphSpacing = null, this.horizontalAlignment = null, this.verticalAlignment = null, this.resizingMode = co[Ht.AUTO_WIDTH], this._cornerRadius = -1;
}
Ag.prototype = {
  constructor: Ag,
  isVisible() {
    return this.freed ? !1 : this.visible;
  },
  isContainer() {
    return this.type === "container";
  },
  isContainerNormalGroup() {
    return this.type === "container" || this.type === "group";
  },
  isNormalGroup() {
    return (this.type === "group" || this.type === "workspace") && !this.isMaskGroup() && !this.isBooleanGroup();
  },
  isComputedGroup() {
    return this.type === "group" || this.isMaskGroup() || this.isBooleanGroup();
  },
  isWorkspace() {
    return this.type === "workspace";
  },
  isScreen() {
    return this.type === "screen";
  },
  isMaskGroup() {
    return this.maskType === Na.ALPHA || this.maskType === Na.INV_ALPHA || this.maskType === Na.LUMEN || this.maskType === Na.INV_LUMEN;
  },
  isBooleanGroup() {
    return this.booleanType === ln.UNION || this.booleanType === ln.SUBTRACT || this.booleanType === ln.INTERSECT || this.booleanType === ln.DIFFERENCE;
  },
  /* general */
  onTransformUpdated() {
    this.update(Z.TRANSFORM);
  },
  /**
   * @param {number} flags
   */
  update(e) {
    this.updateFlags |= e, this.visualServer.updateList.add(this), this.version = this.visualServer.currentVersion();
  },
  clear() {
    if (this.removeFills(), this.removeStrokes(), this.removeInnerShadows(), this.removeDropShadows(), this.version = 0, this.clipping = !1, this.isEmpty = !1, this.updateFlags = 0, this.freed = !1, this.visible = !0, this.depth = 0, this.blur.amount = 0, this.blur.visible = !1, this.blendMode = Ut.NORMAL, this.maskType = Na.NONE, this.booleanType = ln.NONE, this.bounds.reset(), this.bbox.set(0, 0, 0, 0), this.transform.reset(), this.baseTransform.connectRef(this.transform), this.transform.off("updateWorld", this.onTransformUpdated, this), this.events.removeAllListeners(), this.name = "", this.type = "group", this.base.vector && (this.base.vector.free(), this.base.vector = null), this.strokes.length)
      for (const e of this.strokes)
        e.vector && (e.vector.free(), e.vector = null);
    return !0;
  },
  /**
   * @param {Vector2Like} size
   */
  setSizeFlag(e) {
    this.sizeFlag.w = ea(e.x), this.sizeFlag.h = ea(e.y);
  },
  /**
   * @param {Vector2Like} scale
   */
  setScaleFlag(e) {
    const n = e.x, s = e.y;
    this.scaleFlag.x = Math.abs(n) < 5e-3 ? "0" : "!0", this.scaleFlag.y = Math.abs(s) < 5e-3 ? "0" : "!0";
  },
  /**
   * @param {boolean} visible
   */
  setVisible(e) {
    this.visible !== e && (this.visible = e, this.update(Z.NODE_SETTING));
  },
  /**
   * @param {number} opacity
   */
  setOpacity(e) {
    this.opacity !== e && (this.opacity = e, this.update(Z.NODE_SETTING));
  },
  /**
   * @param {number} locked
   */
  setLocked(e) {
    this.locked !== e && (this.locked = e);
  },
  /**
   * @param {BlendMode} blendMode
   */
  setBlendMode(e) {
    this.blendMode !== e && (this.blendMode = e, this.update(Z.NODE_SETTING));
  },
  /**
   * @param {number} geometryIndex
   * @param {number} index
   * @param {boolean} visible
   */
  setLayerVisible(e, n, s) {
    const i = Gu(this, e, n);
    i && (i.visible = s), this.update(Z.STYLE | Z.TRANSFORM);
  },
  /**
   * @param {number} index
   * @param {boolean} visible
   */
  setInnerShadowVisible(e, n) {
    const s = dS(this, e);
    s && (s.visible = n), this.update(Z.STYLE | Z.TRANSFORM);
  },
  /**
   * @param {number} index
   * @param {boolean} visible
   */
  setDropShadowVisible(e, n) {
    const s = fS(this, e);
    s && (s.visible = n), this.update(Z.STYLE | Z.TRANSFORM);
  },
  /* paint */
  /**
   * @param {number} geometryIndex
   * @param {number} index
   * @param {Color} color
   * @param {number} opacity
   */
  solid(e, n, s, i) {
    Gu(this, e, n).solid(s, i), this.update(Z.STYLE);
  },
  /**
   * @param {number} geometryIndex
   * @param {number} index
   * @param {PaintType} type
   * @param {{ position: number, color: RGBA }[]} colorStops
   * @param {Transform2D} transform
   * @param {number} opacity
   */
  gradient(e, n, s, i, r, o) {
    var l;
    const a = Gu(this, e, n);
    let c = (l = a == null ? void 0 : a.paint) == null ? void 0 : l.gradient;
    c || (c = this.visualServer.storage.createGradientResource()), a.gradient(s, c, r, o), c.setColorStops(i), this.update(Z.STYLE);
  },
  /**
   * @param {number} geometryIndex
   * @param {number} index
   * @param {string} imageID
   * @param {ImageOptions} options
   * @param {number} opacity
   */
  image(e, n, s, i, r) {
    Gu(this, e, n).image(s, i, r), this.update(Z.STYLE);
  },
  styleUpdated() {
    this.update(Z.STYLE);
  },
  removeFills() {
    for (let e = 0; e < this.fillLayers.length; e++)
      this.fillLayers[e].clear();
    this.fillLayers.length = 0, this.update(Z.STYLE);
  },
  removeStrokes() {
    for (let e = 0; e < this.strokeLayers.length; e++)
      this.strokeLayers[e].clear();
    this.strokeLayers.length = 0, this.update(Z.STYLE | Z.GEOMETRY | Z.TRANSFORM);
  },
  removeInnerShadows() {
    for (const e of this.innerShadows)
      e.clear();
    this.innerShadows.length = 0, this.update(Z.STYLE);
  },
  removeDropShadows() {
    for (const e of this.dropShadows)
      e.clear();
    this.dropShadows.length = 0, this.update(Z.STYLE | Z.TRANSFORM);
  },
  /* effect */
  /**
   * @param {number} blur
   */
  setBlur(e) {
    this.blur.amount = e, this.blur.visible = e > 0.5, this.update(Z.STYLE | Z.TRANSFORM);
  },
  /**
   * @param {number} index
   * @param {number} x
   * @param {number} y
   * @param {number} blur
   * @param {Color} color
   */
  setDropShadow(e, n, s, i, r) {
    fS(this, e).dropShadow(n, s, i, r), this.update(Z.STYLE | Z.TRANSFORM);
  },
  /**
   * @param {number} index
   * @param {number} x
   * @param {number} y
   * @param {number} blur
   * @param {Color} color
   */
  setInnerShadow(e, n, s, i, r) {
    dS(this, e).innerShadow(n, s, i, r), this.update(Z.STYLE);
  },
  /**
   * @param {number} offset
   * @param {number} begin
   * @param {number} end
   * @param {TrimPathMode} mode
   */
  setTrimPath(e, n, s, i) {
    this.trim.offset = Number.isFinite(e) ? e : 0, this.trim.begin = Number.isFinite(n) ? n : 0, this.trim.end = Number.isFinite(s) ? s : 1, this.trim.mode = i || ar.SIMULTANEOUSLY, this.trim.version = -1, this.update(Z.GEOMETRY | Z.TRANSFORM);
  },
  /**
   * Get the corner radius value
   * @returns {number} The corner radius value
   */
  get cornerRadius() {
    return this._cornerRadius;
  },
  /**
   * Set the corner radius value
   * @param {number} value - The new corner radius value
   */
  set cornerRadius(e) {
    this._cornerRadius !== e && (this._cornerRadius = e, this.update(Z.GEOMETRY | Z.TRANSFORM));
  }
};
function kd(e) {
  const n = new Tg();
  return n.storage = e.visualServer.storage, n;
}
function Gu(e, n, s) {
  let i = null;
  return n < 0 ? (s >= e.fillLayers.length && (e.fillLayers[s] = kd(e)), i = e.fillLayers[s]) : (s >= e.strokeLayers.length && (e.strokeLayers[s] = kd(e)), i = e.strokeLayers[s]), i;
}
function dS(e, n) {
  let s = null;
  return n >= e.innerShadows.length && (e.innerShadows[n] = kd(e)), s = e.innerShadows[n], s;
}
function fS(e, n) {
  let s = null;
  return n >= e.dropShadows.length && (e.dropShadows[n] = kd(e)), s = e.dropShadows[n], s;
}
function ea(e) {
  return e === 0 ? "t0" : e < Qt ? "f0" : "!0";
}
Wc({
  mesh: { type: Ed }
});
Oe.MESH_CHANGES;
Oe.GROUP_ADD_CHILDREN, Oe.GROUP_REMOVE_CHILDREN;
Wc({
  pan: { type: se },
  color: { type: as }
});
Oe.SCENE_TREE_CHANGES;
Oe.GROUP_ADD_CHILDREN, Oe.GROUP_REMOVE_CHILDREN;
const wk = {
  TEXT: "com.phase/clip-text"
};
Me.SCREEN;
Me.SCREEN, Me.CONTAINER;
new Fn();
new Fn();
new se();
new se();
const Dk = "/", hE = {
  baseUrl: Dk
};
let an;
const uE = () => an;
function nt() {
  return ot;
}
function ui(e) {
  if (!e || e.length === 0) return { ptr: 0, len: 0 };
  const n = e.length, s = an._ph_allocArena(e.length) >>> 0;
  return new Uint8Array(an.HEAP8.buffer, s, n).set(e), { ptr: s, len: n };
}
function dE(e) {
  if (!e || e.length === 0) return { ptr: 0, len: 0 };
  const n = e.length, s = an._ph_allocArena32(n) >>> 0;
  return new Float32Array(an.HEAP32.buffer, s, n).set(e), { ptr: s, len: n };
}
function mC(e) {
  const n = ot.getPathBBoxEx(e) >>> 0, s = new Float32Array(an.HEAP32.buffer, n, 4), i = new Float32Array(s.buffer.slice(s.byteOffset, s.byteOffset + s.byteLength));
  return {
    x: i[0],
    y: i[1],
    w: i[2],
    h: i[3]
  };
}
function OC(e) {
  return ot.getTextLineLength(e);
}
function Lk(e) {
  const n = ot.getTextLineLength(e) * 4, s = ot.getTextBaseline(e) >>> 0, i = new Float32Array(an.HEAP32.buffer, s, n);
  return new Float32Array(i.buffer.slice(i.byteOffset, i.byteOffset + i.byteLength));
}
function Mk(e) {
  const s = 1 + ot.getTextLineLength(e) * 4, i = ot.getTextSelectionBlockEx(e) >>> 0, r = new Float32Array(an.HEAP32.buffer, i, s);
  return new Float32Array(r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength));
}
function Pk() {
  return ot.getTextEditingNodeIdEx();
}
function bk() {
  const e = ot.getTextCaretPosEx() >>> 0, n = new Float32Array(an.HEAP32.buffer, e, 4);
  return new Float32Array(n.buffer.slice(n.byteOffset, n.byteOffset + n.byteLength));
}
function IC(e, n) {
  const s = ot.getStrokeBBox(e, n) >>> 0, i = new Float32Array(an.HEAP32.buffer, s, 4), r = new Float32Array(i.buffer.slice(i.byteOffset, i.byteOffset + i.byteLength));
  return {
    x: r[0],
    y: r[1],
    w: r[2],
    h: r[3]
  };
}
const ot = {
  initialized: !1,
  readU8Array: (e, n) => new Uint8Array(an.HEAP8.buffer, e, n),
  /**
   * @param {number} w
   * @param {number} h
   */
  setWindowSize: (e, n) => {
    console.warn("API missing");
  },
  /**
   * @returns {number} width
   */
  getCanvasWidth: () => (console.warn("API missing"), 0),
  /**
   * @returns {number} height
   */
  getCanvasHeight: () => (console.warn("API missing"), 0),
  /**
   * @param {number} len
   */
  allocArena: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {number} len
   */
  allocArena32: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {number} len
   */
  allocPerm: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {number} len
   */
  allocPerm32: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {number} ptr
   */
  freePerm: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {number} ptr
   */
  freePerm32: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {string} path
   */
  setAssetsPath: (e) => {
    const s = new TextEncoder().encode(e), i = ui(s);
    ot.setAssetsPathEx(i.ptr, i.len);
  },
  /**
   * @param {number} ptr
   * @param {number} len
   */
  setAssetsPathEx: (e, n) => {
    console.warn("API missing");
  },
  /**
   * @param {number} id
   */
  getPathBBoxEx: (e) => {
    console.warn("API missing");
  },
  getPathBBox(e) {
    const n = ot.getPathBBoxEx(e) >>> 0, s = new Float32Array(an.HEAP32.buffer, n, 4), i = new Float32Array(s.buffer.slice(s.byteOffset, s.byteOffset + s.byteLength));
    return {
      x: i[0],
      y: i[1],
      w: i[2],
      h: i[3]
    };
  },
  getTextPathBBoxEx: (e) => {
    console.warn("API missing");
  },
  getTextPathBBox: (e) => {
    const n = ot.getTextPathBBoxEx(e) >>> 0, s = new Float32Array(an.HEAP32.buffer, n, 4), i = new Float32Array(s.buffer.slice(s.byteOffset, s.byteOffset + s.byteLength));
    return {
      x: i[0],
      y: i[1],
      w: i[2],
      h: i[3]
    };
  },
  /**
   * @param {DinoID} id
   */
  getTextLineLength: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} id
   */
  getTextBaseline: (e) => {
    console.warn("API missing");
  },
  getTextEditingNodeIdEx: () => {
    console.warn("API missing");
  },
  getTextSelectionBlockEx: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} path_id
   * @param {DinoID} stroke_id
   */
  getStrokeBBox: (e, n) => {
    console.warn("API missing");
  },
  GROUP: 0,
  PATH: 1,
  TEXT: 2,
  /**
   * @param {DinoID} node_id
   */
  markNodeChanged: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {0|1|2} type
   */
  makeNode: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} id
   */
  destroyNode: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} parent_id
   * @param {DinoID} child_id
   */
  addNodeChild: (e, n) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} parent_id
   */
  getNodeChildCount: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} parent_id
   * @param {DinoID} child_id
   * @param {number} index
   */
  insertNodeChild: (e, n, s) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} node_id
   */
  addNodeToRoot: (e) => {
    console.warn("API missing");
  },
  /**
   * reorder node in parent
   * @param {DinoID} node_id
   * @param {number} index
   */
  reorderNode: (e, n) => {
    console.warn("API missing");
  },
  /**
   * Remove relationship of node with its parent and siblings, but will keep the child
   * @param {DinoID} node_id
   */
  removeNode: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} node_id
   * @param {number} x
   * @param {number} y
   * @param {number} rotation
   * @param {number} scale_x
   * @param {number} scale_y
   * @param {number} skew_x
   * @param {number} skew_y
   */
  setNodeTransform: (e, n, s, i, r, o, a, c) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} node_id
   * @param {boolean} visible
   */
  setNodeVisible: (e, n) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} node_id
   * @param {number} opacity
   */
  setNodeOpacity: (e, n) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} node_id
   * @param {number} blend
   */
  setNodeBlend: (e, n) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} node_id
   * @param {number} idx
   * @param {DinoID} comp_id
   */
  setNodeCompose: (e, n, s) => {
    console.warn("API missing");
  },
  /**
   * Remove compose from node, would not destroy anything
   * @param {DinoID} node_id
   * @param {number} idx
   */
  removeNodeCompose: (e, n) => {
    console.warn("API missing");
  },
  /**
   * Do three things
   * 1. Remove compose from node
   * 2. Destroy whole compose subtree
   * 3. Destroy compose
   * @param {DinoID} node_id
   * @param {number} idx
   */
  destroyNodeCompose: (e, n) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} node_id
   * @param {DinoID} path_id
   */
  setNodePath: (e, n) => {
    console.warn("API missing");
  },
  updatePageOffset: (e, n) => {
    console.warn("API missing");
  },
  COLOR: 1,
  GRADIENT: 2,
  IMAGE: 3,
  PATTERN: 4,
  /**
   * @param {DinoID} node_id
   * @param {number} tag
   * @param {DinoID} paint_id
   */
  setNodeFillPaint: (e, n, s) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} node_id
   * @param {number} opacity
   */
  setNodeFillOpacity: (e, n) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} node_id
   * @param {number} tag
   * @param {DinoID} paint_id
   */
  setNodeStrokePaint: (e, n, s) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} node_id
   * @param {number} opacity
   */
  setNodeStrokeOpacity: (e, n) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} node_id
   * @param {DinoID} stroke_id
   */
  setNodeStrokeData: (e, n) => {
    console.warn("API missing");
  },
  /**
   * @param {PathData} path
   * @returns {DinoID} path_id
   */
  makePath: (e) => {
    if (e.commands.length === 0 || e.vertices.length === 0)
      return ot.makeEmptyPath();
    const n = ui(e.commands), s = dE(e.vertices);
    return ot.makePathEx(n.ptr, n.len, s.ptr, s.len);
  },
  makeEmptyPath: () => {
    console.warn("API missing");
  },
  /**
   * @param {number} cmd_ptr
   * @param {number} cmd_len
   * @param {number} vtx_ptr
   * @param {number} vtx_len
   */
  makePathEx: (e, n, s, i) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} path_id
   * @param {PathData} path
   */
  setPath: (e, n) => {
    if (n.commands.length === 0 || n.vertices.length === 0)
      ot.setEmptyPath(e);
    else {
      const s = ui(n.commands), i = dE(n.vertices);
      ot.setPathEx(e, s.ptr, s.len, i.ptr, i.len);
    }
  },
  /**
   * @param {DinoID} path_id
   */
  setEmptyPath: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} path_id
   * @param {number} cmd_ptr
   * @param {number} cmd_len
   * @param {number} vtx_ptr
   * @param {number} vtx_len
   */
  setPathEx: (e, n, s, i, r) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} path_id
   */
  destroyPath: (e) => {
    console.warn("API missing");
  },
  fetchFontEx(e, n, s, i, r, o) {
    console.warn("API missing");
  },
  fetchFont(e, n, s, i) {
    const r = ui(Array.from(new TextEncoder().encode(e))), o = ui(Array.from(new TextEncoder().encode(n))), a = s === "Regular" ? 0 : 1;
    return ot.fetchFontEx(r.ptr, r.len, o.ptr, o.len, a, i);
  },
  getTextDocID: (e) => ot.getTextDocIDEx(e),
  getTextDocIDEx: (e) => {
    console.warn("API missing");
  },
  setTextDoc: (e, n, s, i) => {
    const { ptr: r, len: o } = ui(Array.from(new TextEncoder().encode(n)));
    return ot.setTextDocEx(e, r, o, s, i);
  },
  setTextDocEx: (e, n, s, i, r) => {
    console.warn("API missing");
  },
  /**
   * @param {number} doc_id
   */
  destroyTextDoc: (e) => {
    console.warn("API missing");
  },
  setTextStyleEx(e, n, s, i, r, o, a, c, l, h, d) {
    console.warn("API missing");
  },
  setTextStyle(e, n, s, i, r, o, a, c, l, h) {
    const d = s === "Regular" ? 0 : 1, { ptr: p, len: E } = ui(Array.from(new TextEncoder().encode(n)));
    ot.setTextStyleEx(e, p, E, d, i, r, o, a, c, l, h);
  },
  enterTextEditingMode(e, n = -1, s, i, r, o, a) {
    console.warn("API missing");
  },
  changeTextEditingNode(e, n) {
    console.warn("API missing");
  },
  exitTextEditingMode() {
    console.warn("API missing");
  },
  setForceDefaultCursor(e) {
    console.warn("API missing");
  },
  setTextSelection(e, n, s, i, r, o, a) {
    console.warn("API missing");
  },
  buildLayoutAndPathEx(e, n, s, i) {
    console.warn("API missing");
  },
  buildLayoutAndPath(e, n, s, i) {
    ot.buildLayoutAndPathEx(e, n, s, i);
  },
  getTextOffsetEx(e) {
    console.warn("API missing");
  },
  getTextOffset(e) {
    const n = ot.getTextOffsetEx(e) >>> 0, s = new Float32Array(an.HEAP32.buffer, n, 2), i = new Float32Array(s.buffer.slice(s.byteOffset, s.byteOffset + s.byteLength));
    return new N(i[0], i[1]);
  },
  getTextLayoutBoxEx(e) {
    console.warn("API missing");
  },
  getTextLayoutBox(e) {
    const n = ot.getTextLayoutBoxEx(e) >>> 0, s = new Float32Array(an.HEAP32.buffer, n, 4), i = new Float32Array(s.buffer.slice(s.byteOffset, s.byteOffset + s.byteLength));
    return new ye(i[0], i[1], i[2], i[3]);
  },
  getTextAutoLineHeightValue(e) {
    console.warn("API missing");
  },
  /**
   * @param {number} r
   * @param {number} g
   * @param {number} b
   * @param {number} a
   * @returns {number} color_id
   */
  makeColor: (e, n, s, i) => (console.warn("API missing"), 0),
  /**
   * @param {number} id
   * @param {number} r
   * @param {number} g
   * @param {number} b
   * @param {number} a
   */
  setColor: (e, n, s, i, r) => {
    console.warn("API missing");
  },
  /**
   * @param {number} id
   */
  destroyColor: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {number} gradient_type
   * @param {number} a grad matrix a
   * @param {number} b grad matrix b
   * @param {number} c grad matrix c
   * @param {number} d grad matrix d
   * @param {number} e grad matrix e
   * @param {number} f grad matrix f
   * @returns {DinoID} gradient_id
   */
  makeGradientEx: (e, n, s, i, r, o, a) => (console.warn("API missing"), 0),
  /**
   * @param {number} gradient_type
   * @param {Transform2D} matrix
   * @returns {DinoID} gradient_id
   */
  makeGradient: (e, n) => ot.makeGradientEx(e, n.a, n.b, n.c, n.d, n.tx, n.ty),
  /**
   * @param {DinoID} gradient_id
   * @param {number} a grad matrix a
   * @param {number} b grad matrix b
   * @param {number} c grad matrix c
   * @param {number} d grad matrix d
   * @param {number} e grad matrix e
   * @param {number} f grad matrix f
   */
  setGradientMatrixEx: (e, n, s, i, r, o, a) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} gradient_id
   * @param {number} matrix
   */
  setGradientMatrix: (e, n) => {
    ot.setGradientMatrixEx(e, n.a, n.b, n.c, n.d, n.tx, n.ty);
  },
  /**
   * @param {DinoID} gradient_id
   * @param {number} tag
   */
  setGradientTag: (e, n) => {
    console.warn("API missing");
  },
  /**
   * note: Remember to call updateGradientPixels after setting all stops
   * @param {DinoID} gradient_id
   * @param {number} len stop count
   */
  setGradientStopLen: (e, n) => {
    console.warn("API missing");
  },
  /**
   * note: Remember to call updateGradientPixels after setting all stops
   * @param {DinoID} gradient_id
   * @param {number} index
   * @param {number} pos
   * @param {number} r
   * @param {number} g
   * @param {number} b
   * @param {number} a
   */
  setGradientStop: (e, n, s, i, r, o, a) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} gradient_id
   */
  updateGradientPixels: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} gradient_id
   */
  destroyGradient: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {number} width
   * @param {number} cap
   * @param {number} join
   * @param {number} miter_limit
   * @param {number} dash
   * @param {number} gap
   * @returns {DinoID} stroke_id
   */
  makeStroke: (e, n, s, i, r, o) => (console.warn("API missing"), 0),
  /**
   * @param {DinoID} stroke_id
   * @param {number} width
   * @param {number} cap
   * @param {number} join
   * @param {number} miter_limit
   * @param {number} dash
   * @param {number} gap
   */
  setStroke: (e, n, s, i, r, o, a) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} node_id
   * @param {DinoID} path_id
   */
  destroyStrokePathCacheEx: (e, n) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} node_id
   * @param {DinoID} path_id
   */
  destroyStrokePathCache: (e, n) => {
    ot.destroyStrokePathCacheEx(e, n);
  },
  /**
   * @param {DinoID} stroke_id
   */
  destroyStroke: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} path_id
   * @returns {number} ptr
   */
  getPathVtxEx: (e) => (console.warn("API missing"), 0),
  /**
   * @param {DinoID} path_id
   * @returns {number[]} vertices
   */
  getPathVtx: (e) => {
    const n = ot.getPathVtxEx(e) >>> 0, s = new Uint32Array(an.HEAP32.buffer, n, 2);
    if (s[1] === 0) return [];
    const i = new Float32Array(an.HEAP32.buffer, s[0], s[1]), r = new Float32Array(i.buffer.slice(i.byteOffset, i.byteOffset + i.byteLength));
    return Array.from(r);
  },
  /**
   * @param {DinoID} path_id
   * @returns {number} ptr
   */
  getPathCmdEx: (e) => (console.warn("API missing"), 0),
  /**
   * @param {DinoID} path_id
   * @returns {number[]} commands
   */
  getPathCmd: (e) => {
    const n = ot.getPathCmdEx(e) >>> 0, s = new Uint32Array(an.HEAP32.buffer, n, 2);
    if (s[1] === 0) return [];
    const i = new Uint8Array(an.HEAP8.buffer, s[0], s[1]), r = new Uint8Array(i.buffer.slice(i.byteOffset, i.byteOffset + i.byteLength));
    return Array.from(r);
  },
  /**
   * @param {DinoID} path_id
   * @param {DinoID} stroke_id
   * @returns {number} ptr
   */
  getStrokePathCmdEx: (e, n) => (console.warn("API missing"), 0),
  /**
   * @param {DinoID} path_id
   * @param {DinoID} stroke_id
   * @returns {number[]} commands
   */
  getStrokePathCmd: (e, n) => {
    const s = ot.getStrokePathCmdEx(e, n) >>> 0, i = new Uint32Array(an.HEAP32.buffer, s, 2);
    if (i[1] === 0) return [];
    const r = new Uint8Array(an.HEAP8.buffer, i[0], i[1]), o = new Uint8Array(r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength));
    return Array.from(o);
  },
  /**
   * @param {DinoID} path_id
   * @param {DinoID} stroke_id
   * @returns {number} ptr
   */
  getStrokePathVtxEx: (e, n) => (console.warn("API missing"), 0),
  /**
   * @param {DinoID} path_id
   * @param {DinoID} stroke_id
   * @returns {number[]} vertices
   */
  getStrokePathVtx: (e, n) => {
    const s = ot.getStrokePathVtxEx(e, n) >>> 0, i = new Uint32Array(an.HEAP32.buffer, s, 2);
    if (i[1] === 0) return [];
    const r = new Float32Array(an.HEAP32.buffer, i[0], i[1]), o = new Float32Array(r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength));
    return Array.from(o);
  },
  getTextPathEx: (e) => (console.warn("API missing"), 0),
  getTextPathData: (e, n) => {
    const i = ot.getTextPathEx(n) >>> 0, r = new Uint32Array(an.HEAP32.buffer, i, 4);
    if (r[1] === 0 || r[3] === 0) return { commands: [], vertices: [] };
    const o = new Uint8Array(an.HEAP8.buffer, r[0], r[1]), a = new Float32Array(an.HEAP32.buffer, r[2], r[3]), c = new Uint8Array(o.buffer.slice(o.byteOffset, o.byteOffset + o.byteLength)), l = new Float32Array(a.buffer.slice(a.byteOffset, a.byteOffset + a.byteLength));
    return {
      commands: c,
      vertices: l
    };
  },
  /**
   * @param {string} doc_id
   */
  destoryTextPath: (e) => {
    console.warn("API missing");
  },
  getTextPathWithStyle: (e, n, s) => {
    ot.destoryTextPath(n), ot.setTextStyle(
      n,
      s.font_family,
      s.font_style,
      s.font_weight,
      s.font_size,
      s.letter_spacing,
      s.line_spacing,
      s.paragraph_spacing,
      s.text_horizontal_alignment,
      s.text_vertical_alignment
    ), ot.buildLayoutAndPath(e, n, -1, -1);
    const i = ot.getTextPathData(e, n), r = ot.makePath(i), o = nt().getPathCmd(r), a = nt().getPathVtx(r);
    return ot.destoryTextPath(n), { vertices: a, commands: o };
  },
  /**
   * @returns {DinoID} image_id
   */
  allocImage: () => (console.warn("API missing"), 0),
  /**
   * @param {number} ptr
   * @param {number} len
   * @returns {DinoID} image_id
   */
  makeImageWithURLEx: (e, n) => (console.warn("API missing"), 0),
  /**
   * @param {string} url
   * @returns {DinoID} image_id
   */
  makeImageWithURL: (e) => {
    const { ptr: n, len: s } = ui(Array.from(new TextEncoder().encode(e)));
    return ot.makeImageWithURLEx(n, s);
  },
  /**
   * @param {number} pixels_ptr
   * @param {number} pixels_len
   * @param {number} width
   * @param {number} height
   * @returns {DinoID} image_id
   */
  makeImageWithPixelsEx: (e, n, s, i) => (console.warn("API missing"), 0),
  /**
   * @param {number[]} pixels
   * @param {number} width
   * @param {number} height
   * @returns {DinoID} image_id
   */
  makeImageWithPixels: (e, n, s) => {
    const { ptr: i, len: r } = ui(e);
    return ot.makeImageWithPixelsEx(i, r, n, s);
  },
  /**
   * @param {number} ptr
   * @param {number} len
   * @returns {DinoID} image_id
   */
  makeImageWithFileDataEx: (e, n) => (console.warn("API missing"), 0),
  /**
   * @param {number[]} fileData
   * @returns {DinoID} image_id
   */
  makeImageWithFileData: (e) => {
    const { ptr: n, len: s } = ui(e);
    return ot.makeImageWithFileDataEx(n, s);
  },
  /**
   * @param {DinoID} image_id
   * @param {number[]} pixels
   * @param {number} width
   * @param {number} height
   */
  setImageWithPixels: (e, n, s, i) => {
    const { ptr: r, len: o } = ui(n);
    ot.setImageWithPixelsEx(e, r, o, s, i);
  },
  /**
   * @param {DinoID} image_id
   * @param {number} pixels_ptr
   * @param {number} pixels_len
   * @param {number} width
   * @param {number} height
   */
  setImageWithPixelsEx: (e, n, s, i, r) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} image_id
   * @param {number} fill_mode
   */
  setImageFillMode: (e, n) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} image_id
   */
  destroyImage: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {number} comp_tag
   * @param {DinoID} root_id
   * @returns {DinoID} comp_id
   */
  makeCompose: (e, n) => (console.warn("API missing"), 0),
  /**
   * @param {DinoID} comp_id
   * @param {DinoID} root_id
   */
  setComposeRoot: (e, n) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} comp_id
   */
  destroyCompose: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {number} r
   * @param {number} g
   * @param {number} b
   * @param {number} a
   */
  setBackgroundColor: (e, n, s, i) => {
    console.warn("API missing");
  },
  /**
   * @returns {number}
   */
  numNodesRender: () => (console.warn("API missing"), 0),
  /**
   * @returns {number}
   */
  numTilesRender: () => (console.warn("API missing"), 0),
  // overlay
  /**
   * @param {number} a
   * @param {number} b
   * @param {number} c
   * @param {number} d
   * @param {number} e
   * @param {number} f
   */
  setTransform: (e, n, s, i, r, o) => {
    console.warn("API missing");
  },
  /**
   * @param {number} r 0-1
   * @param {number} g 0-1
   * @param {number} b 0-1
   * @param {number} a 0-1
   */
  fillStyle: (e, n, s, i) => {
    console.warn("API missing");
  },
  /**
   * @param {number} width
   * @param {number} r 0-1
   * @param {number} g 0-1
   * @param {number} b 0-1
   * @param {number} a 0-1
   */
  strokeStyle: (e, n, s, i, r) => {
    console.warn("API missing");
  },
  /**
   * @param {number} layer_id
   * @param {number} x
   * @param {number} y
   * @param {number} cmd_ptr
   * @param {number} cmd_len
   * @param {number} vtx_ptr
   * @param {number} vtx_len
   */
  drawPathEx: (e, n, s, i, r, o, a) => {
    console.warn("API missing");
  },
  /**
   * @param {number} layer_id
   * @param {number} x
   * @param {number} y
   * @param {PathData} path
   */
  drawPath: (e, n, s, i) => {
    if (i.commands.length === 0 || i.vertices.length === 0)
      return;
    const r = ui(i.commands), o = dE(i.vertices);
    ot.drawPathEx(e, n, s, r.ptr, r.len, o.ptr, o.len);
  },
  /**
   * @param {number} layer_id
   * @param {number} x0
   * @param {number} y0
   * @param {number} x1
   * @param {number} y1
   */
  drawLine: (e, n, s, i, r) => {
    console.warn("API missing");
  },
  /**
   * @param {number} layer_id
   * @param {number} x0
   * @param {number} y0
   * @param {number} x1
   * @param {number} y1
   */
  drawLineShadow: (e, n, s, i, r) => {
    console.warn("API missing");
  },
  /**
   * @param {number} layer_id
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  drawRect: (e, n, s, i, r) => {
    console.warn("API missing");
  },
  /**
   * @param {number} layer_id
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @param {number} corner_radius
   */
  drawRoundedRect: (e, n, s, i, r, o) => {
    console.warn("API missing");
  },
  /**
   * @param {number} layer_id
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  drawSolidRect: (e, n, s, i, r) => {
    console.warn("API missing");
  },
  /**
   * @param {number} layer_id
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @param {number} corner_radius
   */
  drawSolidRoundedRect: (e, n, s, i, r, o) => {
    console.warn("API missing");
  },
  /**
   * @param {number} layer_id
   * @param {number} x
   * @param {number} y
   * @param {number} radius
   */
  drawCircle: (e, n, s, i) => {
    console.warn("API missing");
  },
  /**
   * @param {number} layer_id
   * @param {number} x
   * @param {number} y
   * @param {number} radius
   */
  drawSolidCircle: (e, n, s, i) => {
    console.warn("API missing");
  },
  /**
   * @param {number} layer_id
   * @param {number} x
   * @param {number} y
   * @param {number} radius
   */
  drawCircleShadow: (e, n, s, i) => {
    console.warn("API missing");
  },
  /**
   * @param {number} layer_id
   * @param {number} x
   * @param {number} y
   * @param {number} radius_x
   * @param {number} radius_y
   * @param {number} rot
   */
  drawEllipse: (e, n, s, i, r, o = 0) => {
    console.warn("API missing");
  },
  /**
   * @param {number} layer_id
   * @param {number} x
   * @param {number} y
   * @param {number} radius_x
   * @param {number} radius_y
   * @param {number} rot
   */
  drawSolidEllipse: (e, n, s, i, r, o = 0) => {
    console.warn("API missing");
  },
  /**
   * @param {number} layer_id
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   * @param {number} rot
   */
  drawEllipseShadow: (e, n, s, i, r, o) => {
    throw new Error("API missing");
  },
  /**
   * @param {number} pixels_ptr
   * @param {number} pixels_len
   * @param {number} width
   * @param {number} height
   * @returns {DinoID} id
   */
  uploadImageEx: (e, n, s, i) => (console.warn("API missing"), 0),
  /**
   * @param {number[]} pixels
   * @param {number} width
   * @param {number} height
   * @returns {DinoID} id
   */
  uploadImage: (e, n, s) => {
    const { ptr: i, len: r } = ui(e);
    return ot.uploadImageEx(i, r, n, s);
  },
  destroyCanvasImage: (e) => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} layer_id
   * @param {DinoID} image_id
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  drawImage: (e, n, s, i, r, o) => {
    console.warn("API missing");
  },
  purge: () => {
    console.warn("API missing");
  },
  /**
   * @param {DinoID} path_id
   * @param {number} x
   * @param {number} y
   * @returns {boolean}
   */
  isPointInPath: (e, n, s) => (console.warn("API missing"), !1),
  /**
   * @param {DinoID} path_id
   * @param {DinoID} stroke_data_id
   * @param {number} x
   * @param {number} y
   * @returns {boolean}
   */
  isPointInStroke: (e, n, s, i) => (console.warn("API missing"), !1),
  /**
   * @param {DinoID} node_id
   * @param {number} x
   * @param {number} y
   * @returns {boolean}
   */
  isPointInText: (e, n, s) => (console.warn("API missing"), !1),
  /**
   * @param {DinoID} node_id
   * @param {number} x
   * @param {number} y
   * @returns {boolean}
   */
  isPointInSelectedText: (e, n, s) => (console.warn("API missing"), !1),
  /**
   * @param {number} r 0.0 - 1.0
   * @param {number} g 0.0 - 1.0
   * @param {number} b 0.0 - 1.0
   * @param {number} a 0.0 - 1.0
   */
  setCaptureBackgroundColor: (e, n, s, i) => {
    console.warn("API missing");
  },
  /**
   * @param {number} node_id
   * @param {number} clip_x
   * @param {number} clip_y
   * @param {number} clip_w
   * @param {number} clip_h
   * @param {number} output_w
   * @param {number} output_y
   */
  capture: (e, n, s, i, r, o, a) => {
    console.warn("API missing");
  },
  pauseApp: () => {
    console.warn("API missing");
  },
  resumeApp: () => {
    console.warn("API missing");
  },
  setNodeFontFamily: (e, n) => {
  },
  setNodeFontWeight: (e, n) => {
  },
  setNodeLineHeight: (e, n) => {
  },
  setNodeLetterSpacing: (e, n) => {
  },
  setNodeFontSize: (e, n) => {
  },
  setNodeTextContent: (e, n) => {
  },
  setNodeHorizontalAlignment: (e, n) => {
  },
  setNodeVerticalAlignment: (e, n) => {
  },
  getNodeStorageCount: () => (console.warn("API missing"), 0),
  getColorStorageCount: () => (console.warn("API missing"), 0),
  getPathStorageCount: () => (console.warn("API missing"), 0),
  getStrokeStorageCount: () => (console.warn("API missing"), 0)
}, Ul = 150, $r = new N(), Al = [
  new N(-150, -150),
  new N($r.x + Ul, -150),
  new N($r.x + Ul, $r.y + Ul),
  new N(-150, $r.y + Ul),
  new N(-150, -150)
], kt = nt(), mg = [], Bd = /* @__PURE__ */ new Map();
let uc = null;
const Uk = (e, n) => {
  let s = Bd.get(`${e}x${n}`);
  s || (s = [], Bd.set(`${e}x${n}`, s));
  let i = s.pop();
  return i || (i = document.createElement("canvas")), i.width = e, i.height = n, i;
}, Gk = (e) => {
  const n = e.width, s = e.height;
  let i = Bd.get(`${n}x${s}`);
  i || (i = [], Bd.set(`${n}x${s}`, i)), i.push(e);
}, Fk = () => {
  for (const e of mg)
    nt().destroyCanvasImage(e);
  mg.length = 0;
};
class kk {
  /**
   * @param {Viewport} viewport
   */
  constructor(n) {
    this.index = 0, this.viewport = n, this.transform = new Ce(), this.globalAlpha = 1, this.fill = {
      color: 16777215,
      alpha: 1
    }, this.stroke = {
      width: 1,
      color: 16777215,
      alpha: 1
    }, this.resetTransform();
  }
  reset() {
    return this.transform.identity(), this.globalAlpha = 1, this.fill.color = 16777215, this.fill.alpha = 1, this.stroke.width = 1, this.stroke.color = 16777215, this.stroke.alpha = 1, this.clear(), this.resetTransform(), !0;
  }
  clear() {
    return Hk(this.viewport), this.resetTransform(), this;
  }
  /**
   * @param {number} alpha
   * @returns {this}
   */
  setAlpha(n) {
    return this.globalAlpha = n, this;
  }
  /**
   * @returns {this}
   */
  resetTransform() {
    return this.transform.identity(), kt.setTransform(this.transform.a, this.transform.b, this.transform.c, this.transform.d, this.transform.tx, this.transform.ty), this;
  }
  /**
   * @param {Transform2D} transform
   * @returns {this}
   */
  appendTransform(n) {
    return this.transform.append(n), kt.setTransform(this.transform.a, this.transform.b, this.transform.c, this.transform.d, this.transform.tx, this.transform.ty), this;
  }
  /**
   * @param {number} color
   * @param {number} [alpha]
   * @returns {this}
   */
  fillStyle(n, s = 1) {
    this.fill.color = n, this.fill.alpha = s;
    const i = (n >> 16 & 255) / 255, r = (n >> 8 & 255) / 255, o = (n & 255) / 255;
    return kt.fillStyle(i, r, o, s), this;
  }
  /**
   * @param {number} width
   * @param {number} color
   * @param {number} [alpha]
   * @returns {this}
   */
  lineStyle(n, s, i = 1) {
    this.stroke.width = n * this.viewport.pixelRatio, this.stroke.color = s, this.stroke.alpha = i;
    const r = (s >> 16 & 255) / 255, o = (s >> 8 & 255) / 255, a = (s & 255) / 255;
    return kt.strokeStyle(n, r, o, a, i), this;
  }
  /**
   * @param {number} x0
   * @param {number} y0
   * @param {number} x1
   * @param {number} y1
   * @returns {this}
   */
  drawLine(n, s, i, r) {
    return kt.setTransform(this.transform.a, this.transform.b, this.transform.c, this.transform.d, this.transform.tx, this.transform.ty), kt.drawLine(this.layer_id, n, s, i, r), this;
  }
  drawLineShadow(n, s, i, r) {
    return kt.setTransform(this.transform.a, this.transform.b, this.transform.c, this.transform.d, this.transform.tx, this.transform.ty), kt.drawLineShadow(this.layer_id, n, s, i, r), this;
  }
  /**
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   * @param {number} [cornerRadius]
   * @param {Vector2} elementScale
   * @returns {this}
   */
  drawRect(n, s, i, r, o = 0) {
    return kt.setTransform(this.transform.a, this.transform.b, this.transform.c, this.transform.d, this.transform.tx, this.transform.ty), o === 0 ? kt.drawRect(this.layer_id, n, s, i, r) : kt.drawRoundedRect(this.layer_id, n, s, i, r, o), this;
  }
  /**
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   * @param {number} [cornerRadius]
   * @returns {this}
   */
  drawSolidRect(n, s, i, r, o = 0) {
    return kt.setTransform(this.transform.a, this.transform.b, this.transform.c, this.transform.d, this.transform.tx, this.transform.ty), o === 0 ? kt.drawSolidRect(this.layer_id, n, s, i, r) : kt.drawSolidRoundedRect(this.layer_id, n, s, i, r, o), this;
  }
  /**
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} [height=width]
   * @param {number} rot
   * @returns {this}
   */
  drawEllipse(n, s, i, r = i, o = 0) {
    return kt.setTransform(this.transform.a, this.transform.b, this.transform.c, this.transform.d, this.transform.tx, this.transform.ty), i === r ? kt.drawCircle(this.layer_id, n, s, i) : kt.drawEllipse(this.layer_id, n, s, i, r, o), this;
  }
  /**
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} [height=width]
   * @param {number} rot
   * @returns {this}
   */
  drawEllipseShadow(n, s, i, r = i, o = 0) {
    return kt.setTransform(this.transform.a, this.transform.b, this.transform.c, this.transform.d, this.transform.tx, this.transform.ty), kt.drawEllipseShadow(this.layer_id, n, s, i, r, o), this;
  }
  /**
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} [height=width]
   * @param {boolean} [center=true]
   * @param {boolean} [isSizeInScreenSpace=false]
   * @returns {this}
   */
  drawSolidEllipse(n, s, i, r = i) {
    return kt.setTransform(this.transform.a, this.transform.b, this.transform.c, this.transform.d, this.transform.tx, this.transform.ty), kt.drawSolidEllipse(this.layer_id, n, s, this.transform.a * i * 0.5, this.transform.d * r * 0.5, 0), this;
  }
  /**
   * Subpath with same first and last point will be considered as "closed",
   * so it won't have line caps
   * @param {number} x
   * @param {number} y
   * @param {PathData} path
   * @returns {this}
   */
  drawPath(n, s, i) {
    return kt.setTransform(this.transform.a, this.transform.b, this.transform.c, this.transform.d, this.transform.tx, this.transform.ty), kt.drawPath(this.layer_id, n, s, i), this;
  }
  measureTextImage(n, s = 12, i = "left", r = "top") {
    uc = uc || document.createElement("canvas");
    const o = uc.getContext("2d"), a = s * this.viewport.pixelRatio;
    o.font = `${a}px Inter`, o.textAlign = i, o.textBaseline = r, o.lineWidth = 0.5;
    const c = o.measureText(n), l = c.actualBoundingBoxAscent + c.actualBoundingBoxDescent;
    return [c.width / ch.pixelRatio, l / ch.pixelRatio];
  }
  drawTextImage(n, s, i, r = { font: "Inter", fontSize: 12, h_align: "left", v_align: "alphabetic" }) {
    const { font: o, fontSize: a, h_align: c, v_align: l } = r;
    nt().setTransform(this.transform.a, this.transform.b, this.transform.c, this.transform.d, this.transform.tx, this.transform.ty), uc = uc || document.createElement("canvas");
    const h = uc.getContext("2d"), d = a * this.viewport.pixelRatio;
    h.font = `${d}px ${o || "Inter"}}`, h.textAlign = c, h.textBaseline = l, h.lineWidth = 0.5;
    const p = h.measureText(i), E = p.actualBoundingBoxAscent, g = p.actualBoundingBoxDescent, T = E + g, A = 2 * this.viewport.pixelRatio, m = T + A, O = (k) => Math.pow(2, Math.ceil(Math.log2(k))), S = O(p.width), y = O(m), v = Uk(S, y), R = v.getContext("2d", {
      willReadFrequently: !0
    });
    R.clearRect(0, 0, S, y), R.font = `${d}px ${o || "Inter"}`, R.textAlign = c, R.textBaseline = l, R.fillStyle = "white", R.lineWidth = 0.5, R.fillText(i, 0, E + A / 2);
    const M = R.getImageData(0, 0, S, y).data, L = nt().uploadImage(M, S, y);
    mg.push(L);
    const P = s - A / 2 / this.viewport.pixelRatio;
    return nt().drawImage(this.layer_id, L, n, P, S / this.viewport.pixelRatio, y / this.viewport.pixelRatio), Gk(v), this;
  }
  /**
   * @param {number} id
   * @param {number} dx
   * @param {number} dy
   * @param {number} dw
   * @param {number} dh
   * @param {boolean} [flipY=false]
   * @returns {this}
   */
  drawImage(n, s, i, r, o) {
    return kt.setTransform(this.transform.a, this.transform.b, this.transform.c, this.transform.d, this.transform.tx, this.transform.ty), kt.drawImage(this.layer_id, n, s, i, r, o), this;
  }
  /**
   * @param {string} imageSrc
   * @param {number} dx display posX
   * @param {number} dy display posY
   * @param {number} ratioX image size ratio
   * @param {number} ratioY image size ratio
   * @param {boolean} centered location of anchor point
   * @param {boolean} centeredX
   * @param {boolean} centeredY
   * @returns {this}
   */
  drawImageFromAtlas(n, s, i, r, o, a = !0, c = !0) {
    const l = Dt(n);
    if (!l || !l.valid)
      return console.log(`image [${n}] not loaded into atlas yet`), this;
    const h = l.imageInfo;
    let d = s - h.w * 0.5 * r / h.pixelRatio, p = i - h.h * 0.5 * o / h.pixelRatio;
    const E = h.w * r / h.pixelRatio, g = h.h * o / h.pixelRatio;
    return a || (d = s), c || (p = i), this.drawImage(l.image, d, p, E, g), this;
  }
  drawSolidRectTexture(n, s, i, r, o = 0) {
    return kt.setTransform(this.transform.a, this.transform.b, this.transform.c, this.transform.d, this.transform.tx, this.transform.ty), kt.drawSolidRoundedRect(this.layer_id, n, s, i, r, o), this;
  }
  drawRectTexture(n, s, i, r, o, a = 0) {
    return kt.setTransform(this.transform.a, this.transform.b, this.transform.c, this.transform.d, this.transform.tx, this.transform.ty), kt.drawRoundedRect(this.layer_id, n, s, i, r, a), this;
  }
}
class Bk {
  /**
   * @param {VisualServer} visualServer
   * @param {Viewport} viewport
   */
  constructor(n, s) {
    this.visualServer = n, this.viewport = s, ch = s, this.panes = [];
  }
  /**
   * @param {number} index
   * @returns {Pane}
   */
  createPane(n) {
    const s = new kk(this.viewport);
    return s.layer_id = n, this.panes[n] = s, s;
  }
  /**
   * @param {number} index
   */
  destroyPane(n) {
    this.panes[n] && (this.panes[n] = null);
  }
  /**
   * @param {number} w
   * @param {number} h
   */
  setSize(n, s) {
    Vk.identity().scale(2 / n, -2 / s).translate(-1, 1);
  }
  /**
   * Clear all exising panes
   */
  clearPanes() {
    for (const n of this.panes)
      n.clear();
  }
  /**
   * Clear the whole overlay, all panes will be freed
   */
  clear() {
    this.panes.length = 0;
  }
}
const Vk = new Ce();
function Hk(e) {
  $r.set(
    e.width * e.pixelRatio,
    e.height * e.pixelRatio
  );
  const n = Ul * e.pixelRatio * Math.max(1, e.scale);
  Al[0].set(-n, -n), Al[1].set($r.x + n, -n), Al[2].set($r.x + n, $r.y + n), Al[3].set(-n, $r.y + n), Al[4].set(-n, -n);
}
const gs = document.createElement("canvas");
let ch = null;
const Ei = gs.getContext("2d", {
  willReadFrequently: !0
}), eo = /* @__PURE__ */ new Map(), Dt = (e) => {
  if (eo.has(e))
    return eo.get(e);
  const n = {
    image: null,
    valid: !1,
    imageInfo: {
      x: 0,
      y: 0,
      w: 0,
      h: 0,
      pixelRatio: ch.pixelRatio * 5
    }
  };
  eo.set(e, n);
  const s = new Image();
  return s.src = e, s.onload = () => {
    Ei.clearRect(0, 0, gs.width, gs.height);
    const i = n.imageInfo.pixelRatio;
    gs.width = Math.max(s.width * i, 1), gs.height = Math.max(s.height * i, 1), Ei.scale(i, i), Ei.drawImage(s, 0, 0);
    const o = Ei.getImageData(0, 0, gs.width, gs.height).data, a = kt.uploadImage(o, gs.width, gs.height);
    n.image = a, n.valid = !0, n.imageInfo.x = 0, n.imageInfo.y = 0, n.imageInfo.w = gs.width, n.imageInfo.h = gs.height, n.imageInfo.pixelRatio = i, eo.set(e, n);
  }, n;
}, fE = /* @__PURE__ */ new Map(), pS = "Arial", Wk = (e, n, s, i = 400, r = "normal") => {
  const o = `${n}`;
  let a = `${pS}-${i}-${r}-${s}-${e}`, c = `${i} ${s}px ${pS}`;
  if (fE.has(o)) {
    if (fE.get(o)) {
      if (a = `${n}-${i}-${r}-${s}-${e}`, eo.has(a)) return eo.get(a);
      c = `${i} ${s}px ${n}`;
    }
  } else
    fE.set(o, !1);
  if (eo.has(a)) return eo.get(a);
  const l = {
    image: null,
    valid: !1,
    imageInfo: {
      x: 0,
      y: 0,
      w: 0,
      h: 0,
      pixelRatio: ch.pixelRatio * 5
    }
  };
  eo.set(a, l);
  const h = l.imageInfo.pixelRatio;
  Ei.font = c;
  const d = Ei.measureText(`${e}`);
  return gs.width = Math.max(d.width * h, 1), gs.height = Math.max((d.fontBoundingBoxAscent + d.fontBoundingBoxDescent) * h, 1), Ei.clearRect(0, 0, gs.width, gs.height), Ei.font = c, Ei.textBaseline = "top", Ei.fillStyle = "#ffffff", Ei.globalAlpha = 1, Ei.scale(h, h), Ei.fillText(e, 0, 0), l.imageInfo.x = 0, l.imageInfo.y = 0, l.imageInfo.w = gs.width, l.imageInfo.h = gs.height, l;
}, Yk = /* @__PURE__ */ new Set([
  Ie.GRADIENT_LINEAR,
  Ie.GRADIENT_RADIAL,
  Ie.GRADIENT_ANGULAR,
  Ie.GRADIENT_DIAMOND
]);
let Xr = null, vs = null, SC = -1;
function Xk(e, n) {
  const { dataStore: s, viewport: i, snapping: r } = e, o = s.editor, a = (p) => {
    if (p.layerProps.size) {
      for (const E of p.layerProps.keys())
        if (p.layerProps.get(E).has("paintType")) {
          c();
          return;
        }
    }
  }, c = () => {
    o && Xr && Yk.has(o.getLayerProp(Xr, "paintType")) ? (vs = new zk(o, Xr), KS(vs), s.eam.activateEditGradient()) : (KS(null), s.setFeature("editGradient", !1));
  }, l = (p, E) => {
    p !== Xr && (Xr && (Xr = null), p && (Xr = p), c());
  };
  o.on(Oe.EDITOR_CHANGES, a), s.selection.on("focusedLayer", l), s.on("mode", () => {
    Xr && (s.eam.activateElementEditMode(), Xr = null);
  }), s.selection.on("activeGradientStopIdx", (p) => {
    SC = p;
  });
  let h;
  s.eam.on(Y.HOVER_GRADIENT_HANDLE, (p) => {
    const E = e.selection.first;
    let g, T;
    if (E.element.get("elementType") === Me.PATH && E.element.get("geometryType") === mn.LINE) {
      const { x: O, y: S, width: y, height: v } = E.node.boundsVisualLocal;
      g = new N(y, v), T = new N(-O, -S);
    } else {
      const { width: O, height: S } = E.node.boundsLocal;
      g = new N(O, S), T = m0(E);
    }
    const m = new Ce(...vs.getGradientTransform()).affine_inverse().scale(g.x, g.y).translate(-T.x, -T.y).prepend(E.node.item.transform.world).prepend(i.projectionTransform);
    if (h = vs.searchHandle(p.mousePos, m, i.scale), p.handled = !1, n("default"), h)
      switch (h.type) {
        case kn.STOP:
          n("default"), s.eam.changeHover(Gt.GRADIENT_STOP_HANDLE);
          break;
        case kn.GRADIENT:
          n("crossMove"), s.eam.changeHover(Gt.GRADIENT_TRANSFORM_START_HANDLE);
          break;
        case kn.HANDLE:
          n("crossMove"), s.eam.changeHover(Gt.GRADIENT_TRANSFORM_END_HANDLE);
          break;
        case kn.ASPECT_RATIO:
          n("crossMove"), s.eam.changeHover(Gt.GRADIENT_TRANSFORM_SHAPE_HANDLE);
          break;
        case kn.REFERENCE:
          n("add"), s.eam.changeHover(Gt.GRADIENT_TRANSFORM_REFERENCE_LINE);
          break;
      }
  });
  let d = null;
  s.eam.on(Y.SELECT_GRADIENT_HANDLE, (p) => {
    h && h.type !== kn.REFERENCE ? h.type === kn.STOP && (s.eam.setActiveGradientStop(h.idx), s.editor.setLayerProps(
      vs.layerItemId,
      {
        gradientStops: vs.getGradientStops(),
        activeGradientStopIdx: h.idx
      }
    )) : p.handled = !1;
  }), s.eam.on(Y.START_DRAG_GRADIENT_HANDLE, (p, E, { snapToGrid: g = !0 }) => {
    if (h && h.type !== kn.REFERENCE) {
      const T = e.selection.first;
      if (!T)
        return;
      d = Kk(h, vs, T, p.mousePos, i, r);
    } else
      p.handled = !1;
  }).on(Y.UPDATE_DRAG_GRADIENT_HANDLE, (p, E) => {
    d(p.mousePos, E);
  }).on(Y.END_DRAG_GRADIENT_HANDLE, () => {
    d = null, r.setEndSnapping(), s.commitUndo();
  }), s.eam.on(Y.MOVE_GRADIENT_HANDLE_KEY, (p) => {
    const E = vs.getGradientStops().map((g, T) => T === vs.activeGradientStopIdx ? { ...g, position: rP(g.position + p / 100, 0, 1) } : g);
    s.editor.setLayerProps(
      vs.layerItemId,
      { gradientStops: E }
    );
  }), s.eam.on(Y.ADD_NEW_GRADIENT_STOP, () => {
    const p = vs.getGradientStops();
    if (p.length >= 32)
      return;
    const E = HP(
      p,
      vs.activeGradientStopIdx,
      h.pos
    ), g = [
      ...p,
      { color: E, position: h.pos }
    ];
    vs.setGradientStops(g), vs.setLayerProp("activeGradientStopIdx", p.length);
  });
}
const tn = new N(), yC = new N(0, 0.5), CC = new N(0.5, 0.5), NC = new N(1, 0.5), xC = new N(0.5, 1), dc = new ye();
class zk {
  /**
   * @param {Editor} editor
   * @param {string} layerItemId
   */
  constructor(n, s) {
    this._editor = n, this._layerItemId = s;
    const i = n.getLayerProp(s, "paintType");
    this.isLinear = i === Ie.GRADIENT_LINEAR, this.isAngular = i === Ie.GRADIENT_ANGULAR, this.center = this.isLinear ? yC : CC, this.bottom = NC, this.left = xC, this.handleSize = 10, this.stopSize = 12, this.activeStopSize = 16, this.referenceSize = 2, this.stopOutlineSize = 1.5, this.activeStopOutlineSize = 2, this.enlargeHitSize = 3, this.stopHitSize = this.stopSize / 2 + this.stopOutlineSize, this.activeStopHitSize = this.activeStopSize / 2 + this.activeStopOutlineSize, this.handleHitSize = this.handleSize;
  }
  get layerItemId() {
    return this._layerItemId;
  }
  get activeGradientStopIdx() {
    return this._editor.getLayerProp(this._layerItemId, "activeGradientStopIdx");
  }
  setLayerProp(n, s, i) {
    this._editor.setLayerProp(this._layerItemId, n, s, i);
  }
  // TODO: @nicktgn make color stops pooled
  /**
   * @returns {ColorStop[]} Sorted copy of gradient stops
   */
  getGradientStops() {
    return this._editor.getLayerProp(this._layerItemId, "gradientStops", !0);
  }
  setGradientStops(n) {
    this.setLayerProp("gradientStops", n, On);
  }
  getGradientTransform() {
    return this._editor.getLayerProp(this._layerItemId, "gradientTransform");
  }
  setGradientTransform(n) {
    const s = n instanceof Ce ? new Ys().copy(n) : n;
    this.setLayerProp("gradientTransform", s, On);
  }
  /**
   * @param {number} position
   * @param {Vector2} out
   */
  getColorStopPos(n, s) {
    if (this.isAngular) {
      const i = n * V1;
      s.set(Math.cos(i), Math.sin(i)).add(1, 1).scale(0.5);
    } else
      s.copy(this.center).linear_interpolate(this.bottom, n);
  }
  /**
   * @param {Vector2} mousePos
   * @param {Transform2D} transform
   * @param {number} zoom
   * @returns {Handle}
   */
  searchHandle(n, s, i) {
    const r = this.getGradientStops();
    for (let c = 0; c < r.length; c++) {
      const l = r[c];
      this.getColorStopPos(l.position, tn), s.xform(tn, tn);
      const h = c === SC ? this.activeStopHitSize : this.stopHitSize;
      if (gF(n.x, n.y, tn.x, tn.y + h / 2, h)) {
        const d = n.clone().sub(tn);
        return {
          type: kn.STOP,
          idx: c,
          stop: l,
          stops: r,
          offset: d
        };
      }
    }
    const o = this.handleHitSize, a = this.handleHitSize * 2;
    if (s.xform(this.bottom, tn), dc.set(tn.x - o, tn.y - o * 3 / 4, a, a), dc.contains(n.x, n.y)) {
      const c = n.clone().sub(tn);
      return {
        type: kn.HANDLE,
        pivot: this.center,
        pos: this.bottom,
        offset: c
      };
    }
    if (s.xform(this.left, tn), dc.set(tn.x - o, tn.y - o / 2, a, a), !this.isLinear && dc.contains(n.x, n.y)) {
      const c = n.clone().sub(tn);
      return {
        type: kn.ASPECT_RATIO,
        offset: c
      };
    }
    if (s.xform(this.center, tn), dc.set(tn.x - o, tn.y - o * 3 / 4, a, a), dc.contains(n.x, n.y))
      if (this.isLinear) {
        const c = n.clone().sub(tn);
        return {
          type: kn.HANDLE,
          pivot: this.bottom,
          pos: this.center,
          offset: c
        };
      } else
        return {
          type: kn.GRADIENT
        };
    if (this.isAngular) {
      const c = s.xform(this.center), l = s.xform(this.left).sub(c), h = s.xform(this.bottom).sub(c), d = n.clone().sub(c), { dis: p, per: E } = pF(d, l, h, c, new Ce());
      if (p < (this.enlargeHitSize + this.referenceSize / 2) / i)
        return {
          type: kn.REFERENCE,
          pos: E
        };
    } else {
      s.xform(this.center, tn);
      const c = tn.clone();
      s.xform(this.bottom, tn);
      const l = tn.clone();
      if (zy(n.x, n.y, c.x, c.y, l.x, l.y) < this.enlargeHitSize) {
        Ky(n.x, n.y, c.x, c.y, l.x, l.y, tn);
        const d = ju(c.x, c.y, tn.x, tn.y), p = ju(l.x, l.y, tn.x, tn.y), E = ju(c.x, c.y, l.x, l.y);
        if (d < E && p < E) {
          const g = Ra(0, 1, d / E);
          return {
            type: kn.REFERENCE,
            pos: g
          };
        }
      }
    }
    return null;
  }
}
const Bc = new Ce(), Og = new N(), vC = new N(), lh = new Ce(), Gl = new Ce(), RC = new N();
function Kk(e, n, s, i, r, o) {
  const { node: a, element: c } = s, l = c.get("elementType") === Me.PATH && c.get("geometryType") === mn.LINE;
  let h, d;
  if (l) {
    const { x: p, y: E, width: g, height: T } = a.boundsVisualLocal;
    d = new N(g, T), h = new N(-p, -E);
  } else {
    const { width: p, height: E } = a.boundsLocal;
    d = new N(p, E), h = m0(s);
  }
  switch (Bc.copy(n.getGradientTransform()), lh.copy(r.invProjectionTransform).prepend(a.item.transform.worldInv).translate(h.x, h.y).scale(1 / d.x, 1 / d.y).prepend(Bc), e.type) {
    case kn.STOP:
      return (p) => Qk(p, n, e);
    case kn.HANDLE: {
      Gl.set(...vs.getGradientTransform()).affine_inverse().scale(d.x, d.y).prepend(a.item.transform.world).prepend(r.projectionTransform);
      const p = r.toWorld(Gl.xform(n.center.clone())).round();
      return o.setSnappingOriginalPos(p), (E, g, T = !0) => Zk(E, n, e, h, d.x, d.y, s, r, o, g, T);
    }
    case kn.GRADIENT: {
      Gl.set(...vs.getGradientTransform()).affine_inverse().scale(d.x, d.y).prepend(a.item.transform.world).prepend(r.projectionTransform);
      const p = r.toWorld(Gl.xform(n.center.clone())), E = p.clone().round(), g = r.toScreen(E), T = r.toScreen(p);
      RC.copy(g.sub(T)), o.setSnappingOriginalPos(E);
      const A = r.toWorld(i).round(), m = r.toScreen(A).round();
      return Og.copy(A), lh.xform(m, vC), (O, S, y = !0) => qk(O, n, r, o, S, y);
    }
    case kn.ASPECT_RATIO:
      return (p) => jk(p, n, e);
  }
}
const A0 = (e, n) => {
  n.offset && e.sub(n.offset);
}, Qk = (e, n, s) => {
  A0(e, s);
  const i = n.bottom.clone().sub(n.center), r = lh.xform(e).sub(n.center);
  n.isAngular ? s.stop.position = i.angle_to_2(r) / V1 : s.stop.position = Ss.clamp(r.divide(i).x, 0, 1), n.setGradientStops(s.stops);
}, Zk = (e, n, s, i, r, o, a, c, l, h, d) => {
  const { node: p } = a, E = new Ce(r, 0, 0, o);
  E.translate(-i.x, -i.y);
  const g = Bc.clone().affine_inverse().prepend(E), T = c.invProjectionTransform.clone().prepend(p.item.transform.worldInv);
  A0(e, s);
  const A = g.xform(s.pivot);
  if (n.isLinear) {
    const M = p.item.transform.world.xform(A);
    l.setSnappingOriginalPos(M);
  }
  const m = g.xform(s.pos).sub(A), O = T.xform(e).sub(A);
  if (d) {
    const M = c.toWorld(Gl.xform(s.pivot)), P = M.clone().round().clone().sub(M);
    O.round().add(P);
    const k = O.clone();
    if (h.shift) {
      k.add(A), p.item.transform.world.xform(k, k);
      const b = p.item.transform.world.xform(A);
      k.sub(b);
    }
    const Q = l.snapAxisAndDiagonal(k, h.shift, "POINT");
    O.copy(Q);
  }
  const S = O.angle_to(m), y = m.length() / O.length(), v = E.translate(-A.x, -A.y), R = new Ce().prepend(v).rotate(S).scale(y, y).prepend(v.affine_inverse());
  n.setGradientTransform(R.prepend(Bc));
}, qk = (e, n, s, i, r, o) => {
  const a = o ? s.toWorld(e).round() : s.toWorld(e), c = a.clone().sub(Og), l = i.snapAxisAndDiagonal(c, r.shift, "POINT");
  a.copy(Og).add(l);
  const h = o ? s.toScreen(a).round().add(RC) : s.toScreen(a), d = lh.xform(h), p = vC.clone().sub(d), E = new Ce().set_origin(p);
  n.setGradientTransform(E.append(Bc));
}, jk = (e, n, s) => {
  A0(e, s);
  const i = lh.xform(e), r = (n.left.y - n.center.y) / (i.y - n.center.y), o = new Ce().translate(-n.center.x, -n.center.y).scale(1, r).translate(n.center.x, n.center.y);
  n.setGradientTransform(o.append(Bc));
}, m0 = ({ element: e, node: n }) => {
  const s = e.get("referencePoint");
  return n.item.isComputedGroup() ? s : new N(0, 0);
};
Te.LINEAR;
const Jk = {
  x: "translateX",
  y: "translateY",
  translateX: "x",
  translateY: "y"
};
new Set(Object.keys(Jk));
const $k = {
  [Te.STEP_START]: [
    [0, 0, 1],
    [0, 1, 1]
  ],
  [Te.STEP_MIDDLE]: [
    [0, 0.5, 0],
    [0.5, 1, 1]
  ],
  [Te.STEP_END]: [
    [0, 1, 0],
    [1, 1, 1]
  ]
};
Te.LINEAR + "", Te.EASE_IN + "", Te.EASE_OUT + "", Te.EASE_IN_OUT + "", Te.EASE_IN_BACK + "", Te.EASE_OUT_BACK + "", Te.EASE_IN_OUT_BACK + "", Te.HOP_IN + "", Te.HOP_OUT + "", Te.HOP_IN_OUT + "";
Te.STEP_END + "", $k[Te.STEP_END];
class eB extends Array {
  /**
   * @param {bool} init  set to true to initialize KF with default objects
   */
  constructor() {
    super(2), this[0] = null, this[1] = null;
  }
  get start() {
    return this[0];
  }
  get end() {
    return this[1];
  }
  get isEmpty() {
    return !this[0] && !this[1];
  }
  /**
   * Update interval assinging input KeyFrame objects to start and end
   * @param {KeyFrameData} start
   * @param {KeyFrameData} end
   * @returns {Interval} self
   */
  update(n, s) {
    return this[0] = n, this[1] = s, this;
  }
  /**
   * Copy the interval values from another interval
   * @param {Inteval} interval input interval
   * @param {bool} [copyKFs=false]    set to true if need to make a copy of KFs from input interval
   * @returns {Interval} self
   */
  copy(n, s = !1) {
    return this[0] = s ? this._copyKFData(n[0], this[0]) : n[0], this[1] = s ? this._copyKFData(n[1], this[1]) : n[1], this;
  }
  /**
   * Update values of the interval KFs
   * @param {any} kf1Val
   * @param {any} kf2Val
   * @returns {Interval} self
   */
  updateValues(n, s) {
    return this[0] ? this[0].value = n : this[0] = { value: n }, this[1] ? this[1].value = s : this[1] = { value: s }, this;
  }
  /**
   * Update times of the interval KFs
   * @param {any} kf1Time
   * @param {any} kf2Time
   * @returns {Interval} self
   */
  updateTimes(n, s) {
    return this[0] ? this[0].time = n : this[0] = { time: n }, this[1] ? this[1].time = s : this[1] = { time: s }, this;
  }
  /**
   * Update easingType of the interval KFs
   * @param {EasingType} easingType
   * @returns {Interval} self
   */
  updateEasingType(n) {
    return this[1] ? this[1].easingType = n : this[1] = { easingType: n }, this;
  }
  _copyKFData(n, s) {
    const i = s || {};
    return i.id = n.id, i.type = n.type, i.frameType = n.frameType, i.trackId = n.trackId, i.easingType = n.easingType, i.bezier = n.bezier, i.steps = n.steps, i.time = n.time, i.value = n.value, i.delta = n.delta, i.ref = n.ref, i.extra = n.extra ? { ...n.extra } : null, i;
  }
  clear() {
    return this[0] = null, this[1] = null, this;
  }
}
new eB();
zi.TRIM_PATH + "";
Ie.GRADIENT_LINEAR, Ie.GRADIENT_RADIAL, Ie.GRADIENT_ANGULAR, Ie.GRADIENT_DIAMOND;
xn.FADE_IN + "", xn.FADE_OUT + "", xn.MOVE_IN + "", xn.MOVE_OUT + "", xn.SCALE_IN + "", xn.SCALE_OUT + "", xn.SPIN_IN + "", xn.SPIN_OUT + "", xn.TRIM_IN + "", xn.TRIM_OUT + "";
VE.NON_EDITABLE;
const tB = /* @__PURE__ */ new Set();
function nB() {
  for (const e of tB)
    try {
      e.clear();
    } catch (n) {
      console.error("Error clearing transition manager:", n);
    }
}
const Ig = 4 * (Math.SQRT2 - 1) / 3, Do = Ig - 1;
function ki([e, n], s = 0) {
  const i = Array.isArray(s);
  let r = i ? s[0] || 0 : s, o = i ? s[1] || 0 : s, a = i ? s[2] || 0 : s, c = i ? s[3] || 0 : s;
  const l = Math.min(e, n) / 2;
  r = Ss.clamp(r, 0, l), o = Ss.clamp(o, 0, l), a = Ss.clamp(a, 0, l), c = Ss.clamp(c, 0, l);
  const h = new Vs();
  return h.commands.push(ve.M, ve.L), h.vertices.push(e, o, e, n - a), a > 0 && (h.commands.push(ve.C), h.vertices.push(
    e,
    n + a * Do,
    e + a * Do,
    n,
    e - a,
    n
  )), h.commands.push(ve.L), h.vertices.push(c, n), c > 0 && (h.commands.push(ve.C), h.vertices.push(
    -c * Do,
    n,
    0,
    n + c * Do,
    0,
    n - c
  )), h.commands.push(ve.L), h.vertices.push(0, r), r > 0 && (h.commands.push(ve.C), h.vertices.push(
    0,
    -r * Do,
    -r * Do,
    0,
    r,
    0
  )), h.commands.push(ve.L), h.vertices.push(e - o, 0), o > 0 && (h.commands.push(ve.C), h.vertices.push(
    e + o * Do,
    0,
    e,
    -o * Do,
    e,
    o
  )), h.commands.push(ve.Z), h;
}
function sB([e, n]) {
  const s = e * 0.5, i = n * 0.5, r = s * Ig, o = i * Ig, a = s - r, c = s + r, l = i - o, h = i + o;
  return new Vs([
    s,
    0,
    c,
    0,
    e,
    l,
    e,
    i,
    e,
    h,
    c,
    n,
    s,
    n,
    a,
    n,
    0,
    h,
    0,
    i,
    0,
    l,
    a,
    0,
    s,
    0
  ], [
    ve.M,
    ve.C,
    ve.C,
    ve.C,
    ve.C,
    ve.Z
  ]);
}
function iB(e, n, s, i) {
  const r = n.dot(n), o = n.dot(s) + r, a = Math.sqrt(2 * r * o) - o, c = 4 / 3 * a / n.cross(s), l = i.x + n.x - c * n.y, h = i.y + n.y + c * n.x, d = i.x + s.x + c * s.y, p = i.y + s.y - c * s.x, E = i.x + s.x, g = i.y + s.y;
  e.cubic(l, h, d, p, E, g);
}
function rB(e, n, s, i, r = !1, o = !1) {
  e.assure_vec(s);
  const a = r ? Math.PI * 2 - i : i, c = Math.ceil(2 * a / Math.PI), l = a / c, h = new N();
  h.copy(s).sub(n);
  const d = (o ? -1 : 1) * (r ? -1 : 1);
  for (let p = 0; p < c; p++) {
    const E = h, g = E.clone().rotate(l * d);
    iB(e, E, g, n), h.copy(g);
  }
}
function Sg(e, n) {
  if (n <= 0) {
    if (Object.keys(e.cornerRadiusOverrides).length === 0) return e;
    let r = !0;
    for (const o of Object.values(e.cornerRadiusOverrides))
      if (o > 0) {
        r = !1;
        break;
      }
    if (r) return e;
  }
  const s = new i0(), i = e.commands;
  e.commands = i.filter((r) => r !== ve.Z);
  for (const r of e.iter()) {
    const o = s.path.commands.length, a = s.path.vertices.length;
    if (r.first().isLast)
      s.copySubpath(r);
    else {
      const c = r.isClosed, h = (r.hasCurves ? aB : oB)(s, r, n), d = (p, E, g, T) => {
        if (g && s.start_vec(p.p0), h(p, E, g, T), !c && T)
          switch (E.cmd) {
            case ve.L:
              s.line_vec(E.p1);
              break;
            case ve.Q:
            case ve.C: {
              const A = E.bezier().project({ x: s.lastX, y: s.lastY }).t, m = 1;
              if (A !== m) {
                const O = E.bezier().split(A, m);
                s.bezier_assure_first_point(O);
              }
            }
          }
      };
      r.forEach(d), c && s.path.vertices.length >= 2 && (s.path.vertices[a] = s.lastX, s.path.vertices[a + 1] = s.lastY, s.firstX = s.lastX, s.firstY = s.lastY), s.end(c);
    }
    s.path.attachMetadata(o, "isEnd0Cap", r.isEnd0Cap), s.path.attachMetadata(o, "isEnd1Cap", r.isEnd1Cap);
  }
  return s.path.hasOpenOrNetworkSubaths = e.hasOpenOrNetworkSubaths, e.commands = i, s.path;
}
function oB(e, n, s) {
  const i = n.isClosed, r = [], o = [], a = [], c = (d, p, E, g) => {
    o.push(d.p0.distance_to(d.p1));
    const T = d.p1.clone().sub(d.p0), A = d.p1.clone().sub(p.p1), m = T.angle_to(A);
    a.push(Math.tan(Math.abs(m) / 2)), !i && g && o.push(p.p0.distance_to(p.p1));
  };
  if (n.forEach(c), !i) {
    const d = o[0] * a[0];
    r.push(d);
  }
  let l = i ? a[a.length - 1] : a[0];
  for (let d = i ? 0 : 1; d < a.length; d++) {
    const p = a[d], E = o[d] * l * p / (l + p);
    r.push(E), l = p;
  }
  if (i)
    r.push(r[0]);
  else {
    const d = o[o.length - 1] * a[a.length - 1];
    r.push(d);
  }
  for (let d = 0; d < r.length; d++)
    r[d] -= ms;
  const h = [];
  for (let d = 0; d < r.length - 1; d++)
    h.push(Math.min(r[d], r[d + 1]));
  return (d, p) => {
    const E = d.cornerRadiusOverride1 === void 0 ? s : d.cornerRadiusOverride1, g = Math.min(h.shift(), E);
    g <= 0 ? e.assure_vec(d.p1) : $u(e, d.p0, d.p1, p.p1, g);
  };
}
function ES(e, n, s, i, r, o, a, c) {
  const l = new N(e, n), h = r ? 1 : 0.5, d = s.derivative(i), p = new N(d.x, d.y).normalize();
  c && p.negate();
  const E = cB(l, p, a, o, h);
  if (E !== null) {
    const g = E.clone().sub(l), T = E.clone().sub(o.clone().scale_with_center(h, a)), A = g.angle_to(T), m = Math.tan(Math.abs(A) / 2), O = Math.min(g.length(), T.length()) * m;
    return {
      p: l,
      i: E,
      r: O,
      t: i
    };
  }
}
function aB(e, n, s) {
  const i = n.isClosed, r = [], o = (c, l, h, d) => {
    let p = c.cornerRadiusOverride1 === void 0 ? s : c.cornerRadiusOverride1;
    if (p <= 0) {
      r.push({ r: p });
      return;
    }
    if (c.isCurve && !l.isCurve) {
      const E = l.p0.distance_to(l.p1);
      p = Math.min(p, E * 0.5);
      const g = c.bezier(), T = g.getLUT(256).map((m) => {
        const O = h && !i ? 0 : 0.5;
        if (m.t >= O)
          return ES(m.x, m.y, g, m.t, d && !i, l.p1, l.p0, !1);
      }).filter((m) => !!m);
      T.reverse();
      const A = T.find((m) => m.r > p);
      A ? r.push(A) : (T.sort((m, O) => O.r - m.r), r.push(T[0]));
    }
    if (!c.isCurve && l.isCurve) {
      const E = c.p0.distance_to(c.p1) * 0.5;
      p = Math.min(p, E * 0.5);
      const g = l.bezier(), T = g.getLUT(256).map((m) => {
        const O = d && !i ? 1 : 0.5;
        if (m.t <= O)
          return ES(m.x, m.y, g, m.t, h && !i, c.p0, c.p1, !0);
      }).filter((m) => !!m), A = T.find((m) => m.r > p);
      A ? r.push(A) : (T.sort((m, O) => O.r - m.r), r.push(T[0]));
    }
    if (c.isCurve && l.isCurve && r.push({ r: 0 }), !c.isCurve && !l.isCurve) {
      const E = c.p0.distance_to(c.p1) * 0.5, g = l.p0.distance_to(l.p1) * 0.5, T = c.p1.clone().sub(c.p0), A = c.p1.clone().sub(l.p1), m = T.angle_to(A), O = Math.tan(Math.abs(m) / 2), S = Math.min(E, g) * O, y = Math.min(p, S);
      r.push({ r: y });
    }
  };
  n.forEach(o);
  let a = i && r[r.length - 1].t || 0;
  return (c, l) => {
    const h = r.shift();
    if (c.isCurve) {
      const d = a, p = h.t || 1;
      if (d !== p) {
        const E = c.bezier().split(d, p);
        e.bezier_assure_first_point(E);
      }
    }
    a = h.t || 0, h.r <= 0 ? e.assure_vec(c.p1) : !c.isCurve && !l.isCurve ? $u(e, c.p0, c.p1, l.p1, h.r) : !c.isCurve && l.isCurve ? $u(e, c.p0, h.i, h.p, h.r) : c.isCurve && !l.isCurve && $u(e, h.p, h.i, l.p1, h.r);
  };
}
function $u(e, n, s, i, r) {
  const o = n.clone().sub(s), a = i.clone().sub(s), c = o.angle_to(a), l = Math.abs(c), h = r / Math.tan(l / 2), d = o.clone().normalize().scale(h).add(s), p = n.normal(s).scale(r).scale(Math.sign(c)).add(d);
  rB(e, p, d, Math.PI - l, !1, c > 0);
}
function cB(e, n, s, i, r = 0.5) {
  const o = i.clone().sub(s), a = new N(-n.y, n.x), c = o.dot(a);
  if (Math.abs(c) < ms)
    return s.clone();
  const l = e.clone().sub(s), h = o.cross(l) / c, d = l.dot(a) / c;
  return h >= 0 && d <= r ? n.clone().scale(h).add(e) : null;
}
const Ac = ["fills", "strokes", "shadows", "innerShadows"], lB = /* @__PURE__ */ new Map([
  [Ac[0], {}],
  [Ac[1], {}],
  [Ac[2], {}],
  [Ac[3], {}]
]);
let hh = /* @__PURE__ */ Object.create(null);
const Ga = new ei();
function hB(e, n) {
  if (hh[n.id]) {
    console.warn(`already watching node ${n.id}`);
    return;
  }
  const s = new fB();
  hh[n.id] = s, s.element = e, s.node = n, s.connect();
}
const no = (e) => {
  const n = hh[e];
  if (!n) {
    console.warn(`No watcher for node ${e}`);
    return;
  }
  n.update();
};
function uB(e) {
  const n = hh[e];
  return n ? (delete hh[e], n.disconnect()) : !1;
}
function gS(e, n) {
  e.clipping = n, e.update(Z.STYLE | Z.TRANSFORM);
}
function _S(e, n) {
  e.autoOrient = n, e.update(Z.STYLE | Z.TRANSFORM);
}
function dB(e, n) {
  e.orientRotation = n, e.update(Z.STYLE | Z.TRANSFORM);
}
function TS(e, n) {
  e.setVisible(n), e.update(Z.NODE_SETTING | Z.GEOMETRY | Z.TRANSFORM);
}
function AS(e, n) {
  e.setOpacity(n), e.update(Z.NODE_SETTING);
}
function mS(e, n) {
  e.setLocked(n);
}
function OS(e, n) {
  e.fontFamily = n, e.update(Z.STYLE | Z.GEOMETRY);
}
function IS(e, n) {
  e.fontStyle = n, e.update(Z.STYLE | Z.GEOMETRY);
}
function SS(e, n) {
  e.fontWeight = n, e.update(Z.STYLE | Z.GEOMETRY);
}
function yS(e, n) {
  e.lineHeight = n, e.update(Z.GEOMETRY | Z.STYLE);
}
function CS(e, n) {
  e.letterSpacing = n, e.update(Z.GEOMETRY);
}
function NS(e, n) {
  e.fontSize = n, e.update(Z.GEOMETRY);
}
function xS(e, n) {
  e.content = n, e.update(Z.GEOMETRY);
}
function vS(e, n) {
  e.horizontalAlignment = n, e.update(Z.STYLE | Z.GEOMETRY);
}
function RS(e, n) {
  e.verticalAlignment = n, e.update(Z.STYLE | Z.GEOMETRY);
}
function wS(e, n) {
  e.resizingMode = co[n], e.update(Z.STYLE | Z.GEOMETRY);
}
function DS(e, n) {
  e.setBlendMode(n), e.update(Z.NODE_SETTING);
}
function yg(e, n, s, i) {
  const r = e.visualServer;
  switch (i.get("paintType")) {
    case Ie.IMAGE: {
      const c = i.get("imageId") || "default";
      let l = r.storage.getImageResource(c);
      if (!l) {
        l = r.storage.createImageResource(c);
        const d = r.dataStore.images.getImage(c), p = d && d.src ? d.src : ib;
        c !== "default" && (!d || !d.src) && console.warn(`Cannot find the image src. imageId: ${c}`), r.storage.loadImage(c, p);
        const E = nt();
        l.dino_image_id = E.allocImage();
      }
      l.node_ids.add(e.id);
      const h = {
        mode: i.get("imageMode") || yr.FILL
      };
      e.image(n, s, c, h, i.get("opacity"));
      break;
    }
    case Ie.GRADIENT_LINEAR:
    case Ie.GRADIENT_RADIAL:
    case Ie.GRADIENT_ANGULAR:
    case Ie.GRADIENT_DIAMOND: {
      const c = i.get("paintType");
      if (c) {
        const l = i.get("gradientStops"), h = i.get("gradientTransform"), d = new Ce();
        d.fromArray(h), e.gradient(n, s, c, l, d, i.get("opacity"));
      }
      break;
    }
    case Ie.SOLID:
    default: {
      Ga.set_with_array(i.get("color")), e.solid(n, s, Ga, i.get("opacity"));
      break;
    }
  }
  const o = i.get("visible");
  e.setLayerVisible(n, s, o);
  const a = e.type === "text" ? Z.STYLE | Z.GEOMETRY : Z.STYLE;
  e.update(a);
}
function wC(e, n, s, i) {
  Ga.set_with_array(i.get("color")), n.setInnerShadow(s, i.get("offsetX"), i.get("offsetY"), i.get("blur"), Ga), n.setInnerShadowVisible(s, i.get("visible")), n.update(Z.STYLE);
}
function DC(e, n, s, i) {
  Ga.set_with_array(i.get("color")), Ga.a *= i.get("opacity"), n.setDropShadow(s, i.get("offsetX"), i.get("offsetY"), i.get("blur"), Ga), n.setDropShadowVisible(s, i.get("visible")), n.update(Z.STYLE | Z.TRANSFORM);
}
class Fu {
  constructor() {
    this.type = null, this.geometryIndex = -1, this.itemIndex = -1, this.element = null, this.node = null, this.layer = null;
  }
  clear() {
    return this.type = null, this.geometryIndex = -1, this.itemIndex = -1, this.element = null, this.node = null, this.layer = null, !0;
  }
  /**
   * @param {object} changes
   * @param {SetterOptions} options
   */
  onChanged(n, s) {
    switch (this.type) {
      case "paint":
        yg(this.node, this.geometryIndex, this.itemIndex, this.layer);
        break;
      case "inner_shadow":
        wC(this.element, this.node, this.itemIndex, this.layer);
        break;
      case "drop_shadow":
        DC(this.element, this.node, this.itemIndex, this.layer);
        break;
    }
    Kr(this.node.visualServer, s.updateType, !1);
  }
}
class fB {
  constructor() {
    this.element = null, this.node = null, this.fills = [], this.strokes = [], this.innerShadows = [], this.shadows = [], this.trim = null, this.isWatching = !1;
  }
  clear() {
    return this.disconnect(), this.node = null, this.element = null, !0;
  }
  connect() {
    if (this.isWatching)
      return !1;
    this.isWatching = !0, this.connectModeWatcher(), this.update();
    const { element: n } = this;
    n.on("name", this.onNameChanged, this), n.on("visible", this.onVisibleChanged, this), n.on("opacity", this.onOpacityChanged, this), n.on("locked", this.onLockedChanged, this), n.on("blendMode", this.onBlendModeChanged, this), n.on("autoOrient", this.onAutoOrientChanged, this), n.on("orientRotation", this.onOrientRotationChanged, this), n.on("overflowX", this.onOverflowChanged, this), n.on("overflowY", this.onOverflowChanged, this), n.on("booleanType", this.onBooleanTypeChanged, this), n.on("maskType", this.onMaskTypeChanged, this), n.on("containerType", this.onContainerTypeChange, this), n.on("cornerRadius", this.onCornerRadiusChanged, this), n.on("fontFamily", this.onFontFamilyChange, this), n.on("fontStyle", this.onFontStyleChange, this), n.on("fontWeight", this.onFontWeightChange, this), n.on("fontSize", this.onFontSizeChange, this), n.on("letterSpacing", this.onLetterSpacingChange, this), n.on("lineHeight", this.onLineHeightChange, this), n.on("content", this.onTextContentChange, this), n.on("elementType", this.onElementTypeChange, this), n.on("horizontalAlignment", this.onHorizontalAlignmentChange, this), n.on("verticalAlignment", this.onVerticalAlignmentChange, this), n.on("resizingMode", this.onResizingModeChange, this);
    const s = n.get("computedStyle");
    return s.on(Oe.LAYER_LIST_CHANGES, this.onLayersChanged, this), n.get("type") === ks.WORKSPACE || n.get("elementType") === Me.GROUP || s.on("size", this.onBoundsResizeChanged, this), s.on("translateX", this.onTranslateXChanged, this), s.on("translateY", this.onTranslateYChanged, this), n.isComputedGroup || s.on("referencePoint", this.onReferencePointChanged, this), s.on("contentAnchor", this.onContentAnchorChanged, this), s.on("scale", this.onScaleChanged, this), s.on("skew", this.onSkewChanged, this), s.on("rotation", this.onRotationChanged, this), s.on("size", this.onSizeChanged, this), s.on(Oe.EFFECT_LIST_CHANGES, this.onEffectsChanged, this), n.dataStore.isActionMode && this._initializeBaseTransform(), !0;
  }
  update() {
    const { element: n, node: s } = this;
    TS(s, n.get("visible")), AS(s, n.get("opacity")), mS(s, n.get("locked")), DS(s, n.get("blendMode")), _S(s, n.get("autoOrient")), dB(s, n.get("orientRotation")), gS(s, n.get("overflowX")), Vd(s, n.get("cornerRadius")), n.get("elementType") === Me.TEXT && (OS(s, n.get("fontFamily")), IS(s, n.get("fontStyle")), SS(s, n.get("fontWeight")), NS(s, n.get("fontSize")), CS(s, n.get("letterSpacing")), yS(s, n.get("lineHeight")), xS(s, n.get("content")), vS(s, n.get("horizontalAlignment")), RS(s, n.get("verticalAlignment")), wS(s, n.get("resizingMode")));
    const i = n.get("computedStyle");
    this.onLayersChanged(lB, null, !0), n.get("type") === ks.WORKSPACE || n.get("elementType") === Me.GROUP ? s.bounds.setSize(null) : s.bounds.setSize(i.get("size")), s.transform.setTranslateX(i.get("translateX")), s.transform.setTranslateY(i.get("translateY")), n.isComputedGroup || s.transform.setReferencePoint(i.get("referencePoint")), s.transform.setContentAnchor(i.get("contentAnchor")), s.transform.setScale(i.get("scale")), s.setScaleFlag(i.get("scale")), s.transform.setSkew(i.get("skew")), s.transform.setRotation(i.get("rotation")), s.transform.setSize(i.get("size")), s.setSizeFlag(i.get("size")), s.update(Z.TRANSFORM), this.onEffectsChanged();
  }
  connectModeWatcher() {
    const { dataStore: n } = this.element;
    n.on("mode", this.onModeChanged, this), this.onModeChanged(n.get("mode")), n.on("state", this.onDocumentModeChanged, this), this.onDocumentModeChanged(n.get("state"));
  }
  disconnectModeWatcher() {
    this.element.dataStore.off("mode", this.onModeChanged, this), this.element.dataStore.off("state", this.onDocumentModeChanged, this);
  }
  disconnect() {
    if (!this.isWatching)
      return !1;
    const { element: n } = this;
    this.disconnectModeWatcher(), n.off("name", this.onNameChanged, this), n.off("visible", this.onVisibleChanged, this), n.off("opacity", this.onOpacityChanged, this), n.off("locked", this.onLockedChanged, this), n.off("blendMode", this.onBlendModeChanged, this), n.off("autoOrient", this.onAutoOrientChanged, this), n.off("overflowX", this.onOverflowChanged, this), n.off("overflowY", this.onOverflowChanged, this), n.off("booleanType", this.onBooleanTypeChanged, this), n.off("maskType", this.onMaskTypeChanged, this), n.off("cornerRadius", this.onCornerRadiusChanged, this), n.off("fontFamily", this.onFontFamilyChange, this), n.off("fontStyle", this.onFontWeightChange, this), n.off("fontWeight", this.onFontWeightChange, this), n.off("fontSize", this.onFontSizeChange, this), n.off("letterSpacing", this.onLetterSpacingChange, this), n.off("lineHeight", this.onLineHeightChange, this), n.off("content", this.onTextContentChange, this), n.off("elementType", this.onElementTypeChange, this), n.off("horizontalAlignment", this.onHorizontalAlignmentChange, this), n.off("verticalAlignment", this.onVerticalAlignmentChange, this), n.off("resizingMode", this.onResizingModeChange, this);
    const s = n.get("computedStyle");
    return s.off(Oe.LAYER_LIST_CHANGES, this.onLayersChanged, this), s.off("size", this.onBoundsResizeChanged, this), this.disconnectFillLayers(), this.disconnectBorderLayers(), this.disconnectShadowLayers(), this.disconnectInnerShadowLayers(), s.off("translateX", this.onTranslateXChanged, this), s.off("translateY", this.onTranslateYChanged, this), s.off("referencePoint", this.onReferencePointChanged, this), s.off("contentAnchor", this.onContentAnchorChanged, this), s.off("scale", this.onScaleChanged, this), s.off("skew", this.onSkewChanged, this), s.off("rotation", this.onRotationChanged, this), s.off("size", this.onSizeChanged, this), s.off(Oe.EFFECT_LIST_CHANGES, this.onEffectsChanged, this), this.trim && this.trim.off("CHANGES", this.onTrimChanged, this), this.isWatching = !1, !0;
  }
  disconnectFillLayers(n = !0) {
    for (const s of this.fills)
      s.layer.off(Oe.DEFAULT_CHANGES, s.onChanged, s);
    n && this.node.removeFills();
    for (const s of this.fills)
      s.clear();
    this.fills.length = 0;
  }
  disconnectBorderLayers(n = !0) {
    for (const s of this.strokes)
      s.layer.off(Oe.DEFAULT_CHANGES, s.onChanged, s);
    n && this.node.removeStrokes();
    for (const s of this.strokes)
      s.clear();
    this.strokes.length = 0;
  }
  disconnectInnerShadowLayers(n = !0) {
    for (const s of this.innerShadows)
      s.layer.off(Oe.DEFAULT_CHANGES, s.onChanged, s);
    n && this.node.removeInnerShadows();
    for (const s of this.innerShadows)
      s.clear();
    this.innerShadows.length = 0;
  }
  disconnectShadowLayers(n = !0) {
    for (const s of this.shadows)
      s.layer.off(Oe.DEFAULT_CHANGES, s.onChanged, s);
    n && this.node.removeDropShadows();
    for (const s of this.shadows)
      s.clear();
    this.shadows.length = 0;
  }
  onModeChanged(n) {
    switch (n) {
      case Rn.ACTION: {
        this._initializeBaseTransform();
        break;
      }
      case Rn.DESIGN: {
        this._resetBaseTransforms();
        break;
      }
    }
  }
  onDocumentModeChanged(n) {
    switch (n) {
      case si.PROTOTYPING: {
        this._initializeBaseTransform();
        break;
      }
    }
  }
  _initializeBaseTransform() {
    const n = this.node.baseTransform;
    n.disconnectRef();
    let s = this.element.getBaseProp("translate");
    n.setTranslate(s), s.on(Oe.DEFAULT_CHANGES, this.onBaseTransitChanged, this), s = this.element.getBaseProp("dimensions"), n.setSize(s), s.on(Oe.DEFAULT_CHANGES, this.onBaseSizeChanged, this), s = this.element.getBaseProp("rotation"), n.setRotation(s), s.on(Oe.DEFAULT_CHANGES, this.onBaseRotationChanged, this), s = this.element.getBaseProp("scale"), n.setScale(s), s.on(Oe.DEFAULT_CHANGES, this.onBaseScaleChanged, this), s = this.element.getBaseProp("skew"), n.setSkew(s), s.on(Oe.DEFAULT_CHANGES, this.onBaseSkewChanged, this), this.element.isComputedGroup || (s = this.element.getBaseProp("referencePoint"), n.setReferencePoint(s), s.on(Oe.DEFAULT_CHANGES, this.onBaseReferencePointChanged, this)), s = this.element.getBaseProp("contentAnchor"), n.setContentAnchor(s), s.on(Oe.DEFAULT_CHANGES, this.onBaseContentAnchorChanged, this), this.node.update(Z.TRANSFORM);
  }
  _resetBaseTransforms() {
    this.node.baseTransform.connectRef(this.node.transform);
    let n = this.element.getBaseProp("translate");
    n && n.off(Oe.DEFAULT_CHANGES, this.onBaseTransitChanged, this), n = this.element.getBaseProp("dimensions"), n && n.off(Oe.DEFAULT_CHANGES, this.onBaseSizeChanged, this), n = this.element.getBaseProp("rotation"), n && n.off(Oe.DEFAULT_CHANGES, this.onBaseRotationChanged, this), n = this.element.getBaseProp("scale"), n && n.off(Oe.DEFAULT_CHANGES, this.onBaseScaleChanged, this), n = this.element.getBaseProp("skew"), n && n.off(Oe.DEFAULT_CHANGES, this.onBaseSkewChanged, this), n = this.element.getBaseProp("referencePoint"), n && n.off(Oe.DEFAULT_CHANGES, this.onBaseReferencePointChanged, this), n = this.element.getBaseProp("contentAnchor"), n && n.off(Oe.DEFAULT_CHANGES, this.onBaseContentAnchorChanged, this), this.node.update(Z.TRANSFORM);
  }
  /**
   * @param {PropChange} changes
   */
  onBaseTransitChanged(n) {
    const s = {};
    let i = n.get("translateX");
    i && (s.translateX = i.after), i = n.get("translateY"), i && (s.translateY = i.after), this.node.baseTransform.setTranslate(s), this.node.update(Z.TRANSFORM);
  }
  /**
   * @param {PropChange} changes
   */
  onBaseRotationChanged(n) {
    const s = {}, i = n.get("rotation");
    i && (s.rotation = i.after), this.node.baseTransform.setRotation(s), this.node.update(Z.TRANSFORM);
  }
  /**
   * @param {PropChange} changes
   */
  onBaseSizeChanged(n) {
    const s = {};
    let i = n.get("width");
    i && (s.width = i.after), i = n.get("height"), i && (s.height = i.after), this.node.baseTransform.setSize(s), this.node.update(Z.TRANSFORM | Z.GEOMETRY);
  }
  /**
   * @param {PropChange} changes
   */
  onBaseScaleChanged(n) {
    const s = {};
    let i = n.get("scaleX");
    i && (s.scaleX = i.after), i = n.get("scaleY"), i && (s.scaleY = i.after), this.node.baseTransform.setScale(s), this.node.update(Z.TRANSFORM);
  }
  /**
   * @param {PropChange} changes
   */
  onBaseSkewChanged(n) {
    const s = {};
    let i = n.get("skewX");
    i && (s.skewX = i.after), i = n.get("skewY"), i && (s.skewY = i.after), this.node.baseTransform.setSkew(s), this.node.update(Z.TRANSFORM);
  }
  /**
   * @param {PropChange} changes
   */
  onBaseReferencePointChanged(n) {
    const s = {};
    let i = n.get("referencePointX");
    i && (s.referencePointX = i.after), i = n.get("referencePointY"), i && (s.referencePointY = i.after), this.node.baseTransform.setReferencePoint(s), this.node.update(Z.TRANSFORM);
  }
  /**
   * @param {PropChange} changes
   */
  onBaseContentAnchorChanged(n) {
    const s = {};
    let i = n.get("contentAnchorX");
    i && (s.contentAnchorX = i.after), i = n.get("contentAnchorY"), i && (s.contentAnchorY = i.after), this.node.baseTransform.setContentAnchor(s), this.node.update(Z.TRANSFORM);
  }
  /**
   * @param {number} value
   * @param {number} original
   * @param {SetterOptions} options
   */
  onTranslateXChanged(n, s, i) {
    this.node.transform.setTranslateX(n), this.node.update(Z.TRANSFORM), Kr(this.node.visualServer, i.updateType, !0);
  }
  /**
   * @param {number} value
   * @param {number} original
   * @param {SetterOptions} options
   */
  onTranslateYChanged(n, s, i) {
    this.node.transform.setTranslateY(n), this.node.update(Z.TRANSFORM), Kr(this.node.visualServer, i.updateType, !0);
  }
  /**
   * @param {Vector2Like} value
   * @param {Vector2Like} original
   * @param {SetterOptions} options
   */
  onReferencePointChanged(n, s, i) {
    this.node.transform.setReferencePoint(n), this.node.update(Z.TRANSFORM), Kr(this.node.visualServer, i.updateType, !0);
  }
  /**
   * @param {Vector2Like} value
   * @param {Vector2Like} original
   * @param {SetterOptions} options
   */
  onContentAnchorChanged(n, s, i) {
    this.node.transform.setContentAnchor(n), this.node.update(Z.TRANSFORM), Kr(this.node.visualServer, i.updateType, !0);
  }
  /**
   * @param {Vector2} value
   * @param {Vector2} original
   * @param {SetterOptions} options
   */
  onScaleChanged(n, s, i) {
    this.node.transform.setScale(n), this.node.transform.update(), this.node.setScaleFlag(n), this.node.update(Z.TRANSFORM), Kr(this.node.visualServer, i.updateType, !0);
  }
  /**
   * @param {Vector2} value
   * @param {Vector2} original
   * @param {SetterOptions} options
   */
  onSkewChanged(n, s, i) {
    this.node.transform.setSkew(n), this.node.transform.update(), this.node.update(Z.TRANSFORM), Kr(this.node.visualServer, i.updateType, !0);
  }
  /**
   * @param {number} value
   * @param {number} original
   * @param {SetterOptions} options
   */
  onRotationChanged(n, s, i) {
    const r = this.node.visualServer.dataStore.isAnimationMode && this.node.autoOrient ? n + this.node.orientRotation : n;
    this.node.transform.setRotation(r), this.node.transform.update(), this.node.update(Z.TRANSFORM), Kr(this.node.visualServer, i.updateType, !0);
  }
  /**
   * @param {Vector2} value
   * @param {Vector2} original
   * @param {SetterOptions} options
   */
  onSizeChanged(n, s, i) {
    this.node.transform.setSize(n), this.node.setSizeFlag(n), this.node.update(Z.TRANSFORM), Kr(this.node.visualServer, i.updateType, !0);
  }
  onEffectsChanged() {
    const { element: n, node: s } = this, i = n.get("computedStyle");
    let r = !1;
    for (const o of i.effects)
      o.get("effectType") === zi.TRIM_PATH && (this.trim && this.trim !== o && this.trim.off("CHANGES", this.onTrimChanged, this), this.trim = o, this.trim.on("CHANGES", this.onTrimChanged, this), this.onTrimChanged(), r = !0);
    r || (this.trim && this.trim.off("CHANGES", this.onTrimChanged, this), s.setTrimPath(0, 0, 1, ar.SIMULTANEOUSLY));
  }
  onTrimChanged() {
    const { node: n, trim: s } = this;
    n.setTrimPath(
      s.get("offset") * 0.01,
      s.get("start") * 0.01,
      s.get("end") * 0.01,
      s.get("mode")
    );
  }
  /**
   * @param {Vector2} value
   */
  onBoundsResizeChanged(n) {
    this.node.bounds.setSize(n), this.node.update(Z.TRANSFORM);
  }
  /**
   * @param {string} name
   */
  onNameChanged(n) {
    this.node.name = n;
  }
  /**
   * @param {boolean} visible
   */
  onVisibleChanged(n) {
    TS(this.node, n);
  }
  /**
   * @param {number} opacity
   */
  onOpacityChanged(n) {
    AS(this.node, n);
  }
  /**
   * @param {number} locked
   */
  onLockedChanged(n) {
    mS(this.node, n);
  }
  /**
   * @param {BlendMode} blendMode
   */
  onBlendModeChanged(n) {
    DS(this.node, n);
  }
  /**
   *
   * @param {Map<string, any>} changes
   * @param {*} _     options event was fired with
   * @param {bool} donotUpdate  extra parameter to not update existing render items & controllers
   */
  onLayersChanged(n, s, i = !1) {
    if (!n.size) return;
    const { element: r, node: o } = this, a = o.visualServer.storage, c = r.get("computedStyle"), l = [];
    for (let h = 0; h < Ac.length; h++) {
      const d = Ac[h];
      n.get(d) && l.push(d);
    }
    for (let h = 0; h < l.length; h++)
      switch (l[h]) {
        case "fills":
          {
            this.disconnectFillLayers(!i);
            let d = 0;
            for (const p of c.fills) {
              o.base && (o.base.vector.setDataType("FILL"), yg(o, -1, d, p));
              const E = new Fu();
              E.type = "paint", E.geometryIndex = -1, E.itemIndex = d, E.element = r, E.node = o, E.layer = p, p.on(Oe.DEFAULT_CHANGES, E.onChanged, E), this.fills.push(E), d += 1;
            }
          }
          break;
        case "strokes":
          {
            this.disconnectBorderLayers(!i);
            let d = 0;
            for (const p of c.strokes) {
              EB(a, o, d, p), o.strokes[d] && (o.strokes[d].vector.setDataType("STROKE"), yg(o, d, d, p));
              const E = new Fu();
              E.type = "paint", E.geometryIndex = d, E.itemIndex = d, E.element = r, E.node = o, E.layer = p, p.on(Oe.DEFAULT_CHANGES, E.onChanged, E), this.strokes.push(E), d++;
            }
          }
          break;
        case "innerShadows":
          {
            this.disconnectInnerShadowLayers(!i);
            let d = 0;
            for (const p of c.innerShadows) {
              o.base && wC(r, o, d, p);
              const E = new Fu();
              E.type = "inner_shadow", E.geometryIndex = -1, E.itemIndex = d, E.element = r, E.node = o, E.layer = p, p.on(Oe.DEFAULT_CHANGES, E.onChanged, E), this.innerShadows.push(E), d += 1;
            }
          }
          break;
        case "shadows":
          {
            this.disconnectShadowLayers(!i);
            let d = 0;
            for (const p of c.shadows) {
              o.base && DC(r, o, d, p);
              const E = new Fu();
              E.type = "drop_shadow", E.geometryIndex = -1, E.itemIndex = d, E.element = r, E.node = o, E.layer = p, p.on(Oe.DEFAULT_CHANGES, E.onChanged, E), this.shadows.push(E), d += 1;
            }
          }
          break;
      }
  }
  onOverflowChanged(n) {
    this.node.clipping !== n && gS(this.node, n);
  }
  onAutoOrientChanged(n) {
    if (this.node.autoOrient !== n && (_S(this.node, n), this.node.visualServer.dataStore.isAnimationMode)) {
      const s = this.node.autoOrient ? this.node.transform.rotation + this.node.orientRotation : this.node.transform.rotation - this.node.orientRotation;
      this.node.transform.setRotation(s), this.node.transform.update(), this.node.update(Z.TRANSFORM);
    }
  }
  onOrientRotationChanged(n) {
    if (this.node.visualServer.dataStore.isAnimationMode) {
      const s = this.node.autoOrient ? this.node.transform.rotation - this.node.orientRotation + n : this.node.transform.rotation;
      this.node.transform.setRotation(s), this.node.transform.update(), this.node.update(Z.TRANSFORM);
    } else
      this.node.transform.setRotation(this.node.baseTransform.rotation), this.node.transform.update(), this.node.update(Z.TRANSFORM);
    this.node.orientRotation = n;
  }
  onBooleanTypeChanged(n) {
    this.node.booleanType !== n && (this.node.booleanType = n, this.node.update(Z.STYLE | Z.TRANSFORM | Z.GEOMETRY));
  }
  onMaskTypeChanged(n) {
    this.node.maskType !== n && (this.node.maskType = n, this.node.update(Z.STYLE));
  }
  /**
   * @param {number | number[]} value
   */
  onCornerRadiusChanged(n) {
    Vd(this.node, n);
  }
  onContainerTypeChange(n) {
    const s = n === kE.NORMAL_GROUP ? "group" : "container";
    this.node.type !== s && (this.node.type = s, this._switchReferencePointEventRecieve(), this.node.update(Z.GEOMETRY | Z.TRANSFORM));
  }
  onElementTypeChange(n) {
    this.node.type = n === Me.TEXT ? "text" : "path", this.node.update(Z.GEOMETRY | Z.TRANSFORM);
  }
  onFontFamilyChange(n) {
    this.node.fontFamily !== n && OS(this.node, n);
  }
  onFontStyleChange(n) {
    this.node.fontStyle !== n && IS(this.node, n);
  }
  onFontWeightChange(n) {
    this.node.fontWeight !== n && SS(this.node, n);
  }
  onFontSizeChange(n) {
    this.node.fontSize !== n && NS(this.node, n);
  }
  onLetterSpacingChange(n) {
    this.node.letterSpacing !== n && CS(this.node, n);
  }
  onLineHeightChange(n) {
    this.node.lineHeight !== n && yS(this.node, n);
  }
  onTextContentChange(n) {
    this.node.textContent !== n && xS(this.node, n);
  }
  onHorizontalAlignmentChange(n) {
    this.node.horizontalAlignment !== n && vS(this.node, n);
  }
  onVerticalAlignmentChange(n) {
    this.node.verticalAlignment !== n && RS(this.node, n);
  }
  onResizingModeChange(n) {
    this.node.resizingMode !== n && wS(this.node, n);
  }
  /**
   * The new added feature - computed group can prevent referencePoint from effecting tranform matrix because there is no utilities related to the feature
   * Therefore, there is a long term goal needs QA's help to remove referencePoint. The following function will no longer exist once we achieve the goal
   */
  _switchReferencePointEventRecieve() {
    const n = this.element.get("computedStyle"), s = this.element.getBaseProp("referencePoint"), i = this.element.get("referencePoint");
    this.node.type === "group" ? (this.node.transform.setReferencePoint(new N(0, 0)), n.off("referencePoint"), s.off(Oe.DEFAULT_CHANGES, this.onBaseReferencePointChanged, this)) : (this.node.transform.setReferencePoint(i), this.node.baseTransform.setReferencePoint(s), n.on("referencePoint", this.onReferencePointChanged, this), s.on(Oe.DEFAULT_CHANGES, this.onBaseReferencePointChanged, this));
  }
}
function pB(e, n) {
  const s = n.item, i = e.get("elementType");
  if (i === Me.PATH) {
    const r = e.get("geometry"), o = () => {
      const d = e.get("size");
      if (Vd(s, e.get("cornerRadius")), n.setGeometry(ki([d[0], d[1]]), [d[0], d[1]]), ml(s.cornerRadius)) {
        const p = ki([d[0], d[1]], s.cornerRadius), E = qe.createFromPathData(p);
        E.version = -1, s.base.setShape(0, Tt.CORNER, E);
      } else s.base.mods[1] && s.base.deleteShape(Tt.CORNER);
      s.update(Z.TRANSFORM | Z.GEOMETRY), s.base.shape.version = -1;
    }, a = () => {
      const d = e.get("size");
      n.setGeometry(sB(d)), s.update(Z.TRANSFORM | Z.GEOMETRY), s.base.shape.version = -1;
    }, c = () => {
      const d = r.get("mesh");
      d.recalculateBounds();
      const p = _d(d);
      if (n.setGeometry(p), e.get("needOrient") && (s.base.shape = qe.createFromPathData(p), s.base.shape.version = -1, s.base.shape.reorient(!1), s.base.setShape(0, Tt.BASE, s.base.shape), s.update(Z.GEOMETRY)), Object.keys(p.cornerRadiusOverrides).length > 0 || ml(s.cornerRadius)) {
        const g = Sg(p, s.cornerRadius), T = qe.createFromPathData(g);
        T.version = -1, s.base.setShape(0, Tt.CORNER, T);
      } else s.base.mods[1] && s.base.deleteShape(Tt.CORNER);
      s.update(Z.TRANSFORM | Z.GEOMETRY), s.base.shape.version = -1, n.parent && n.parent.item.trim.enabled && (n.parent.item.trim.version = -1, n.parent.item.update(Z.GEOMETRY));
    }, l = () => {
      switch (e.get("geometryType")) {
        case mn.RECTANGLE: {
          e.on("size", o), e.on("cornerRadius", o), o();
          break;
        }
        case mn.ELLIPSE: {
          e.on("size", a), a();
          break;
        }
        case mn.POLYGON:
        case mn.LINE: {
          e.on("cornerRadius", c), e.on("needOrient", c), e.on(Oe.MESH_CHANGES, c), e.on(Oe.TRIGGER_VECTOR_FORCE_UPDATE, c), c();
          break;
        }
      }
    }, h = (d) => {
      d.off("size", o), d.off("cornerRadius", o), d.off("size", a), d.off("needOrient", c), d.off("cornerRadius", c), d.off(Oe.MESH_CHANGES, c), d.off(Oe.TRIGGER_VECTOR_FORCE_UPDATE, c);
    };
    e.on("geometryType", () => {
      h(e), l();
    }), l();
  } else if (i === Me.TEXT) {
    const r = e.get("geometry"), o = () => {
      const h = r.get("mesh");
      h.recalculateBounds(), Vd(s, e.get("cornerRadius"));
      const d = _d(h);
      if (n.setGeometry(d), Object.keys(d.cornerRadiusOverrides).length > 0 || ml(s.cornerRadius)) {
        const E = Sg(d, s.cornerRadius), g = qe.createFromPathData(E);
        g.version = -1, s.base.setShape(0, Tt.CORNER, g);
      } else s.base.mods[1] && s.base.deleteShape(Tt.CORNER);
      s.update(Z.TRANSFORM | Z.GEOMETRY), s.base.shape.version = -1, n.parent && n.parent.item.trim.enabled && (n.parent.item.trim.version = -1, n.parent.item.update(Z.GEOMETRY));
    }, a = () => {
      const h = e.get("size");
      n.setGeometry(ki([h[0], h[1]]), [h[0], h[1]]), s.update(Z.TRANSFORM | Z.GEOMETRY), s.base.shape.version = -1;
    }, c = () => {
      switch (e.get("geometryType")) {
        case mn.TEXT: {
          e.on("size", a), a();
          break;
        }
        case mn.POLYGON:
        case mn.LINE: {
          e.on("cornerRadius", o), e.on(Oe.MESH_CHANGES, o), e.on(Oe.TRIGGER_VECTOR_FORCE_UPDATE, o), o();
          break;
        }
      }
    }, l = (h) => {
      h.off("size", a);
    };
    e.on("geometryType", () => {
      l(e), c();
    }), e.on("size", a), a();
  } else if (i === Me.SCREEN) {
    const r = () => {
      const o = e.get("size");
      if (!s.isBooleanGroup()) {
        if (s.isMaskGroup() || e.isNormalGroup) {
          const a = ki([o[0], o[1]]), c = e.get("referencePoint");
          for (let l = 0; l < a.vertices.length; l += 2)
            a.vertices[l] -= c[0], a.vertices[l + 1] -= c[1];
          n.setGeometry(a);
        } else
          n.setGeometry(ki([o[0], o[1]]), [o[0], o[1]]);
        if (ml(s.cornerRadius)) {
          const a = ki([o[0], o[1]], s.cornerRadius), c = qe.createFromPathData(a);
          c.version = -1, s.base.setShape(0, Tt.CORNER, c);
        } else s.base.mods[1] && s.base.deleteShape(Tt.CORNER);
        s.update(Z.TRANSFORM | Z.GEOMETRY), s.base.shape.version = -1;
      }
    };
    e.on("size", r), e.on("cornerRadius", r), e.on("containerType", r), r();
  } else if (i === Me.CONTAINER) {
    const r = () => {
      const o = e.get("size"), a = e.get("cornerRadius");
      if (!s.isBooleanGroup()) {
        if (s.isMaskGroup() || e.isNormalGroup) {
          const c = ki([o[0], o[1]]), l = e.get("referencePoint");
          for (let h = 0; h < c.vertices.length; h += 2)
            c.vertices[h] -= l[0], c.vertices[h + 1] -= l[1];
          n.setGeometry(c);
        } else
          n.setGeometry(ki([o[0], o[1]]), [o[0], o[1]]);
        if (ml(a)) {
          const c = ki([o[0], o[1]], a), l = qe.createFromPathData(c);
          l.version = -1, s.base.setShape(0, Tt.CORNER, l);
        } else s.base.mods[1] && s.base.deleteShape(Tt.CORNER);
        s.update(Z.TRANSFORM | Z.GEOMETRY), s.base.shape.version = -1;
      }
    };
    e.on("size", r), e.on("cornerRadius", r), e.on("containerType", r), r();
  } else Me.GROUP;
}
function EB(e, n, s, i) {
  n.strokes[s] = new ah(`${n.id}[stroke@${s}]`);
  const r = () => {
    n.strokes[s] || (n.strokes[s] = new ah(`${n.id}[stroke@${s}]`));
    const o = gB(i), a = n.strokes[s].style;
    a.width = o.width, a.join = o.joinType;
    let c = o.capType;
    a.miterLimit = 1 / Math.sin(fF(o.miter) * 0.5), c === cn.NONE && o.ends === Ba.ROUND && (c = cn.ROUND), a.startCap = c, a.endCap = c, a.dashPattern.length = 0;
    for (let l = 0; l < o.dashes.length; l++)
      a.dashPattern.push(o.dashes[l] || 0, o.gaps[l] || 0);
    n.update(Z.GEOMETRY | Z.TRANSFORM);
  };
  i.ons("width", "growDirection", "offset", "dash", "gap", "join", "joinSize", "miter", "ends", "cap", "capSize", r), r();
}
function gB(e) {
  const { width: n, growDirection: s, offset: i, dash: r, gap: o, join: a, joinSize: c, miter: l, ends: h, cap: d, capSize: p } = e.gets("width", "growDirection", "offset", "dash", "gap", "join", "joinSize", "miter", "ends", "cap", "capSize");
  return {
    width: n,
    offset: i,
    dashes: r,
    gaps: o,
    joinType: a,
    joinSize: c,
    miter: l,
    ends: h,
    capType: d,
    capSize: p,
    growDirection: s
  };
}
function Vd(e, n) {
  e.cornerRadius = n;
}
function ml(e) {
  if (Array.isArray(e)) {
    for (const n of e)
      if (n !== 0) return !0;
  } else
    return e !== 0;
  return !1;
}
const Kr = (e, n, s = !1) => {
  switch (n) {
    case Gs.UNDO_REDO:
      e.updateUpdateLevel(
        s ? Is.UPDATE_ALL_NEED_BBOX_RECALC : Is.UPDATE_ALL
      );
      break;
    case Gs.USER_EDITING:
      e.updateUpdateLevel(
        s ? Is.UPDATE_NEED_BBOX_RECALC : Is.UPDATE
      );
      break;
  }
}, B = nt();
function _B(e, n, s) {
  n.item.name = s.get("name");
  const i = s.get("type"), r = s.get("elementType");
  n.item.booleanType = ln.NONE, i !== ks.WORKSPACE && r === Me.CONTAINER && (s.get("isMask") && (n.item.maskType = Na.ALPHA), n.item.booleanType = s.get("booleanType") || ln.NONE), n.item.type = NB(n.item, s), i === ks.ELEMENT && pB(s, n), hB(s, n.item), vH(n);
}
const uh = (e, n) => {
  const s = e.view.getOrCreateDinoTree(n.id), i = n.item.type;
  O0(i, s), n.item.type === "text" && e.view.setParent(s.text_node_id, n.id);
}, O0 = (e, n) => {
  switch (e) {
    case "screen": {
      n.root_id = B.makeNode(B.GROUP), n.fills.id = B.makeNode(B.GROUP), B.addNodeChild(n.root_id, n.fills.id), n.children.id = B.makeNode(B.GROUP), B.addNodeChild(n.root_id, n.children.id);
      break;
    }
    case "workspace":
    case "group": {
      n.root_id = B.makeNode(B.GROUP), n.children.id = B.makeNode(B.GROUP), B.addNodeChild(n.root_id, n.children.id);
      break;
    }
    case "container": {
      n.root_id = B.makeNode(B.GROUP), n.fills.id = B.makeNode(B.GROUP), B.addNodeChild(n.root_id, n.fills.id), n.strokes.id = B.makeNode(B.GROUP), B.addNodeChild(n.root_id, n.strokes.id), n.children.id = B.makeNode(B.GROUP), B.addNodeChild(n.root_id, n.children.id);
      break;
    }
    case "text": {
      n.text_node_id = B.makeNode(B.TEXT), n.text_doc_id = B.getTextDocID(n.text_node_id), n.root_id = B.makeNode(B.GROUP), n.fills.id = B.makeNode(B.GROUP), B.addNodeChild(n.root_id, n.fills.id), n.strokes.id = B.makeNode(B.GROUP), B.addNodeChild(n.root_id, n.strokes.id);
      break;
    }
    case "path": {
      n.root_id = B.makeNode(B.GROUP), n.fills.id = B.makeNode(B.GROUP), B.addNodeChild(n.root_id, n.fills.id), n.strokes.id = B.makeNode(B.GROUP), B.addNodeChild(n.root_id, n.strokes.id);
      break;
    }
    case "mask": {
      n.root_id = B.makeNode(B.GROUP), n.children.id = B.makeNode(B.GROUP), B.addNodeChild(n.root_id, n.children.id);
      break;
    }
    default:
      throw new Error(`Unknown node type: ${e}`);
  }
}, Hd = (e, n, s, i) => {
  const r = e.view.getOrCreateDinoTree(n.id), o = e.view.getOrCreateDinoTree(s.id), a = o.children.compose[1] !== null, c = B.getNodeChildCount(o.children.id) + (a ? 1 : 0);
  if (s.item.isMaskGroup())
    if (c === 0) {
      o.children.compose[1] = new Xi(), o.children.compose[1].id = r.root_id;
      const h = 2;
      o.children.compose[1].comp_id = B.makeCompose(h, o.children.compose[1].id), B.setNodeCompose(o.children.id, 1, o.children.compose[1].comp_id);
    } else
      c === i ? (B.setComposeRoot(o.children.compose[1].comp_id, r.root_id), B.insertNodeChild(o.children.id, o.children.compose[1].id, i - 1), o.children.compose[1].id = r.root_id, B.markNodeChanged(o.children.id)) : B.insertNodeChild(o.children.id, r.root_id, i);
  else
    B.insertNodeChild(o.children.id, r.root_id, i);
}, Cg = (e, n, s, i) => {
  const r = e.view.getOrCreateDinoTree(n.id), o = e.view.getOrCreateDinoTree(s.id), a = o.children.compose[1] !== null, c = B.getNodeChildCount(o.children.id) + (a ? 1 : 0);
  if (s.item.isMaskGroup()) {
    if (r.root_id === o.children.compose[1].id) {
      const d = s.getLastChild(), p = e.view.getOrCreateDinoTree(d.id);
      d.item.update(Z.GEOMETRY | Z.TRANSFORM), B.removeNode(p.root_id), B.setComposeRoot(o.children.compose[1].comp_id, p.root_id), B.insertNodeChild(o.children.id, o.children.compose[1].id, i), o.children.compose[1].id = p.root_id, B.markNodeChanged(o.root_id);
    }
    i === c - 1 ? (B.removeNode(r.root_id), B.setComposeRoot(o.children.compose[1].comp_id, r.root_id), B.insertNodeChild(o.children.id, o.children.compose[1].id, i), o.children.compose[1].id = r.root_id, B.markNodeChanged(o.root_id)) : B.reorderNode(r.root_id, i);
  } else
    B.reorderNode(r.root_id, i);
}, TB = (e, n) => {
  const s = e.view.getRootDinoTree(), i = e.view.getOrCreateDinoTree(n.id);
  B.insertNodeChild(s.children.id, i.root_id, 0);
}, Ng = (e, n, s, i) => {
  const r = e.view.getOrCreateDinoTree(n.id), o = e.view.getOrCreateDinoTree(s.id);
  if (i) {
    const a = s.getLastChild();
    if (a) {
      const c = e.view.getOrCreateDinoTree(a.id);
      a.item.update(Z.GEOMETRY | Z.TRANSFORM), B.removeNode(c.root_id), B.setComposeRoot(o.children.compose[1].comp_id, c.root_id), o.children.compose[1].id = c.root_id, B.markNodeChanged(o.children.id);
    } else
      B.setComposeRoot(o.children.compose[1].comp_id, 0);
  } else
    B.removeNode(r.root_id);
}, xg = (e, n) => {
  const s = e.view.getAndDeleteDinoTree(n.id);
  dh(s);
}, dh = (e) => {
  if (e.children.compose[0] !== null && B.destroyNodeCompose(e.children.id, 0), e.children.compose[1] !== null && B.removeNodeCompose(e.children.id, 1), e.children.compose[0] = null, e.children.compose[1] = null, e.path_id !== 0 && B.destroyPath(e.path_id), e.base_path_id !== 0 && B.destroyPath(e.base_path_id), e.text_doc_id !== 0 && B.destroyTextDoc(e.text_doc_id), e.path_id = 0, e.base_path_id = 0, e.fills.children.length > 0)
    for (let n = 0; n < e.fills.children.length; n++) {
      const s = e.fills.children[n];
      Kl(s), s.text_doc_id !== 0 && B.destroyTextDoc(s.text_doc_id), B.destroyNode(s.id), s.id = 0;
    }
  if (e.strokes.children.length > 0)
    for (let n = 0; n < e.strokes.children.length; n++) {
      const s = e.strokes.children[n];
      Ql(s), s.text_doc_id !== 0 && B.destroyTextDoc(s.text_doc_id), B.destroyNode(s.id), s.id = 0, s.stroke_data_id !== 0 && (B.destroyStroke(s.stroke_data_id), s.stroke_data_id = 0);
    }
  e.root_id !== 0 && B.destroyNode(e.root_id), e.children.id !== 0 && B.destroyNode(e.children.id), e.fills.id !== 0 && B.destroyNode(e.fills.id), e.strokes.id !== 0 && B.destroyNode(e.strokes.id), e.text_node_id !== 0 && B.destroyNode(e.text_node_id), e.root_id = 0, e.children.id = 0, e.fills.id = 0, e.strokes.id = 0;
}, AB = (e, n) => {
  const s = e.view.getOrCreateDinoTree(n.id), i = n.parent && n.parent.item.isMaskGroup() && n.parent.getLastChild().id === n.id, r = n.item.transform;
  if (i) {
    const { scale: o, skew: a, rotation: c, translation: l } = r.world.decompose();
    B.setNodeTransform(
      s.root_id,
      l.x,
      l.y,
      c,
      o.x,
      o.y,
      Rt(a.x),
      Rt(a.y)
    ), B.setNodeTransform(
      s.fills.id,
      0,
      0,
      0,
      1,
      1,
      0,
      0
    ), B.setNodeTransform(
      s.strokes.id,
      0,
      0,
      0,
      1,
      1,
      0,
      0
    ), B.setNodeTransform(
      s.children.id,
      0,
      0,
      0,
      1,
      1,
      0,
      0
    );
  } else {
    B.setNodeTransform(
      s.root_id,
      r.translate.x,
      r.translate.y,
      r.rotation,
      r.scale.x,
      r.scale.y,
      Rt(r.skew.x),
      Rt(r.skew.y)
    );
    const o = r.getPivotOffset();
    B.setNodeTransform(
      s.fills.id,
      -o.x,
      -o.y,
      0,
      1,
      1,
      0,
      0
    ), B.setNodeTransform(
      s.strokes.id,
      -o.x,
      -o.y,
      0,
      1,
      1,
      0,
      0
    ), B.setNodeTransform(
      s.children.id,
      -o.x,
      -o.y,
      0,
      1,
      1,
      0,
      0
    );
  }
  if (s.children.compose[0] !== null) {
    const { scale: o, skew: a, rotation: c, translation: l } = r.world.decompose();
    B.setNodeTransform(
      s.children.compose[0].id,
      l.x,
      l.y,
      c,
      o.x,
      o.y,
      Rt(a.x),
      Rt(a.y)
    );
  }
}, mB = (e, n) => {
  const s = n.item.fillLayers;
  for (let r = 0; r < s.length; r++)
    OB(e, n, r, s[r]);
  const i = e.view.getOrCreateDinoTree(n.id);
  for (let r = n.item.fillLayers.length; r < i.fills.children.length; r++) {
    const o = i.fills.children[r];
    Kl(o), B.destroyNode(o.id), o.id = 0;
  }
  i.fills.children.length = s.length;
}, OB = (e, n, s, i) => {
  var a, c;
  const r = e.view.getOrCreateDinoTree(n.id);
  switch (i.paint.type) {
    case Ie.SOLID: {
      const l = i.paint.params.fill_color, h = i.paint.params.opacity[0];
      if (r.fills.children[s] && r.fills.children[s].fill_id > 0 && r.fills.children[s].fill_tag === B.COLOR)
        B.setColor(r.fills.children[s].fill_id, l[0], l[1], l[2], h), B.markNodeChanged(r.fills.children[s].id);
      else {
        r.fills.children[s] ? Kl(r.fills.children[s]) : (r.fills.children[s] = new Xi(), n.item.type === "text" ? (r.fills.children[s].id = B.makeNode(B.TEXT), r.fills.children[s].text_doc_id = B.getTextDocID(r.fills.children[s].id)) : r.fills.children[s].id = B.makeNode(B.PATH), e.view.setParent(r.fills.children[s].id, n.id), B.addNodeChild(r.fills.id, r.fills.children[s].id));
        const d = B.makeColor(l[0], l[1], l[2], h);
        r.fills.children[s].fill_id = d, r.fills.children[s].fill_tag = B.COLOR, B.setNodeFillPaint(r.fills.children[s].id, B.COLOR, d);
      }
      break;
    }
    case Ie.GRADIENT_LINEAR:
    case Ie.GRADIENT_RADIAL:
    case Ie.GRADIENT_ANGULAR:
    case Ie.GRADIENT_DIAMOND: {
      const l = i.paint.gradient, h = i.paint.params.opacity[0], d = i.paint.transform, p = LC(i.paint.type);
      if (((a = r.fills.children[s]) == null ? void 0 : a.fill_id) > 0 && ((c = r.fills.children[s]) == null ? void 0 : c.fill_tag) === B.GRADIENT) {
        const g = r.fills.children[s].fill_id;
        B.setGradientMatrix(g, d), B.setGradientTag(g, p), B.setGradientStopLen(g, l.colorStops.length);
        for (let T = 0; T < l.colorStops.length; T++) {
          const A = l.colorStops[T];
          B.setGradientStop(g, T, A.pos, A.color[0], A.color[1], A.color[2], A.color[3]);
        }
        B.updateGradientPixels(g), B.setNodeFillOpacity(r.fills.children[s].id, h), B.markNodeChanged(r.fills.children[s].id);
      } else {
        r.fills.children[s] ? Kl(r.fills.children[s]) : (r.fills.children[s] = new Xi(), r.fills.children[s].id = B.makeNode(B.PATH), e.view.setParent(r.fills.children[s].id, n.id), B.addNodeChild(r.fills.id, r.fills.children[s].id));
        const g = B.makeGradient(p, d);
        r.fills.children[s].fill_id = g, r.fills.children[s].fill_tag = B.GRADIENT, B.setGradientStopLen(g, l.colorStops.length);
        for (let T = 0; T < l.colorStops.length; T++) {
          const A = l.colorStops[T];
          B.setGradientStop(g, T, A.pos, A.color[0], A.color[1], A.color[2], A.color[3]);
        }
        B.updateGradientPixels(g), B.setNodeFillPaint(r.fills.children[s].id, B.GRADIENT, g), B.setNodeFillOpacity(r.fills.children[s].id, h);
      }
      break;
    }
    case Ie.IMAGE: {
      const l = i.paint.image, h = i.paint.params.opacity[0], d = MC(i.paint.imageOptions.mode);
      if (r.fills.children[s] && r.fills.children[s].fill_id > 0 && r.fills.children[s].fill_tag === B.IMAGE) {
        const p = l.dino_image_id;
        r.fills.children[s].fill_id = p, B.setImageFillMode(p, d), B.setNodeFillPaint(r.fills.children[s].id, B.IMAGE, p), B.setNodeFillOpacity(r.fills.children[s].id, h);
      } else {
        r.fills.children[s] ? Kl(r.fills.children[s]) : (r.fills.children[s] = new Xi(), r.fills.children[s].id = B.makeNode(B.PATH), e.view.setParent(r.fills.children[s].id, n.id), B.addNodeChild(r.fills.id, r.fills.children[s].id));
        const p = l.dino_image_id;
        r.fills.children[s].fill_id = p, r.fills.children[s].fill_tag = B.IMAGE, B.setImageFillMode(p, d), B.setNodeFillPaint(r.fills.children[s].id, B.IMAGE, p), B.setNodeFillOpacity(r.fills.children[s].id, h);
      }
      break;
    }
    default:
      throw new Error(`Unsupported fill type: ${i.paint.type}`);
  }
  const o = i.visible;
  B.setNodeVisible(r.fills.children[s].id, o);
}, Kl = (e) => {
  switch (e.fill_tag) {
    case B.COLOR: {
      B.destroyColor(e.fill_id), e.fill_id = 0, e.fill_tag = 0;
      break;
    }
    case B.GRADIENT: {
      B.destroyGradient(e.fill_id), e.fill_id = 0, e.fill_tag = 0;
      break;
    }
    case B.IMAGE: {
      e.fill_id = 0, e.fill_tag = 0;
      break;
    }
  }
}, Ql = (e) => {
  switch (e.stroke_tag) {
    case B.COLOR: {
      B.destroyColor(e.stroke_id), e.stroke_id = 0, e.stroke_tag = 0;
      break;
    }
    case B.GRADIENT: {
      B.destroyGradient(e.stroke_id), e.stroke_id = 0, e.stroke_tag = 0;
      break;
    }
    case B.IMAGE: {
      e.stroke_id = 0, e.stroke_tag = 0;
      break;
    }
  }
}, IB = (e, n) => {
  const s = n.item.strokeLayers;
  for (let r = 0; r < s.length; r++)
    SB(e, n, r, s[r]);
  const i = e.view.getOrCreateDinoTree(n.id);
  for (let r = s.length; r < i.strokes.children.length; r++) {
    const o = i.strokes.children[r];
    Ql(o), B.destroyNode(o.id), o.id = 0, o.stroke_data_id !== 0 && (B.destroyStroke(o.stroke_data_id), o.stroke_data_id = 0);
  }
  i.strokes.children.length = s.length;
}, SB = (e, n, s, i) => {
  var a, c;
  const r = e.view.getOrCreateDinoTree(n.id);
  switch (i.paint.type) {
    case Ie.SOLID: {
      const l = i.paint.params.fill_color, h = i.paint.params.opacity[0];
      if (r.strokes.children[s] && r.strokes.children[s].stroke_id > 0 && r.strokes.children[s].stroke_tag === B.COLOR)
        B.setColor(r.strokes.children[s].stroke_id, l[0], l[1], l[2], h), B.markNodeChanged(r.strokes.children[s].id);
      else {
        r.strokes.children[s] ? Ql(r.strokes.children[s]) : (r.strokes.children[s] = new Xi(), n.item.type === "text" ? (r.strokes.children[s].id = B.makeNode(B.TEXT), r.strokes.children[s].text_doc_id = B.getTextDocID(r.strokes.children[s].id)) : r.strokes.children[s].id = B.makeNode(B.PATH), e.view.setParent(r.strokes.children[s].id, n.id), B.addNodeChild(r.strokes.id, r.strokes.children[s].id));
        const d = B.makeColor(l[0], l[1], l[2], h);
        r.strokes.children[s].stroke_id = d, r.strokes.children[s].stroke_tag = B.COLOR, B.setNodeStrokePaint(r.strokes.children[s].id, B.COLOR, d);
      }
      break;
    }
    case Ie.GRADIENT_LINEAR:
    case Ie.GRADIENT_RADIAL:
    case Ie.GRADIENT_ANGULAR:
    case Ie.GRADIENT_DIAMOND: {
      const l = i.paint.gradient, h = i.paint.params.opacity[0], d = i.paint.transform, p = LC(i.paint.type);
      if (((a = r.strokes.children[s]) == null ? void 0 : a.stroke_id) > 0 && ((c = r.strokes.children[s]) == null ? void 0 : c.stroke_tag) === B.GRADIENT) {
        const g = r.strokes.children[s].stroke_id;
        B.setGradientMatrix(g, d), B.setGradientTag(g, p), B.setGradientStopLen(g, l.colorStops.length);
        for (let T = 0; T < l.colorStops.length; T++) {
          const A = l.colorStops[T];
          B.setGradientStop(g, T, A.pos, A.color[0], A.color[1], A.color[2], A.color[3]);
        }
        B.updateGradientPixels(g), B.setNodeStrokeOpacity(r.strokes.children[s].id, h), B.markNodeChanged(r.strokes.children[s].id);
      } else {
        r.strokes.children[s] ? Ql(r.strokes.children[s]) : (r.strokes.children[s] = new Xi(), r.strokes.children[s].id = B.makeNode(B.PATH), e.view.setParent(r.strokes.children[s].id, n.id), B.addNodeChild(r.strokes.id, r.strokes.children[s].id));
        const g = B.makeGradient(p, d);
        r.strokes.children[s].stroke_id = g, r.strokes.children[s].stroke_tag = B.GRADIENT, B.setGradientStopLen(g, l.colorStops.length);
        for (let T = 0; T < l.colorStops.length; T++) {
          const A = l.colorStops[T];
          B.setGradientStop(g, T, A.pos, A.color[0], A.color[1], A.color[2], A.color[3]);
        }
        B.updateGradientPixels(g), B.setNodeStrokePaint(r.strokes.children[s].id, B.GRADIENT, g), B.setNodeStrokeOpacity(r.strokes.children[s].id, h);
      }
      break;
    }
    case Ie.IMAGE: {
      const l = i.paint.image, h = i.paint.params.opacity[0], d = MC(i.paint.imageOptions.mode);
      if (r.strokes.children[s] && r.strokes.children[s].stroke_id > 0 && r.strokes.children[s].stroke_tag === B.IMAGE) {
        const p = l.dino_image_id;
        r.strokes.children[s].stroke_id = p, B.setImageFillMode(p, d), B.setNodeStrokeOpacity(r.strokes.children[s].id, h), B.setNodeStrokePaint(r.strokes.children[s].id, B.IMAGE, p);
      } else {
        r.strokes.children[s] ? Ql(r.strokes.children[s]) : (r.strokes.children[s] = new Xi(), r.strokes.children[s].id = B.makeNode(B.PATH), e.view.setParent(r.strokes.children[s].id, n.id), B.addNodeChild(r.strokes.id, r.strokes.children[s].id));
        const p = l.dino_image_id;
        r.strokes.children[s].stroke_id = p, r.strokes.children[s].stroke_tag = B.IMAGE, B.setImageFillMode(p, d), B.setNodeStrokePaint(r.strokes.children[s].id, B.IMAGE, p), B.setNodeStrokeOpacity(r.strokes.children[s].id, h);
      }
      break;
    }
    default:
      throw new Error(`Unsupported stroke type: ${i.paint.type}`);
  }
  const o = i.visible;
  B.setNodeVisible(r.strokes.children[s].id, o);
}, LC = (e) => {
  switch (e) {
    case Ie.GRADIENT_LINEAR:
      return 0;
    case Ie.GRADIENT_RADIAL:
      return 1;
    case Ie.GRADIENT_ANGULAR:
      return 2;
    case Ie.GRADIENT_DIAMOND:
      return 3;
  }
  return 0;
}, MC = (e) => {
  switch (e) {
    case yr.STRETCH:
      return 0;
    case yr.FILL:
      return 1;
    case yr.FIT:
      return 2;
  }
}, yB = (e) => {
  switch (e) {
    case Ut.NORMAL:
    case Ut.PASS_THROUGH:
      return 0;
    case Ut.DARKEN:
      return 1;
    case Ut.MULTIPLY:
      return 2;
    case Ut.COLOR_BURN:
      return 3;
    case Ut.LIGHTEN:
      return 4;
    case Ut.SCREEN:
      return 5;
    case Ut.COLOR_DODGE:
      return 6;
    case Ut.OVERLAY:
      return 7;
    case Ut.SOFT_LIGHT:
      return 8;
    case Ut.HARD_LIGHT:
      return 9;
    case Ut.DIFFERENCE:
      return 10;
    case Ut.EXCLUSION:
      return 11;
    case Ut.HUE:
      return 12;
    case Ut.SATURATION:
      return 13;
    case Ut.COLOR:
      return 14;
    case Ut.LUMINOSITY:
      return 15;
  }
  return 0;
};
function CB(e) {
  let n = e.parent;
  for (; n; )
    n.item.isBooleanGroup() && n.item.update(Z.GEOMETRY), n = n.parent;
}
function NB(e, n) {
  const s = n.get("type"), i = n.get("elementType");
  if (s === ks.WORKSPACE)
    return "workspace";
  switch (i) {
    case Me.CONTAINER:
      return n.isNormalGroup ? "group" : n.isBooleanType() ? "path" : n.isMaskGroup() ? "mask" : "container";
    case Me.SCREEN:
      return "screen";
    case Me.PATH:
      return "path";
    case Me.TEXT:
      return "text";
  }
  return "group";
}
const xB = 8, Fl = nt();
class PC {
  /** @param {VisualServer} VS */
  constructor(n) {
    this.VS = n, this.rootId = null, this.nodeMap = /* @__PURE__ */ new Map(), this.dinoParentMap = /* @__PURE__ */ new Map(), this.rootDinoTree = null, this.actionSelectionChangeHandler = null;
  }
  /**
   * Set up dino trees with given root
   * @param {DataStore} dataStore
   * @param {string} rootId - ID of the root RenderItem to be displayed
   * @param {string | null} actionId - ID of the action to be displayed
   */
  setup(n, s, i = null) {
    this.cleanup();
    const r = this.VS.indexer.getNode(s);
    if (!r) {
      console.error("Root RenderItem not found:", s);
      return;
    }
    this.rootId = s, this.rootDinoTree = new Fd(), O0("group", this.rootDinoTree), Fl.addNodeToRoot(this.rootDinoTree.root_id), UC(this.VS, r);
    const o = i || n.selection.selectedActionId, a = n.transition.currentTime;
    La(this.VS, o, a), this.bindEvents();
  }
  /**
   * Refresh visual representation by reloading computed styles and applying current action state
   */
  reload() {
    const n = this.VS.dataStore.selection.selectedActionId, s = this.VS.dataStore.transition.currentTime;
    La(this.VS, n, s);
  }
  bindEvents() {
    this.actionSelectionChangeHandler = this.actionSelectionChange.bind(this), this.VS.dataStore.selection.on(Oe.SELECT, this.actionSelectionChangeHandler);
  }
  unbindEvents() {
    this.actionSelectionChangeHandler && (this.VS.dataStore.selection.off(Oe.SELECT, this.actionSelectionChangeHandler), this.actionSelectionChangeHandler = null);
  }
  /**
   * @param {SceneNode} node
   */
  createDinoNode(n) {
    uh(this.VS, n), no(n.id);
  }
  /**
   * @param {SceneNode} node
   * @param {SceneNode} parent
   * @param {boolean} originallyIsMaskElement
   */
  removeDinoNode(n, s, i) {
    Ng(this.VS, n, s, i), no(n.id);
  }
  /**
   * @param {SceneNode} node
   * @param {SceneNode} parent
   * @param {number} index
   */
  insertDinoNode(n, s, i) {
    Hd(this.VS, n, s, i), no(n.id);
  }
  /**
   * @param {SceneNode} node
   */
  destroyDinoNode(n) {
    xg(this.VS, n);
  }
  /**
   * @param {SceneNode} node
   * @param {SceneNode} parent
   * @param {number} index
   */
  reorderDinoNode(n, s, i) {
    Cg(this.VS, n, s, i), no(n.id);
  }
  update() {
  }
  updateAll() {
  }
  /**
   * Clean up resources for current default view
   */
  cleanup() {
    for (const [, n] of this.nodeMap.entries())
      dh(n);
    this.rootDinoTree !== null && (dh(this.rootDinoTree), this.rootDinoTree = null), this.rootId = null, this.dinoParentMap.clear(), this.nodeMap.clear(), this.unbindEvents();
  }
  actionSelectionChange(n) {
    const s = n.get("action");
    if (!s) return;
    const i = s.after;
    La(this.VS, i);
  }
  /**
   * Given a NodeID, return the corresponding DinoTree for current view
   * @param {NodeID} id
   * @returns {DinoTree}
   */
  getOrCreateDinoTree(n) {
    let s = this.nodeMap.get(n);
    return s || (s = new Fd(), s.id = n, this.nodeMap.set(n, s)), s;
  }
  /**
   * @param {DinoID} dinoId
   * @param {NodeID} nodeId
   */
  setParent(n, s) {
    this.dinoParentMap.set(n, s);
  }
  /**
   * @param {DinoID} dinoId
   * @returns {boolean}
   */
  hasParent(n) {
    return this.dinoParentMap.has(n);
  }
  /**
   * @param {DinoID} dinoId
   * @returns {NodeID | null}
   */
  getParent(n) {
    return this.dinoParentMap.get(n);
  }
  /**
   * @returns {DinoTree}
   */
  getRootDinoTree() {
    return this.rootDinoTree;
  }
  /**
   * @param {string} id
   * @returns {DinoTree | null}
   */
  getAndDeleteDinoTree(n) {
    const s = this.getOrCreateDinoTree(n);
    return this.nodeMap.delete(n), s;
  }
  /**
   * @returns {Vector2}
   */
  getActiveOffset() {
    return new N(0, 0);
  }
  updateBounds() {
  }
  layout() {
  }
}
class vB {
  /**
   * @param {number} row
   * @param {number} col
   */
  constructor(n, s) {
    this.row = n, this.col = s, this.actionId = null, this.actionName = null, this.originalBounds = new ye(), this.mergedBounds = new ye(), this.alignedBounds = new ye(), this.worldBounds = new ye(), this.offset = new N(), this.nodeMap = /* @__PURE__ */ new Map(), this.dinoParentMap = /* @__PURE__ */ new Map(), this.rootDinoTree = null;
  }
}
class I0 {
  /**
   * @param {VisualServer} VS
   */
  constructor(n) {
    this.VS = n, this.rootId = null, this.rows = 0, this.cols = 0, this.cells = [], this._activeCell = null, this._dirtyLayout = !1, this._lastViewOffset = null, this.offset = new N(), this.padding = 40, this.leftClickDownHandler = null, this.actionSelectionChangeHandler = null;
  }
  /**
   * Set up dino trees with given root
   * @param {DataStore} dataStore
   * @param {string} rootId - ID of the root RenderItem to be displayed
   */
  setup(n, s) {
    this.cleanup();
    const i = this.VS.indexer.getNode(s);
    if (!i) {
      console.error("Root RenderItem not found:", s);
      return;
    }
    this.rootId = s;
    const r = n.elementInteractionManager.getActionIdListByElementId(s);
    this.rows = r.length + 1, this.cols = 1;
    for (let l = 0; l < this.cols; l++) {
      this.cells[l] = [];
      for (let h = 0; h < this.rows; h++) {
        const d = new vB(h, l), p = h === 0 ? null : r[h - 1];
        d.actionId = p;
        const E = (g) => {
          const T = "Unknown", A = this.VS.dataStore.interaction.getAction(g);
          if (!A)
            return T;
          const m = this.VS.dataStore.interaction.getTrigger(A.triggerList[0]);
          if (!m)
            return T;
          const S = {
            [di.CLICK]: "Click",
            [di.DOUBLE_CLICK]: "Double Click",
            [di.HOVER]: "Hover",
            [di.PRESS]: "Press",
            [di.LONG_PRESS]: "Long Press",
            [di.KEY_PRESS]: "Key Press",
            [di.MOUSE_ENTER]: "Mouse In",
            [di.MOUSE_LEAVE]: "Mouse Out",
            [di.MOUSE_UP]: "Mouse Up",
            [di.MOUSE_DOWN]: "Mouse Down",
            [di.DRAG]: "Drag"
          }[m.triggerType] ?? T;
          return A.name || `${S}`;
        };
        d.actionName = p ? E(p) : null, this.cells[l][h] = d, this.activeCell = d, d.rootDinoTree = new Fd(), O0("group", d.rootDinoTree), Fl.addNodeToRoot(d.rootDinoTree.root_id), UC(this.VS, i);
      }
    }
    const o = n.selection.selectedActionId, a = n.transition.currentTime, c = this.getCellByActionId(o);
    this.activeCell = c, La(this.VS, c.actionId, a), this.updateAll(!0), this.bindEvents();
  }
  bindEvents() {
    this.leftClickDownHandler = this.leftClickDown.bind(this), this.actionSelectionChangeHandler = this.actionSelectionChange.bind(this), H.get(H.Events.LEFT_CLICK_DOWN).on("trigger", this.leftClickDownHandler), this.VS.dataStore.selection.on(Oe.SELECT, this.actionSelectionChangeHandler);
  }
  unbindEvents() {
    this.leftClickDownHandler && (H.get(H.Events.LEFT_CLICK_DOWN).off("trigger", this.leftClickDownHandler), this.leftClickDownHandler = null), this.actionSelectionChangeHandler && (this.VS.dataStore.selection.off(Oe.SELECT, this.actionSelectionChangeHandler), this.actionSelectionChangeHandler = null);
  }
  /**
   * Update active cell's and calculate its biggest bounds
   */
  update() {
    this.activeCell.originalBounds.copy(
      ed(this.VS, this.activeCell.actionId).worldBoundsAABB
    ), this._dirtyLayout = !0;
  }
  /**
   * Suppost to update all things silently at background
   * @param {boolean} recalculateBounds
   */
  updateAll(n = !1) {
    console.log("update all cells at background (silently)");
    const s = this.activeCell, i = this.VS.dataStore.transition.currentTime;
    for (let r = 0; r < this.cols; r++)
      for (let o = 0; o < this.rows; o++) {
        const a = this.cells[r][o];
        a !== s && (this.activeCell = a, this.VS.dataStore.set(
          "mode",
          this.activeCell.actionId === null ? Rn.DESIGN : Rn.ACTION,
          { fire: !1, undoable: !1 }
        ), La(this.VS, this.activeCell.actionId, void 0, !0), n && (this.activeCell.originalBounds.copy(
          ed(this.VS, this.activeCell.actionId).worldBoundsAABB
        ), this._dirtyLayout = !0));
      }
    this.activeCell = s, this.VS.dataStore.set(
      "mode",
      this.activeCell.actionId === null ? Rn.DESIGN : Rn.ACTION,
      { fire: !1, undoable: !1 }
    ), La(this.VS, this.activeCell.actionId, i, !0), n && (this.activeCell.originalBounds.copy(
      ed(this.VS, this.activeCell.actionId).worldBoundsAABB
    ), this._dirtyLayout = !0);
  }
  /**
   * @param {SceneNode} node
   */
  createDinoNode(n) {
    const s = this.activeCell;
    for (let i = 0; i < this.rows; i++) {
      const r = this.cells[s.col][i];
      r !== s && (this.activeCell = r, uh(this.VS, n));
    }
    this.activeCell = s, uh(this.VS, n), no(n.id);
  }
  /**
   * @param {SceneNode} node
   * @param {SceneNode} parent
   * @param {boolean} originallyIsMaskElement
   */
  removeDinoNode(n, s, i) {
    const r = this.activeCell;
    for (let o = 0; o < this.rows; o++) {
      const a = this.cells[r.col][o];
      a !== r && (this.activeCell = a, Ng(this.VS, n, s, i));
    }
    this.activeCell = r, Ng(this.VS, n, s, i), no(n.id);
  }
  /**
   * @param {SceneNode} node
   * @param {SceneNode} parent
   * @param {number} index
   */
  insertDinoNode(n, s, i) {
    const r = this.activeCell;
    for (let o = 0; o < this.rows; o++) {
      const a = this.cells[r.col][o];
      a !== r && (this.activeCell = a, Hd(this.VS, n, s, i));
    }
    this.activeCell = r, Hd(this.VS, n, s, i), no(n.id);
  }
  /**
   * @param {SceneNode} node
   */
  destroyDinoNode(n) {
    const s = this.activeCell;
    for (let i = 0; i < this.rows; i++) {
      const r = this.cells[s.col][i];
      r !== s && (this.activeCell = r, xg(this.VS, n));
    }
    this.activeCell = s, xg(this.VS, n);
  }
  /**
   * @param {SceneNode} node
   * @param {SceneNode} parent
   * @param {number} index
   */
  reorderDinoNode(n, s, i) {
    const r = this.activeCell;
    for (let o = 0; o < this.rows; o++) {
      const a = this.cells[r.col][o];
      a !== r && (this.activeCell = a, Cg(this.VS, n, s, i));
    }
    this.activeCell = r, Cg(this.VS, n, s, i), no(n.id);
  }
  /**
   * Clean up resources for current table view
   */
  cleanup() {
    for (let n = 0; n < this.cols; n++) {
      for (let s = 0; s < this.rows; s++) {
        const i = this.cells[n][s];
        this.activeCell = i;
        for (const [, r] of i.nodeMap.entries())
          dh(r);
        i.rootDinoTree !== null && dh(i.rootDinoTree), i.nodeMap.clear(), i.dinoParentMap.clear();
      }
      this.cells[n].length = 0;
    }
    this.cells.length = 0, this.activeCell = null, this.rootId = null, this.rows = 0, this.cols = 0, this._lastViewOffset = null, this.unbindEvents();
  }
  leftClickDown(n) {
    const s = this.getCellAt(n.mousePos.x, n.mousePos.y);
    s && wB(this.VS, s.actionId);
  }
  actionSelectionChange(n) {
    const s = n.get("action");
    if (!s) return;
    const i = s.after, r = this.getCellByActionId(i);
    r ? this.activeCell = r : this.activeCell = this.cells[0][0], La(this.VS, this.activeCell.actionId), this._dirtyLayout = !0, this.layout(!0);
  }
  get activeCell() {
    if (this._activeCell === null)
      throw new Error("Active cell not found");
    return this._activeCell;
  }
  set activeCell(n) {
    this._activeCell = n;
  }
  /**
   * Given a NodeID, return the corresponding DinoTree for current active cell
   * @param {NodeID} id
   * @returns {DinoTree}
   */
  getOrCreateDinoTree(n) {
    const s = this.activeCell;
    let i = s.nodeMap.get(n);
    return i || (i = new Fd(), i.id = n, s.nodeMap.set(n, i)), i;
  }
  /**
   * @param {DinoID} dinoId
   * @param {NodeID} nodeId
   */
  setParent(n, s) {
    this.activeCell.dinoParentMap.set(n, s);
  }
  /**
   * @param {DinoID} dinoId
   * @returns {boolean}
   */
  hasParent(n) {
    return this.activeCell.dinoParentMap.has(n);
  }
  /**
   * @param {DinoID} dinoId
   * @returns {NodeID | null}
   */
  getParent(n) {
    return this.activeCell.dinoParentMap.get(n);
  }
  /**
   * @returns {DinoTree}
   */
  getRootDinoTree() {
    return this.activeCell.rootDinoTree;
  }
  /**
   * @param {NodeID} id
   * @returns {DinoTree | null}
   */
  getAndDeleteDinoTree(n) {
    const s = this.activeCell, i = s.nodeMap.get(n);
    return i ? (s.nodeMap.delete(n), i) : (console.error("Dino tree not found:", n), null);
  }
  /**
   * @param {number} x
   * @param {number} y
   * @returns {TableCell | null}
   */
  getCellAt(n, s) {
    const i = this.VS.viewport.toWorld(new N(n, s));
    for (let r = 0; r < this.cols; r++)
      for (let o = 0; o < this.rows; o++) {
        const a = this.cells[r][o];
        if (a.worldBounds.contains(i.x, i.y))
          return a;
      }
    return null;
  }
  /**
   * TODO: Might change after adding Variants
   * Fallback to the first cells[0][0] if is not found
   * @param {string | null} actionId
   * @returns {TableCell}
   */
  getCellByActionId(n) {
    for (let s = 0; s < this.cols; s++)
      for (let i = 0; i < this.rows; i++) {
        const r = this.cells[s][i];
        if (r.actionId === n)
          return r;
      }
    return this.cells[0][0];
  }
  /**
   * Get active cell's offset
   * @returns {Vector2}
   */
  getActiveOffset() {
    const n = this.activeCell;
    return new N(n.offset.x, n.offset.y);
  }
  /**
   * Base on cell's originalBounds to generate the bounds to be as a table cell
   * @param {boolean} offsetViewport - if true, offset the viewport after layout
   */
  layout(n = !1) {
    if (!this._dirtyLayout) return;
    this._dirtyLayout = !1, pE.set(0, 0, 0, 0);
    for (let h = 0; h < this.cols; h++)
      for (let d = 0; d < this.rows; d++) {
        const p = this.cells[h][d];
        p.actionId === null ? (pE.copy(p.originalBounds), p.mergedBounds.copy(p.originalBounds)) : p.mergedBounds.copy(pE).merge_with(p.originalBounds.clone());
      }
    const s = [], i = [], r = [], o = [];
    for (let h = 0; h < this.cols; h++) {
      let d = 1 / 0, p = -1 / 0;
      for (let E = 0; E < this.rows; E++) {
        const g = this.cells[h][E];
        d = Math.min(d, g.mergedBounds.x), p = Math.max(p, g.mergedBounds.x + g.mergedBounds.w);
      }
      s.push({ minX: d - this.padding, maxX: p + this.padding });
    }
    for (let h = 0; h < this.rows; h++) {
      let d = 1 / 0, p = -1 / 0;
      for (let E = 0; E < this.cols; E++) {
        const g = this.cells[E][h];
        d = Math.min(d, g.mergedBounds.y), p = Math.max(p, g.mergedBounds.y + g.mergedBounds.h);
      }
      i.push({ minY: d - this.padding, maxY: p + this.padding });
    }
    this.offset.x = s[0].minX, this.offset.y = i[0].minY;
    let a = 0;
    for (let h = 0; h < s.length; h++) {
      h === 0 && (a = s[h].minX);
      const d = s[h].maxX - s[h].minX;
      r.push({ accumulatedX: a, w: d }), a += d;
    }
    let c = 0;
    for (let h = 0; h < i.length; h++) {
      h === 0 && (c = i[h].minY);
      const d = i[h].maxY - i[h].minY;
      o.push({ accumulatedY: c, h: d }), c += d;
    }
    for (let h = 0; h < this.cols; h++)
      for (let d = 0; d < this.rows; d++) {
        const p = this.cells[h][d];
        p.alignedBounds.x = s[h].minX, p.alignedBounds.y = i[d].minY, p.alignedBounds.w = s[h].maxX - s[h].minX, p.alignedBounds.h = i[d].maxY - i[d].minY, p.worldBounds.x = r[h].accumulatedX, p.worldBounds.y = o[d].accumulatedY, p.worldBounds.w = r[h].w, p.worldBounds.h = o[d].h, p.offset.x = p.worldBounds.x - p.alignedBounds.x, p.offset.y = p.worldBounds.y - p.alignedBounds.y;
      }
    const l = this.getActiveOffset();
    for (let h = 0; h < this.cols; h++)
      for (let d = 0; d < this.rows; d++) {
        const p = this.cells[h][d];
        p.worldBounds.x -= l.x, p.worldBounds.y -= l.y;
        const E = new N(
          p.offset.x - l.x,
          p.offset.y - l.y
        );
        Fl.setNodeTransform(
          p.rootDinoTree.root_id,
          E.x,
          E.y,
          0,
          1,
          1,
          0,
          0
        );
        for (const [, g] of p.nodeMap.entries()) {
          if (g.children.compose[0]) {
            const T = this.VS.indexer.getNode(g.id), { scale: A, skew: m, rotation: O, translation: S } = T.item.transform.world.decompose();
            Fl.setNodeTransform(
              g.children.compose[0].id,
              S.x + E.x,
              S.y + E.y,
              O,
              A.x,
              A.y,
              Rt(m.x),
              Rt(m.y)
            );
          }
          if (g.children.compose[1]) {
            const A = this.VS.indexer.getNode(g.id).getLastChild(), { scale: m, skew: O, rotation: S, translation: y } = A.item.transform.world.decompose();
            Fl.setNodeTransform(
              g.children.compose[1].id,
              y.x + E.x,
              y.y + E.y,
              S,
              m.x,
              m.y,
              Rt(O.x),
              Rt(O.y)
            );
          }
        }
      }
    if (this._lastViewOffset === null)
      this._lastViewOffset = l;
    else if (!this._lastViewOffset.equals(l)) {
      if (n) {
        const h = l.clone().sub(this._lastViewOffset);
        this.VS.viewport.projectionTransform.xform_vec(h, h), this.VS.viewport.offsetPos(h);
      }
      this._lastViewOffset.copy(l);
    }
  }
}
const bC = (e, n, s, i) => {
  i(e, n, s);
  for (let r = 0; r < e.children.length; r++)
    bC(e.children[r], e, r, i);
}, UC = (e, n) => {
  uh(e, n), TB(e, n);
  let s = 0;
  for (const i of n.children)
    bC(i, n, s, (r, o, a) => {
      uh(e, r), Hd(e, r, o, a);
    }), s++;
}, La = (e, n, s = void 0, i = !1) => {
  console.log("reloadNodes", e.dataStore.isDesignMode ? "Design" : "Action", n, s, i);
  const r = e.indexer.getWorkspaceNode();
  for (const o of e.dataStore.traverseSubtree(r.id, !0, !0))
    e.dataStore.getElement(o).computedStyle.reload(), no(o);
  if (n === null)
    e.updateNodes();
  else {
    nB(), e.dataStore.transition.loadInteraction(e.dataStore.interaction, n);
    let o = s;
    if (o === void 0) {
      const a = e.dataStore.interaction.getResponseList(n)[0];
      o = e.dataStore.interaction.getResponseDuration(a);
    }
    i && e.dataStore.transition.setPlayheadTime(o, !0, !i, i), e.updateNodes();
  }
}, ed = (e, n, s = !0, i = 1 / 0) => {
  console.log("calculateBiggestBounds", n, i);
  const r = e.view.rootId, o = e.indexer.getNode(r), a = s || !o.item.clipping ? "subtreeBounds" : "boundsVisualWorldAABB", { interaction: c, transition: l } = e.dataStore, h = {};
  if (n === null)
    h.worldBoundsAABB = o[a].clone(), h.isClamped = !1;
  else {
    const d = l.currentTime, p = c.getResponseList(n)[0], E = c.getResponseDuration(p);
    let g = null;
    const T = Math.ceil(1e3 / xB);
    for (let A = 0; A <= E; A += T)
      l.setPlayheadTime(A, !0, !1, !0), e.updateNodes(), g === null ? (g = new ye(), g.copy(o[a])) : g.merge_with(o[a].clone());
    E % T !== 0 && (l.setPlayheadTime(E, !0, !1, !0), e.updateNodes(), g.merge_with(o[a].clone())), l.setPlayheadTime(d, !0, !1, !0), e.updateNodes(), h.worldBoundsAABB = g, h.isClamped = !1;
  }
  return h;
};
function RB(e, n, s = 1 / 0) {
  return ed(e, n, !1, s);
}
const wB = (e, n) => {
  e.dataStore.isActionMode && (e.dataStore.transition.stop(), e.updateNodes()), e.dataStore.eam.switchMode(n === null ? Rn.DESIGN : Rn.ACTION), e.dataStore.selection.selectAction(n);
}, pE = new ye(), GC = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M6.25%204.40212V2C6.25%201.0335%207.0335%200.25%208%200.25C8.9665%200.25%209.75%201.0335%209.75%202V4.40212C10.5535%204.79367%2011.2063%205.44648%2011.5979%206.25H14C14.9665%206.25%2015.75%207.0335%2015.75%208C15.75%208.9665%2014.9665%209.75%2014%209.75H11.5979C11.2063%2010.5535%2010.5535%2011.2063%209.75%2011.5979V14C9.75%2014.9665%208.9665%2015.75%208%2015.75C7.0335%2015.75%206.25%2014.9665%206.25%2014V11.5979C5.44648%2011.2063%204.79367%2010.5535%204.40212%209.75H2C1.0335%209.75%200.25%208.9665%200.25%208C0.25%207.0335%201.0335%206.25%202%206.25H4.40212C4.79367%205.44648%205.44648%204.79367%206.25%204.40212Z'%20fill='white'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M8%201.25C8.41421%201.25%208.75%201.58579%208.75%202V5.09451C9.80421%205.36585%2010.6342%206.19579%2010.9055%207.25H14C14.4142%207.25%2014.75%207.58579%2014.75%208C14.75%208.41421%2014.4142%208.75%2014%208.75H10.9055C10.6342%209.80421%209.80421%2010.6342%208.75%2010.9055V14C8.75%2014.4142%208.41421%2014.75%208%2014.75C7.58579%2014.75%207.25%2014.4142%207.25%2014V10.9055C6.19579%2010.6342%205.36585%209.80421%205.09451%208.75H2C1.58579%208.75%201.25%208.41421%201.25%208C1.25%207.58579%201.58579%207.25%202%207.25H5.09451C5.36585%206.19579%206.19579%205.36585%207.25%205.09451V2C7.25%201.58579%207.58579%201.25%208%201.25ZM9.5%208C9.5%208.82843%208.82843%209.5%208%209.5C7.17157%209.5%206.5%208.82843%206.5%208C6.5%207.17157%207.17157%206.5%208%206.5C8.82843%206.5%209.5%207.17157%209.5%208Z'%20fill='%231C6EE8'/%3e%3c/svg%3e", FC = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.8125%205.50265V2.5C7.8125%201.29188%208.79188%200.3125%2010%200.3125C11.2081%200.3125%2012.1875%201.29188%2012.1875%202.5V5.50265C13.1919%205.99209%2014.0079%206.8081%2014.4974%207.8125H17.5C18.7081%207.8125%2019.6875%208.79188%2019.6875%2010C19.6875%2011.2081%2018.7081%2012.1875%2017.5%2012.1875H14.4974C14.0079%2013.1919%2013.1919%2014.0079%2012.1875%2014.4974V17.5C12.1875%2018.7081%2011.2081%2019.6875%2010%2019.6875C8.79188%2019.6875%207.8125%2018.7081%207.8125%2017.5V14.4974C6.8081%2014.0079%205.99209%2013.1919%205.50265%2012.1875H2.5C1.29188%2012.1875%200.3125%2011.2081%200.3125%2010C0.3125%208.79188%201.29188%207.8125%202.5%207.8125H5.50265C5.99209%206.8081%206.8081%205.99209%207.8125%205.50265Z'%20fill='white'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M10%201.5625C10.5178%201.5625%2010.9375%201.98223%2010.9375%202.5V6.36814C12.2553%206.70731%2013.2927%207.74474%2013.6319%209.0625H17.5C18.0178%209.0625%2018.4375%209.48223%2018.4375%2010C18.4375%2010.5178%2018.0178%2010.9375%2017.5%2010.9375H13.6319C13.2927%2012.2553%2012.2553%2013.2927%2010.9375%2013.6319V17.5C10.9375%2018.0178%2010.5178%2018.4375%2010%2018.4375C9.48223%2018.4375%209.0625%2018.0178%209.0625%2017.5V13.6319C7.74474%2013.2927%206.70731%2012.2553%206.36814%2010.9375H2.5C1.98223%2010.9375%201.5625%2010.5178%201.5625%2010C1.5625%209.48223%201.98223%209.0625%202.5%209.0625H6.36814C6.70731%207.74474%207.74474%206.70731%209.0625%206.36814V2.5C9.0625%201.98223%209.48223%201.5625%2010%201.5625ZM11.875%2010C11.875%2011.0355%2011.0355%2011.875%2010%2011.875C8.96447%2011.875%208.125%2011.0355%208.125%2010C8.125%208.96447%208.96447%208.125%2010%208.125C11.0355%208.125%2011.875%208.96447%2011.875%2010Z'%20fill='%231C6EE8'/%3e%3c/svg%3e", kC = "data:image/svg+xml,%3csvg%20width='12'%20height='12'%20viewBox='0%200%2012%2012'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='6'%20cy='6'%20r='5'%20fill='%231C6EE8'%20stroke='white'%20stroke-width='2'/%3e%3c/svg%3e", DB = "data:image/svg+xml,%3csvg%20width='64'%20height='64'%20viewBox='0%200%2064%2064'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20opacity='0.4'%20width='64'%20height='64'%20fill='url(%23paint0_linear_53_58)'/%3e%3cpath%20d='M0%2025.6H64V38.4H0L0%2025.6Z'%20fill='white'/%3e%3cpath%20d='M0%2025.6H64V38.4H0L0%2025.6Z'%20fill='white'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_53_58'%20x1='32'%20y1='0'%20x2='32'%20y2='64'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-opacity='0'/%3e%3cstop%20offset='0.358891'%20stop-opacity='0.25'/%3e%3cstop%20offset='0.647229'%20stop-opacity='0.25'/%3e%3cstop%20offset='1'%20stop-opacity='0'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e", BC = "data:image/svg+xml,%3csvg%20width='12'%20height='12'%20viewBox='0%200%2012%2012'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20width='12'%20height='12'%20rx='6'%20transform='matrix(-1%200%200%201%2012%200)'%20fill='white'/%3e%3crect%20width='12'%20height='12'%20rx='6'%20transform='matrix(-1%200%200%201%2012%200)'%20fill='url(%23pattern0)'%20fill-opacity='0.12'/%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='0.666667'%20height='0.666667'%3e%3cuse%20xlink:href='%23image0_64_5'%20transform='scale(0.0104167)'/%3e%3c/pattern%3e%3cimage%20id='image0_64_5'%20width='64'%20height='64'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAA40lEQVR4Xu3bQQ6EQAhEUbj/oXsO8Sdh4XOvJAi/qkF3Zt6E6710++xuiD6T40uACtACqYlzD2IACFKBkoHcgmSQDJJBMngKIT6ADygF6DSYfcCLTzg/z0eGrASogDbT0gKxB2MB5pkiBoBgrEEMwIBjLx9fAAiCIAhygmkkRgYjhWMHditsL2AvYC+QIHjdwzk+BmAABmBAWc1kCF0bKRAEQRAEQRAMGaACbaCUz/P5BRiKxhQaiV07uRjfYgQDMKDpGAhGCMUCzD4CBEEw1iAGYIBPZMJh+g8/P8cKpAJfV4EfMee/sLtaEFIAAAAASUVORK5CYII='/%3e%3c/defs%3e%3c/svg%3e", VC = "data:image/svg+xml,%3csvg%20width='120'%20height='120'%20viewBox='0%200%20120%20120'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20filter='url(%23filter0_f_73_20)'%3e%3crect%20width='64'%20height='64'%20rx='32'%20transform='matrix(-1%200%200%201%2092%2028)'%20fill='black'%20fill-opacity='0.4'/%3e%3crect%20x='1'%20y='-1'%20width='66'%20height='66'%20rx='33'%20transform='matrix(-1%200%200%201%2094%2028)'%20stroke='white'%20stroke-width='2'/%3e%3c/g%3e%3cdefs%3e%3cfilter%20id='filter0_f_73_20'%20x='0.4'%20y='0.4'%20width='119.2'%20height='119.2'%20filterUnits='userSpaceOnUse'%20color-interpolation-filters='sRGB'%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'/%3e%3cfeBlend%20mode='normal'%20in='SourceGraphic'%20in2='BackgroundImageFix'%20result='shape'/%3e%3cfeGaussianBlur%20stdDeviation='12.8'%20result='effect1_foregroundBlur_73_20'/%3e%3c/filter%3e%3c/defs%3e%3c/svg%3e", HC = "data:image/svg+xml,%3csvg%20width='64'%20height='64'%20viewBox='0%200%2064%2064'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20width='64'%20height='64'%20rx='32'%20transform='matrix(-1%200%200%201%2064%200)'%20fill='white'%20fill-opacity='1'/%3e%3c/svg%3e", WC = "data:image/svg+xml,%3csvg%20width='116'%20height='116'%20viewBox='0%200%20116%20116'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20filter='url(%23filter0_d_58_2)'%3e%3crect%20width='64'%20height='64'%20rx='32'%20transform='matrix(-1%200%200%201%2090%2026)'%20fill='white'/%3e%3c/g%3e%3cdefs%3e%3cfilter%20id='filter0_d_58_2'%20x='0.4'%20y='0.4'%20width='115.2'%20height='115.2'%20filterUnits='userSpaceOnUse'%20color-interpolation-filters='sRGB'%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'/%3e%3cfeColorMatrix%20in='SourceAlpha'%20type='matrix'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%20127%200'%20result='hardAlpha'/%3e%3cfeOffset/%3e%3cfeGaussianBlur%20stdDeviation='12.8'/%3e%3cfeComposite%20in2='hardAlpha'%20operator='out'/%3e%3cfeColorMatrix%20type='matrix'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.4%200'/%3e%3cfeBlend%20mode='normal'%20in2='BackgroundImageFix'%20result='effect1_dropShadow_58_2'/%3e%3cfeBlend%20mode='normal'%20in='SourceGraphic'%20in2='effect1_dropShadow_58_2'%20result='shape'/%3e%3c/filter%3e%3c/defs%3e%3c/svg%3e", YC = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M16%2016V27L18.909%2024.1822L19.0658%2024.0455H24L16%2016Z'%20fill='white'/%3e%3c/svg%3e", XC = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20filter='url(%23filter0_d_2637_1859)'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M16%2016V27L18.909%2024.1822L19.0658%2024.0455H24L16%2016Z'%20fill='white'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M15%2013.5742L26.4046%2025.0437H19.455L15%2029.3591V13.5742ZM19.0658%2024.0437H24L16%2015.9982V26.9982L18.909%2024.1803L19.0658%2024.0437Z'%20fill='white'/%3e%3c/g%3e%3cdefs%3e%3cfilter%20id='filter0_d_2637_1859'%20x='12'%20y='11.5742'%20width='17.4062'%20height='21.7852'%20filterUnits='userSpaceOnUse'%20color-interpolation-filters='sRGB'%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'/%3e%3cfeColorMatrix%20in='SourceAlpha'%20type='matrix'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%20127%200'%20result='hardAlpha'/%3e%3cfeOffset%20dy='1'/%3e%3cfeGaussianBlur%20stdDeviation='1.5'/%3e%3cfeColorMatrix%20type='matrix'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.35%200'/%3e%3cfeBlend%20mode='normal'%20in2='BackgroundImageFix'%20result='effect1_dropShadow_2637_1859'/%3e%3cfeBlend%20mode='normal'%20in='SourceGraphic'%20in2='effect1_dropShadow_2637_1859'%20result='shape'/%3e%3c/filter%3e%3c/defs%3e%3c/svg%3e", Lo = {
  scaleVisible: 9,
  size: 1,
  color: 0,
  alpha: 0.05
};
let mc, vg;
function LB(e, n) {
  vg = e, mc = vg.overlay.createPane(n);
}
function zC() {
  mc.clear();
  const e = vg.viewport, n = e.scale, s = e.width, i = e.height, r = 1 / e.scale, o = -e.x * r, a = -e.y * r;
  if (n >= Lo.scaleVisible - 1) {
    const c = n >= Lo.scaleVisible ? Lo.alpha : Lo.alpha - Lo.alpha * (Lo.scaleVisible - n);
    mc.lineStyle(Lo.size, Lo.color, c);
    const l = (Math.floor(o) - o) * n, h = (Math.floor(a) - a) * n;
    for (let d = l; d < s; d += n)
      mc.drawLine(d, 0, d, i);
    for (let d = h; d < i; d += n)
      mc.drawLine(0, d, s, d);
  }
}
function MB() {
  mc.clear();
}
let Zl = null, ql = null;
function PB(e, n) {
  Zl = e, ql = Zl.overlay.createPane(n);
}
function Rg() {
  ql.clear();
  for (const e of Zl.dataStore.workspace.children) {
    const n = Zl.getRenderItemOfElement(e);
    if (Ge(n) || e.get("elementType") !== Me.SCREEN || !e.get("visible"))
      continue;
    const s = e.get("name"), i = Zl.viewport.projectionTransform.clone().append(n.transform.world);
    ql.fillStyle(RI.color);
    const r = { fontSize: 12, h_align: "left", v_align: "top" };
    ql.drawTextImage(i.tx, i.ty - RI.padding * 3, s, r);
  }
}
function bB() {
  ql.clear();
}
const so = {
  selectedColor: 1863400,
  hoverAndSelectedColor: 4819949,
  unselectedColor: 14437212,
  unselectedAlpha: 0.4,
  unselectedHoverAlpha: 0.6,
  highlightAlpha: 1,
  width: 1
}, zo = /* @__PURE__ */ new Set();
function KC(e, n, s = !1) {
  zo.clear();
  const i = e.dataStore.get("state");
  if (i === "VERSIONING" || i === "INSPECTING")
    return;
  const r = e.viewport, o = e.viewport.projectionTransform, a = e.dataStore.selection.get("guidelines"), c = e.dataStore.selection.get("hoverGuideline");
  a.forEach((l) => {
    const h = c && l.id === c.id ? so.hoverAndSelectedColor : so.selectedColor;
    Wd(n, l, h, 1, o, r, s), zo.add(l.id);
  }), LS(e, n, e.snapping.xHighlightGuide, dt.VERTICAL, o, r, s), LS(e, n, e.snapping.yHighlightGuide, dt.HORIZONTAL, o, r, s), c && !zo.has(c.id) && (zo.add(c.id), Wd(
    n,
    c,
    so.unselectedColor,
    so.unselectedHoverAlpha,
    o,
    r,
    s
  )), MS(
    e,
    n,
    e.dataStore.guidelines.getGuidelineListVertical(),
    dt.VERTICAL,
    o,
    r,
    s
  ), MS(
    e,
    n,
    e.dataStore.guidelines.getGuidelineListHorizontal(),
    dt.HORIZONTAL,
    o,
    r,
    s
  );
}
function Wd(e, n, s, i, r, o, a) {
  const c = { width: so.width, color: s, alpha: i };
  if (n.direction === dt.VERTICAL) {
    const l = r.a * n.position + r.tx;
    e.lineStyle(c.width, c.color, c.alpha).drawLine(l, 0, l, a ? ft.size : o.height);
  } else {
    const l = r.d * n.position + r.ty;
    e.lineStyle(c.width, c.color, c.alpha).drawLine(0, l, a ? ft.size : o.width, l);
  }
}
function LS(e, n, s, i, r, o, a) {
  for (const c of s) {
    if (zo.has(c))
      continue;
    const l = e.dataStore.guidelines.getGuideline(c);
    l && (Wd(
      n,
      l,
      so.unselectedColor,
      so.highlightAlpha,
      r,
      o,
      a
    ), zo.add(c));
  }
}
function MS(e, n, s, i, r, o, a) {
  for (const c of s) {
    if (zo.has(c))
      continue;
    const l = e.dataStore.guidelines.getGuideline(c);
    l && (Wd(
      n,
      l,
      so.unselectedColor,
      so.unselectedAlpha,
      r,
      o,
      a
    ), zo.add(c));
  }
}
let Hi = null, Kt = null;
const Un = [], Ui = [], gc = /* @__PURE__ */ new Set();
function UB(e, n) {
  Hi = e, Kt = Hi.overlay.createPane(n);
}
function GB(e) {
  const n = [1, 2, 5, 10, 25, 50, 100, 250, 500, 1e3, 2500, 5e3];
  let s = 1 / 0, i;
  for (const r of n) {
    const o = Math.abs(e - r);
    o < s && (s = o, i = r);
  }
  return i;
}
function FB() {
  const e = ft.size;
  Kt.fillStyle(ft.background), Kt.drawSolidRectTexture(0, 0, e, e), Kt.lineStyle(1, ft.borderColor), Kt.drawRect(-0.5, -0.5, e, e);
}
function kB() {
  const e = Hi.viewport.width + 1, n = Hi.viewport.height + 1, s = ft.size;
  Kt.lineStyle(1, ft.borderColor), Kt.fillStyle(ft.background), Kt.drawSolidRect(-0.5, -0.5, e, s), Kt.drawRect(-0.5, -0.5, e, s), Kt.drawSolidRect(-0.5, -0.5, s, n), Kt.drawRect(-0.5, -0.5, s, n);
}
function PS(e, n, s, i, r) {
  const o = i ? -1 : 1, a = 1 / e, c = -n * a, l = (s - n) * a, h = Wk("8", "Inter", ft.fontSize).imageInfo, d = h.w / h.pixelRatio, p = d * (Math.max(Math.abs(Math.ceil(c)).toString().length, Math.abs(Math.ceil(l)).toString().length) + 1), E = p * ft.spacingMultiple, g = s / E, T = GB((l - c) / g), A = T * e, m = j2(-c, T) * e, O = ft.size - ft.dashSize, S = O * 0.5 + h.h / h.pixelRatio * -0.3, y = s + p, v = T * Math.ceil(c / T) * o;
  Un.length = 0, Ui.length = 0;
  let R = v;
  for (let b = m; b < y; b += A)
    Un.push(b), Ui.push(R.toString()), R += o * T;
  const M = Hi.viewport.projectionTransform;
  for (const b of r) {
    if (!b) continue;
    const K = (Math.round(b.position * 100) / 100).toString();
    let V;
    i ? (V = M.d * b.position + M.ty, V = Hi.viewport.height - V) : V = M.a * b.position + M.tx, HB(Un, Ui, V, K), gc.add(V);
  }
  const L = [[], [], [], []], P = [[], [], [], []], k = [[], [], [], []];
  Kt.lineStyle(1, ft.color, ft.alpha), Kt.fillStyle(16777215);
  const Q = 10;
  for (let b = 0; b < Un.length; b++)
    if (gc.has(Un[b]))
      if (b > 0 && gc.has(Un[b - 1])) {
        const X = Un[b - 1], K = Un[b], V = K - d * Ui[b].length * 0.5 - (X + d * Ui[b - 1].length * 0.5), J = bS(V);
        J !== null && L[J].push([K, Ui[b]]);
      } else
        L[3].push([Un[b], Ui[b]]);
    else {
      let X = 1 / 0, K = 1 / 0;
      b > 0 && gc.has(Un[b - 1]) && (X = Un[b] - d * Ui[b].length * 0.5 - (Un[b - 1] + d * Ui[b - 1].length + Q)), b < Un.length - 1 && gc.has(Un[b + 1]) && (K = Un[b + 1] - (Un[b] + d * Ui[b].length * 0.5 + Q));
      const V = Math.min(X, K);
      if (V <= 4) {
        const J = bS(V);
        J !== null && (P[J].push([Un[b], Ui[b]]), k[J].push(Un[b]));
      } else
        P[3].push([Un[b], Ui[b]]), Kt.drawLine(Un[b], O - 1, Un[b], ft.size - 1);
    }
  for (let b = 0; b < 3; b++)
    if (k[b].length > 0) {
      Kt.lineStyle(1, ft.color, ft.overlapAlpha[b]), Kt.fillStyle(16777215);
      for (let X = 0; X < k[b].length; X++)
        Kt.drawLine(k[b][X], O - 1, k[b][X], ft.size - 1);
    }
  for (let b = 0; b < 4; b++) {
    const X = { fontSize: 10, h_align: "left", v_align: "top" };
    if (L[b].length > 0) {
      Kt.fillStyle(ft.guidelineColor, ft.overlapAlpha[b]);
      for (let K = 0; K < L[b].length; K++)
        i ? Kt.drawTextImage(L[b][K][0] + Q / 2, S * 1.6, L[b][K][1], X) : Kt.drawTextImage(L[b][K][0] + Q / 2, S, L[b][K][1], X);
    }
    if (P[b].length > 0) {
      Kt.fillStyle(ft.color, ft.overlapAlpha[b]);
      for (let K = 0; K < P[b].length; K++) {
        const V = new N().fromArray(Kt.measureTextImage(P[b][K][1], X.fontSize, "left", "top"));
        Kt.drawTextImage(P[b][K][0] - V.x / 2, S, P[b][K][1], X);
      }
    }
  }
}
function BB() {
  Kt.clear(), kB(), gc.clear();
  const e = Hi.dataStore.selection.get("hoverGuideline"), n = Hi.dataStore.selection.get("guidelines"), s = n.filter((h) => h.direction === dt.HORIZONTAL), i = n.filter((h) => h.direction === dt.VERTICAL);
  e && (e.direction === dt.HORIZONTAL ? s.push(e) : e.direction === dt.VERTICAL && i.push(e));
  const r = Hi.viewport, o = { x: 0, y: 0 };
  if (Hi.view instanceof I0) {
    const h = Hi.view.offset.clone();
    o.x = h.x, o.y = h.y;
  }
  const a = r.x + o.x * r.scale;
  PS(r.scale, a, r.width, !1, i);
  const c = new Ce().rotate(-Math.PI * 0.5).translate(0, r.height);
  Kt.appendTransform(c);
  const l = r.height - r.y - o.y * r.scale;
  PS(r.scale, l, r.height, !0, s), Kt.resetTransform(), KC(Hi, Kt, !0), FB();
}
function VB() {
  Kt.clear();
}
function HB(e, n, s, i) {
  if (e.length === 0)
    return e.push(s), e;
  const r = WB(e, s);
  return n.splice(r, 0, i), e.splice(r, 0, s), e;
}
function WB(e, n) {
  let s = 0, i = e.length;
  for (; s < i; ) {
    const r = Math.floor((s + i) / 2);
    e[r] < n ? s = r + 1 : i = r;
  }
  return s;
}
function bS(e) {
  return e > 4 ? 3 : e > 3 ? 2 : e > 2 ? 1 : e > 1 ? 0 : null;
}
const tr = {
  size: 20,
  padding: 5,
  color: 8947848,
  colorHover: 13421772,
  borderRadius: 5
};
let fh = null, wg = null, Yd = 0, Dg = null, mr = null;
function YB(e, n) {
  return wg = e, fh = wg.overlay.createPane(n), fh;
}
function XB(e) {
  Dg = e;
}
function zB(e) {
  mr = e;
}
function QC(e) {
  Yd = e;
}
function KB() {
  if (fh.clear(), mr === null || Yd < Number.EPSILON) return;
  const e = wg.viewport, n = tr.padding;
  QB(e, n, mr.left, mr.width, mr.top, mr.height);
}
function QB(e, n, s, i, r, o) {
  Math.round(mr.right - mr.left) < e.width && fh.fillStyle(Dg === "x" ? tr.colorHover : tr.color, Yd).drawSolidRect(
    s,
    e.height - tr.size + n,
    i,
    tr.size - n * 2,
    tr.borderRadius
  ), Math.round(mr.bottom - mr.top) < e.height && fh.fillStyle(Dg === "y" ? tr.colorHover : tr.color, Yd).drawSolidRect(
    e.width - tr.size + n,
    r,
    tr.size - n * 2,
    o,
    tr.borderRadius
  );
}
const ph = "data:image/svg+xml,%3csvg%20width='13'%20height='12'%20viewBox='0%200%2013%2012'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='6.5'%20y='1.0529'%20width='7'%20height='7'%20transform='rotate(45%206.5%201.0529)'%20fill='white'%20stroke='%231C6EE8'/%3e%3c/svg%3e", Eh = "data:image/svg+xml,%3csvg%20width='13'%20height='12'%20viewBox='0%200%2013%2012'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='6.5'%20y='1.0529'%20width='7'%20height='7'%20transform='rotate(45%206.5%201.0529)'%20fill='white'%20stroke='%2395BEF2'/%3e%3c/svg%3e", gh = "data:image/svg+xml,%3csvg%20width='17'%20height='18'%20viewBox='0%200%2017%2018'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='8.5'%20y='1.92575'%20width='10'%20height='10'%20transform='rotate(45%208.5%201.92575)'%20fill='%2395BEF2'%20stroke='white'%20stroke-width='2'/%3e%3c/svg%3e", _h = "data:image/svg+xml,%3csvg%20width='17'%20height='18'%20viewBox='0%200%2017%2018'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='8.5'%20y='1.92587'%20width='10'%20height='10'%20transform='rotate(45%208.5%201.92587)'%20fill='%231C6EE8'%20stroke='white'%20stroke-width='2'/%3e%3c/svg%3e", lf = "data:image/svg+xml,%3csvg%20width='11'%20height='10'%20viewBox='0%200%2011%2010'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='5.5'%20cy='5'%20r='4.5'%20fill='white'%20stroke='%231C6EE8'/%3e%3c/svg%3e", S0 = "data:image/svg+xml,%3csvg%20width='11'%20height='10'%20viewBox='0%200%2011%2010'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='5.5'%20cy='5'%20r='4.5'%20fill='white'%20stroke='%2395BEF2'/%3e%3c/svg%3e", y0 = "data:image/svg+xml,%3csvg%20width='15'%20height='14'%20viewBox='0%200%2015%2014'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='7.5'%20cy='7'%20r='6'%20fill='%2395BEF2'%20stroke='white'%20stroke-width='2'/%3e%3c/svg%3e", C0 = "data:image/svg+xml,%3csvg%20width='15'%20height='14'%20viewBox='0%200%2015%2014'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='7.5'%20cy='7'%20r='6'%20fill='%231C6EE8'%20stroke='white'%20stroke-width='2'/%3e%3c/svg%3e";
let Ti = null, oo = null, Lg = null, Xd = null, Th = null;
const Nr = new Ce(), ku = new N(), Vt = new N();
let wh = null, hf = null, $t = null, Ah = !0, EE = null;
const Hn = {
  visible: !1,
  dirty: !1,
  position: new N(),
  snapId: null,
  builder: new i0(),
  curved: !0
}, Ai = {
  visible: !1,
  position: new N(),
  highlighted: !1
}, rs = {
  visible: !1,
  dirty: !1,
  edgeIds: [],
  builder: new i0()
};
let ZC = [];
const ct = {
  LINE_WIDTH: 1,
  LINE_COLOR: 9145227,
  SELECTED_LINE_COLOR: 1863400,
  SVG_COLOR: 16777215,
  GHOST_COLOR: 1863400,
  CURVE_OFFSET: 4,
  HIGHLIGHTED_COLOR: 16724530,
  ASSIST_LINE_CROSS_SIZE: 3
}, Dh = /* @__PURE__ */ new Map();
Dh.set(
  0,
  /** @type {DrawVertexCallback} */
  (e) => {
    const n = $t.getVertPos(e.id);
    Nr.xform(Vt.set(n[0], n[1]), Vt), oo.fillStyle(ct.SVG_COLOR).drawImageFromAtlas(lf, Vt.x, Vt.y, 1, 1);
  }
);
const N0 = 1 << Be.SELECTED;
Dh.set(
  N0,
  /** @type {DrawVertexCallback} */
  (e) => {
    const n = $t.getVertPos(e.id);
    Nr.xform(Vt.set(n[0], n[1]), Vt), oo.fillStyle(ct.SVG_COLOR).drawImageFromAtlas(C0, Vt.x, Vt.y, 1, 1);
  }
);
const x0 = 1 << Be.CURVE_VERT;
Dh.set(
  x0,
  /** @type {DrawVertexCallback} */
  (e) => {
    if (!e.adjacentMainVertex || !$t.vertices.has(e.adjacentMainVertex) || e.adjacentMainVertex.pos.eq(e.pos)) return;
    const n = e.adjacentMainVertex;
    n.isFlagged(Be.CONNECT_SELECTED) && (Hn.visible && !Hn.curved && e.id === n.unlinkedCurveControl && n.isFlagged(Be.SELECTED) || (jC(e.id, n.id, !1), qC(e.id, !1)));
  }
);
Dh.set(
  x0 | N0,
  /** @type {DrawVertexCallback} */
  (e) => {
    if (!e.adjacentMainVertex || !$t.vertices.has(e.adjacentMainVertex) || e.adjacentMainVertex.pos.eq(e.pos)) return;
    const n = e.adjacentMainVertex.id;
    jC(e.id, n, !0), qC(e.id, !0);
  }
);
function qC(e, n) {
  const s = $t.getVertPos(e);
  Nr.xform(Vt.set(s[0], s[1]), Vt), ZB(Vt.x, Vt.y, n);
}
function ZB(e, n, s) {
  const i = s ? _h : ph;
  oo.fillStyle(ct.SVG_COLOR).drawImageFromAtlas(i, e, n, 1, 1);
}
function jC(e, n, s) {
  const i = $t.getVertPos(e, jB), r = $t.getVertPos(n, JB);
  Nr.xform(Vt.set(i[0], i[1]), Vt), Nr.xform(ku.set(r[0], r[1]), ku), qB(Vt.x, Vt.y, ku.x, ku.y, s);
}
function qB(e, n, s, i, r) {
  const o = new N(s - e, i - n), a = o.length(), c = 1 / a;
  o.scale(c);
  const l = r ? ct.SELECTED_LINE_COLOR : ct.LINE_COLOR;
  oo.lineStyle(ct.LINE_WIDTH, l).drawLine(
    e,
    n,
    e + o.x * (a - ct.CURVE_OFFSET),
    n + o.y * (a - ct.CURVE_OFFSET)
  );
}
const jB = new Float32Array(2), JB = new Float32Array(2);
function $B(e, n, s, i, r) {
  Ti = e, Xd = e.overlay.createPane(n), Lg = Ti.overlay.createPane(s), oo = Ti.overlay.createPane(i), Th = Ti.overlay.createPane(r), Ti.dataStore.selection.on(Oe.SELECT_CELL, (o) => {
    const a = o.get("vertices").after;
    t4(a), !a.length > 0 && (Hn.visible = !1);
  }), Ti.dataStore.on(Oe.DEFAULT_CHANGES, (o) => {
    o.has("activeTool") && o.get("activeTool").after !== st.PEN && (Hn.visible = !1, Ai.visible = !1, Ai.highlighted = !1);
  }), e4();
}
function e4() {
  Dt(ph), Dt(Eh), Dt(gh), Dt(_h), Dt(lf), Dt(S0), Dt(y0), Dt(C0);
}
function t4(e) {
  if (wh) {
    for (const n of $t.vertices)
      n.removeFlag(Be.SELECTED), n.removeFlag(Be.CONNECT_SELECTED);
    for (const n of e)
      n.flag(Be.SELECTED), n.flag(Be.CONNECT_SELECTED), n.isFlagged(Be.CURVE_VERT) && (n.controllingEdge ? (n.controllingEdge.v.flag(Be.CONNECT_SELECTED), n.controllingEdge.w.flag(Be.CONNECT_SELECTED)) : n.adjacentMainVertex && n.adjacentMainVertex.flag(Be.CONNECT_SELECTED));
    for (const n of $t.getEdges())
      n.v.isFlagged(Be.SELECTED) && n.w.flag(Be.CONNECT_SELECTED), n.w.isFlagged(Be.SELECTED) && n.v.flag(Be.CONNECT_SELECTED);
  }
}
function n4() {
  Ah && (EE = _d($t), Ah = !1), EE && Xd.lineStyle(ct.LINE_WIDTH, ct.LINE_COLOR).drawPath(0, 0, EE.applyXorm(Nr)), Hn.visible && (Hn.visible = i4(Hn)), Hn.visible && Xd.lineStyle(ct.LINE_WIDTH, ct.GHOST_COLOR).drawPath(0, 0, Hn.builder.path.applyXorm(Nr)), rs.visible && (r4(), rs.builder.path.commands.length > 0 && Th.lineStyle(ct.LINE_WIDTH, ct.HIGHLIGHTED_COLOR).drawPath(0, 0, rs.builder.path.applyXorm(Nr)));
  for (const e of [...$t.vertices].sort((n, s) => n.index - s.index))
    Dh.get(e.flags & (x0 | N0))(e);
  s4();
  for (const e of ZC)
    Th.lineStyle(1, ct.HIGHLIGHTED_COLOR).drawLine(
      e[0].x,
      e[0].y,
      e[1].x,
      e[1].y
    ).drawLine(
      e[0].x - ct.ASSIST_LINE_CROSS_SIZE,
      e[0].y - ct.ASSIST_LINE_CROSS_SIZE,
      e[0].x + ct.ASSIST_LINE_CROSS_SIZE,
      e[0].y + ct.ASSIST_LINE_CROSS_SIZE
    ).drawLine(
      e[0].x - ct.ASSIST_LINE_CROSS_SIZE,
      e[0].y + ct.ASSIST_LINE_CROSS_SIZE,
      e[0].x + ct.ASSIST_LINE_CROSS_SIZE,
      e[0].y - ct.ASSIST_LINE_CROSS_SIZE
    ).drawLine(
      e[1].x - ct.ASSIST_LINE_CROSS_SIZE,
      e[1].y - ct.ASSIST_LINE_CROSS_SIZE,
      e[1].x + ct.ASSIST_LINE_CROSS_SIZE,
      e[1].y + ct.ASSIST_LINE_CROSS_SIZE
    ).drawLine(
      e[1].x - ct.ASSIST_LINE_CROSS_SIZE,
      e[1].y + ct.ASSIST_LINE_CROSS_SIZE,
      e[1].x + ct.ASSIST_LINE_CROSS_SIZE,
      e[1].y - ct.ASSIST_LINE_CROSS_SIZE
    );
}
function s4() {
  const e = Ti.dataStore.selection.get("hoverVertex");
  if (!e || !wh) return;
  const n = $t.getVertPos(e.id);
  Nr.xform(Vt.set(n[0], n[1]), Vt);
  let s = Eh, i = S0;
  e.isFlagged(Be.SELECTED) && (s = gh, i = y0), e.isFlagged(Be.CURVE_VERT) ? oo.fillStyle(ct.SVG_COLOR).drawImageFromAtlas(s, Vt.x, Vt.y, 1, 1) : oo.fillStyle(ct.SVG_COLOR).drawImageFromAtlas(i, Vt.x, Vt.y, 1, 1), Ai.highlighted && Th.lineStyle(ct.LINE_WIDTH, ct.HIGHLIGHTED_COLOR).drawLine(
    Vt.x - ct.ASSIST_LINE_CROSS_SIZE,
    Vt.y - ct.ASSIST_LINE_CROSS_SIZE,
    Vt.x + ct.ASSIST_LINE_CROSS_SIZE,
    Vt.y + ct.ASSIST_LINE_CROSS_SIZE
  ).drawLine(
    Vt.x - ct.ASSIST_LINE_CROSS_SIZE,
    Vt.y + ct.ASSIST_LINE_CROSS_SIZE,
    Vt.x + ct.ASSIST_LINE_CROSS_SIZE,
    Vt.y - ct.ASSIST_LINE_CROSS_SIZE
  );
}
function i4(e) {
  if (!e.dirty) return !0;
  e.dirty = !1, e.builder.clear();
  const n = Ti.dataStore.selection.get("vertices");
  if (n.length !== 1 || n[0].isFlagged(Be.CURVE_VERT))
    return !1;
  const s = n[0], i = $t.getVertPos(s.id, Ol);
  let r = !1;
  if (e.snapId) {
    const o = $t.cellTable.get(e.snapId);
    if (o.isFlagged(Be.CURVE_VERT))
      return !1;
    for (const a of o.upperTierIDs) {
      const c = $t.cellTable.get(a);
      if (!c.isCurve && (c.v === s && c.w === o || c.w === s && c.v === o))
        return !1;
    }
    $t.getVertPos(e.snapId, $i), o.unlinkedCurveControl ? (r = !0, $t.getVertPos(o.unlinkedCurveControl, ga)) : (ga[0] = $i[0], ga[1] = $i[1]);
  } else {
    if (hf.transform.worldInv.xform(e.position, e.position), new N(Ol[0], Ol[1]).distance_to(e.position) < Number.EPSILON) return !1;
    $i[0] = e.position.x, $i[1] = e.position.y, ga[0] = $i[0], ga[1] = $i[1];
  }
  return (s.unlinkedCurveControl || r) && e.curved ? (s.unlinkedCurveControl ? $t.getVertPos(s.unlinkedCurveControl, Il) : (Il[0] = i[0], Il[1] = i[1]), e.builder.start(i[0], i[1]), e.builder.cubic(
    Il[0],
    Il[1],
    ga[0],
    ga[1],
    $i[0],
    $i[1]
  ), e.builder.end(), !0) : (e.builder.start(Ol[0], Ol[1]), e.builder.line($i[0], $i[1]), e.builder.end(), !0);
}
function r4() {
  if (rs.dirty) {
    rs.dirty = !1, rs.builder.clear();
    for (const e of rs.edgeIds) {
      const n = $t.cellTable.get(e);
      if (!n) {
        console.error(`Could not find edge ${e}`);
        continue;
      }
      if (n.isCurve) {
        const s = $t.getEdgeCurve(e), i = new N(s[0].x, s[0].y), r = new N(s[1].x, s[1].y), o = $t.getVertPos(n.v.id), a = new N(o.x, o.y), c = $t.getVertPos(n.w.id), l = new N(c.x, c.y);
        rs.builder.start(a.x, a.y), rs.builder.cubic(i.x, i.y, r.x, r.y, l.x, l.y), rs.builder.end();
      } else {
        const s = $t.getVertPos(n.v.id), i = new N(s.x, s.y), r = $t.getVertPos(n.w.id), o = new N(r.x, r.y);
        rs.builder.start(i.x, i.y), rs.builder.line(o.x, o.y), rs.builder.end();
      }
    }
  }
}
const Ol = new Float32Array(2), $i = new Float32Array(2), Il = new Float32Array(2), ga = new Float32Array(2);
function o4() {
  oo.clear(), Lg.clear(), Xd.clear(), Th.clear(), Ai.visible && Lg.fillStyle(ct.SVG_COLOR).drawImageFromAtlas(lf, Ai.position.x, Ai.position.y, 1, 1), wh !== null && (Nr.copy(hf.transform.world).prepend(Ti.viewport.projectionTransform), n4());
}
function a4(e) {
  e.canMorph || console.error(`${e.get("id")} can't edit path`), wh = e, hf = Ti.getRenderItemOfElement(e), $t = e.get("geometry").get("mesh"), Ah = !0;
}
function c4() {
  if ($t)
    for (const e of $t.vertices)
      e.removeFlag(Be.SELECTED);
  wh = null, $t = null, hf = null, oo.clear(), Ah = !0;
}
function Sl(e, n, s) {
  if (Ai.visible = !0, Ai.highlighted = !1, s) {
    const i = new N(e, n), o = Ti.viewport.toWorld(i).round(), a = Ti.viewport.toScreen(o);
    Ai.position.copy(a);
  } else
    Ai.position.set(e, n);
}
function Mg(e) {
  Ai.visible = !1, Ai.highlighted = e;
}
function l4(e, n, s) {
  Hn.visible = !0, Hn.dirty = !0, Hn.snapId = null, Hn.position.copy(Ti.viewport.toWorld(Ai.position)), Hn.curved = s;
}
function h4(e, n) {
  Hn.visible = !0, Hn.dirty = !0, Hn.snapId = e, Hn.curved = n;
}
function vc() {
  Hn.visible = !1, Hn.dirty = !0;
}
function Rc(e) {
  rs.edgeIds = e, rs.dirty = !0, rs.visible = e.length > 0;
}
function u4() {
  rs.visible = !1, rs.dirty = !0;
}
function qo(e) {
  ZC = e;
}
function td() {
  Ah = !0;
}
const JC = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12.6769%207.0297L9.13808%202.90796C8.53951%202.2108%207.46049%202.21079%206.86192%202.90796L3.32308%207.0297C2.84052%207.59175%202.84052%208.42191%203.32308%208.98396L6.86192%2013.1057C7.46049%2013.8029%208.53951%2013.8029%209.13808%2013.1057L12.6769%208.98396C13.1595%208.42191%2013.1595%207.59175%2012.6769%207.0297Z'%20fill='white'%20stroke='%231C6EE8'/%3e%3c/svg%3e", $C = "data:image/svg+xml,%3csvg%20width='16'%20height='18'%20viewBox='0%200%2016%2018'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.2705%207.69822L9.51744%202.16226C8.71935%201.23272%207.28066%201.23271%206.48256%202.16226L1.72951%207.69822C1.08609%208.44762%201.08609%209.5545%201.72951%2010.3039L6.48256%2015.8399C7.28065%2016.7694%208.71934%2016.7694%209.51744%2015.8399L14.2705%2010.3039C14.9139%209.5545%2014.9139%208.44762%2014.2705%207.69822Z'%20fill='%231C6EE8'%20stroke='white'%20stroke-width='2'/%3e%3c/svg%3e", eN = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9.13808%202.90796C8.53951%202.2108%207.46049%202.21079%206.86192%202.90796L3.32308%207.0297C2.84052%207.59175%202.84052%208.42191%203.32308%208.98396L6.86192%2013.1057C7.46049%2013.8029%208.53951%2013.8029%209.13808%2013.1057L12.6769%208.98396C13.1595%208.42191%2013.1595%207.59175%2012.6769%207.0297L9.13808%202.90796Z'%20fill='white'%20stroke='%231C6EE8'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M13.0561%206.70416L9.51722%202.58242C8.71913%201.65287%207.28044%201.65287%206.48234%202.58242L2.9435%206.70416C2.30008%207.45356%202.30008%208.56044%202.9435%209.30984L6.48234%2013.4316C7.28043%2014.3611%208.71912%2014.3611%209.51721%2013.4316L13.0561%209.30984C13.6995%208.56044%2013.6995%207.45356%2013.0561%206.70416ZM12.2973%208.6584C12.2973%208.65841%2012.2973%208.65841%2012.2973%208.65841V8.65842C12.2973%208.65841%2012.2973%208.65841%2012.2973%208.6584Z'%20fill='white'%20fill-opacity='0.6'/%3e%3c/svg%3e", tN = "data:image/svg+xml,%3csvg%20width='16'%20height='18'%20viewBox='0%200%2016%2018'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9.51744%202.16226C8.71935%201.23272%207.28066%201.23271%206.48256%202.16226L1.72951%207.69822C1.08609%208.44762%201.08609%209.5545%201.72951%2010.3039L6.48256%2015.8399C7.28065%2016.7694%208.71934%2016.7694%209.51744%2015.8399L14.2705%2010.3039C14.9139%209.5545%2014.9139%208.44762%2014.2705%207.69822L9.51744%202.16226Z'%20fill='%231C6EE8'%20stroke='white'%20stroke-width='2'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M14.2706%207.69833L9.51756%202.16237C8.71947%201.23282%207.28078%201.23282%206.48269%202.16237L1.72963%207.69833C1.08622%208.44773%201.08622%209.55461%201.72963%2010.304L6.48269%2015.84C7.28078%2016.7695%208.71947%2016.7695%209.51756%2015.84L14.2706%2010.304C14.914%209.55461%2014.914%208.44773%2014.2706%207.69833ZM2.38279%209.50439C2.41295%209.55612%202.44814%209.60575%202.48835%209.65259L7.24141%2015.1885L2.48835%209.65258C2.44814%209.60574%202.41295%209.55612%202.38279%209.50439Z'%20fill='white'%20fill-opacity='0.6'/%3e%3c/svg%3e", nN = "data:image/svg+xml,%3csvg%20width='8'%20height='8'%20viewBox='0%200%208%208'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M1.75%204C1.75%202.75736%202.75736%201.75%204%201.75C5.24264%201.75%206.25%202.75736%206.25%204C6.25%205.24264%205.24264%206.25%204%206.25C2.75736%206.25%201.75%205.24264%201.75%204Z'%20fill='white'/%3e%3ccircle%20cx='4'%20cy='4'%20r='2'%20fill='%238B8B8B'/%3e%3c/svg%3e";
let Tn = null, Le = null, sN = null, Xa = null, iN = null;
const Pg = new Ce(), bg = new Ce();
let kl = null, Ar = null, xr = null, yn = null, _s = null, Ug = !1;
const US = new N();
let GS = null;
const FS = /* @__PURE__ */ new Map(), Sr = "FAKE_INIT_KF_ID", kS = /* @__PURE__ */ new Set(["delay", "start", "end"]), Tr = new Bt(0, 0, 0, 0, 0, 0, 0, 0), He = /* @__PURE__ */ new Map(), Ki = /* @__PURE__ */ new Map(), Ii = /* @__PURE__ */ new Map(), rN = {
  VERT_HALF_BOX_WIDTH: 8
}, qr = {
  HOVER_SEGMENT_WIDTH: 2.5,
  HOVER_SEGMENT_COLOR: 1863400,
  LINE_WIDTH: 1.5,
  LINE_COLOR: 9145227,
  SVG_COLOR: 16777215
};
function d4(e, n, s, i) {
  Tn = e, Le = Tn.dataStore, Xa = Tn.overlay.createPane(n), sN = Tn.overlay.createPane(s), iN = Tn.overlay.createPane(i), Le.selection.on(Oe.SELECT, (a) => {
    const c = a.get("motionPoints");
    c && (_s = c.after);
  }), Le.eam.on(Y.HOVER_MOTION_POINT, ({ mousePos: a }, { modifier: c = !1 }) => {
    const l = Le.selection.get("elements");
    if (Le.get("mode") !== Rn.ACTION || l.length !== 1 || l[0].get("locked") || Tn.dataStore.getFeature("editOrigin") || Tn.dataStore.getFeature("editSelector")) {
      yn = null;
      return;
    }
    const h = Tn.viewport.toWorld(a);
    yn = S4(h), yn && (Le.eam.changeHover(Gt.MOTION_POINT), kl(c ? "arrowCurve" : "default")), Le.selection.set("hoverMotionPoint", yn);
  }), Le.eam.on(Y.SELECT_MOTION_POINT, (a, { shift: c, modifier: l }) => {
    const h = Le.selection, d = h.get("elements");
    if (!yn || Le.get("mode") !== Rn.ACTION || d.length !== 1 || xr.item.locked || Tn.dataStore.getFeature("editOrigin") || Tn.dataStore.getFeature("editSelector")) {
      yn = null;
      return;
    }
    const p = _s.length > 0 && (_s[0].type === "point" && yn.type === "point" || _s[0].type !== "point" && yn.type !== "point");
    l && f4(yn), c && p ? Le.selection.toggleMotionPoints([yn], zd) : zd(_s, yn) || Le.selection.selectMotionPoints([yn]), _s = h.get("motionPoints"), aN(_s);
  }), Le.eam.on(Y.SELECT_ALL_MOTION_POINTS, () => {
    const a = Le.selection.get("elements")[0], l = Le.transition.getPropertyKeyframesByElementId(a.get("id"), "motionPath").map((h) => ({ type: "point", key: h.id, trackId: h.trackId, time: h.time }));
    Le.selection.selectMotionPoints(l);
  }), Le.eam.on(Y.DESELECT_MOTION_POINT, () => {
    Le.selection.selectMotionPoints([]), _s = null;
  }), Le.eam.on(Y.START_DRAG_MOTION_POINT, (a) => {
    if (!yn) {
      a.handled = !1;
      return;
    }
    if (!He.has(yn.key)) {
      a.handled = !1;
      return;
    }
    _s = Le.selection.get("motionPoints");
    for (const c of _s) {
      const l = c.type === "point" ? "pos" : c.type;
      FS.set(c.key + c.type, new N().fromArray(He.get(c.key)[l]));
    }
    GS = Tn.viewport.toWorld(a.mousePos), US.set(0, 0);
  }).on(Y.UPDATE_DRAG_MOTION_POINT, ({ mousePos: a }) => {
    kl("default");
    const c = Tn.viewport.toWorld(a);
    US.copy(c).sub(GS);
    const l = xr.item.transform.parent, d = Pg.copy(l).affine_inverse().xform(c);
    He.has(yn.key) && (Le.editor.setMotionPathProps(
      d,
      yn,
      { commit: !1, delta: !1 }
    ), yn = Le.selection.get("hoverMotionPoint"));
  }).on(Y.END_DRAG_MOTION_POINT, () => {
    FS.clear(), Le.commitUndo();
  });
  const r = 2, o = {
    lastMousePos: new N(),
    isPressingShift: !1,
    hoverMotionSegment: null,
    hasDragged: !1,
    initMousePos: new N()
  };
  Le.eam.on(Y.HOVER_MOTION_SEGMENT, ({ mousePos: a }) => {
    if (Le.selection.get("hoverMotionPoint")) {
      Le.selection.set("hoverMotionSegment", null);
      return;
    }
    o.hoverMotionSegment = x4(a), o.hoverMotionSegment && (Le.eam.changeHover(Gt.MOTION_SEGMENT), kl("arrowCurve")), Le.selection.set("hoverMotionSegment", o.hoverMotionSegment);
  }), Le.eam.on(Y.START_DRAG_MOTION_SEGMENT, (a, { shift: c }) => {
    o.hasDragged = !1, o.initMousePos.copy(a.mousePos);
    const l = Tn.viewport.toWorld(a.mousePos);
    o.lastMousePos.copy(l), o.isPressingShift = c;
  }).on(Y.UPDATE_DRAG_MOTION_SEGMENT, (a, { shift: c }) => {
    o.isPressingShift = c;
    const l = Tn.viewport.toWorld(a.mousePos), h = l.clone().sub(o.lastMousePos);
    if (o.lastMousePos.copy(l), o.hasDragged === !1) {
      if (o.initMousePos.clone().sub(a.mousePos).length() > r) {
        if (o.hasDragged = !0, !o.hoverMotionSegment) {
          a.handled = !1;
          return;
        }
        const p = o.hoverMotionSegment.keyStart, E = o.hoverMotionSegment.keyEnd, g = p4(p, E, o.hoverMotionSegment);
        if (g.length !== 2 || !g[0] || !g[1]) {
          a.handled = !1;
          return;
        }
        Le.selection.selectMotionPoints([g[0]], On), Le.selection.addMotionPoints([g[1]], On);
        const T = He.get(g[0].key), A = He.get(g[1].key), m = new N().fromArray(T.out), O = new N().fromArray(A.in), S = new N().fromArray(T.pos), y = new N().fromArray(A.pos);
        if (m && O && m.is_zero() && O.is_zero()) {
          const { oneThird: v, twoThirds: R } = N.getThirds(
            S,
            y
          );
          BS(T, A, v.sub(S), R.sub(y));
        }
      }
    } else {
      const d = Array.from(Le.selection.get("motionPoints")).sort((R, M) => R.time - M.time), p = He.get(d[0].key), E = He.get(d[1].key), g = new N().fromArray(p.pos), T = new N().fromArray(E.pos), A = new N().fromArray(p.out).add(g), m = new N().fromArray(E.in).add(T), { deltaP1: O, deltaP2: S } = L4(
        o.hoverMotionSegment.t,
        h.x,
        h.y
      ), y = A.clone().add(O).sub(g), v = m.clone().add(S).sub(T);
      BS(p, E, y, v);
    }
  }).on(Y.END_DRAG_MOTION_SEGMENT, () => {
    Le.commitUndo();
  }), Le.eam.on(Y.START_DRAG_ELEMENT, () => {
    Ug = !0;
  }).on(Y.END_DRAG_ELEMENT, () => {
    Ug = !1;
  }), E4();
}
function f4(e) {
  if (e.type === "point") {
    xr = Tn.indexer.getNode(Ar.get("id"));
    const n = xr.item.baseTransform.translate, s = He.get(e.key);
    let i;
    switch (s.mirror) {
      case pe.ANGLE:
        i = pe.NONE;
        break;
      case pe.ANGLE_AND_LENGTH:
        i = pe.NONE;
        break;
      case pe.INDEPENDENT:
        i = pe.NONE;
        break;
      default:
        i = pe.ANGLE_AND_LENGTH;
    }
    cN(e, n, i);
  } else if (e.type === "in") {
    const n = He.get(e.key), s = new N().fromArray(n.out);
    Le.editor.setMotionPathProps(
      {
        mirror: s.is_zero() ? pe.NONE : pe.INDEPENDENT,
        x: -n.in[0],
        y: -n.in[1]
      },
      {
        key: n.id,
        type: "in",
        time: n.time,
        trackId: n.trackId
      },
      { commit: !1, delta: !0 }
    ), Le.selection.removeMotionPoints([e], zd, { commit: !1 });
    const i = Ki.get(e.key);
    Ii.get(e.key).in.copy(i);
  } else if (e.type === "out") {
    const n = He.get(e.key), s = new N().fromArray(n.in);
    Le.editor.setMotionPathProps(
      {
        mirror: s.is_zero() ? pe.NONE : pe.INDEPENDENT,
        x: -n.out[0],
        y: -n.out[1]
      },
      {
        key: n.id,
        type: "out",
        time: n.time,
        trackId: n.trackId
      },
      { commit: !1, delta: !0 }
    ), Le.selection.removeMotionPoints([e], zd, { commit: !1 });
    const i = Ki.get(e.key);
    Ii.get(e.key).out.copy(i);
  }
}
function BS(e, n, s, i) {
  if (e.mirror === pe.ANGLE || e.mirror === pe.ANGLE_AND_LENGTH) {
    const o = new N().fromArray(e.in), a = Math.atan2(s.y, s.x) + Math.PI, c = e.mirror === pe.ANGLE ? o.length() : s.length();
    o.set(Math.cos(a) * c, Math.sin(a) * c), Le.editor.setMotionPathProps(
      {
        mirror: e.mirror,
        x: o.x - e.in[0],
        y: o.y - e.in[1]
      },
      {
        key: e.id,
        type: "in",
        time: e.time,
        trackId: e.trackId
      },
      { commit: !1, delta: !0 }
    );
  }
  Le.editor.setMotionPathProps(
    {
      mirror: e.mirror === pe.NONE ? pe.INDEPENDENT : e.mirror,
      x: s.x - e.out[0],
      y: s.y - e.out[1]
    },
    {
      key: e.id,
      type: "out",
      time: e.time,
      trackId: e.trackId
    },
    { commit: !1, delta: !0 }
  );
  const r = new N().fromArray(n.out);
  if (n.mirror === pe.ANGLE || n.mirror === pe.ANGLE_AND_LENGTH) {
    const o = Math.atan2(i.y, i.x) + Math.PI, a = n.mirror === pe.ANGLE ? r.length() : i.length();
    r.set(Math.cos(o) * a, Math.sin(o) * a), Le.editor.setMotionPathProps(
      {
        mirror: n.mirror,
        x: r.x - n.out[0],
        y: r.y - n.out[1]
      },
      {
        key: n.id,
        type: "out",
        time: n.time,
        trackId: n.trackId
      },
      { commit: !1, delta: !0 }
    );
  }
  Le.editor.setMotionPathProps(
    {
      mirror: n.mirror === pe.NONE ? pe.INDEPENDENT : n.mirror,
      x: i.x - n.in[0],
      y: i.y - n.in[1]
    },
    {
      key: n.id,
      type: "in",
      time: n.time,
      trackId: n.trackId
    },
    { commit: !1, delta: !0 }
  );
}
function p4(e, n, s) {
  const i = [];
  let r, o;
  const a = xr.item.baseTransform.translate;
  if (e === Sr)
    r = gE(0, 0, 0, s.trackIds[0]);
  else if (kS.has(e)) {
    const c = bg.xform(s.points[0]).sub(a);
    r = gE(c.x, c.y, s.times[0], s.trackIds[0]);
  } else
    r = {
      type: "point",
      key: e,
      data: new N().fromArray(He.get(e).pos),
      time: He.get(e).time,
      trackId: He.get(e).trackId
    };
  if (!r) return [];
  if (i.push(r), kS.has(n)) {
    const c = bg.xform(s.points[1]).sub(a);
    o = gE(c.x, c.y, s.times[1], s.trackIds[1]);
  } else
    o = {
      type: "point",
      key: n,
      data: new N().fromArray(He.get(n).pos),
      time: He.get(n).time,
      trackId: He.get(n).trackId
    };
  return o ? (i.push(o), s.keyStart = i[0].key, s.keyEnd = i[1].key, Le.interaction.fire(), oN(Ar.get("id")), i) : [];
}
function gE(e, n, s, i = Sr) {
  const r = "motionPath", o = Ar.get("id"), a = Le.selection.selectedActionId;
  let c = Le.interaction.getPropertyTrackByElementIdAndPropKey(a, o, r);
  if (!c) {
    const p = Le.interaction.getAnimationPreset(i);
    if (!p)
      return null;
    const E = Le.interaction.getElementTrack(p.elementTrackId), g = E.propertyTrackMap.get(r);
    if (c = Le.interaction.getPropertyTrack(g), !c) {
      const T = [r];
      c = Le.interaction._createPropertyTrackRecursive(E, T)[0];
    }
  }
  let l = null;
  l = {
    elementId: o,
    propKey: r,
    value: {
      pos: [e, n]
    },
    delta: !0,
    frameType: BE.EXPLICIT
  };
  const h = {
    ...l,
    time: s
  };
  return {
    type: "point",
    key: Le.interaction.upsertKeyframeToPropertyTrack(c, h).id,
    data: new N(e, n),
    time: s,
    trackId: c.id
  };
}
function E4() {
  Dt(ph), Dt(Eh), Dt(gh), Dt(_h), Dt(lf), Dt(S0), Dt(y0), Dt(C0), Dt(JC), Dt($C), Dt(eN), Dt(tN), Dt(nN);
}
function oN(e) {
  const n = Le.transition.getPropertyKeyframesByElementId(e, "motionPath");
  if (!n || n.length === 0)
    return;
  let s = 0, i = null;
  He.clear(), n[0].time !== 0 && (He.set(Sr, {
    id: Sr,
    trackId: Sr,
    time: 0,
    pos: [0, 0],
    in: [0, 0],
    out: [0, 0],
    mirror: 0,
    prev: null,
    next: n[0].id
  }), i = Sr);
  for (let r = 0; r < n.length; r++) {
    const o = n[r], a = o.id ?? s++;
    o.frameType === 1 ? He.set(a, {
      id: a,
      trackId: o.trackId,
      time: o.time,
      pos: [0, 0],
      in: [0, 0],
      out: [0, 0],
      mirror: 0,
      prev: i,
      next: r < n.length - 1 ? n[r + 1].id : null
    }) : He.set(a, {
      id: a,
      trackId: o.trackId,
      time: o.time,
      pos: o.value.pos,
      in: o.value.in,
      out: o.value.out,
      mirror: o.value.mirror,
      prev: i,
      next: r < n.length - 1 ? n[r + 1].id : null
    }), i = a;
  }
  _s && aN(_s);
}
function g4() {
  if (Le.get("editMode") === Dn.SHAPE || Le.getFeature("editGradient") || Le.get("activeTool") === st.COMMENT || Le.get("mode") !== Rn.ACTION) return;
  const e = Le.selection.get("elements");
  if (e.length !== 1 || (Ug ? (Ar = Le.selection.get("cachedElements")[0], Ar || (Ar = e[0])) : Ar = e[0], !Ar) || (_s = Le.selection.get("motionPoints"), oN(Ar.get("id")), He.size === 0)) return;
  xr = Tn.indexer.getNode(Ar.get("id"));
  const n = xr.item.baseTransform.translate, s = xr.item.transform.parent, i = Pg.copy(s).prepend(Tn.viewport.projectionTransform);
  bg.copy(Pg).affine_inverse();
  const r = new N(), o = new N(), a = i.xform(new N());
  for (const [c, l] of He)
    r.set(l.pos[0], l.pos[1]).add(n), Ki.set(c, i.xform(r)), r.set(l.in[0], l.in[1]), o.set(l.out[0], l.out[1]), Ii.set(c, {
      in: i.xform(r).sub(a),
      out: i.xform(o).sub(a)
    });
  _4(), T4() && (A4(), m4());
}
function _4() {
  const e = Le.selection.get("hoverMotionSegment");
  if (e) {
    const { keyStart: n, keyEnd: s } = e;
    if (!VS(n) || !VS(s))
      return;
    const i = O4(n, s);
    _E(i, qr.HOVER_SEGMENT_WIDTH, qr.HOVER_SEGMENT_COLOR);
    const r = HS(s);
    _E(r, qr.LINE_WIDTH, qr.LINE_COLOR);
  } else {
    const n = HS();
    _E(n, qr.LINE_WIDTH, qr.LINE_COLOR);
  }
}
function T4() {
  return !(!Tn.dataStore.isEditingMode || Tn.dataStore.getFeature("editOrigin") || Tn.dataStore.getFeature("editSelector") || xr.item.locked);
}
function A4() {
  const e = Tn.dataStore.selection.get("hoverMotionPoint");
  for (const [n, s] of Ki) {
    if (n === Sr) continue;
    const i = s, r = Ii.get(n).in, o = Ii.get(n).out;
    let a = e && e.type === "in" && e.key === n ? Eh : ph, c = e && e.type === "out" && e.key === n ? Eh : ph;
    if (He.get(n).selected) {
      for (const l of _s)
        l.key === n && l.type === "in" ? e && e.key === n && e.type === "in" ? a = gh : a = _h : l.key === n && l.type === "out" && (e && e.key === n && e.type === "out" ? c = gh : c = _h);
      Xa.lineStyle(qr.LINE_WIDTH, qr.LINE_COLOR).drawLine(i.x, i.y, i.x + r.x, i.y + r.y).drawLine(i.x, i.y, i.x + o.x, i.y + o.y), Xa.fillStyle(qr.SVG_COLOR).drawImageFromAtlas(a, i.x + r.x, i.y + r.y, 1, 1).drawImageFromAtlas(c, i.x + o.x, i.y + o.y, 1, 1);
    }
  }
}
function m4() {
  for (const [e, n] of Ki) {
    let s = yn && yn.type === "point" && yn.key === e ? eN : JC;
    if (_s) {
      for (const i of _s)
        if (i.key === e && i.type === "point") {
          yn && yn.key === e && yn.type === "point" ? s = tN : s = $C;
          break;
        }
    }
    e === Sr && (s = nN), Xa.fillStyle(16777215).drawImageFromAtlas(s, n.x, n.y, 1, 1);
  }
}
function VS(e) {
  return Ii.has(e) && Ki.has(e);
}
function O4(e, n) {
  const s = Ii.get(e), i = Ii.get(n), r = s.in, o = s.out, a = i.in, c = i.out, l = Ki.get(e), h = Ki.get(n), d = [
    new Fe().initWithPoints(l, r, o),
    new Fe().initWithPoints(h, a, c)
  ], p = new qe();
  return p.addChild(xt.createPath(d, !1)), p;
}
function HS(e = null) {
  const n = new qe();
  let s = [];
  for (const [i, r] of Ki) {
    e && i === e && s.length > 1 && (n.addChild(xt.createPath(s, !1)), s = []);
    const o = Ii.get(i), a = o.in, c = o.out;
    s.push(new Fe().initWithPoints(r, a, c));
  }
  return s.length > 0 && n.addChild(xt.createPath(s, !1)), n;
}
function _E(e, n, s) {
  const i = new ye(0, 0, Tn.viewport.width, Tn.viewport.height), r = e.getBounds();
  if (i.containsRect(r)) {
    const a = cS(e, [4, 2.5], !1).toPathData();
    Xa.lineStyle(n, s).drawPath(0, 0, a);
  } else if (i.intersects(r)) {
    const o = ZF(e, i);
    if (o) {
      const c = cS(o, [4, 2.5], !1).toPathData();
      Xa.lineStyle(n, s).drawPath(0, 0, c);
    }
  }
}
function I4() {
  sN.clear(), Xa.clear(), iN.clear(), Ki.clear(), Ii.clear(), He.clear(), g4();
}
const Bu = new ye(0, 0, 0, 0);
function S4(e) {
  const n = rN.VERT_HALF_BOX_WIDTH, s = Tn.viewport.toScreen(e);
  Bu.set(s.x - n, s.y - n, 2 * n, 2 * n);
  const i = new Map([...Ki.entries()].sort((o, a) => He.get(a[0]).time - He.get(o[0]).time)), r = new Map([...Ii.entries()].sort((o, a) => He.get(a[0]).time - He.get(o[0]).time));
  for (const [o, a] of i)
    if (o !== Sr && Bu.contains(a))
      return {
        type: "point",
        key: o,
        data: new N().fromArray(He.get(o).pos),
        time: He.get(o).time,
        trackId: He.get(o).trackId
      };
  for (const [o, a] of r) {
    if (o === Sr) continue;
    const c = i.get(o).clone().add(a.in);
    if (Bu.contains(c))
      return {
        type: "in",
        key: o,
        data: new N().fromArray(He.get(o).in),
        time: He.get(o).time,
        trackId: He.get(o).trackId
      };
    if (c.copy(i.get(o)).add(a.out), Bu.contains(c))
      return {
        type: "out",
        key: o,
        data: new N().fromArray(He.get(o).out),
        time: He.get(o).time,
        trackId: He.get(o).trackId
      };
  }
  return null;
}
function zd(e, n) {
  for (const s of e)
    if (s.key === n.key && s.type === n.type) return !0;
  return !1;
}
function aN(e) {
  for (const n of e) {
    const s = He.get(n.key);
    if (!s) {
      console.log("The selection data cannot match the motionPathKFs due to not update yet");
      continue;
    }
    switch (s.selected = !0, n.type) {
      case "in": {
        He.has(s.prev) && (He.get(s.prev).selected = !0);
        break;
      }
      case "out": {
        He.has(s.next) && (He.get(s.next).selected = !0);
        break;
      }
      case "point": {
        He.has(s.prev) && (He.get(s.prev).selected = !0), He.has(s.next) && (He.get(s.next).selected = !0);
        break;
      }
    }
  }
}
function y4(e, n, s, i, r, o, a) {
  if (a !== pe.NONE && o === pe.NONE)
    i.copy(e), r.copy(e);
  else if (a === pe.NONE) {
    if (o === pe.ANGLE || o === pe.INDEPENDENT || o === pe.ANGLE_AND_LENGTH) {
      let c, l;
      if (n && s) {
        const h = Sc(n, e, s);
        c = h.e1, l = h.e2, o === pe.ANGLE_AND_LENGTH && C4(c, e, l);
      } else {
        let h, d;
        if (n && !s)
          h = n, d = e;
        else if (!n && s)
          h = e, d = s;
        else {
          console.warn("Invalid motion point");
          return;
        }
        const p = new N();
        if (p.copy(d).sub(h), p.equals(N.ZERO))
          p.set(-10, 0), console.log("vector of the edge is zero when calculate the control point");
        else {
          const E = p.length();
          p.scale(1 / E), h.equals(d) && ([p.x, p.y] = [p.y, -p.x]), p.scale(E * 0.2);
        }
        c = new N().copy(e).sub(p), l = new N().copy(e).add(p);
      }
      i.copy(c), r.copy(l);
    }
  } else if (a === pe.ANGLE && o === pe.ANGLE_AND_LENGTH) {
    const h = TE(i, e, r, o);
    i.copy(h[0]), r.copy(h[1]);
  } else if (a === pe.INDEPENDENT && o === pe.ANGLE_AND_LENGTH) {
    const h = TE(i, e, r, o);
    i.copy(h[0]), r.copy(h[1]);
  } else if (a === pe.INDEPENDENT && o === pe.ANGLE) {
    let c = 0;
    if (e.equals(i)) {
      const h = n, d = s, { e1: p } = Sc(h, e, d);
      c = Math.sqrt(Math.pow(p.x - e.x, 2) + Math.pow(p.y - e.y, 2)), i.copy(p);
    } else if (e.equals(r)) {
      const h = n, d = s, { e2: p } = Sc(h, e, d);
      c = Math.sqrt(Math.pow(p.x - e.x, 2) + Math.pow(p.y - e.y, 2)), r.copy(p);
    }
    const l = TE(i, e, r, o, c);
    i.copy(l[0]), r.copy(l[1]);
  }
}
function C4(e, n, s) {
  let i = e.x - n.x, r = e.y - n.y, o = s.x - n.x, a = s.y - n.y;
  const c = Math.sqrt(i * i + r * r), l = Math.sqrt(o * o + a * a);
  c < l ? (i = i / c * l, r = r / c * l, e.x = n.x + i, e.y = n.y + r) : (o = o / l * c, a = a / l * c, s.x = n.x + o, s.y = n.y + a);
}
function TE(e, n, s, i, r = 0) {
  const o = new N();
  o.copy(n).sub(e);
  const a = new N();
  a.copy(n).sub(s);
  let c, l, h;
  const d = o.length(), p = a.length();
  d < p ? (c = s, l = e, h = i === pe.ANGLE_AND_LENGTH ? p : d) : (c = e, l = s, h = i === pe.ANGLE_AND_LENGTH ? d : p), h < 1e-5 && (h = r), o.copy(c).sub(n), o.x = -1 * (c.x - n.x), o.y = -1 * (c.y - n.y), o.normalize(), o.scale(h);
  const E = new N();
  return E.copy(n).add(o), l === e ? [E, c] : [c, E];
}
function N4(e, { commit: n = !0 } = {}) {
  const s = xr.item.baseTransform.translate;
  for (const i of _s)
    cN(i, s, e);
  n && Le.commitUndo();
}
function cN(e, n, s) {
  const i = He.get(e.key), r = new N().fromArray(i.pos).add(n), o = i.prev ? new N().fromArray(He.get(i.prev).pos).add(n) : null, a = i.next ? new N().fromArray(He.get(i.next).pos).add(n) : null, c = new N().fromArray(i.in), l = new N().fromArray(i.out);
  y4(r, o, a, c.add(r), l.add(r), s, i.mirror), Le.editor.setMotionPathProps(
    {
      mirror: s,
      x: c.x,
      y: c.y
    },
    {
      key: e.key,
      type: "in",
      time: e.time,
      trackId: e.trackId
    },
    { commit: !1, delta: !1 }
  ), Le.editor.setMotionPathProps(
    {
      mirror: s,
      x: l.x,
      y: l.y
    },
    {
      key: e.key,
      type: "out",
      time: e.time,
      trackId: e.trackId
    },
    { commit: !1, delta: !1 }
  );
}
function x4(e) {
  const n = rN.VERT_HALF_BOX_WIDTH, s = [...Ki.entries()];
  s.sort((c, l) => {
    const h = He.get(c[0]).time, d = He.get(l[0]).time;
    return h - d;
  });
  const i = [], r = [];
  for (const [c, l] of s)
    r.push(c), i.push(l);
  let o = 1 / 0, a = null;
  for (let c = 0; c < i.length - 1; c++) {
    const l = r[c], h = r[c + 1], d = i[c], p = i[c + 1], E = Ii.get(l), g = Ii.get(h), T = d.clone(), A = p.clone();
    E && T.add(E.out), g && A.add(g.in);
    let m = 1 / 0, O = -1;
    if (R4(d, T, A, p)) {
      const S = w4(e, d, p);
      m = S.distance, O = S.t;
    } else {
      const S = v4(d, T, A, p, e);
      m = S.d, O = S.t;
    }
    m < o && (o = m, a = {
      points: [d, p],
      times: [He.get(l).time, He.get(h).time],
      t: O,
      // Parameter t of the closest point on the line segment
      keyStart: l,
      keyEnd: h,
      trackIds: [He.get(l).trackId, He.get(h).trackId]
    });
  }
  return o > n ? null : a;
}
function v4(e, n, s, i, r) {
  return Tr.points[0].x = e.x, Tr.points[0].y = e.y, Tr.points[1].x = n.x, Tr.points[1].y = n.y, Tr.points[2].x = s.x, Tr.points[2].y = s.y, Tr.points[3].x = i.x, Tr.points[3].y = i.y, Tr.update(), Tr.project(r);
}
function R4(e, n, s, i) {
  return WS(e, i, n) && WS(e, i, s);
}
function WS(e, n, s) {
  const i = (n.y - e.y) * (s.x - e.x) - (n.x - e.x) * (s.y - e.y);
  return Math.abs(i) < 1e-6;
}
function w4(e, n, s) {
  const i = e.x, r = e.y, o = n.x, a = n.y, c = s.x, l = s.y, h = c - o, d = l - a, p = h * h + d * d;
  if (p === 0)
    return { distance: Math.hypot(i - o, r - a), t: 0 };
  let E = ((i - o) * h + (r - a) * d) / p;
  E = Math.max(0, Math.min(1, E));
  const g = o + E * h, T = a + E * d;
  return { distance: Math.hypot(i - g, r - T), t: E };
}
function D4(e) {
  kl = e;
}
function L4(e, n, s, i, r, o = 0.01) {
  const a = 3 * (1 - e) * (1 - e) * e, c = 3 * (1 - e) * e * e, l = a * a + o, h = a * c, d = c * c + o, p = a * n, E = c * n, g = a * s, T = c * s, A = l * d - h * h;
  if (Math.abs(A) < 1e-8)
    throw new Error("Determinant is zero or near zero; cannot solve the system uniquely.");
  const m = (p * d - h * E) / A, O = (l * E - h * p) / A, S = (g * d - h * T) / A, y = (l * T - h * g) / A;
  return { deltaP1: new N(m, S), deltaP2: new N(O, y) };
}
const Bl = 8, ao = 1863400, $s = 16777215, Gg = 64, M4 = 12, fs = {
  nameMaxLength: 180,
  tagPadding: 6,
  tagHeight: 20,
  tagCornerRadius: 6,
  tagBorderWidth: 1,
  tagBorderOpacity: 0.1,
  tagBorderColor: 0,
  tagOffset: new N(10, 16),
  selectionWidth: 2
};
let uf = !0, df = !0, v0 = !1;
const ti = new Ce(), Kd = new Ce(), mi = new N(), AE = new N(), Mo = qe.create(), Vu = new Vs();
let q;
const ce = {
  /** @type {Pane} */
  highlightBbox: null,
  /** @type {Pane} */
  presenceCursor: null,
  /** @type {Pane} */
  presenceSelection: null,
  /** @type {Pane} */
  selection: null,
  /** @type {Pane} */
  handles: null,
  /** @type {Pane} */
  gradientHandles: null,
  /** @type {Pane} */
  gradientHandlesCover: null,
  /** @type {Pane} */
  text: null,
  /** @type {Pane} */
  selectionArea: null,
  /** @type {Pane} */
  snapping: null,
  /** @type {Pane} */
  snappingSpacing: null,
  /** @type {Pane} */
  guidelines: null,
  /** @type {Pane} */
  debug: null
};
let Fg = !1, kg = !1;
const P4 = /* @__PURE__ */ new Set();
function b4(e) {
  W4(), q = e;
  let n = 0;
  LB(q, n++), PB(q, n++), ce.presenceSelection = q.overlay.createPane(n++), ce.highlightBbox = q.overlay.createPane(n++), ce.snappingSpacing = q.overlay.createPane(n++), ce.selection = q.overlay.createPane(n++), ce.handles = q.overlay.createPane(n++), ce.gradientHandles = q.overlay.createPane(n++), ce.gradientHandlesCover = q.overlay.createPane(n++), ce.text = q.overlay.createPane(n++), $B(q, n++, n++, n++, n++), d4(q, n++, n++, n++), ce.selectionArea = q.overlay.createPane(n++), ce.snapping = q.overlay.createPane(n++), ce.guidelines = q.overlay.createPane(n++), ce.presenceCursor = q.overlay.createPane(n++), ce.debug = q.overlay.createPane(n++), YB(q, n++), UB(q, n++), ce.editOrigin = q.overlay.createPane(n++), $4(), q.dataStore.eam.on(Y.TOGGLE_INTERFACE, () => {
    kg = !kg;
  }), q.dataStore.eam.on(Y.TOGGLE_RULER, () => {
    Fg = !Fg;
  });
}
function U4() {
  uf = !0, Rg(), q.dataStore.isEditingMode && Rg();
}
function G4() {
  df = !0, zC();
}
function F4() {
  uf = !1, bB();
}
function k4() {
  df = !1, MB();
}
function B4() {
  return df;
}
function V4() {
  return uf;
}
function H4() {
  v0 = !0;
}
function W4() {
  window.__Panes__ || (window.__Panes__ = {
    setUIScreenNameEnabled: U4,
    setUIGridEnabled: G4,
    setUIScreenNameDisabled: F4,
    setUIGridDisabled: k4,
    getUIGridEnabled: B4,
    getUIScreenNameEnabled: V4,
    setOriginEnable: H4
  });
}
function Y4() {
  Fk(), P4.clear(), df && zC(), uf && q.dataStore.isEditingMode && !q.dataStore.isTableView && Rg(), TV(), K4(), q.dataStore.get("activeTool") !== st.COMMENT && (tV(), X4(), q.dataStore.selection.get("textRange") === null && (ce.handles.clear().lineStyle(1.5, ao).fillStyle(16777215), Q4() && (Z4(), q4()))), J4(), z4(), eV(), o4(), q.dataStore.getFeature("editSelector") || I4(), uV(), EV(), KB(), Fg || kg || !q.dataStore.isEditingMode && !q.dataStore.isInspectingMode || q.dataStore.isPrototypeMode ? VB() : (BB(), ce.guidelines.clear(), KC(q, ce.guidelines)), v0 = q.dataStore.getFeature("editOrigin");
}
function X4() {
  if (ce.selection.clear().lineStyle(1.5, ao), Qd) return;
  const e = q.dataStore.get("editMode"), n = q.dataStore.get("activeTool"), s = q.dataStore.getFeature("editGradient");
  if (!(e === Dn.SHAPE || s)) {
    if (q.selection.containsMultiple)
      if (n === st.SCALE) {
        for (const { element: i, node: r } of q.selection.iter())
          i.isLineElement() || Bg(ce.selection, i, r);
        for (const { element: i, node: r } of q.selection.iter())
          jl(ce.selection, i, r);
      } else {
        const i = q.selection.bounds.clone(), { width: r, height: o } = i, a = ea(r), c = ea(o);
        if (a === "f0" && (i.width = 0, i.x += r * 0.5), c === "f0" && (i.height = 0, i.y += o * 0.5), Fa(ce.selection, i), a === "!0" && c === "!0")
          for (const { element: l, node: h } of q.selection.iter())
            jl(ce.selection, l, h);
      }
    else if (q.selection.single) {
      const { element: i, node: r } = q.selection.single;
      jl(ce.selection, i, r), !Qd && !i.isLineElement() && Bg(ce.selection, i, r);
    }
  }
}
function z4() {
  if (q.snapping.updateThreshold(q.viewport.scale), ce.snapping.clear().lineStyle(1, 16711680), !q.snapping.isSnappingUIDataDirty()) return;
  const e = ti.reset().prepend(q.viewport.projectionTransform);
  if (ce.snapping.appendTransform(e), q.snapping.axisDiagonalCount > 0) {
    const c = (q.viewport.width + q.viewport.height) * 2, l = new N(), h = new N();
    for (let d = 0; d < q.snapping.axisDiagonalCount; d++)
      l.copy(q.snapping.axisDiagonalVec[d]).scale(c).add(q.snapping.startOrigin), h.copy(q.snapping.axisDiagonalVec[d]).scale(c).negate().add(q.snapping.startOrigin), ce.snapping.drawLine(l.x, l.y, h.x, h.y);
  }
  const n = q.snapping.snapToElementXUI, s = q.snapping.snapToElementYUI, r = 3 / e.get_scale().x;
  let o = 16777215, a = -16777215;
  if (n.size > 0)
    for (const [c, l] of n.entries()) {
      o = 16777215, a = -16777215;
      for (const [h] of l.entries())
        o = o > h ? h : o, a = a > h ? a : h, ce.snapping.drawLine(
          c - r,
          h - r,
          c + r,
          h + r
        ), ce.snapping.drawLine(
          c + r,
          h - r,
          c - r,
          h + r
        );
      ce.snapping.drawLine(c, o, c, a);
    }
  if (s.size > 0)
    for (const [c, l] of s.entries()) {
      o = 16777215, a = -16777215;
      for (const [h] of l.entries())
        o = o > h ? h : o, a = a > h ? a : h, ce.snapping.drawLine(
          h - r,
          c - r,
          h + r,
          c + r
        ), ce.snapping.drawLine(
          h + r,
          c - r,
          h - r,
          c + r
        );
      ce.snapping.drawLine(o, c, a, c);
    }
  ce.snapping.resetTransform();
}
function K4() {
  if (!q.snapping.isSnappingUIDataDirty()) return;
  const e = ti.reset().prepend(q.viewport.projectionTransform);
  ce.snappingSpacing.clear(), ce.snappingSpacing.appendTransform(e);
  const n = q.snapping.spacingAreaUIMap, s = q.snapping.spacingVerticalVec, i = q.snapping.spacingHorizontalVec, r = q.snapping.spacingVertical, o = q.snapping.spacingHorizontal;
  ce.snappingSpacing.fillStyle(16711680, 0.2);
  for (const h of n.values())
    ce.snappingSpacing.drawSolidRect(h.x, h.y, h.width, h.height);
  if (ce.snappingSpacing.resetTransform(), !o && !r) return;
  const a = 3 * q.viewport.pixelRatio / q.viewport.scale, c = new N(), l = new N();
  ce.snappingSpacing.lineStyle(1, 14437212), o && (c.set(i.x, i.y), l.set(i.x + o, i.y), q.viewport.projectionTransform.xform(c, c), q.viewport.projectionTransform.xform(l, l), ce.snappingSpacing.drawLine(c.x, c.y, l.x, l.y), c.set(i.x, i.y - a), l.set(i.x, i.y + a), q.viewport.projectionTransform.xform(c, c), q.viewport.projectionTransform.xform(l, l), ce.snappingSpacing.drawLine(c.x, c.y, l.x, l.y), c.set(i.x + o, i.y - a), l.set(i.x + o, i.y + a), q.viewport.projectionTransform.xform(c, c), q.viewport.projectionTransform.xform(l, l), ce.snappingSpacing.drawLine(c.x, c.y, l.x, l.y), c.set(i.x + o * 0.5, i.y), q.viewport.projectionTransform.xform(c, c), YS(c.x, c.y, o, !0)), r && (c.set(s.x, s.y), l.set(s.x, s.y + r), q.viewport.projectionTransform.xform(c, c), q.viewport.projectionTransform.xform(l, l), ce.snappingSpacing.drawLine(c.x, c.y, l.x, l.y), c.set(s.x - a, s.y), l.set(s.x + a, s.y), q.viewport.projectionTransform.xform(c, c), q.viewport.projectionTransform.xform(l, l), ce.snappingSpacing.drawLine(c.x, c.y, l.x, l.y), c.set(s.x - a, s.y + r), l.set(s.x + a, s.y + r), q.viewport.projectionTransform.xform(c, c), q.viewport.projectionTransform.xform(l, l), ce.snappingSpacing.drawLine(c.x, c.y, l.x, l.y), c.set(s.x, s.y + r * 0.5), q.viewport.projectionTransform.xform(c, c), YS(c.x, c.y, r, !1));
}
function YS(e, n, s, i) {
  const r = s.toString(), o = 9, a = 4, c = 4.5, l = 2, h = new N().fromArray(ce.snappingSpacing.measureTextImage(r, o, "left", "top"));
  if (i) {
    const d = e - h.x * 0.5 - l, p = n + c, E = h.x + l * 2, g = h.y + l * 2;
    ce.snappingSpacing.fillStyle(14437212, 1).drawSolidRectTexture(d, p, E, g, a);
    const T = d + l, A = p + (g - h.y) * 0.5;
    ce.snappingSpacing.fillStyle($s, 1).drawTextImage(T, A, r, {
      fontSize: o,
      h_align: "left",
      v_align: "top"
    });
  } else {
    const d = e - h.x - c - l * 2, p = n - h.y * 0.5 - l, E = h.x + l * 2, g = h.y + l * 2;
    ce.snappingSpacing.fillStyle(14437212, 1).drawSolidRectTexture(d, p, E, g, a);
    const T = d + l, A = p + (g - h.y) * 0.5;
    ce.snappingSpacing.fillStyle($s, 1).drawTextImage(T, A, r, {
      fontSize: o,
      h_align: "left",
      v_align: "top"
    });
  }
}
const yl = (e, n, s = 0) => {
  const i = e.xform(n);
  Kd.reset().rotate(s).translate(i.x, i.y), ce.handles.appendTransform(Kd), ce.handles.drawSolidRect(-8 * 0.5, -8 * 0.5, Bl, Bl).drawRect(-8 * 0.5, -8 * 0.5, Bl, Bl), ce.handles.resetTransform();
}, XS = (e, n, s, i) => {
  if (i && i.item.isEmpty) {
    const a = e.xform(n.center);
    Kd.reset().translate(a.x, a.y), ce.handles.appendTransform(Kd), ce.handles.drawEllipseShadow(0, 0, 2, 2), ce.handles.resetTransform();
    return;
  }
  const r = s && !s.get("locked"), o = q.selection.all((a) => a.element.isLocked());
  if ((r || !s) && !o) {
    const a = i ? i.item.transform.saveWorld.get_rotation() : 0;
    s && s.isLineElement() ? j4(s, e, yl, n, a) : (yl(e, mi.set(n.left, n.top), a), yl(e, mi.set(n.left, n.bottom), a), yl(e, mi.set(n.right, n.top), a), yl(e, mi.set(n.right, n.bottom), a));
  }
};
function Q4() {
  return !(Qd || !q.dataStore.selection.get("elements").length || q.dataStore.getFeature("editGradient") || q.dataStore.get("editMode") !== Dn.ELEMENT && q.dataStore.get("editMode") !== Dn.MOTION_PATH || q.dataStore.getFeature("editSelector"));
}
function Z4() {
  if (!q.dataStore.get("hideOrigin"))
    for (const { element: e, node: n } of q.selection.iter()) {
      const s = e.isLocked(), i = e.get("elementType") === Me.SCREEN, r = e.get("id") === w0;
      if (!i)
        if (v0 && !s) {
          const o = r ? FC : GC;
          zS(ce.handles, n, o, 1, 1);
        } else
          zS(ce.handles, n, kC, 0.5, 1);
    }
}
function q4() {
  if (!q.dataStore.isEditingMode) return;
  let e;
  if (q.dataStore.get("activeTool") === st.SCALE)
    for (const n of q.selection.iter()) {
      if (e = n.node.boundsLocal_zero, wc(e, n.node.item.transform.world)) continue;
      ti.copy(n.node.item.transform.world);
      const i = ti.prepend(q.viewport.projectionTransform);
      XS(i, e, n.element, n.node);
    }
  else {
    const n = q.selection.single;
    if (n === null) {
      ti.reset(), e = q.selection.bounds.clone();
      const { width: i, height: r } = q.selection.bounds, o = ea(i), a = ea(r);
      o === "f0" && (e.width = 0, e.x += i * 0.5), a === "f0" && (e.height = 0, e.y += r * 0.5);
    } else
      ti.copy(n.node.item.transform.world), e = n.node.boundsLocal_zero.clone();
    if (!wc(e, ti)) {
      const i = ti.prepend(q.viewport.projectionTransform);
      XS(i, e, n == null ? void 0 : n.element, n == null ? void 0 : n.node);
    }
  }
}
function j4(e, n, s, i, r = 0) {
  const o = e.get("geometry").get("mesh"), a = o.edges.values().next().value, c = o.getVertPos(a.v.id), l = o.getVertPos(a.w.id), h = Math.sign(l.x - c.x), d = Math.sign(l.y - c.y);
  h * d > 0 ? (s(n, mi.set(i.left, i.top), r), s(n, mi.set(i.right, i.bottom), r)) : (s(n, mi.set(i.right, i.top), r), s(n, mi.set(i.left, i.bottom), r));
}
const Cl = new N(), Nl = new N(), mE = new Ce();
function wc(e, n) {
  const s = Bl / q.viewport.projectionTransform.a;
  Cl.set(e.width, 0), Nl.set(0, e.height), mE.copy(n).rotate(-n.get_rotation()), mE.basis_xform(Cl, Cl), mE.basis_xform(Nl, Nl);
  const i = Math.abs(Cl.x) < Qt && Math.abs(Nl.y) < Qt, r = Math.abs(Cl.x) <= s + 1e-6 && Math.abs(Nl.y) <= s + 1e-6;
  return !i && r;
}
function zS(e, n, s, i, r) {
  e.fillStyle(16777215, r);
  const o = n.item.transform.worldPivot;
  q.viewport.projectionTransform.xform(o, o), e.drawImageFromAtlas(s, o.x, o.y, i, i);
}
let sn = null;
function KS(e) {
  sn = e;
}
function J4() {
  if (ce.gradientHandles.clear(), ce.gradientHandlesCover.clear(), !sn)
    return;
  const e = sn.getGradientTransform();
  if (!e)
    return;
  const n = q.selection.first, s = q.dataStore.getFeature("editGradient");
  if (n === null || !s || !sn || !q.selection.single) return;
  const i = new N();
  let r, o;
  if (n.element.get("elementType") === Me.PATH && n.element.get("geometryType") === mn.LINE) {
    const { x: y, y: v, width: R, height: M } = n.node.boundsVisualLocal;
    o = new N(R, M), r = new N(-y, -v);
  } else {
    const { width: y, height: v } = n.node.boundsLocal;
    o = new N(y, v), r = m0(n);
  }
  const c = ti.set(...e).affine_inverse().scale(o.x, o.y).translate(-r.x, -r.y).prepend(n.node.item.transform.world).prepend(q.viewport.projectionTransform);
  ce.gradientHandles.appendTransform(c);
  const l = ce.gradientHandles.transform.xform(sn.bottom), h = q.viewport.toWorld(l), d = ce.gradientHandles.transform.xform(sn.center), p = q.viewport.toWorld(d), E = ce.gradientHandles.transform.xform(sn.left), g = q.viewport.toWorld(E);
  i.x = g.distance_to(p) / (0.5 * o.x), i.y = h.distance_to(p) / (0.5 * o.y);
  const T = ce.gradientHandles.transform.clone(), A = ti.reset().affine_inverse().prepend(q.viewport.projectionTransform);
  if (ce.gradientHandles.transform.copy(A), ce.gradientHandlesCover.transform.copy(A), sn.isLinear && (i.y *= 0.5, i.x = i.y), sn.isAngular) {
    ce.gradientHandles.transform.copy(T);
    const y = new Ce().set(...sn.getGradientTransform()).decompose(), v = y.scale.sign(), R = n.node.item.transform.world.get_rotation() - (y.rotation + Math.PI * 0.5);
    ce.gradientHandles.lineStyle(sn.referenceSize, $s).drawEllipseShadow(
      sn.center.x,
      sn.center.y,
      v.x,
      v.y,
      R
    ).lineStyle(sn.referenceSize, $s), ce.gradientHandles.transform.copy(A);
  } else
    ce.gradientHandles.lineStyle(sn.referenceSize * 2, $s).drawLineShadow(p.x, p.y, h.x, h.y).lineStyle(sn.referenceSize, $s).drawLine(p.x, p.y, h.x, h.y).lineStyle(sn.referenceSize, $s);
  sn.isLinear || OE(g), OE(h), OE(p);
  const m = sn.getGradientStops(), O = sn.activeGradientStopIdx;
  ce.gradientHandles.lineStyle(sn.stopOutlineSize, $s);
  const S = new N();
  for (let y = m.length - 1; y >= 0; y--)
    y !== O && QS(m[y], S, sn.stopSize, T);
  ce.gradientHandles.lineStyle(sn.activeStopOutlineSize, $s), m[O] && QS(m[O], S, sn.activeStopSize, T), ce.gradientHandles.resetTransform(), ce.gradientHandlesCover.resetTransform();
}
function $4() {
  Dt(kC), Dt(GC), Dt(FC), Dt(DB), Dt(BC), Dt(VC), Dt(HC), Dt(WC), Dt(YC), Dt(XC);
}
const OE = (e) => {
  const s = 1 / q.viewport.scale * sn.handleSize / Gg;
  ce.gradientHandles.fillStyle($s).drawImageFromAtlas(WC, e.x, e.y, s, s);
};
function QS(e, n, s, i) {
  sn.getColorStopPos(e.position, n);
  const r = i.xform(n), o = q.viewport.toWorld(r), a = 1 / q.viewport.scale, c = a * s / Gg, l = a * s / M4, h = a * s / Gg;
  ce.gradientHandles.fillStyle($s).drawImageFromAtlas(VC, o.x, o.y, h, h).drawImageFromAtlas(BC, o.x, o.y, l, l).fillStyle(g0(e.color), e.color.a).drawImageFromAtlas(HC, o.x, o.y, c, c), ce.gradientHandles.lineStyle(sn.referenceSize, $s).drawEllipseShadow(o.x, o.y, a * s, a * s, !0, !0);
}
function eV() {
  if (ce.text.clear(), document.activeElement.id !== "input") return;
  const e = q.dataStore.selection.get("textRange");
  e && (e.start === e.end ? cV(ce.text) : aV(ce.text)), ce.text.resetTransform();
}
function tV() {
  ce.highlightBbox.clear(), q.view instanceof I0 && (nV(), sV()), iV(), rV();
}
function nV() {
  const e = q.view;
  for (const n of e.cells)
    for (const s of n)
      ce.highlightBbox.lineStyle(1, 65535), Fa(ce.highlightBbox, s.worldBounds), ce.highlightBbox.fillStyle(16777215, 0.1), ce.highlightBbox.transform.copy(q.viewport.projectionTransform), ce.highlightBbox.drawSolidRect(s.worldBounds.x, s.worldBounds.y, s.worldBounds.w, e.padding), ce.highlightBbox.drawSolidRect(s.worldBounds.x, s.worldBounds.y + s.worldBounds.h - e.padding, s.worldBounds.w, e.padding), ce.highlightBbox.drawSolidRect(s.worldBounds.x, s.worldBounds.y + e.padding, e.padding, s.worldBounds.h - 2 * e.padding), ce.highlightBbox.drawSolidRect(s.worldBounds.x + s.worldBounds.w - e.padding, s.worldBounds.y + e.padding, e.padding, s.worldBounds.h - 2 * e.padding), ce.highlightBbox.fillStyle(16777215, 1).drawTextImage(
        s.worldBounds.x + 15,
        s.worldBounds.y + 15,
        s.actionName || "Design",
        {
          font: "Inter",
          fontSize: 12,
          h_align: "left",
          v_align: "top"
        }
      ), ce.highlightBbox.resetTransform();
}
function sV() {
  ce.highlightBbox.lineStyle(2, 16711680);
  const n = q.view.activeCell;
  if (!n) return;
  const { x: s, y: i, width: r, height: o } = n.worldBounds, a = 10, c = new ye(s + a, i + a, r - 2 * a, o - 2 * a);
  Fa(ce.highlightBbox, c);
}
function iV() {
  ce.highlightBbox.lineStyle(2, ao);
  const e = q.dataStore.selection;
  let n = e.get("hover");
  if ((!n || e.isSelected(n)) && (n = e.get("elements").find((i) => i.get("id") === w0), ce.highlightBbox.lineStyle(3, ao)), !n) return;
  const s = q.indexer.getNode(n.get("id"));
  Ge(s) || jl(ce.highlightBbox, n, s);
}
function rV() {
  ce.highlightBbox.lineStyle(2, ao);
  const n = q.dataStore.selection.get("dragOver");
  if (!n) return;
  const s = q.indexer.getNode(n.get("id"));
  Ge(s) || jl(ce.highlightBbox, n, s);
}
function jl(e, n, s = q.indexer.getNode(n.get("id"))) {
  var r;
  if (Ge(s)) return;
  const i = n.get("elementType");
  if (n.isLineElement())
    ZS(e, n, s);
  else if (s.item.type === "text" && (((r = q.selection.single) == null ? void 0 : r.element) !== n || q.dataStore.selection.get("textRange") === null))
    oV(e, s);
  else if (s.item.sizeFlag.w === "f0") {
    const o = s.boundsLocal_zero.clone();
    o.width = 0, Fa(e, o, s.item.transform.world);
  } else if (s.item.sizeFlag.h === "f0") {
    const o = s.boundsLocal_zero.clone();
    o.height = 0, Fa(e, o, s.item.transform.world);
  } else
    i === Me.PATH || n.isContainer && n.isComputedGroup ? ZS(e, n, s) : Fa(e, s.boundsLocal_zero, s.item.transform.world);
}
function ZS(e, n, s) {
  const i = ti.copy(s.item.transform.world).prepend(q.viewport.projectionTransform);
  let r = null;
  if (s.item.isBooleanGroup() || s.item.isMaskGroup()) {
    const o = s.item;
    r = (o.base.modVector || o.base.vector).path;
  } else if (n.get("geometryType") === mn.POLYGON || n.get("geometryType") === mn.LINE) {
    const o = n.get("geometry").get("mesh");
    r = _d(o);
  } else {
    const o = s.item;
    r = o.base.mods[1] && o.base.mods[1][2].toPathData() || o.base.vector.path;
  }
  if (r) {
    Vu.commands = r.commands, Vu.vertices = [];
    for (let o = 0; o < r.vertices.length / 2; o++)
      i.xform(mi.set(r.vertices[o * 2], r.vertices[o * 2 + 1]), AE), Vu.vertices.push(AE.x, AE.y);
    e.drawPath(0, 0, Vu);
  }
}
function Bg(e, n, s) {
  let i = s;
  if (!s && n && (i = q.indexer.getNode(n.get("id"))), s) {
    const r = i.boundsLocal_zero.clone();
    Fa(e, r, i.item.transform.world);
  }
}
function oV(e, n) {
  const i = q.view.getOrCreateDinoTree(n.id).text_node_id;
  if (!i) return;
  const r = OC(i);
  if (r === 0) return;
  const o = Lk(i), a = ti.copy(n.item.transform.world).prepend(q.viewport.projectionTransform);
  let c = 0;
  for (let l = 0; l < r; l++) {
    const h = a.xform(new N(o[c++], o[c++])), d = a.xform(new N(o[c++], o[c++]));
    e.drawLine(
      h.x,
      h.y,
      d.x,
      d.y
    );
  }
}
function aV(e) {
  const n = q.selection.single.node;
  if (!n) return;
  const s = q.dataStore.getById(n.id).get("size").width;
  e.clear().lineStyle(2, ao).fillStyle(ao, 0.4);
  const r = q.view.getOrCreateDinoTree(n.id).text_node_id;
  if (!r || OC(r) === 0) return;
  const a = Mk(r), c = Math.floor(a[0]);
  if (c === 0) return;
  e.transform.copy(n.item.transform.world).prepend(q.viewport.projectionTransform);
  let l = 1;
  for (let h = 0; h < c; h++) {
    const d = new ye(
      a[l++],
      a[l++],
      a[l++],
      a[l++]
    );
    e.drawSolidRect(
      d.x,
      d.y,
      s < d.width ? s : d.width,
      d.height
    );
  }
  e.transform.reset();
}
function cV(e) {
  const n = Pk();
  if (!n || !q.dataStore.selection.get("textRange")) return;
  const s = q.indexer.getNode(q.view.getParent(n));
  if (!s) return;
  const i = s.item.fillLayers.length === 1 && s.item.fillLayers[0].paint.type === 0 ? g0(s.item.fillLayers[0].paint.params.fill_color) : 0;
  e.clear().lineStyle(1.75, i).fillStyle(i, 1);
  const r = bk();
  e.transform.copy(s.item.transform.world).prepend(q.viewport.projectionTransform), e.drawLine(r[0], r[1], r[2], r[3]), e.transform.reset();
}
function Fa(e, n, s = Ce.IDENTITY) {
  const i = ti.copy(s).prepend(q.viewport.projectionTransform), r = i.xform(mi.set(n.x, n.y)), o = i.xform(mi.set(n.x + n.width, n.y)), a = i.xform(mi.set(n.x, n.y + n.height)), c = i.xform(mi.set(n.x + n.width, n.y + n.height));
  qe.destroy(Mo), Mo.moveTo(r.x, r.y), Mo.lineTo(o.x, o.y), Mo.lineTo(c.x, c.y), Mo.lineTo(a.x, a.y), Mo.lineTo(r.x, r.y), Mo.close(), e.drawPath(0, 0, Mo.toPathData());
}
let sr, R0;
function lV(e, n = !0) {
  sr = e, R0 = n;
}
function hV() {
  sr = null, R0 = null;
}
function uV() {
  if (ce.selectionArea.clear().lineStyle(1, ao).fillStyle(ao, 0.25), sr) {
    const e = ti.reset().prepend(q.viewport.projectionTransform);
    ce.selectionArea.appendTransform(e), R0 ? ce.selectionArea.drawSolidRect(sr.x, sr.y, sr.width, sr.height) : ce.selectionArea.drawRect(sr.x, sr.y, sr.width, sr.height), ce.selectionArea.resetTransform();
  }
}
let w0 = null, Qd = !1;
function dV(e) {
  w0 = e;
}
function IE(e) {
  Qd = e;
}
const Oa = /* @__PURE__ */ new Map(), fV = 60;
function pV() {
  const e = window.PresenceManager.tabId, n = window.PresenceManager.getUsers().filter((i) => i.tabId !== e), s = (/* @__PURE__ */ new Date()).getTime();
  for (const i of n)
    if (!Oa.has(i.tabId) && i.cursor) {
      const r = q.viewport.toScreen(new N().copy(i.cursor));
      Oa.set(i.tabId, { pos: r, prev: new N().copy(i.cursor), curr: new N().copy(i.cursor), timer: s, ratio: 0, done: !0 });
    } else if (Oa.has(i.tabId) && !i.cursor)
      Oa.delete(i.tabId);
    else if (Oa.has(i.tabId) && i.cursor) {
      const r = Oa.get(i.tabId), o = q.viewport.toScreen(r.curr), a = q.viewport.toScreen(r.prev);
      if (r.prev.equals(r.curr))
        r.pos = q.viewport.toScreen(r.curr);
      else if (!r.done) {
        const c = s - r.timer;
        r.timer = s, r.ratio += c / fV, r.done = r.ratio >= 1;
        const l = Math.min(Math.max(r.ratio, 0), 1);
        r.pos.x = (1 - l) * a.x + l * o.x, r.pos.y = (1 - l) * a.y + l * o.y;
        continue;
      }
      r.pos = o, r.prev = r.curr, r.timer = s, r.curr = new N().copy(i.cursor), r.ratio = 0, r.done = !1;
    }
}
function EV() {
  pV();
  const e = window.PresenceManager.isPresenceShow, n = q.dataStore.isVersionPreviewMode, s = q.dataStore.isPrototypeMode;
  if (n || !n && !e || s) return;
  const i = window.PresenceManager.tabId, o = window.PresenceManager.getUsers().filter((a) => a.tabId !== i);
  o.length !== 0 && (gV(i) || o.forEach((a) => _V(a)));
}
function gV(e) {
  return window.PresenceManager.users.has(e) && q.dataStore.get("mode") === Rn.ACTION;
}
function _V({ user: e, cursor: n, mode: s, tabId: i, color: r, idleTime: o, isVersionPreviewMode: a }) {
  if (!e || !n || s === Rn.ACTION || o || a) return;
  const c = Oa.get(i).pos, l = (parseInt(r.substring(1), 16) << 8) / 256;
  ce.presenceCursor.transform.clone(ce.selection.transform), AV(c, l), mV(c, e.username, l);
}
function TV() {
  const e = q.dataStore.isVersionPreviewMode, n = window.PresenceManager.isPresenceShow;
  if (e || !e && !n) return;
  const s = window.PresenceManager.tabId, r = window.PresenceManager.getUsers().filter((o) => o.tabId !== s);
  if (r.length !== 0)
    for (let o = 0; o < r.length; ++o) {
      const a = r[o];
      if (a.idleTime) continue;
      const c = (parseInt(a.color.substr(1), 16) << 8) / 256;
      if (ce.presenceSelection.lineStyle(q.viewport.pixelRatio === 1 ? fs.selectionWidth + 1 : fs.selectionWidth, c), a.selections)
        for (let l = 0; l < a.selections.length; l++) {
          const h = q.dataStore.getById(a.selections[l]), d = q.indexer.getNode(a.selections[l]);
          d && Bg(ce.presenceSelection, h, d);
        }
    }
}
const AV = (e, n) => {
  ce.presenceCursor.fillStyle($s).drawImageFromAtlas(XC, e.x, e.y, 1, 1), ce.presenceCursor.fillStyle(n).drawImageFromAtlas(YC, e.x, e.y, 1, 1);
}, mV = (e, n, s) => {
  const r = e.clone().add(fs.tagOffset), o = new N().fromArray(ce.presenceCursor.measureTextImage(n, 12, "left", "top")), a = OV(n, o.x * q.viewport.pixelRatio, 12), c = new N().fromArray(ce.presenceCursor.measureTextImage(a, 12, "left", "top")), l = r.clone().add(fs.tagPadding, (fs.tagHeight - c.y) * 0.5);
  ce.presenceCursor.fillStyle(s).drawSolidRectTexture(
    r.x,
    r.y,
    c.x + fs.tagPadding * 2,
    fs.tagHeight,
    fs.tagCornerRadius
  ).lineStyle(fs.tagBorderWidth, fs.tagBorderColor, fs.tagBorderOpacity).drawRectTexture(
    r.x,
    r.y,
    c.x + fs.tagPadding * 2,
    fs.tagHeight,
    fs.tagBorderWidth,
    fs.tagCornerRadius
  );
  const h = { fontSize: 12, h_align: "left", v_align: "top" };
  ce.presenceCursor.fillStyle($s).drawTextImage(
    l.x,
    l.y,
    a,
    h
  );
}, OV = (e, n, s) => {
  let i = e;
  if (n > fs.nameMaxLength) {
    i = "...";
    const r = new N().fromArray(ce.presenceCursor.measureTextImage("...", s, "left", "top"));
    i = "";
    for (let o = 0; o < e.length; o++)
      if (i += e[o], new N().fromArray(ce.presenceCursor.measureTextImage(i, s, "left", "top")).x > fs.nameMaxLength - r.x) {
        i += "...";
        break;
      }
  }
  return i;
};
function qS(e, n = new N()) {
  const { skew: s, scale: i, rotation: r, translation: o } = e.decompose(), a = new Ce().translate_right(n.x, n.y).rotate_right(r).skew_right(Rt(s.x), Rt(s.y)).scale_right(i.x, i.y).translate_right(-n.x, -n.y);
  return o.sub(a.get_origin()), { position: o, scale: i, skew: s, rotation: r };
}
function lN(e, n) {
  const s = n.sub(e);
  let i = 0, r;
  return (o) => {
    const a = o.sub(e), c = Math.trunc(s.angle_to(a) * MP) * PP, l = Math.abs(c) < bP;
    if (r !== void 0 && !(i === 0 && l)) {
      const p = Math.sign(r), E = Math.sign(c);
      let g = 0;
      p === -1 && E === 1 ? g = -1 : p === 1 && E === -1 && (g = 1), l && (g *= -1), i += g;
    }
    c !== 0 && (r = c);
    const d = Math.PI * Math.sign(i) * Math.abs(i % 2);
    return {
      delta: c + d + i * Math.PI,
      direction: a
    };
  };
}
const jS = new N(), SE = new N(), yE = new N(), CE = new N(), Sn = {}, IV = {
  isMultipleOf90: !0,
  isMultipleOf180: !0
};
function SV(e, n, s, i, r) {
  const o = [], a = new N(1, 1);
  Sn.size = new N(Math.max(Es, s.width), Math.max(Es, s.height)), Sn.position = new N(s.x, s.y), Sn.center = Sn.size.clone().scale(0.5).add(s.x, s.y), Sn.origin = new N(0.5, 0.5), Sn.transform = new Ce(1, 0, 0, 1, s.x, s.y);
  for (const { element: h, node: d } of n) {
    const p = {
      referencePoint: new N(...h.get("referencePoint")),
      contentAnchor: new N(...h.get("contentAnchor")),
      scale: new N(...h.get("scale")),
      size: new N(...h.get("size")),
      skew: new N(...h.get("skew")),
      translate: new N(...h.get("translate")),
      rotation: h.get("rotation"),
      parentWorld: d.item.transform._parent.clone(),
      parentWorldInv: d.item.transform._parent.clone().affine_inverse(),
      element: h,
      node: d,
      sizeFlag: { ...d.item.sizeFlag },
      scaleFlag: { ...d.item.scaleFlag }
    };
    o.push(p);
  }
  const c = Sn.size.x / Sn.size.y;
  return jS.copy(Sn.size), SE.copy(r), CE.copy(r), yE.copy(r).sub(Sn.position), (h, d, p, E, g = !0, T = !0) => {
    const A = E && p ? E.clone().sub(e.anchor) : E, m = E ? A : e.anchor, O = (m.x === 0 || m.x === 1) && m.y === 0.5, S = new N(1 - m.x, 1 - m.y), y = h.clone();
    a.x = Math.sign(S.x - 0.5), a.y = Math.sign(S.y - 0.5);
    const v = y.clone();
    i.updateSnapMovingData(!1), i.vs.selection.updateBounds(), i.setResizeSelectedElementOAB(m);
    const R = S.clone().multiply(jS), M = Sn.position.clone().add(R);
    CE.copy(M);
    const L = S.clone().sub(m);
    L.set(Math.abs(L.x), Math.abs(L.y)), L.multiply(yE.x - R.x, yE.y - R.y);
    const P = m.x === 0.5 || m.y === 0.5;
    if (g) {
      const ne = i.snapResizeElementToPixelGrid(
        v,
        SE,
        M,
        P,
        !0
      );
      v.copy(ne), ne.sub(L.x, L.y);
    }
    if (T) {
      const ne = i.comparingVerticesWithResize(
        v,
        SE,
        M,
        m,
        g,
        IV,
        Hc.ResizeTypes.RESIZE_ELEMENTS,
        d
      );
      v.copy(ne), v.sub(L.x, L.y), y.copy(v);
    }
    const k = Es, Q = y.clone().sub(CE), b = p ? 2 : 1, X = S.clone().sub(m).multiply(Q).multiply(b, b), K = X.clone().add(Sn.size);
    K.x < Qt && (K.x = k), K.y < Qt && (K.y = k), d && c !== 0 && !Number.isNaN(c) && (m.y === 0.5 || m.x !== 0.5 && X.x >= X.y ? K.y = K.x / c : K.x = K.y * c);
    const V = CV(m, K);
    if (p) {
      const ne = S.clone().sub(m).divide(2, 2), ue = K.clone().sub(Sn.size).multiply(ne);
      V.sub(ue);
    }
    const J = K.clone().divide(Sn.size), ge = o[0].element.dataStore;
    ge.beginChangeGroup();
    for (const ne of o) {
      const ue = ne.element;
      ue.isLocked() || l(J, ne, d, K, V, ue, O);
    }
    ge.endChangeGroup();
  };
  function l(h, d, p, E, g, T, A) {
    const m = new Ce().scale_right(h.x, h.y).rotate_right(d.rotation).skew_right(d.skew.x, d.skew.y), { rotation: O, scale: S, skew: y } = m.decompose(), v = new N().copy(d.size).multiply(S), R = d.contentAnchor.clone().multiply(S), M = d.referencePoint.clone().multiply(S), L = d.translate.clone();
    p || (d.sizeFlag.w === "f0" && (L.x += d.size.x * 0.5), d.sizeFlag.h === "f0" && (L.y += d.size.y * 0.5));
    const P = d.parentWorld.xform(L), k = Sn.size.clone().scale(0.5).add(Sn.position), b = P.sub(k).divide(Sn.size).add(Sn.origin).multiply(E).add(g);
    d.parentWorldInv.xform(b, b), p || (v.x > 0 && v.x < Qt && (b.x -= v.x * 0.5), v.y > 0 && v.y < Qt && (b.y -= v.y * 0.5));
    const X = d.scaleFlag.x === "0" || p && d.sizeFlag.w === "f0", K = d.scaleFlag.y === "0" || p && d.sizeFlag.h === "f0";
    X && (v.x = d.size.x, R.x = d.contentAnchor.x, M.x = d.contentAnchor.x), K && (v.y = d.size.y, R.y = d.contentAnchor.y, M.y = d.contentAnchor.y), T.isText && (d.node.item.resizingMode === co[Ht.AUTO_WIDTH] && Math.abs(d.size.x - v.x) > 0.01 && d.element.set("resizingMode", Ht.AUTO_HEIGHT), Math.abs(d.size.y - v.y) > 0.01 && d.element.set("resizingMode", Ht.FIXED)), A ? T.sets({
      width: v.x,
      contentAnchorX: R.x,
      referencePointX: M.x,
      skew: new N().copy(y),
      rotation: O,
      translateX: b.x
    }) : T.sets({
      size: new N().copy(v),
      contentAnchorX: R.x,
      contentAnchorY: R.y,
      referencePointX: M.x,
      referencePointY: M.y,
      skew: new N().copy(y),
      rotation: O,
      translateX: b.x,
      translateY: b.y
    });
  }
}
function yV(e, n, s, i) {
  const r = [];
  for (const { element: a } of e) {
    const c = a.get("rotation");
    r.push({ rotation: c, element: a });
  }
  const o = lN(n, s);
  return (a, { shift: c }) => {
    const { delta: l } = o(a), h = r[0].element.dataStore;
    h.beginChangeGroup();
    for (const { rotation: d, element: p } of r) {
      if (p.isLocked() || p.get("elementType") === Me.SCREEN) continue;
      let E = d + l;
      if (c) {
        const g = E % ss[15];
        E -= g >= ss[15] * 0.5 ? g - ss[15] : g;
      }
      p.set("rotation", E, {
        updateType: Gs.USER_EDITING
      });
    }
    i("rotate"), h.endChangeGroup();
  };
}
function CV(e, n) {
  const s = e.clone().multiply(Sn.size), i = Sn.transform.xform(s), r = Sn.origin.clone().sub(e).multiply(n), o = Sn.transform.basis_xform(r), a = i.clone().add(o);
  return n.clone().multiply(Sn.origin).clone().negate().add(a);
}
const dn = new N(), NE = new N(), Vg = new N(), xa = new N(), va = new N(), hN = new N(), uN = new N();
let dN = 0;
const Zd = new Ce(), nd = new Ce(), sd = new Ce(), Hg = new N(), NV = new N(), Jl = new N();
let Wg = null, Qr = null, jr = null;
const $l = {
  isMultipleOf90: !1,
  isMultipleOf180: !1
}, ns = { w: "!0", h: "!0" }, ko = { x: "!0", y: "!0" };
let As = null, ds = null, fN = null, id = !1, rd = !1;
function xV(e, n, s, i, r, o, a) {
  if (Wg = e, jr = i, As = n, ds = s, id = o, rd = a, Qr = new N(1, 1), dn.set(...As.get("size")), va.set(...As.get("contentAnchor")), xa.set(...As.get("referencePoint")), As.isComputedGroup ? vV(ds, NE, Zd, nd) : (NE.copy(ds.item.transform.getPivotOffset()), Zd.copy(ds.item.transform.local), nd.copy(ds.item.transform.world)), Vg.copy(NE).divide(dn), Yg(Vg, Es * 0.5, Es * 0.5), hN.set(...As.get("scale")), uN.set(...As.get("skew")), dN = As.get("rotation"), fN = dn.x / dn.y, ds.item.transform.local.basis_determinant() === 0) {
    const { translate: c, scale: l, skew: h, rotation: d } = ds.item.transform, p = ds.item.transform.getPivotOffset();
    sd.reset().append(ds.parent.item.transform.world.clone().affine_inverse()).translate_right(p.x, p.y).scale_right(l.x === 0 ? 0 : 1 / l.x, l.y === 0 ? 0 : 1 / l.y).skew_right(Rt(-h.x), Rt(-h.y)).rotate_right(-d).translate_right(-c.x, -c.y);
  } else
    sd.copy(nd).affine_inverse();
  return Jl.copy(r), $l.isMultipleOf90 = jr.isMultipleOf90Degree(ds.item.transform.world.get_rotation()), $l.isMultipleOf180 = $l.isMultipleOf90 && jr.isMultipleOf180Degree(ds.item.transform.world.get_rotation()), ns.w = ds.item.sizeFlag.w, ns.h = ds.item.sizeFlag.h, ko.x = ds.item.scaleFlag.x, ko.y = ds.item.scaleFlag.y, Hg.set(0, 0), sd.xform(Jl, Hg), DV;
}
function vV(e, n, s, i) {
  n.copy(xa).add(va);
  const { translate: r, rotation: o, scale: a, skew: c } = e.item.transform;
  s.reset().translate_right(r.x, r.y).rotate_right(o).skew_right(Rt(c.x), Rt(c.y)).scale_right(a.x, a.y).translate_right(-n.x, -n.y), i.copy(e.item.transform.parent).append(s);
}
function RV(e, n, s, i) {
  const r = n.item.transform.worldPivot, o = e.get("rotation"), a = lN(r, s);
  return (c, { shift: l }) => {
    const { delta: h } = a(c);
    let d = o + h;
    if (l) {
      const p = d % ss[15];
      d -= p >= ss[15] * 0.5 ? p - ss[15] : p;
    }
    e.dataStore.beginChangeGroup(), e.set("rotation", d, {
      updateType: Gs.USER_EDITING
    }), e.dataStore.endChangeGroup(), i("rotate");
  };
}
function wV(e, n, s, i, r, o, a, c, l, h) {
  const d = s.xform(e);
  h.copy(d).sub(n);
  const p = l ? 2 : 1, E = r.clone().sub(o).multiply(h).multiply(p, p), g = E.clone().add(i);
  return a && c !== 0 && !Number.isNaN(c) && (o.y === 0.5 || o.x !== 0.5 && Math.abs(E.x) >= Math.abs(E.y) ? g.y = g.x / c : g.x = g.y * c), g;
}
function Yg(e, n, s) {
  Number.isFinite(e.x) || (e.x = n), Number.isFinite(e.y) || (e.y = s);
}
const DV = (e, n, s, i, r = !0, o = !0, a = !1) => {
  const c = !s, l = i && s ? i.clone().sub(Wg.anchor) : i, h = i ? l : Wg.anchor, d = new N(1 - h.x, 1 - h.y);
  Qr.x = Math.sign(d.x - 0.5), Qr.y = Math.sign(d.y - 0.5);
  const p = Hg.clone();
  c && (ns.w === "f0" && (p.x += dn.x * 0.5 * Qr.x), ns.h === "f0" && (p.y += dn.y * 0.5 * Qr.y));
  const E = hN.clone(), g = uN.clone(), T = dN, A = d.clone().multiply(dn), m = nd.xform(A), O = h.x === 0.5 || h.y === 0.5;
  if (jr.updateSnapMovingData(!1), jr.vs.selection.updateBounds(), jr.setResizeSelectedElementOAB(h), r) {
    jr.updateMoved(e.clone().sub(Jl));
    const J = jr.snapResizeElementToPixelGrid(
      e,
      Jl,
      m,
      O,
      $l.isMultipleOf90
    );
    e.copy(J);
  }
  if (o) {
    const J = jr.comparingVerticesWithResize(
      e,
      Jl,
      m,
      h,
      r,
      $l,
      Hc.ResizeTypes.RESIZE_ONE_ELEMENT,
      n
    );
    e.copy(J);
  }
  const S = n && ns.w !== "f0" && ns.h !== "f0" && ns.w !== "t0" && ns.h !== "t0" && ko.x !== "0" && ko.y !== "0", y = wV(
    e,
    p,
    sd,
    dn,
    d,
    h,
    S,
    fN,
    s,
    NV
    /* out param */
  );
  y.x < Qt && (y.x = Es), y.y < Qt && (y.y = Es), ko.x === "0" && (y.x = dn.x), ko.y === "0" && (y.y = dn.y), n && (ns.w === "f0" && ns.h === "f0" && ko.x !== "0" && ko.y !== "0" ? y.y = y.x * (E.x / (E.y === 0 ? 1 : E.y)) : (ns.w === "f0" && (y.x = dn.x), ns.h === "f0" && (y.y = dn.y)));
  const v = xa.clone().multiply(y).divide(dn);
  Yg(v, xa.x, xa.y);
  const R = va.clone().multiply(y).divide(dn);
  Yg(R, va.x, va.y), id && (R.x = va.x + xa.x + dn.x * 0.5 - v.x - Es * 0.5 - (y.x > Qt ? Es * 0.5 : 0)), rd && (R.y = va.y + xa.y + dn.y * 0.5 - v.y - Es * 0.5 - (y.y > Qt ? Es * 0.5 : 0));
  const M = y.clone();
  id && (M.x = dn.x), rd && (M.y = dn.y);
  const L = h.clone().multiply(dn), P = Vg.clone().multiply(M);
  c && (ns.w === "f0" && (P.x += dn.x * 0.5 * Qr.x), ns.h === "f0" && (P.y += dn.y * 0.5 * Qr.y), y.x < Qt && (P.x -= Es * 0.5 * Qr.x), y.y < Qt && (P.y -= Es * 0.5 * Qr.y)), id && (P.x -= y.x > Qt ? Es * 0.5 : 0), rd && (P.y -= y.y > Qt ? Es * 0.5 : 0);
  const k = Zd.xform(L), Q = h.clone().multiply(M).negate().add(P);
  ns.w === "t0" && (Q.x = 0), ns.h === "t0" && (Q.y = 0);
  const b = Zd.basis_xform(Q), X = k.clone().add(b);
  if (s) {
    const J = d.clone().sub(h).divide(2, 2), ge = y.clone().sub(dn).multiply(J);
    X.sub(ge);
    const ne = new N(As.get("translate").x, As.get("translate").y);
    ne.equals(X) && X.copy(ne);
  }
  const K = y.clone().abs();
  As.isText && (ds.item.resizingMode === co[Ht.AUTO_WIDTH] ? (dn.x != K.x && As.set("resizingMode", Ht.AUTO_HEIGHT), dn.y != K.y && As.set("resizingMode", Ht.FIXED)) : ds.item.resizingMode === co[Ht.AUTO_HEIGHT] && dn.y != K.y && As.set("resizingMode", Ht.FIXED)), As.dataStore.beginChangeGroup();
  const V = {
    scale: new se(E),
    skew: new se(g),
    rotation: T,
    width: K.x,
    height: K.y
  };
  ns.w !== "t0" && (V.translateX = X.x, V.referencePointX = v.x, V.contentAnchorX = R.x), ns.h !== "t0" && (V.translateY = X.y, V.referencePointY = v.y, V.contentAnchorY = R.y), As.sets(V, {
    updateType: Gs.USER_EDITING
  }), As.dataStore.endChangeGroup();
}, zr = N, Rs = {
  RESIZE: 0,
  ROTATE: 1
}, Ps = {
  TOP_LEFT: new zr(0, 0),
  TOP: new zr(0.5, 0),
  TOP_RIGHT: new zr(1, 0),
  RIGHT: new zr(1, 0.5),
  BOTTOM_RIGHT: new zr(1, 1),
  BOTTOM: new zr(0.5, 1),
  BOTTOM_LEFT: new zr(0, 1),
  LEFT: new zr(0, 0.5),
  CENTER: new zr(0.5, 0.5)
}, it = {
  TOP_LEFT: {
    type: Rs.RESIZE,
    anchor: Ps.BOTTOM_RIGHT,
    cursorRot: ss[45]
  },
  TOP_RIGHT: {
    type: Rs.RESIZE,
    anchor: Ps.BOTTOM_LEFT,
    cursorRot: -ss[45]
  },
  BOTTOM_RIGHT: {
    type: Rs.RESIZE,
    anchor: Ps.TOP_LEFT,
    cursorRot: ss[45]
  },
  BOTTOM_LEFT: {
    type: Rs.RESIZE,
    anchor: Ps.TOP_RIGHT,
    cursorRot: -ss[45]
  },
  TOP: {
    type: Rs.RESIZE,
    anchor: Ps.BOTTOM,
    cursorRot: ss[90]
  },
  RIGHT: {
    type: Rs.RESIZE,
    anchor: Ps.LEFT,
    cursorRot: ss[0]
  },
  BOTTOM: {
    type: Rs.RESIZE,
    anchor: Ps.TOP,
    cursorRot: ss[90]
  },
  LEFT: {
    type: Rs.RESIZE,
    anchor: Ps.RIGHT,
    cursorRot: ss[0]
  },
  TOP_LEFT_ROTATE: {
    type: Rs.ROTATE,
    anchor: Ps.BOTTOM_RIGHT,
    cursorRot: -ss[90]
  },
  TOP_RIGHT_ROTATE: {
    type: Rs.ROTATE,
    anchor: Ps.BOTTOM_LEFT,
    cursorRot: ss[0]
  },
  BOTTOM_RIGHT_ROTATE: {
    type: Rs.ROTATE,
    anchor: Ps.TOP_LEFT,
    cursorRot: ss[90]
  },
  BOTTOM_LEFT_ROTATE: {
    type: Rs.ROTATE,
    anchor: Ps.TOP_RIGHT,
    cursorRot: ss[180]
  }
};
function LV(e, n) {
  const { getCurrentState: s, setState: i } = n, { dataStore: r, viewport: o, snapping: a } = e;
  let c = null, l = null, h = null, d = null, p = null;
  const E = new N();
  let g = null;
  const T = /* @__PURE__ */ new Map(), A = { w: "!0", h: "!0" }, m = {
    // tool used at the start of the action (resize or rotate)
    currentTool: null,
    // set this to true to ignore active tool and always resize (during element creation)
    ignoreActiveTool: !1,
    /** @param {string} handleName */
    setHandle: (V) => {
      c = it[V];
    },
    /**
     * @param {ISEvent} e
     * @param {boolean} snapToGrid
     * @param {boolean} snapToObject
     */
    resizeStart: (V, J, ge) => {
      if (c && c.type === Rs.RESIZE) {
        const ne = e.selection.single, ue = r.get("activeTool");
        switch (m.currentTool = m.ignoreActiveTool ? st.SELECT : ue, m.currentTool) {
          case st.SELECT:
            if (ne === null)
              g = SV(
                c,
                e.selection.iter(),
                e.selection.bounds.clone(),
                a,
                o.toWorld(V.mousePos)
              );
            else {
              let te = !1, ie = !1;
              A.w = ne.node.item.sizeFlag.w, A.h = ne.node.item.sizeFlag.h;
              const re = ne.element, { width: fe, height: Ne } = re.get("size"), At = re.get("contentAnchor"), Ke = re.get("referencePoint"), St = {};
              if (fe > 0 && fe < Qt) {
                const gt = At.x + (Ke.x - fe * 0.5);
                if (Math.abs(gt) > 1)
                  te = !0;
                else {
                  const Xs = gt * fe * Ru - (Ke.x - fe * 0.5);
                  St.contentAnchorX = Xs;
                }
              }
              if (Ne > 0 && Ne < Qt) {
                const gt = At.y + (Ke.y - Ne * 0.5);
                if (Math.abs(gt) > 1)
                  ie = !0;
                else {
                  const Xs = gt * Ne * Ru - (Ke.y - Ne * 0.5);
                  St.contentAnchorY = Xs;
                }
              }
              const rn = r.drawInfo.getFixedPositionByChanges(re.get("id"), St);
              rn && (St.translateX = rn[0] || rn.x, St.translateY = rn[1] || rn.y, ne.element.sets(St)), g = xV(
                c,
                ne.element,
                ne.node,
                a,
                o.toWorld(V.mousePos),
                te,
                ie
              );
            }
            m.resizeUpdate = O;
            break;
          case st.SCALE:
            K(V, J, ge);
            break;
        }
      } else
        V.handled = !1;
    },
    /** @type {(mousePos: Vector2, keepAspect: boolean, anchorOverride: Anchor) => void} */
    resizeUpdate: () => {
    },
    /**
     * @param {bool} [commit=true]
     */
    resizeEnd: (V = !0) => {
      if (m.currentTool === st.SCALE && (d && (d = null), p && (p = null), T.clear()), m.currentTool === st.SELECT) {
        const J = e.selection.single;
        if (J) {
          const ge = J.element, { width: ne, height: ue } = ge.get("size"), te = ge.get("contentAnchor"), ie = ge.get("referencePoint"), re = {};
          if (ne > 0 && ne < Qt && A.w === "!0") {
            const Ke = (te.x + (ie.x - ne * 0.5)) / ne / Ru - (ie.x - ne * 0.5);
            re.contentAnchorX = Ke;
          }
          if (ue > 0 && ue < Qt && A.h === "!0") {
            const Ke = (te.y + (ie.y - ue * 0.5)) / ue / Ru - (ie.y - ue * 0.5);
            re.contentAnchorY = Ke;
          }
          const fe = r.drawInfo.getFixedPositionByChanges(ge.get("id"), re);
          fe && (re.translateX = fe[0] || fe.x, re.translateY = fe[1] || fe.y, J.element.sets(re));
        }
      }
      m.resizeUpdate = () => {
      }, m.currentTool = null, m.ignoreActiveTool = !1, a.setEndSnapping(), a.endSnapMovingElementToElement(), V && (r.commitUndo(), r.isDesignMode && e.updateUpdateLevel(Is.UPDATE_ALL_NEED_BBOX_RECALC));
    },
    /** @param {ISEvent} e */
    rotateStart: (V) => {
      if (c && c.type === Rs.ROTATE) {
        const J = e.selection.single, ge = r.get("activeTool") === st.SCALE ? l.node.item.transform.worldPivot : e.selection.bounds.center;
        m.rotateUpdate = J === null ? yV(e.selection.iter(), ge, o.toWorld(V.mousePos), i) : RV(J.element, J.node, o.toWorld(V.mousePos), i);
      } else
        V.handled = !1;
    },
    /** @type {(mousePos: Vector2, snapTo15deg: boolean) => void} */
    rotateUpdate: () => {
    },
    rotateEnd: () => {
      m.rotateUpdate = () => {
      }, r.commitUndo(), r.isDesignMode && e.updateUpdateLevel(Is.UPDATE_ALL_NEED_BBOX_RECALC);
    }
  };
  r.selection.on(Oe.SELECT, () => {
    r.selection.isEmpty() && r.get("activeTool") !== st.PEN && i("default");
  }), r.on(Oe.DEFAULT_CHANGES, (V) => {
    if (V.has("activeTool")) {
      if (V.get("activeTool").value !== st.SCALE) return;
      if (c && c.type !== Rs.ROTATE) {
        const ge = e.selection.single.node.item.transform.saveWorld.get_rotation();
        i("scale", ge + c.cursorRot);
      }
    }
  }), r.eam.on(Y.HOVER_BOX_HANDLE, (V) => {
    const J = e.selection.single, ge = r.get("activeTool"), ne = s();
    if (h = null, J === null)
      if (ge === st.SCALE) {
        let te = [];
        for (const ie of e.selection.iter())
          te = [{ ...ie }, ...te];
        h = a1(te, V.mousePos);
      } else {
        const te = e.selection.bounds.clone(), { width: ie, height: re } = te, fe = ea(ie), Ne = ea(re);
        fe === "f0" && (te.width = 0, te.x += ie * 0.5), Ne === "f0" && (te.height = 0, te.y += re * 0.5), h = HV(te, V.mousePos);
      }
    else
      h = a1([J], V.mousePos);
    l = null, c = null, h && (l = h.item, c = h.handle);
    const ue = e.selection.all((te) => te.element.isLocked());
    if (c && !ue) {
      const te = e.selection.all((re) => re.element.get("elementType") === Me.SCREEN), ie = e.selection.all((re) => re.element.get("locked") && re.element.get("elementType") !== Me.SCREEN);
      if (c.type === Rs.ROTATE) {
        if (te || ie) {
          r.eam.changeHover(Gt.NONE), i("default");
          return;
        }
        r.eam.changeHover(Gt.ROTATE_HANDLE), i("rotate");
      } else {
        if (l && l.element.isLineElement())
          i(
            ge === st.SCALE && l ? "crossScale" : "crossMove"
          );
        else {
          let fe = (l ? l.node.item.transform.saveWorld.get_rotation() : 0) + c.cursorRot;
          if (l) {
            const Ne = l.element.get("skew"), At = l.node.item.transform.world.get_scale(), Ke = Ps.CENTER.clone().sub(c.anchor).multiply(2, 2).abs();
            fe -= Ne[0] * Ke.y / (Ke.x + Ke.y), fe += Ne[1] * Ke.x / (Ke.x + Ke.y), !js(c.anchor.x, 0.5, 1e-3) && !js(c.anchor.y, 0.5, 1e-3) && (At.x < 0 && (fe += Math.PI * 0.5), At.y < 0 && (fe += Math.PI * 0.5), Math.abs(Math.floor((Ne[0] + Math.PI * 0.5) / Math.PI) % 2) === 1 && (fe += Math.PI * 0.5), Math.abs(Math.floor((Ne[1] + Math.PI * 0.5) / Math.PI) % 2) === 1 && (fe += Math.PI * 0.5));
          }
          if (ge === st.SCALE) {
            if (te || ie) {
              r.eam.changeHover(Gt.NONE), i("default");
              return;
            }
            i("scale", fe);
          } else !r.selection.get("hoverMotionPoint") && !r.selection.get("hoverMotionSegment") && i("resize", fe);
        }
        r.eam.changeHover(Gt.RESIZE_HANDLE);
      }
    } else
      ne.secondState || i("default");
  });
  const O = (V, J, ge, ne) => {
    g(o.toWorld(V.mousePos), J.shift, J.alt, void 0, ge, ne);
  }, S = new Ce(), y = new N(), v = new N(), R = new N(), M = new N(), L = new N(), P = new N(), k = new N(), Q = new N(), b = new N(), X = new N(), K = (V, J = !0, ge = !0) => {
    p = new N(
      Ps.CENTER.x - c.anchor.x,
      Ps.CENTER.y - c.anchor.y
    );
    const ne = e.selection, ue = l.node, te = l.element, ie = e.snapping, re = c.anchor.x === 0.5 || c.anchor.y === 0.5;
    d = o.toWorld(V.mousePos);
    const fe = {
      isMultipleOf90: ie.isMultipleOf90Degree(ue.item.transform.rotation),
      isMultipleOf180: ie.isMultipleOf180Degree(ue.item.transform.rotation)
    }, Ne = ie.getScalingClickPoint(p, ue);
    E.copy(Ne), T.clear();
    for (const { element: St, node: rn } of ne.iter()) {
      const gt = St.get("scale");
      T.set(St.get("id"), {
        sizeFlag: rn.item.sizeFlag,
        scaleX: gt.x,
        scaleY: gt.y
      });
    }
    const At = ie.isScalingSnapToPixelGrid(ue, re);
    if (ue.item.transform.world.basis_determinant() === 0) {
      const { translate: St, skew: rn, rotation: gt } = ue.item.transform, Wn = ue.item.transform.getPivotOffset();
      S.reset().append(ue.parent.item.transform.world.clone().affine_inverse()).translate_right(Wn.x, Wn.y).skew_right(-rn.x, -rn.y).rotate_right(-gt).translate_right(-St.x, -St.y);
    } else
      S.copy(ue.item.transform.world.clone().affine_inverse());
    y.set(te.get("scale").x, te.get("scale").y), v.set(te.get("size").width, te.get("size").height);
    const Ke = y.y * v.y === 0 ? 0 : y.x * v.x / (y.y * v.y);
    m.resizeUpdate = (St, rn) => {
      ie.updateSnapMovingData(), ie.vs.selection.updateBounds(), ie.setResizeSelectedElementOAB(c.anchor, ue);
      const gt = o.toWorld(St.mousePos);
      ie.updateMoved(gt.clone().sub(d));
      let Wn = gt.x - d.x, Xs = gt.y - d.y;
      if (Wn !== 0 || Xs !== 0) {
        if (r.beginChangeGroup(), J && At) {
          const En = ie.snapScaleElementToPixelGrid(
            gt,
            d,
            E,
            re,
            fe.isMultipleOf90
          );
          gt.copy(En), Wn = gt.x - d.x, Xs = gt.y - d.y;
        }
        if (ge) {
          const En = ie.comparingVerticesWithResize(
            gt,
            d,
            E,
            c.anchor,
            J,
            fe,
            Hc.ResizeTypes.SCALE_ONE_ELEMENT,
            rn.shift
          );
          En.sub(d), Wn = En.x, Xs = En.y;
        }
        const ls = new N(1, 1), Ci = js(y.x, 0, 1e-3) && js(y.y, 0, 1e-3), ho = !js(y.x, 0, 1e-3) && !js(y.y, 0, 1e-3), Yn = rn.shift;
        if (Yn && (Ci || ho))
          if (re)
            ls.x = c.anchor.x === 0.5 ? 0 : ls.x, ls.y = c.anchor.y === 0.5 ? 0 : ls.y;
          else {
            const En = S.xform(gt), { width: Ni, height: Bn } = te.get("size"), ys = te.get("contentAnchor"), Dr = te.get("referencePoint"), Lr = (Dr.x + ys.x) / Ni, Cs = (Dr.y + ys.y) / Bn, fr = new N(Lr, Cs), zs = En.sub(fr).abs();
            zs.y * Ke < zs.x ? ls.x = 0 : ls.y = 0;
          }
        R.set(1 - c.anchor.x, 1 - c.anchor.y), Q.set(Wn, Xs), S.basis_xform(Q, M), ho && M.multiply(y.x, y.y), M.multiply((R.x - 0.5) * 2, (R.y - 0.5) * 2);
        for (const { element: En } of ne.iter()) {
          if (En.get("elementType") === Me.SCREEN || En.isLocked()) continue;
          const { scaleX: Ni, scaleY: Bn, sizeFlag: ys } = T.get(En.get("id")), Dr = js(Ni, 0, 1e-3) && js(Bn, 0, 1e-3), Lr = !js(Ni, 0, 1e-3) && !js(Bn, 0, 1e-3), Cs = Ni === 0 ? 1e-12 : Ni, fr = Bn === 0 ? 1e-12 : Bn;
          X.set(Ni, Bn);
          let { width: zs, height: uo } = En.get("size");
          const fo = En.get("contentAnchor"), Lh = En.get("referencePoint"), na = (Lh.x + fo.x) / zs, po = (Lh.y + fo.y) / uo;
          if (b.set(na, po), zs *= Cs, uo *= fr, P.copy(R), k.copy(b), P.x === 0 && (P.x = 1 - P.x, k.x = 1 - k.x), P.y === 0 && (P.y = 1 - P.y, k.y = 1 - k.y), P.x === k.x && (k.x = 1 - k.x), P.y === k.y && (k.y = 1 - k.y), L.copy(M).multiply(Math.sign(P.x - k.x), Math.sign(P.y - k.y)), !js(P.x, 0.5, 1e-3)) {
            const pr = Math.sign(P.x - k.x) * L.x;
            X.x = (zs + pr - zs * k.x) / (zs * (1 - k.x)) * Cs;
          }
          if (!js(P.y, 0.5, 1e-3)) {
            const pr = Math.sign(P.y - k.y) * L.y;
            X.y = (uo + pr - uo * k.y) / (uo * (1 - k.y)) * fr;
          }
          if (Yn && (Lr || Dr) && ys.w === "!0" && ys.h === "!0") {
            const pr = Dr ? uo / zs : Ni / Bn;
            ls.x === 0 ? X.x = X.y * pr : X.y = X.x / pr;
          }
          Yn && !Dr && (js(Ni, 0, 1e-3) && (X.x = 0), js(Bn, 0, 1e-3) && (X.y = 0)), Yn && Dr && (ys.w === "f0" || ys.h === "f0" || ys.w === "t0" || ys.h === "t0") && (X.x = 0, X.y = 0), (ys.w === "f0" || ys.w === "t0") && (X.x = Ni), (ys.h === "f0" || ys.h === "t0") && (X.y = Bn), En.set("scale", X, {
            updateType: Gs.USER_EDITING
          });
        }
        r.endChangeGroup();
      }
    };
  };
  return m;
}
function js(e, n, s) {
  return Math.abs(e - n) <= s;
}
const Xg = nt(), wr = {
  VERT_HALF_BOX_WIDTH: 8,
  ORIGIN_HALF_BOX_WIDTH: 8,
  RESIZE_HANDLES_HALF_BOX_WIDTH: 4,
  ROTATE_HANDLES_RADIUS: 14,
  MOVE_LINE_RADIUS: 0.5,
  GUIDELINE_WIDTH: 4
}, pN = 2.5;
let pn;
class MV {
  constructor() {
    /** @type {Map<NodeID, SceneNode>} */
    je(this, "node_bank", /* @__PURE__ */ new Map());
    /** @type {NodeID} */
    je(this, "root", "");
  }
  /**
   * @param {ComputeContext} ctx
   * @param {SceneNode} node
   */
  addNewNode(n, s) {
    this.node_bank.set(s.id, s);
    const i = s.item.transform.parent;
    D0(n, this, s.id, i), L0(n, this.node_bank, s.id, !1), M0(n, this.node_bank, s.id);
  }
  /**
   * @param {ComputeContext} ctx
   * @param {SceneNode} node
   * @param {boolean} selectable
   * @param {number} zoom
   * @param {Vector2} size
   */
  addScreenNode(n, s, i, r, o) {
    this.addNewNode(n, s);
    const a = ON(n, s, i, r, o);
    n.screen_name.set(s.id, a);
  }
}
class PV {
  constructor() {
    /** @type {Map<NodeID, {world: Transform2D, local: Transform2D, worldInv: Transform2D}>} */
    je(this, "transform", /* @__PURE__ */ new Map());
    /** @type {Map<NodeID, {world: Rect2, visualWorld: Rect2, local: Rect2, subtree: Rect2}>} */
    je(this, "bounds", /* @__PURE__ */ new Map());
    /** @type {Map<NodeID, Rect2>} */
    je(this, "screen_name", /* @__PURE__ */ new Map());
    // if element itself is locked or its parent is locked, it will be set to locked here
    /** @type {Map<NodeID, boolean>}} */
    je(this, "locked", /* @__PURE__ */ new Map());
    // if element itself is hidden or its parent is hidden / BooleanGroup / MaskGroup,
    // it will be set to hidden here
    /** @type {Map<NodeID, boolean>}} */
    je(this, "hidden", /* @__PURE__ */ new Map());
  }
}
class bV {
  constructor(n) {
    /** @type {State} */
    je(this, "state", {
      compute: new PV(),
      /** @type {Scene} */
      scene: new MV(),
      /** @type {NodeID} */
      hovered: null,
      guidelines: {
        horizontal: {
          map: /* @__PURE__ */ new Map(),
          sortedDataWorld: [],
          isDirty: !1
        },
        vertical: {
          map: /* @__PURE__ */ new Map(),
          sortedDataWorld: [],
          isDirty: !1
        }
      }
    });
    this.visualServer = n, pn = n;
  }
  update() {
    D0(this.state.compute, this.state.scene, this.state.scene.root, Ce.IDENTITY), L0(this.state.compute, this.state.scene.node_bank, this.state.scene.root, !0), M0(this.state.compute, this.state.scene.node_bank, this.state.scene.root);
  }
  updateScreenNameBounds() {
    GV(this.state.compute, this.state.scene.node_bank);
  }
  updateGuidelines() {
    FV(this.state);
  }
}
function UV(e, n, s, i) {
  const o = n.node_bank.get(s).item.transform.local.clone(), a = i.clone().append(o), c = i.clone().append(o).affine_inverse();
  let l = e.transform.get(s);
  l || (l = { local: o, world: a, worldInv: c }, e.transform.set(s, l)), l.local.copy(o), l.world.copy(a), l.worldInv.copy(c);
}
function D0(e, n, s, i, r = !1, o = !1) {
  const a = n.node_bank.get(s), c = r || a.item.locked;
  e.locked.set(s, c);
  const l = o || !a.item.visible;
  e.hidden.set(s, l), UV(e, n, s, i);
  const d = e.transform.get(s).world;
  for (let p = 0; p < a.children.length; p++)
    D0(e, n, a.children[p].id, d, c, l);
}
function L0(e, n, s, i = !1) {
  const r = n.get(s), o = e.transform.get(s), a = r.boundsLocal.clone(), c = o.world.xform_rect(a), l = r.subtreeBounds;
  if (e.bounds.has(s)) {
    const h = e.bounds.get(s);
    h.local.copy(a), h.world.copy(c), h.visualWorld.copy(l);
  } else
    e.bounds.set(s, {
      world: c.clone(),
      visualWorld: l.clone(),
      local: a.clone(),
      subtree: c.clone()
    });
  if (i)
    for (let h = 0; h < r.children.length; h++)
      L0(e, n, r.children[h].id, !0);
}
function M0(e, n, s) {
  const i = n.get(s), r = e.bounds.get(s);
  if (i.children.length === 0) {
    r.subtree.copy(r.visualWorld);
    return;
  }
  const o = r.visualWorld.clone();
  for (let a = i.children.length - 1; a >= 0; a--) {
    M0(e, n, i.children[a].id);
    const c = e.bounds.get(i.children[a].id);
    o.merge_with(c.subtree);
  }
  r.subtree.copy(o.clone());
}
function GV(e, n) {
  for (const s of e.screen_name) {
    const i = s[0], r = pn.dataStore.getById(i), o = r.get("visible") && !r.get("locked"), a = pn.dataStore.workspace.get("scale"), c = { fontSize: 12, h_align: "left", v_align: "top" }, h = pn.overlay.panes[0].measureTextImage(r.get("name"), c.fontSize, c.h_align, c.v_align), d = n.get(i), p = ON(e, d, o, a, h);
    e.screen_name.set(i, p);
  }
}
function FV(e) {
  e.guidelines.horizontal.isDirty && (e.guidelines.horizontal.sortedDataWorld = Array.from(e.guidelines.horizontal.map.entries()), e.guidelines.horizontal.sortedDataWorld.sort((n, s) => n[1] - s[1]), e.guidelines.horizontal.isDirty = !1), e.guidelines.vertical.isDirty && (e.guidelines.vertical.sortedDataWorld = Array.from(e.guidelines.vertical.map.entries()), e.guidelines.vertical.sortedDataWorld.sort((n, s) => n[1] - s[1]), e.guidelines.vertical.isDirty = !1);
}
const ni = (e, n) => {
  const s = pN / pn.viewport.scale;
  return Kn.set(e.x - s, e.y - s, e.width + s * 2, e.height + s * 2), Kn.contains(n);
};
function Vc(e, n, s, i) {
  const r = pN / pn.viewport.scale, o = [], a = 30, c = n.get(s);
  for (let l = 0; l < 360 / a; l++)
    o.push(new N(i.x + r * Math.cos(l * a * Math.PI / 180), i.y + r * Math.sin(l * a * Math.PI / 180)));
  for (let l = 0; l < o.length; l++)
    if (c.item.type === "text") {
      const d = pn.view.getOrCreateDinoTree(s).text_node_id;
      if (!d) return !1;
      const E = e.transform.get(s).worldInv.xform(i);
      if (pn.dataStore.selection.get("textRange") && ni(c.boundsLocal, new N(E.x, E.y)) || Xg.isPointInText(d, E.x, E.y)) return !0;
    } else if (EN(e, n, s, o[l])) return !0;
  return !1;
}
function EN(e, n, s, i) {
  const r = pn.dataStore.getById(s);
  let o = !1;
  if (r.isLineElement()) {
    const T = wr.MOVE_LINE_RADIUS / pn.viewport.projectionTransform.a, A = e.transform.get(s), m = r.get("geometry").get("mesh"), O = Array.from(m.edges.values());
    for (let S = 0; S < O.length; S++) {
      const y = A.world.xform(m.getVertPos(O[S].v.id)), v = A.world.xform(m.getVertPos(O[S].w.id));
      xE.setP(y, v);
      const R = xE.nearest(i);
      xE.eval(R.t).subtract(i).length_squared() <= T && (o = !0);
    }
  }
  let a = n.get(s);
  a.item.isMaskGroup() && a.children.length && (a = a.children[a.children.length - 1]);
  const { x: c, y: l } = a.item.transform.size;
  if (c < Qt && l < Qt) return !1;
  const p = e.transform.get(a.id).world.clone().clone().affine_inverse().xform(i), E = kV(a.item, p);
  return a.item.fillLayers.length === 0 && a.item.strokeLayers.length !== 0 ? a.item.isContainerNormalGroup() ? E > 0 || o : E === 3 || o : E > 0 || o;
}
function kV(e, n) {
  const s = pn.view.getOrCreateDinoTree(e.id);
  for (let i = 0; i < s.strokes.children.length; i++)
    if (Xg.isPointInStroke(
      s.strokes.children[i].path_id,
      s.strokes.children[i].stroke_data_id,
      n.x,
      n.y
    ))
      return 3;
  return Xg.isPointInPath(s.path_id, n.x, n.y) ? 2 : 0;
}
function qd(e, n, s, i, r, o, a = !1) {
  var T;
  const c = e.locked.get(i), l = e.hidden.get(i);
  if (c || l) return null;
  const h = s.get(i), d = n, p = e.bounds.get(i);
  if (h.parent && h.parent.item.isMaskGroup() && h.id === h.parent.children[h.parent.children.length - 1].id && !a) return null;
  const g = h.item.isMaskGroup() || h.item.isBooleanGroup() || h.item.clipping;
  if (ni(g ? p.visualWorld : p.subtree, r)) {
    const A = h.item.isContainerNormalGroup() || h.item.isMaskGroup() || h.item.isBooleanGroup();
    if (o || !ni(p.visualWorld, r) || d && A) {
      for (let m = h.children.length - 1; m >= 0; m--) {
        const O = qd(e, n, s, h.children[m].id, r, !1, a);
        if (O !== null)
          return O;
      }
      return d && h.item.isContainer() && ((T = h.item.fillLayers) == null ? void 0 : T.length) > 0 && ni(p.visualWorld, r) ? i : ni(p.visualWorld, r) && a && Vc(e, s, i, r) ? d && A ? null : i : null;
    } else {
      if (!Vc(e, s, i, r) || h.item.isNormalGroup()) {
        const m = s.get(i);
        if (m.item.isContainer() && !m.item.clipping || m.item.isNormalGroup()) {
          for (let O = m.children.length - 1; O >= 0; O--)
            if (qd(e, n, s, m.children[O].id, r, !1, a) !== null)
              return i;
        }
        return null;
      }
      return i;
    }
  }
  return null;
}
function BV(e, n, s, i) {
  const r = s.first.id, o = e.scene.node_bank, a = e.scene.node_bank.get(e.scene.root);
  if (a.children.length === 0)
    return;
  const c = a.children[0].id, l = o.get(r), h = l.item.type === "screen" ? l.item.depth + 1 : l.item.depth, d = gN(e, o, c, n, h, i, !0), p = i;
  if (d) {
    let E = o.get(d);
    if (!p) {
      for (; E.item.depth > h; )
        E = o.get(E.parent.id);
      if (E.item.depth === h && s.bounds.has_point(n)) {
        e.hovered = E.id;
        return;
      }
    }
    e.hovered = c === E.id ? null : E.id;
  } else {
    e.hovered = null;
    for (const [E, g] of e.compute.screen_name)
      ni(g, n) && (e.hovered = E);
  }
}
function gN(e, n, s, i, r, o, a) {
  var A;
  const c = e.compute.locked.get(s), l = e.compute.hidden.get(s);
  if (c || l) return null;
  const h = o, d = n.get(s);
  if (d.parent && d.parent.item.isMaskGroup() && d.id === d.parent.children[d.parent.children.length - 1].id || d.item.depth > r && !h) return null;
  const E = e.compute.bounds.get(s), g = d.item.isMaskGroup() || d.item.isBooleanGroup() || d.item.clipping, T = d.item.type === "text" && pn.dataStore.selection.get("textRange") ? E.world : E.subtree;
  if (ni(g ? E.visualWorld : T, i)) {
    const m = n.get(pn.selection.first.id), O = d.item.isContainerNormalGroup() || d.item.isMaskGroup() || d.item.isBooleanGroup();
    if (a || !ni(E.visualWorld, i) || h && O || m.parent.id === s || d.item.isContainerNormalGroup()) {
      if (d.item.depth + 1 <= r || h)
        for (let S = d.children.length - 1; S >= 0; S--) {
          const y = gN(e, n, d.children[S].id, i, r, o);
          if (y !== null)
            return y;
        }
      if (h && d.item.isContainer() && ((A = d.item.fillLayers) == null ? void 0 : A.length) > 0 && ni(E.visualWorld, i))
        return s;
      if (Vc(e.compute, n, s, i) && !h) {
        if (d.item.isNormalGroup()) {
          for (let S = d.children.length - 1; S >= 0; S--)
            if (qd(e.compute, o, n, d.children[S].id, i, !1, !1) !== null)
              return s;
          return null;
        }
        return s;
      } else
        return null;
    } else
      return h && O || !Vc(e.compute, n, s, i) ? null : s;
  }
  return null;
}
function JS(e, n, s, i, r = !1) {
  const o = e.compute, a = e.scene.node_bank, c = n;
  let l = qd(o, n, a, i, s, !0, r), h = a.get(l);
  if (!c && !r)
    for (; h && h.parent.id !== i; )
      h = a.get(h.parent.id);
  if (l = h ? h.id : null, !l)
    for (const [d, p] of o.screen_name)
      ni(p, s) && (l = d);
  e.hovered = l;
}
function _N(e, n, s) {
  const i = e.compute, r = e.scene.node_bank;
  return TN(i, r, s, n) || s;
}
function $S(e, n, s) {
  const i = _N(e, n, s);
  e.hovered = i;
}
function TN(e, n, s, i) {
  const r = e.locked.get(s), o = e.hidden.get(s);
  if (r || o) return null;
  const a = n.get(s);
  if (!(a.item.isScreen() || a.item.isContainerNormalGroup())) return null;
  const l = e.bounds.get(s);
  if (ni(l.subtree, i)) {
    for (let h = a.children.length - 1; h >= 0; h--) {
      const d = TN(e, n, a.children[h].id, i);
      if (d !== null)
        return d;
    }
    if (Vc(e, n, s, i))
      return s;
  }
  return null;
}
function e1(e, n, s, i = !1) {
  if (s.size < 1) return !1;
  const r = pn.dataStore.workspace.children[0].get("id");
  for (const o of s.iter()) {
    if (i && r === o.id) continue;
    const a = e.compute.bounds.get(o.id).local, l = e.compute.transform.get(o.id).world.clone().affine_inverse().xform(n);
    if (ni(a, l))
      if (o.element.isLineElement()) {
        if (Vc(e.compute, e.scene.node_bank, o.id, n)) return o.id;
      } else
        return o.id;
  }
  return null;
}
function zg(e, n, s, i, r, o) {
  this.p = new N(e, n), this.p1 = new N(s, i), this.p2 = new N(r, o);
}
zg.prototype = {
  constructor: zg,
  set(e, n, s, i, r, o) {
    return this.p.set(e, n), this.p1.set(s, i), this.p2.set(r, o), this;
  },
  setP(e, n, s) {
    return this.p.copy(e), this.p1.copy(n), this.p2.copy(s), this;
  },
  isPointInside(e) {
    const n = this.p1.clone().subtract(this.p), s = this.p2.clone().subtract(this.p);
    if (n.x === 0 && n.y === 0 || s.x === 0 && s.y === 0) return !1;
    const i = e.clone().subtract(this.p);
    if (i.x === 0 && i.y === 0) return !1;
    const r = n.cross(s), o = n.cross(i), a = -1 * r, c = s.cross(i);
    return Math.sign(r) === Math.sign(o) && Math.sign(a) === Math.sign(c) && Math.abs(r) >= Math.abs(o) && Math.abs(a) >= Math.abs(c);
  }
};
const VV = 24, AN = (e, n) => {
  const s = VV / pn.viewport.projectionTransform.a, i = e.xform(n.bottomRight), r = e.xform(n.topRight), o = e.xform(n.bottomLeft), a = e.xform(n.topLeft);
  return i.distance(r) < s || r.distance(a) < s || a.distance(o) < s || o.distance(i) < s;
}, HV = (e, n) => {
  const s = wr.RESIZE_HANDLES_HALF_BOX_WIDTH / pn.viewport.projectionTransform.a, i = wr.ROTATE_HANDLES_RADIUS / pn.viewport.projectionTransform.a, r = pn.viewport.toWorld(n), o = Ce.IDENTITY, a = AN(o, e);
  if (wc(e, o)) return null;
  const c = o.xform(e.bottomRight), l = o.xform(e.topRight), h = o.xform(e.bottomLeft), d = o.xform(e.topLeft);
  if (a) {
    if (Kn.set(c.x, c.y, s, s), Kn.contains(r)) return { item: null, handle: it.BOTTOM_RIGHT };
    if (Kn.set(l.x, l.y - s, s, s), Kn.contains(r)) return { item: null, handle: it.TOP_RIGHT };
    if (Kn.set(h.x - s, h.y, s, s), Kn.contains(r)) return { item: null, handle: it.BOTTOM_LEFT };
    if (Kn.set(d.x - s, d.y - s, s, s), Kn.contains(r)) return { item: null, handle: it.TOP_LEFT };
  } else {
    if (Kn.set(c.x - s, c.y - s, s * 2, s * 2), Kn.contains(r)) return { item: null, handle: it.BOTTOM_RIGHT };
    if (Kn.set(l.x - s, l.y - s, s * 2, s * 2), Kn.contains(r)) return { item: null, handle: it.TOP_RIGHT };
    if (Kn.set(h.x - s, h.y - s, s * 2, s * 2), Kn.contains(r)) return { item: null, handle: it.BOTTOM_LEFT };
    if (Kn.set(d.x - s, d.y - s, s * 2, s * 2), Kn.contains(r)) return { item: null, handle: it.TOP_LEFT };
  }
  ut.set(d.y - l.y, l.x - d.x).normalize().multiply(s, s), It.set(ut.x, ut.y).negate(), Xt.set(d.y - h.y, h.x - d.x).normalize().multiply(s, s), fn.set(Xt.x, Xt.y).negate();
  const p = 0, E = a ? 0 : 1;
  return We.setP(
    h.clone().add(p, 0).add(ut),
    h.clone().add(p, 0).add(It.clone().multiply(E, E)),
    c.clone().add(-0, 0).add(ut)
  ), We.isPointInside(r) ? { item: null, handle: it.BOTTOM } : (We.setP(
    c.clone().add(0, p).add(fn),
    c.clone().add(0, p).add(Xt.clone().multiply(E, E)),
    l.clone().add(0, -0).add(fn)
  ), We.isPointInside(r) ? { item: null, handle: it.RIGHT } : (We.setP(
    d.clone().add(0, p).add(Xt),
    d.clone().add(0, p).add(fn.clone().multiply(E, E)),
    h.clone().add(0, -0).add(Xt)
  ), We.isPointInside(r) ? { item: null, handle: it.LEFT } : (We.setP(
    l.clone().add(p, 0).add(It),
    l.clone().add(p, 0).add(ut.clone().multiply(E, E)),
    d.clone().add(-0, 0).add(It)
  ), We.isPointInside(r) ? { item: null, handle: it.TOP } : (We.setP(h, d, c), We.isPointInside(r) ? null : c.distance_to(r) < i ? { item: null, handle: it.BOTTOM_RIGHT_ROTATE } : l.distance_to(r) < i ? { item: null, handle: it.TOP_RIGHT_ROTATE } : h.distance_to(r) < i ? { item: null, handle: it.BOTTOM_LEFT_ROTATE } : d.distance_to(r) < i ? { item: null, handle: it.TOP_LEFT_ROTATE } : null))));
}, fc = [], WV = (e, n, s) => {
  const i = wr.RESIZE_HANDLES_HALF_BOX_WIDTH / pn.viewport.projectionTransform.a, r = wr.ROTATE_HANDLES_RADIUS / pn.viewport.projectionTransform.a, o = pn.viewport.toWorld(s);
  fc.length = 0;
  for (let a = 0; a < n.length; a++) {
    const c = n[a], l = e.transform.get(c.node.id).world.clone(), h = c.node.boundsLocal_zero, d = AN(l, h);
    let p = null;
    if (c.element.isLineElement()) {
      const E = c.element.get("geometry").get("mesh"), g = E.edges.values().next().value, T = E.getVertPos(g.v.id), A = E.getVertPos(g.w.id), m = Math.sign(A.x - T.x), O = Math.sign(A.y - T.y), S = new N(), y = new N();
      m * O > 0 ? (S.copy(l.xform(h.bottomRight)), y.copy(l.xform(h.topLeft))) : (S.copy(l.xform(h.bottomLeft)), y.copy(l.xform(h.topRight))), p = { signX: m, signY: O, p1: S, p2: y };
    }
    fc.push({ item: c, T: l, bbox: h, isTiny: d, lineInfo: p });
  }
  for (let a = 0; a < fc.length; a++) {
    const { item: c, T: l, bbox: h, isTiny: d, lineInfo: p } = fc[a];
    if (c.node.item.isEmpty || wc(h, l))
      continue;
    const E = l.clone().get_rotation();
    if (Po.reset().rotate(E), c.element.isLineElement()) {
      const { signX: g, signY: T, p1: A, p2: m } = p;
      if (ut.set(i, 0), It.set(0, i), Po.basis_xform(ut, ut), Po.basis_xform(It, It), Xt.copy(ut).negate(), fn.copy(It).negate(), ut.multiply(2, 2), It.multiply(2, 2), g * T > 0) {
        const O = A.clone().add(Xt).add(fn);
        if (We.setP(
          O,
          O.clone().add(ut),
          O.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.BOTTOM_RIGHT };
        const S = m.clone().add(Xt).add(fn);
        if (We.setP(
          S,
          S.clone().add(ut),
          S.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.TOP_LEFT };
      } else if (g === 0) {
        const O = A.clone().add(Xt).add(fn);
        if (We.setP(
          O,
          O.clone().add(ut),
          O.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.BOTTOM_RIGHT };
        const S = m.clone().add(Xt).add(fn);
        if (We.setP(
          S,
          S.clone().add(ut),
          S.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.TOP_LEFT };
      } else if (T === 0) {
        const O = m.clone().add(Xt).add(fn);
        if (We.setP(
          O,
          O.clone().add(ut),
          O.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.BOTTOM_RIGHT };
        const S = A.clone().add(Xt).add(fn);
        if (We.setP(
          S,
          S.clone().add(ut),
          S.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.TOP_LEFT };
      } else {
        const O = A.clone().add(Xt).add(fn);
        if (We.setP(
          O,
          O.clone().add(ut),
          O.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.BOTTOM_LEFT };
        const S = m.clone().add(Xt).add(fn);
        if (We.setP(
          S,
          S.clone().add(ut),
          S.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.TOP_RIGHT };
      }
    } else {
      const g = l.xform(h.bottomRight), T = l.xform(h.topRight), A = l.xform(h.bottomLeft), m = l.xform(h.topLeft);
      if (d) {
        ut.set(i, 0), It.set(0, i), Po.basis_xform(ut, ut), Po.basis_xform(It, It), Xt.copy(ut).negate(), fn.copy(It).negate();
        const O = g.clone();
        if (We.setP(
          O,
          O.clone().add(ut),
          O.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.BOTTOM_RIGHT };
        const S = T.clone().add(fn);
        if (We.setP(
          S,
          S.clone().add(ut),
          S.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.TOP_RIGHT };
        const y = A.clone().add(Xt);
        if (We.setP(
          y,
          y.clone().add(ut),
          y.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.BOTTOM_LEFT };
        const v = m.clone().add(Xt).add(fn);
        if (We.setP(
          v,
          v.clone().add(ut),
          v.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.TOP_LEFT };
      } else {
        Po.reset().rotate(E), ut.set(i, 0), It.set(0, i), Po.basis_xform(ut, ut), Po.basis_xform(It, It), Xt.copy(ut).negate(), fn.copy(It).negate(), ut.multiply(2, 2), It.multiply(2, 2);
        const O = g.clone().add(Xt).add(fn);
        if (We.setP(
          O,
          O.clone().add(ut),
          O.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.BOTTOM_RIGHT };
        const S = T.clone().add(Xt).add(fn);
        if (We.setP(
          S,
          S.clone().add(ut),
          S.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.TOP_RIGHT };
        const y = A.clone().add(Xt).add(fn);
        if (We.setP(
          y,
          y.clone().add(ut),
          y.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.BOTTOM_LEFT };
        const v = m.clone().add(Xt).add(fn);
        if (We.setP(
          v,
          v.clone().add(ut),
          v.clone().add(It)
        ), We.isPointInside(o)) return { item: c, handle: it.TOP_LEFT };
      }
    }
  }
  for (let a = 0; a < n.length; a++) {
    const { item: c, T: l, bbox: h, isTiny: d } = fc[a];
    if (c.node.item.isEmpty || wc(h, l) || c.element.isLineElement()) continue;
    const p = l.xform(h.bottomRight), E = l.xform(h.topRight), g = l.xform(h.bottomLeft), T = l.xform(h.topLeft), A = l.get_scale(), m = (A.x >= 0 ? 1 : -1) * (A.y >= 0 ? 1 : -1);
    ut.set(T.y - E.y, E.x - T.x).normalize().multiply(i, i).multiply(m, m), It.set(ut.x, ut.y).negate(), Xt.set(T.y - g.y, g.x - T.x).normalize().multiply(i, i).multiply(m, m), fn.set(Xt.x, Xt.y).negate();
    const O = !d || c.node.item.isScreen() ? 1 : 0;
    if (We.setP(
      g.clone().add(ut),
      g.clone().add(It.clone().multiply(O, O)),
      p.clone().add(ut)
    ), We.isPointInside(o)) return { item: c, handle: it.BOTTOM };
    if (We.setP(
      p.clone().add(fn),
      p.clone().add(Xt.clone().multiply(O, O)),
      E.clone().add(fn)
    ), We.isPointInside(o)) return { item: c, handle: it.RIGHT };
    if (We.setP(
      T.clone().add(Xt),
      T.clone().add(fn.clone().multiply(O, O)),
      g.clone().add(Xt)
    ), We.isPointInside(o)) return { item: c, handle: it.LEFT };
    if (We.setP(
      E.clone().add(It),
      E.clone().add(ut.clone().multiply(O, O)),
      T.clone().add(It)
    ), We.isPointInside(o)) return { item: c, handle: it.TOP };
  }
  for (let a = 0; a < n.length; a++) {
    const { item: c, T: l, bbox: h, lineInfo: d } = fc[a];
    if (!(c.node.item.isEmpty || wc(h, l) || c.node.item.isScreen()))
      if (c.element.isLineElement()) {
        const { signX: p, signY: E, p1: g, p2: T } = d;
        if (PH(o, c.node.id)) continue;
        if (p * E > 0) {
          if (g.distance_to(o) < r) return { item: c, handle: it.BOTTOM_RIGHT_ROTATE };
          if (T.distance_to(o) < r) return { item: c, handle: it.TOP_LEFT_ROTATE };
        } else {
          if (g.distance_to(o) < r) return { item: c, handle: it.BOTTOM_LEFT_ROTATE };
          if (T.distance_to(o) < r) return { item: c, handle: it.TOP_RIGHT_ROTATE };
        }
      } else {
        const p = l.xform(h.bottomRight), E = l.xform(h.topRight), g = l.xform(h.bottomLeft), T = l.xform(h.topLeft);
        if (We.setP(g, T, p), We.isPointInside(o)) continue;
        if (p.distance_to(o) < r) return { item: c, handle: it.BOTTOM_RIGHT_ROTATE };
        if (E.distance_to(o) < r) return { item: c, handle: it.TOP_RIGHT_ROTATE };
        if (g.distance_to(o) < r) return { item: c, handle: it.BOTTOM_LEFT_ROTATE };
        if (T.distance_to(o) < r) return { item: c, handle: it.TOP_LEFT_ROTATE };
      }
  }
  return null;
};
function mN(e, n, s, i, r = !1) {
  const o = [];
  for (let a = 0, c = s.length; a < c; a++) {
    const l = s[a], h = pn.dataStore.getById(l);
    if (!e.hidden.get(l) && !(r && e.locked.get(l)))
      if (h.isLineElement()) {
        const p = e.transform.get(l), E = h.get("geometry").get("mesh"), g = Array.from(E.edges.values());
        for (let T = 0; T < g.length; T++) {
          const A = p.world.xform(E.getVertPos(g[T].v.id)), m = p.world.xform(E.getVertPos(g[T].w.id));
          if (i.intersects_segment(A, m)) {
            o.push(l);
            break;
          }
        }
      } else {
        const p = n.get(l), E = e.bounds.get(l).local, g = e.bounds.get(l).world;
        if (p.parent && p.parent.item.clipping) {
          const T = e.bounds.get(p.parent.id).world;
          g.clip_by(T);
        }
        if (g.is_zero()) continue;
        if (i.containsRect(g))
          o.push(l);
        else if (i.overlaps(g)) {
          let T = !1;
          const A = e.transform.get(l), m = A.world.xform(E.actualTopLeft()), O = A.world.xform(E.actualTopRight()), S = A.world.xform(E.actualBottomRight()), y = A.world.xform(E.actualBottomLeft()), v = [[m, O], [O, S], [S, y], [y, m]];
          for (let M = 0; M < 4; M++) {
            const [L, P] = v[M];
            if (i.intersects_segment(L, P)) {
              o.push(l), T = !0;
              break;
            }
          }
          if (T) continue;
          const R = i.actualTopLeft();
          if (We.set(m.x, m.y, O.x, O.y, y.x, y.y), We.isPointInside(R)) {
            o.push(l);
            continue;
          }
        }
      }
  }
  return o;
}
function ON(e, n, s, i, r) {
  const a = e.transform.get(n.id).local;
  return new ye(
    a.tx,
    a.ty - r[1] / i,
    s ? r[0] / i : 0,
    s ? r[1] / i : 0
  );
}
function YV(e, n, s, i, r) {
  const o = wr.VERT_HALF_BOX_WIDTH / i.scale, a = n.vertices, c = [];
  for (const l of a) {
    const d = e.transform.get(s.id).world.xform(n.getVertPos(l.id));
    Jd.set(r.x - o, r.y - o, 2 * o, 2 * o), Jd.contains(d) && c.push(l);
  }
  return c;
}
function XV(e, n, s) {
  const i = wr.ORIGIN_HALF_BOX_WIDTH / pn.viewport.scale, r = [];
  for (const o of s) {
    const a = o.item.transform.worldPivot;
    Jd.set(n.x - i, n.y - i, 2 * i, 2 * i), Jd.contains(a) && r.push(o);
  }
  return r;
}
function zV(e, n, s, i, r, o = !1) {
  const a = wr.VERT_HALF_BOX_WIDTH / i.scale, l = e.transform.get(s.id).world, h = [];
  for (const d of n.vertices) {
    const p = l.xform(n.getVertPos(d.id));
    (o && r.contains(p) || !o && r.overlaps(Kn.set(p.x - a, p.y - a, 2 * a, 2 * a))) && h.push(d);
  }
  return h;
}
function KV(e, n) {
  const s = e.guidelines[n.direction === dt.HORIZONTAL ? "horizontal" : "vertical"];
  s.map.set(n.id, n.position), s.isDirty = !0;
}
function QV(e, n) {
  Object.entries(e.guidelines).forEach(([, s]) => {
    s.map.has(n) && (s.map.delete(n), s.isDirty = !0);
  });
}
function ZV(e, n) {
  let s = "", i = "";
  if (e.guidelines.horizontal.sortedDataWorld.length) {
    const r = n.y, o = jd(e.guidelines.horizontal.sortedDataWorld, r, 1);
    Math.abs(o[1] - r) < wr.GUIDELINE_WIDTH / pn.viewport.projectionTransform.a && (s = o[0]);
  }
  if (e.guidelines.vertical.sortedDataWorld.length) {
    const r = n.x, o = jd(e.guidelines.vertical.sortedDataWorld, r, 1);
    Math.abs(o[1] - r) < wr.GUIDELINE_WIDTH / pn.viewport.projectionTransform.d && (i = o[0]);
  }
  return [
    s,
    i
  ];
}
function qV(e, n) {
  let s = null, i = null;
  return e.guidelines.horizontal.sortedDataWorld.length && (s = jd(e.guidelines.horizontal.sortedDataWorld, n.y, 1)), e.guidelines.vertical.sortedDataWorld.length && (i = jd(e.guidelines.vertical.sortedDataWorld, n.x, 1)), { closestHorizontal: s, closestVertical: i };
}
function jd(e, n, s) {
  let i = 0, r = e.length - 1;
  for (; i <= r; ) {
    const c = Math.floor((i + r) / 2), l = e[c][s];
    if (l === n)
      return e[c];
    l < n ? i = c + 1 : r = c - 1;
  }
  if (i >= e.length)
    return e[r];
  if (r < 0)
    return e[i];
  const o = e[i][s], a = e[r][s];
  return Math.abs(o - n) < Math.abs(a - n) ? e[i] : e[r];
}
const xE = new tb(), Jd = new ye(0, 0, 0, 0), Kn = new ye(), We = new zg(), ut = new N(), It = new N(), Xt = new N(), fn = new N(), Po = new Ce(), jV = {
  [st.RECTANGLE]: Me.PATH,
  [st.ELLIPSE]: Me.PATH,
  [st.PEN]: Me.PATH,
  [st.TEXT]: Me.TEXT,
  [st.CONTAINER]: Me.CONTAINER
}, JV = {
  [st.RECTANGLE]: mn.RECTANGLE,
  [st.ELLIPSE]: mn.ELLIPSE,
  [st.PEN]: mn.POLYGON,
  [st.TEXT]: mn.TEXT,
  [st.CONTAINER]: void 0
}, $V = { width: 1, height: 1 };
function eH(e, n, s, i) {
  const { dataStore: r } = e;
  let o, a = !1, c = !1;
  const l = new N(), h = new N(), d = (v) => {
    r.get("mode") !== "ACTION" && (o = v);
  }, p = (v = !0) => {
    o && (o = void 0, a = !1, c = !1, g = null, T = !1, i("default"), v && r.eam.setLastGeneralTool());
  }, E = (v) => {
    let R;
    if (o === st.TEXT) {
      const M = r.editor.cacheFontProps;
      R = { width: 0, height: Math.round(M.fontSize * M.lineHeight) };
    }
    if (c || (g = Kg(v, o, e, R), e.indexer.updateTransformRecursively(e.indexer.getNode(g.get("id"))), g.get("parent").recalculateBounds()), o === st.CONTAINER) {
      const { startPos: M, endPos: L } = c ? y(T) : { startPos: l, endPos: l.clone().add(100, 100) };
      s.start({ mousePos: M }), s.insideContainer = !0;
      const P = s.update({ mousePos: L }, { alt: !0 }, !1, !0);
      s.insideContainer = !1, s.end(!1), r.addElementsToContainer(r.sortElements([...P]), g), r.commitUndo(), r.isDesignMode && e.updateUpdateLevel(Is.UPDATE_ALL_NEED_BBOX_RECALC);
    }
  };
  r.eam.on(Y.ACTIVATE_RECTANGLE_TOOL, () => {
    d(st.RECTANGLE);
  }), r.eam.on(Y.ACTIVATE_CONTAINER_TOOL, () => {
    d(st.CONTAINER);
  }), r.eam.on(Y.ACTIVATE_ELLIPSE_TOOL, () => {
    d(st.ELLIPSE);
  }), r.eam.on(Y.ACTIVATE_TEXT_TOOL, () => {
    d(st.TEXT);
  });
  let g = null, T = !1;
  r.eam.on(Y.START_CREATE_ELEMENT, (v) => {
    a = !0, l.copy(v.mousePos), h.copy(v.mousePos);
  }).on(Y.UPDATE_CREATE_ELEMENT, (v, R, { snapToGrid: M = !0, snapToObject: L = !0 }) => {
    c || (g = Kg(l, o, e, $V, !1, M), e.updateTransformRecursively(g.get("id")), n.setHandle("BOTTOM_RIGHT"), n.ignoreActiveTool = !0, n.resizeStart(v, M, L)), c = !0, n.resizeUpdate(v, R, M, L), h.copy(v.mousePos), T = R.alt;
  }).on(Y.END_CREATE_ELEMENT, () => {
    const v = o === st.CONTAINER, R = o === st.TEXT;
    n.resizeEnd(!v && (!R || c)), a && (E(h), p());
  }), r.eam.on(Y.CREATE_ELEMENT_W_DEFAULT_SIZE, (v) => {
    T = !1, l.copy(v.mousePos), h.copy(v.mousePos), E(v.mousePos), p();
  });
  let A = null, m = null;
  const { viewport: O } = e, S = new N();
  r.eam.on(Y.START_CREATE_GUIDE, (v) => {
    m = null, A = null, l.copy(v.mousePos), v.mousePos.x < ft.size && v.mousePos.y >= ft.size ? A = dt.VERTICAL : v.mousePos.y < ft.size && v.mousePos.x >= ft.size && (A = dt.HORIZONTAL);
  }).on(Y.UPDATE_CREATE_GUIDE, (v, R, { snapToGrid: M = !0, snapToObject: L = !0 }) => {
    const P = O.toWorld(v.mousePos);
    if (m) {
      const k = e.dataStore.selection.get("hoverGuideline");
      M && (A === dt.HORIZONTAL ? P.y = Math.round(P.y) : P.x = Math.round(P.x));
      const Q = P.clone();
      if (Q.sub(S), L) {
        e.snapping.updateSnapMovingDataForGuides();
        const b = e.snapping.compareVerticesWithGuides(k, Q, M);
        Number.isFinite(b) && (k.direction === dt.VERTICAL ? Q.x += b : Q.y += b);
      }
      r.guidelines.moveMultiGuidelines([k], Q), S.add(Q);
    } else {
      A === dt.VERTICAL ? v.mousePos.x >= ft.size && (m = r.guidelines.createGuideline(A, P.x), S.copy(O.toWorld(v.mousePos))) : A === dt.HORIZONTAL && v.mousePos.y >= ft.size && (m = r.guidelines.createGuideline(A, P.y), S.copy(O.toWorld(v.mousePos)));
      const k = e.dataStore.guidelines.getGuideline(m);
      e.dataStore.selection.set("hoverGuideline", k), r.eam.changeHover(Gt.GUIDELINE);
    }
  }).on(Y.END_CREATE_GUIDE, () => {
    r.commitUndo();
  });
  function y(v) {
    if (!v)
      return {
        startPos: l,
        endPos: h
      };
    const R = l.clone(), M = h.clone(), L = M.clone().sub(R);
    return {
      startPos: R.clone().sub(L),
      endPos: M
    };
  }
}
function tH(e) {
  const n = NH(e), s = n.children.length;
  return { parent: n, index: s };
}
function Kg(e, n, s, i, r = !0, o = !0) {
  const { dataStore: a, viewport: c } = s, l = jV[n], h = c.toWorld(e);
  o && h.round(), s.indexer.getActiveScreenNode().item.transform.worldInv.xform(h, h);
  const { parent: d, index: p } = tH(h), E = [
    a.createNewElement(l, h, i, JV[n])
  ], g = a.workspace.watched.children[0];
  if (a.addChildrenAt(g, E, g.children.length, On), d !== g && !a.addChildrenAt(d, E, p, On)) {
    console.warn("Failed to create new element"), a.clearUndo();
    return;
  }
  return a.selection.selectElements(
    E,
    r && l !== Me.TEXT ? { EventFlag: or.FROM_ELEMENT_CREATE } : { ...On, EventFlag: or.FROM_ELEMENT_CREATE }
  ), l === Me.TEXT && a.eam.activateTextEditMode(!0), E[0];
}
const ps = Object.freeze(
  {
    NONE: -1,
    Vertex: 0,
    Edge: 1,
    Contour: 2,
    SameAxis: 3
  }
), Wi = new se();
class nH {
  /**
   * @param {VisualServer} visualServer
   */
  constructor(n) {
    this.visualServer = n, this.mesh = void 0, this.mapEdge2TreeItem = /* @__PURE__ */ new Map(), this.dirty = !1, this.setDirtyFunc = this.setDirty.bind(this), this.onMeshChangedFunc = this.onMeshChanged.bind(this), this.positionStaticBuffer = new N(), this.positionStaticBuffer2 = new N(), this.vertexHittest = null;
  }
  /**
   * @param {Element} element
   * @param {Mesh} mesh
   * @param {RenderItem} node
   */
  assign(n, s, i) {
    this.clear(), this.element = n, this.mesh = s, this.node = i, s || console.error("No mesh is specified to the SnappingPath"), this.createEdgeTree(), this.node.transform.on("updateWorld", this.setDirtyFunc), this.element.get("geometry").on(Oe.MESH_CHANGES, this.onMeshChangedFunc);
  }
  cancel() {
    this.clear(), this.node && this.node.transform.off("updateWorld", this.setDirtyFunc), this.element && this.element.get("geometry").off(Oe.MESH_CHANGES, this.onMeshChangedFunc), this.element = null, this.mesh = null, this.node = null;
  }
  createEdgeTree() {
    const n = this.element.get("size");
    for (const s of this.mesh.edges) {
      const i = {
        bbox: new ye(),
        edge: s
      };
      this.mapEdge2TreeItem.set(s, i), this._fillEdgeTreeItem(s, n, i);
    }
  }
  updateEdgeTree() {
    const n = this.element.get("size");
    for (const [s, i] of this.mapEdge2TreeItem)
      this._fillEdgeTreeItem(s, n, i);
  }
  /**
   *
   * @param {Edge} edge
   * @param {duVector2} size
   * @param {EdgeTreeItem} treeItem
   * @returns {EdgeTreeItem}
   */
  _fillEdgeTreeItem(n, s, i) {
    const r = this.node.transform.world, o = new ye();
    return n.isCurve ? this._fillCurveTreeItem(n, s, r, i, o) : this._fillLineTreeItem(n, s, o, r, i);
  }
  _fillCurveTreeItem(n, s, i, r, o) {
    const a = this.mesh.getEdgeCurve(n.id), c = new N(a[0].x, a[0].y), l = new N(a[1].x, a[1].y), h = this.mesh.getVertPos(n.v.id), d = new N(h.x, h.y), p = this.mesh.getVertPos(n.w.id), E = new N(p.x, p.y);
    i.xform(c, c), i.xform(l, l), i.xform(d, d), i.xform(E, E), r.bezier = new Bt(
      d.x,
      d.y,
      c.x,
      c.y,
      l.x,
      l.y,
      E.x,
      E.y
    );
    const g = r.bezier.bbox();
    return o.set(g.x.min, g.y.min, g.x.max - g.x.min, g.y.max - g.y.min), r.bbox.copy(o), r;
  }
  _fillLineTreeItem(n, s, i, r, o) {
    const a = this.mesh.getVertPos(n.v.id), c = a.x, l = a.y, h = this.mesh.getVertPos(n.w.id), d = h.x, p = h.y, E = Math.max(c, d), g = Math.min(c, d), T = Math.max(l, p), A = Math.min(l, p), m = 5;
    i.set(g, A, Math.max(m, E - g), Math.max(m, T - A));
    const O = r.xform_rect(i);
    return o.bbox.copy(O), o;
  }
  clear() {
    this.mapEdge2TreeItem.clear();
  }
  /**
   * Executes the update event about the actions once per frame.
   */
  update() {
    this.dirty && (this.dirty = !1, this.updateEdgeTree());
  }
  setDirty() {
    this.dirty = !0;
  }
  onMeshChanged(n) {
    n.DELETE.size !== 0 || n.CREATE.size !== 0 ? (this.clear(), this.createEdgeTree()) : this.dirty = !0;
  }
  /**
   * @todo Integrate all of the items able to be the target
   * @param {Vector2} worldMousePos
   * @param {boolean} snapToGrid
   * @param {boolean} snapToObject
   * @returns {SnapTarget}
   */
  snapMousePos(n, s, i) {
    const r = {
      type: ps.NONE,
      position: this.positionStaticBuffer
    }, o = {
      type: ps.NONE,
      position: this.positionStaticBuffer2
    };
    if (!i) return o;
    const a = this.visualServer.snapping, c = this._getThreshold(this.visualServer.viewport.scale), l = this.visualServer.snapping._convertPosToUIPanelVersion(n);
    return s && l.round(), this._snapOnEdge(l, r, c), this._snapOnSameAxis(a, n, o, [{ pos: l }], l, s), r.type === ps.Edge ? (o.type === ps.SameAxis && this._snapOnSameAxisEdge(a, r, o), r) : o;
  }
  _snapOnSameAxisEdge(n, s, i) {
    const r = s.edge, o = this._getThreshold(this.visualServer.viewport.scale);
    if (n.snapToElementXUI.size > 0) {
      const a = i.position.clone().add(0, -o), c = i.position.clone().add(0, o);
      if (r.isCurve) {
        const l = r._bezier.lineIntersects({ p1: a, p2: c });
        if (l.length > 0) {
          const h = new N().copy(r._bezier.get(l[0]));
          if (s.position.distance_squared_to(h) <= o * o) {
            const d = this.visualServer.snapping._convertPosToUIPanelVersion(h);
            s.position.copy(d), n.snapToElementXUI.has(d.x) && (n.snapToElementXUI.get(d.x).delete(i.position.y), n.snapToElementXUI.get(d.x).set(d.y, 0));
          } else
            n.snapToElementXUI.clear();
        } else
          n.snapToElementXUI.clear();
      } else {
        const { q1: l, q2: h } = s1(this.mesh, r, this.node.transform.world);
        let d = qn.intersect(a.x, a.y, c.x, c.y, l.x, l.y, h.x, h.y);
        if (l.x - h.x === 0 && i.position.x === l.x && (d = i.position.clone()), d && s.position.distance_squared_to(d) <= o * o) {
          const p = this.visualServer.snapping._convertPosToUIPanelVersion(d);
          s.position.copy(p), n.snapToElementXUI.has(p.x) && (n.snapToElementXUI.get(p.x).delete(i.position.y), n.snapToElementXUI.get(p.x).set(p.y, 0));
        } else
          n.snapToElementXUI.clear();
      }
    }
    if (n.snapToElementYUI.size > 0) {
      const a = i.position.clone().add(-o, 0), c = i.position.clone().add(o, 0);
      if (r.isCurve) {
        const l = r._bezier.lineIntersects({ p1: a, p2: c });
        if (l.length > 0) {
          const h = new N().copy(r._bezier.get(l[0]));
          if (s.position.distance_squared_to(h) <= o * o) {
            const d = this.visualServer.snapping._convertPosToUIPanelVersion(h);
            s.position.copy(d), n.snapToElementYUI.has(d.y) && (n.snapToElementYUI.get(d.y).delete(i.position.x), n.snapToElementYUI.get(d.y).set(d.x, 0));
          } else
            n.snapToElementYUI.clear();
        } else
          n.snapToElementYUI.clear();
      } else {
        const { q1: l, q2: h } = s1(this.mesh, r, this.node.transform.world);
        let d = qn.intersect(a.x, a.y, c.x, c.y, l.x, l.y, h.x, h.y);
        if (l.y - h.y === 0 && i.position.y === l.y && (d = i.position.clone()), d && s.position.distance_squared_to(d) <= o * o) {
          const p = this.visualServer.snapping._convertPosToUIPanelVersion(d);
          s.position.copy(p), n.snapToElementYUI.has(p.y) && (n.snapToElementYUI.get(p.y).delete(i.position.x), n.snapToElementYUI.get(p.y).set(p.x, 0));
        } else
          n.snapToElementYUI.clear();
      }
    }
  }
  _snapOnSameAxis(n, s, i, r = [], o, a) {
    const c = this.visualServer.viewport.rectW.clone(), l = 18 / this.visualServer.viewport.scale, h = this._getThreshold(this.visualServer.viewport.scale), p = this.visualServer.getRenderItemOfElement(this.element).transform.world, g = n._convertPosToUIPanelVersion(s).clone().sub(o);
    let T, A, m = !1, O = !1, S = h, y = h, v = s.x, R = s.y;
    const M = [], L = [];
    let P = !1, k = !1;
    const Q = new N();
    for (let b = 0; b < r.length; b++) {
      T = void 0, A = void 0;
      const X = r[b], K = X.id ? new N().fromArray(this.mesh.getVertPos(X.id)) : X.pos, V = this.visualServer.snapping._convertPosToUIPanelVersion(g.clone().add(K));
      X.id && p.xform(V, V);
      const J = n1(c, l, V, h), ge = Hu(this.mesh, J, p);
      for (const te of ge) {
        if (r.indexOf(te) !== -1 || te.isFlagged(Be.CURVE_VERT))
          continue;
        const ie = xl(this.mesh, p, te), re = this.visualServer.snapping._convertPosToUIPanelVersion(ie);
        if (a && !Number.isInteger(re.x)) continue;
        const fe = Math.abs(re.x - V.x);
        if (fe <= S && fe < h) {
          const Ne = re.x - V.x;
          (!P || Ne !== Q.x) && (P && fe !== S && (M.length = 0, n.snapToElementXUI.clear()), Q.x = Ne, S = fe, P = !0), T = re.x, n._addSnapXUIData(re.x, re.y, n.snapToElementXUI), m = !0;
        }
      }
      const ne = t1(c, l, V, h), ue = Hu(this.mesh, ne, p);
      for (const te of ue) {
        if (r.indexOf(te) !== -1 || te.isFlagged(Be.CURVE_VERT))
          continue;
        const ie = xl(this.mesh, p, te), re = this.visualServer.snapping._convertPosToUIPanelVersion(ie);
        if (a && !Number.isInteger(re.y)) continue;
        const fe = Math.abs(re.y - V.y);
        if (fe <= y && fe < h) {
          const Ne = re.y - V.y;
          (!k || Ne !== Q.y) && (k && fe !== y && (L.length = 0, n.snapToElementYUI.clear()), Q.y = Ne, y = fe, k = !0), A = re.y, n._addSnapYUIData(re.x, re.y, n.snapToElementYUI), O = !0;
        }
      }
      T !== void 0 && M.push(new N(T, V.y)), A !== void 0 && L.push(new N(V.x, A));
    }
    for (const b of M)
      n._addSnapXUIData(b.x, b.y + Q.y, n.snapToElementXUI);
    for (const b of L)
      n._addSnapYUIData(b.x + Q.x, b.y, n.snapToElementYUI);
    (m || O) && (v = s.x + Q.x, R = s.y + Q.y, i.position.set(v, R), i.type = ps.SameAxis);
  }
  snapDraggingVertex(n, s, i, r, o, a, c) {
    const l = {
      type: ps.NONE,
      position: this.positionStaticBuffer
    };
    if (!o) return l;
    const h = this.visualServer.snapping, d = /* @__PURE__ */ new Map(), p = new N(n.x - s.x, n.y - s.y);
    for (const A of i) {
      const m = xl(a, c, A);
      m.add(p), d.set(A, m);
    }
    const E = this._getThreshold(this.visualServer.viewport.scale);
    this._snapOnSameAxis(h, n, l, i, s, r);
    let g = E;
    const T = {
      type: ps.NONE,
      // the snapped vertex position
      position: new N(),
      // the original vertex position
      sourcePos: new N()
    };
    for (const [A, m] of d) {
      const O = this._snapOnEdge(m, T, g, i);
      if (O < g) {
        g = O;
        const S = this.mesh.getVertPos(A.id);
        T.sourcePos.fromArray(S), c.xform(T.sourcePos, T.sourcePos);
      }
    }
    return T.type === ps.Edge ? (l.type === ps.SameAxis && this._snapOnSameAxisEdge(h, T, l), T) : l;
  }
  /**
   * @typedef PosAlignAxes
   * @property {Vector2} alignDelta
   * @property {boolean} isAligned
   */
  /**
   * @param {Rect2} viewportRect
   * @param {number} rulerSize
   * @param {number} threshold
   * @param {Map<Vertex, Vector2>} selectVertices2WorldPosPred
   * @param {Snapping} elemSnapping
   * @returns {PosAlignAxes}
   */
  _getPosAlignAxes(n, s, i, r, o) {
    let a = i, c = i, l = 0, h = 0, d = !1;
    const E = this.visualServer.getRenderItemOfElement(this.element).transform.world;
    for (const T of r.values()) {
      const A = o._convertPosToUIPanelVersion(T), m = n1(n, s, T, i), O = Hu(this.mesh, m, E);
      for (const v of O) {
        if (v.isFlagged(Be.CURVE_VERT) || r.has(v))
          continue;
        const R = xl(this.mesh, E, v), M = this.visualServer.snapping._convertPosToUIPanelVersion(R), L = Math.abs(M.x - A.x);
        L < a && (a = L, l = R.x - T.x, d = !0);
      }
      const S = t1(n, s, T, i), y = Hu(this.mesh, S, E);
      for (const v of y) {
        if (v.isFlagged(Be.CURVE_VERT) || r.has(v))
          continue;
        const R = xl(this.mesh, E, v), M = this.visualServer.snapping._convertPosToUIPanelVersion(R), L = Math.abs(M.y - A.y);
        L < c && (c = L, h = R.y - T.y, d = !0);
      }
    }
    return { alignDelta: new N(l, h), isAligned: d };
  }
  _snapOnEdge(n, s, i, r = []) {
    const o = [];
    for (const [c, l] of this.mapEdge2TreeItem)
      if (l.bbox.contains(n) && o.push(l), l.bbox.height === 0 || l.bbox.width === 0) {
        const h = new ye(n.x, n.y).grow_to(i);
        l.bbox.intersects(h) && o.push(l);
      }
    let a = i;
    for (const c of o) {
      if (!c.edge)
        continue;
      const l = c.edge;
      if (!(r.indexOf(l.v) !== -1 || r.indexOf(l.w) !== -1))
        if (l.isCurve) {
          const h = c.bezier;
          if (!h) {
            console.error(`No bezier found for ${l.id}`);
            continue;
          }
          const d = h.project(n);
          Math.abs(d.d) < a && (a = d.d, s.type = ps.Edge, s.edge = l, s.position.set(d.x, d.y), s.timeOnEdge = d.t);
        } else {
          this.mesh.getVertPos(l.v.id, Wi);
          const h = Wi.x, d = Wi.y;
          this.mesh.getVertPos(l.w.id, Wi);
          const p = Wi.x, E = Wi.y, g = new N(h, d), T = new N(p, E);
          if (this.node.transform.world.xform(g, g), this.node.transform.world.xform(T, T), g.equals(T))
            continue;
          const A = zy(
            n.x,
            n.y,
            g.x,
            g.y,
            T.x,
            T.y
          );
          if (a > Math.abs(A)) {
            s.type = ps.Edge, s.edge = l, a = A, Ky(
              n.x,
              n.y,
              g.x,
              g.y,
              T.x,
              T.y,
              s.position
            );
            const m = new N(T.x - g.x, T.y - g.y), O = new N(s.position.x - g.x, s.position.y - g.y);
            s.timeOnEdge = O.length() / m.length();
          }
        }
    }
    return a;
  }
  /**
   * @todo Use this function if bezier.project is the bottleneck
   * @param {Vector2} worldMousePos
   * @param {LUTItem[]} LUT
   * @param {number} threshold
   * @returns {LUTItem}
   */
  findClosestLUT(n, s, i) {
    let r, o = i;
    for (let a = 0; a < s.length; a++) {
      const c = s[a];
      c.t = a / (s.length - 1);
      const l = n.distance_to(c);
      l < o && (o = l, c.i = a, r = c);
    }
    return r;
  }
  /**
   * @todo Use this function if bezier.project is the bottleneck
   * Binary search for the projected point on the curve within the closest LUTs
   * @param {Bezier} curve
   * @param {Vector2} worldMousePos
   * @param {LUTItem[]} LUT
   * @param {number} index
   * @returns {LUTItem}
   */
  refineBinary(n, s, i, r) {
    let o = r, a = i, c = a[o], l = 1, h = Number.MAX_SAFE_INTEGER;
    do {
      const d = o === 0 ? 0 : o - 1, p = o === a.length - 1 ? a.length - 1 : o + 1, E = a[d].t, g = a[p].t, T = [], A = (g - E) / 4;
      if (A < 1e-3) break;
      T.push(a[d]);
      for (let m = 1; m <= 3; m++) {
        const O = n.get(E + m * A);
        O.distance = Math.abs(s.distance_to(O)), O.distance < h && (h = O.distance, c = O, o = m), T.push(O);
      }
      T.push(a[p]), a = T;
    } while (l++ < 25);
    return c;
  }
  /**
   *
   * @param {Vector2} worldMousePos
   * @param {Vector2} basePoint
   * @param {Vector2} outputPoint
   * @param {boolean} snapToGrid
   * @returns {Vector2}
   */
  constraint(n, s, i, r) {
    let o = Number.MIN_VALUE;
    n.sub(s);
    const a = new N(), c = new N();
    for (let l = 0; l < 8; l++) {
      const h = 45 * l * (Math.PI / 180);
      a.set(Math.cos(h), Math.sin(h));
      const d = a.dot(n);
      o < d && (o = d, c.copy(a));
    }
    return i.set(o * c.x, o * c.y), i.scale(100), i.x = i.x < 0 ? -Math.round(-i.x) : Math.round(i.x), i.y = i.y < 0 ? -Math.round(-i.y) : Math.round(i.y), i.scale(0.01), r && (i.x = i.x < 0 ? -Math.round(-i.x) : Math.round(i.x), i.y = i.y < 0 ? -Math.round(-i.y) : Math.round(i.y)), i.add(s), i;
  }
  _getThreshold(n) {
    const s = Math.floor(n * 100);
    if (s <= 2)
      return 200;
    if (s <= 5)
      return 100;
    if (s <= 10)
      return 66;
    if (s <= 25)
      return 21;
    if (s <= 50)
      return 9;
    if (s <= 75)
      return 7;
    if (s <= 100)
      return 4;
    if (s <= 200)
      return 3;
    if (s <= 400)
      return 2;
    if (s <= 25600)
      return 1;
  }
}
function t1(e, n, s, i) {
  const r = e.x + n;
  let o = s.y - i * 2;
  o < e.y + n && (o = e.y + n);
  const a = e.width - n;
  let c = i * 4;
  return o + c > e.bottom && (c = e.bottom - o), new ye(r, o, a, c);
}
function n1(e, n, s, i) {
  let r = s.x - i * 2;
  r < e.x + n && (r = e.x + n);
  const o = e.y + n;
  let a = i * 4;
  r + a > e.right && (a = e.right - r);
  const c = e.height - n;
  return new ye(r, o, a, c);
}
function xl(e, n, s) {
  const i = e.getVertPos(s.id), r = new N();
  return r.set(i[0], i[1]), n.xform(r, r), r;
}
function s1(e, n, s) {
  e.getVertPos(n.v.id, Wi);
  const i = Wi.x, r = Wi.y;
  e.getVertPos(n.w.id, Wi);
  const o = Wi.x, a = Wi.y, c = new N(i, r), l = new N(o, a);
  return s.xform(c, c), s.xform(l, l), { q1: c, q2: l };
}
function Hu(e, n, s) {
  const i = [];
  for (const r of e.vertices) {
    const o = e.getVertPos(r.id), a = s.xform(o);
    n.contains(a) && i.push(r);
  }
  return i;
}
let ke = null, at = null, jt = null, _a = null, Qg = !1;
const Nt = new N(), sH = new ye();
function iH(e, n) {
  ke = e, rH(n), oH(n), lH(n);
}
const i1 = () => {
  td();
};
function r1(e) {
  if (!e) {
    _a && (_a.off(Oe.MESH_CHANGES, i1), _a = null), at && (at = null), jt && (jt.off("size", td), jt.off(Oe.TRIGGER_VECTOR_FORCE_UPDATE, td), Qg = !1, jt.removeIfEmpty()), Qg && console.log("should correct the origin"), jt = null, c4(), ro(), ke.snappingPath.cancel();
    return;
  }
  jt = e, jt.on(Oe.TRIGGER_VECTOR_FORCE_UPDATE, td), _a = jt.get("geometry"), _a.execute("startEditing"), at = _a.get("mesh"), _a.on(Oe.MESH_CHANGES, i1), a4(jt), ke.snappingPath.assign(jt, at, ke.getRenderItemOfElement(jt));
}
function $d(e, n) {
  const s = e.get("mesh"), i = BH(s, ke.getRenderItemOfElement(e), ke.viewport, n), r = [], o = 1 << Be.CONNECT_SELECTED | 1 << Be.SELECTED;
  for (const a of i) {
    if (a.isFlagged(Be.CURVE_VERT))
      if (a.adjacentMainVertex) {
        if (!(a.adjacentMainVertex.flags & o) || a.adjacentMainVertex.pos.eq(a.pos))
          continue;
      } else
        console.warn("There is a curve control without real vertex");
    r.push(a);
  }
  return r.length > 0 ? r.sort((a, c) => a.index - c.index)[0] : null;
}
function rH(e) {
  const n = ke.viewport, s = ke.dataStore;
  s.selection.on(Oe.SELECT_CELL, (r) => {
    const o = r.get("vertices").before;
    if (o.length === 1) {
      if (!at) {
        console.error("Can not deselect node not in the path edit mode");
        return;
      }
      at.vertices.has(o[0]) && !o[0].isFlagged(Be.CURVE_VERT) && o[0].upperTierIDs.size === 0 && at.deleteCellsByVertex(o);
    }
  });
  let i;
  s.on("editMode", (r) => {
    if (r === Dn.SHAPE) {
      const o = ke.selection.single;
      o && o.element ? (e(s.eam.states.activeTool === st.PEN ? "penDefault" : "default"), r1(o.element)) : console.warn("Entrying ShapeState without selected element"), s.get("editMode") !== Dn.SHAPE && console.error("The editMode should be shape mode");
    } else i === Dn.SHAPE && (r1(null), s.get("editMode") !== Dn.ELEMENT && console.error("The editMode should be element mode"));
    i = r;
  }), s.eam.on(Y.SELECT_ALL_CELLS, () => {
    s.selection.get("guidelines").length ? s.selection.selectGuidelines(ke.dataStore.guidelines.getAllGuidelines()) : s.selection.selectVertices([...at.vertices].filter((o) => !o.isFlagged(Be.CURVE_VERT)));
  }), s.eam.on(Y.HOVER_CREATE_PATH, ({ mousePos: r }, o, { snapToGrid: a = !0, snapToObject: c = !0 }) => {
    Sl(r.x, r.y, a);
  }), s.eam.on(Y.SWITCH_BEND_TOOL, ({ mousePos: r }) => {
    const o = n.toWorld(r), a = $d(ke.selection.first.element, o);
    s.selection.set("hoverVertex", a), a ? a.isFlagged(Be.CURVE_VERT) ? (s.eam.changeHover(Gt.CURVE_CONTROL), e("convertPath")) : (s.eam.changeHover(Gt.VERTEX), e("default")) : e("default");
  }), s.eam.on(Y.HOVER_CELL, ({ mousePos: r }, { shift: o = !1 }, { snapToGrid: a = !0, snapToObject: c = !0 }) => {
    const l = s.eam.states.activeTool === st.PEN, h = s.selection.get("vertices"), d = ef(h), p = n.toWorld(r);
    if (ro(), qo([]), l) {
      a && p.round();
      const m = n.toScreen(p);
      Sl(m.x, m.y, a), e("penDefault");
    } else
      e("default");
    if (s.get("editMode") !== Dn.SHAPE)
      return;
    const E = $d(ke.selection.first.element, p);
    if (s.selection.set("hoverVertex", E), Rc([]), E) {
      if (E.isFlagged(Be.CURVE_VERT))
        e("default"), s.eam.changeHover(Gt.CURVE_CONTROL), Mg(!1);
      else {
        let m = Gt.VERTEX;
        E.upperTierIDs.size > 1 || (m = Gt.ENDPOINT), s.eam.changeHover(m), m !== Gt.ENDPOINT ? e("default") : l && e(d ? "penClose" : "penOpen"), Mg(l && c);
      }
      s.selection.set("snapTarget", null);
      return;
    }
    if (!l) {
      s.selection.set("snapTarget", null);
      return;
    }
    const g = ke.snappingPath.snapMousePos(p, a, c), T = g.position.clone();
    let A = !1;
    if (l && o && d) {
      const m = ff(jt, at, h[0]);
      ke.snappingPath.constraint(p, m, T, a), qo([[n.toScreen(m), n.toScreen(T)]]), A = !0, T.equals(g.position) || ro(), g.position.copy(T);
    } else
      qo([]);
    switch (g.type) {
      case ps.Edge: {
        g.edge || console.warn("The edge of the target is missing");
        const m = n.toScreen(g.position);
        Sl(m.x, m.y, a), A || (s.eam.changeHover(Gt.EDGE), s.selection.set("snapTarget", g), e("penAdd"), Rc([g.edge.id]));
        break;
      }
      case ps.SameAxis: {
        const m = n.toScreen(g.position);
        Sl(m.x, m.y, a);
        break;
      }
      case ps.NONE:
        if (A) {
          const m = n.toScreen(T);
          Sl(m.x, m.y, a);
        } else
          g.position.copy(p);
    }
    s.selection.set("snapTarget", g);
  }), s.eam.on(Y.SELECT_CELL, (r, { shift: o, alt: a }) => {
    const c = ke.dataStore.selection, l = c.get("hoverVertex");
    if (!l) {
      r.handled = !1;
      return;
    }
    if (l.isFlagged(Be.CURVE_VERT) && l.adjacentMainVertex && l.adjacentMainVertex.upperTierIDs.size < 1) {
      r.handled = !1;
      return;
    }
    if (a && l.isFlagged(Be.CURVE_VERT) && at.prepareVertexPropertyChanges(l.adjacentMainVertex.id, "mirror", pe.INDEPENDENT), o) {
      c.toggleVertices([l]);
      return;
    }
    c.get("vertices").includes(l) || c.selectVertices([l]);
  }), s.eam.on(Y.DESELECT_CELL, () => {
    ke.dataStore.selection.selectVertices([]);
  }), ke.dataStore.eam.on(Y.TOGGLE_CELL_SELECTION, () => {
    const r = ke.dataStore.selection, o = r.get("hoverVertex");
    o && r.toggleVertices([o]);
  }), ke.dataStore.eam.on(Y.MOVE_CELL_SELECTION_KEY, (r) => {
    hH(r);
  });
}
function oH(e) {
  const n = ke.dataStore, s = n.selection, i = ke.viewport;
  {
    const r = new N(), o = new N();
    let a = !1;
    const c = ke.snapping, l = new N(), h = new N();
    let d, p;
    n.eam.on(Y.START_DRAG_CELL, (E) => {
      d = s.get("hoverVertex");
      const g = i.toWorld(E.mousePos);
      h.copy(ff(jt, at, d)), l.copy(g), r.copy(h), o.set(0, 0), c.setSnappingOriginalPos(r), p = ke.getRenderItemOfElement(jt).transform.world, Rc([]);
    }).on(Y.UPDATE_DRAG_CELL, ({ mousePos: E }, { shift: g }, { snapToGrid: T = !0, snapToObject: A = !0 }) => {
      ro();
      const m = i.toWorld(E);
      a = g, o.copy(m).sub(l);
      const O = $d(ke.selection.first.element, m);
      e("default"), IN(
        O,
        s,
        p,
        m,
        d,
        h,
        T,
        A,
        r,
        a
      );
    }).on(Y.END_DRAG_CELL, () => {
      qo([]), ro(), c.setEndSnapping(), n.commitUndo();
    });
  }
  n.eam.on(Y.DELETE_CELL, () => {
    const r = s.get("vertices");
    r.length !== 0 && (at.deleteCellsByVertex(r), s.selectVertices([], On), n.commitUndo());
  }), n.eam.on(Y.DUPLICATE_CELL, () => {
    const r = s.get("vertices");
    if (r.length === 0) return;
    const o = at.closureOfCells(r), a = [], c = ke.getRenderItemOfElement(jt).transform.world, l = jt.get("size");
    for (const O of o) {
      const S = O.save();
      switch (S.type = O.type, S.type) {
        case "Vertex":
          {
            const y = at.getVertPos(S.id);
            Nt.set(y[0], y[1]), c.xform(Nt, Nt), S.pos[0] = Nt.x, S.pos[1] = Nt.y;
          }
          break;
        case "Edge":
          if (S.curve) {
            const y = at.getEdgeCurve(S.id);
            Nt.set(y[0][0], y[0][1]), c.xform(Nt, Nt), S.curve[0][0] = Nt.x, S.curve[0][1] = Nt.y, Nt.set(y[1][0], y[1][1]), c.xform(Nt, Nt), S.curve[1][0] = Nt.x, S.curve[1][1] = Nt.y;
          }
          break;
      }
      a.push(S);
    }
    const h = ke.viewport.rectW, d = Nt, p = sH;
    p.set();
    const E = new N();
    d.set(0, 0);
    let g = 0;
    const T = new N();
    for (let O = 0; O < a.length; O++)
      a[O].type === "Vertex" && (p.is_zero() ? p.set(a[O].pos[0], a[O].pos[1], 0, 0) : (T.set(a[O].pos[0], a[O].pos[1]), p.expand_to(T)), d.x += a[O].pos[0], d.y += a[O].pos[1], g++);
    d.x /= g, d.y /= g, h.intersects(p) || (E.x = h.center.x - d.x, E.y = h.center.y - d.y);
    const A = {};
    for (let O = 0; O < a.length; O++) {
      const S = a[O];
      switch (S.type) {
        case "Vertex":
          Nt.set(S.pos[0], S.pos[1]), Dc(Nt, Nt), A[S.id] = [Nt.x + E.x, Nt.y + E.y];
          break;
        case "Edge":
          S.curve && (Nt.set(S.curve[0][0], S.curve[0][1]), Dc(Nt, Nt), S.curve[0][0] = Nt.x + E.x, S.curve[0][1] = Nt.y + E.y, Nt.set(S.curve[1][0], S.curve[1][1]), Dc(Nt, Nt), S.curve[1][0] = Nt.x + E.x, S.curve[1][1] = Nt.y + E.y, A[S.id] = [S.curve[0], S.curve[1]]);
          break;
      }
    }
    const m = at.duplicateCells(a, A, l.x, l.y);
    s.selectVertices(m, On), n.commitUndo();
  });
}
function IN(e, n, s, i, r, o, a, c, l, h) {
  const d = n.get("vertices"), p = ke.viewport, { delta: E, adjustedMousePos: g } = aH(e, r, p, o, a, c, i, d, s);
  if (h) {
    const T = l.clone();
    g.add(E), ke.snappingPath.constraint(i, T, g, a), qo([[p.toScreen(l), p.toScreen(g)]]);
    const A = g.sub(o);
    A.equals(E) || ro(), E.copy(A);
  } else
    qo([]);
  o.add(E), SN(E, E), at.moveVertex(
    d,
    E.x,
    E.y
  );
}
function aH(e, n, s, i, r, o, a, c, l) {
  const h = new N(), d = new N();
  if (o && e && e !== n) {
    Rc([]);
    const p = ff(jt, at, e);
    qo([[s.toScreen(p), s.toScreen(p)]]), h.set(p.x - i.x, p.y - i.y), d.copy(p);
  } else {
    r && a.round();
    const p = ke.snappingPath.snapDraggingVertex(
      a,
      i,
      c,
      r,
      o,
      at,
      l
    );
    p.type === ps.Edge && p.edge && p.edge.v !== n && p.edge.w !== n ? (h.set(p.position.x - p.sourcePos.x, p.position.y - p.sourcePos.y), Rc([p.edge.id]), d.copy(p.position)) : (Rc([]), h.set(a.x - i.x, a.y - i.y), d.copy(a)), p.type === ps.SameAxis && (h.set(p.position.x - i.x, p.position.y - i.y), d.copy(p.position));
  }
  return { delta: h, adjustedMousePos: d };
}
function ro() {
  ke.snapping.snapToElementXUI.clear(), ke.snapping.snapToElementYUI.clear();
}
function cH(e, n, s = !0, i) {
  const r = ke.dataStore.selection.get("hoverVertex"), o = ke.dataStore.selection.get("vertices");
  if (!ef(o)) {
    vc();
    return;
  }
  if (r)
    r.upperTierIDs.size < 2 ? h4(r.id, n) : vc();
  else {
    const a = ke.dataStore.selection.get("snapTarget");
    if (a && a.type !== ps.Edge) {
      const c = ke.viewport.toScreen(a.position);
      l4(c.x, c.y, n);
    } else
      vc();
  }
}
function ef(e) {
  return e.length === 1 && !e[0].isFlagged(Be.CURVE_VERT) && e[0].upperTierIDs.size < 2;
}
function lH(e) {
  const n = ke.viewport, s = ke.dataStore, i = s.selection;
  {
    const r = new N(), o = 0.99;
    let a = null, c = null, l = null;
    const h = (M, L, P = !0) => {
      c = null, l = null, vc(), ro();
      const k = ke.viewport.toWorld(M.mousePos);
      r.copy(k);
      const Q = i.get("vertices");
      if (jt) {
        const b = i.get("snapTarget");
        b && k.copy(b.position), at.vertices.size || (jt.setBaseProp("translate", { translateX: k.x, translateY: k.y }), jt.setBaseProp("dimensions", { width: 0, height: 0 }));
        const X = Dc(k, Nt);
        let K;
        if (ef(Q)) {
          const V = at.appendLine(
            Q[0].id,
            X.x,
            X.y,
            !L
          );
          K = V.vertex, l = V.curveCtrl;
        } else {
          const V = at.edges.size ? X : ke.indexer.getRootNode().item.transform.worldInv.xform(k, Nt);
          K = at.startNewPath(
            V.x,
            V.y
          );
        }
        i.selectVertices([K], On);
      } else {
        Kg(M.mousePos, st.PEN, ke, { width: 0, height: 0 }, !1, P), at = s.selection.get("elements")[0].get("geometry").get("mesh"), s.eam.activateShapeMode(On), s.eam.activatePenTool(XP);
        const X = [...at.vertices][0];
        s.selection.selectVertices([X], On), Qg = !0;
      }
    }, d = (M, L) => {
      c = null, l = null, a = null, vc();
      const P = ke.viewport.toWorld(M.mousePos);
      r.copy(P);
      const k = i.get("vertices"), Q = ke.dataStore.selection.get("hoverVertex");
      if (ef(k))
        if (k[0].id === Q.id) {
          if (k[0].unlinkedCurveControl) {
            const b = at.cellTable.get(k[0].unlinkedCurveControl);
            b && at.deleteCellsByVertex([b]);
          }
        } else {
          const b = at.connectVertices(k[0].id, Q.id, !L);
          b && (l = b.curveCtrl, a = b.edge);
        }
      i.selectVertices([Q], On);
    }, p = (M) => {
      const L = n.toWorld(M.mousePos);
      if (r.distance_to(L) < o) return;
      const P = i.get("vertices")[0];
      if (!P) {
        M.handled = !1;
        return;
      }
      c || (l || (l = at.falsifyIndCurveCtrl(P)), c = at.addIndpendentCurveCtrl(P, pe.ANGLE_AND_LENGTH)), e("default"), Dc(L, L), at.moveIndCurveControl(c, P, l, L.x, L.y, !0);
    }, E = (M) => {
      const L = n.toWorld(M.mousePos);
      if (r.distance_to(L) < o) return;
      const P = i.get("vertices")[0];
      if (!P) {
        M.handled = !1;
        return;
      }
      c || (c = l ? at.falsifyIndCurveCtrl(P) : at.addIndpendentCurveCtrl(P, pe.INDEPENDENT)), e("convertPath"), Dc(L, L), at.moveIndCurveControl(c, P, l, L.x, L.y, !0);
    };
    s.eam.on(Y.HOVER_CELL_WITH_SELECTION, (M, { toggle: L, reconnect: P }, { snapToGrid: k = !1 } = {}) => {
      if (P) {
        const Q = i.get("vertices")[0];
        Q && ke.dataStore.selection.selectVertices([Q], On);
      }
      cH(M.mousePos, !L, k);
    }), s.eam.on(Y.START_DRAW_PATH, (M, { modifier: L }, { snapToGrid: P = !0 }) => {
      h(M, L, P);
    }).on(Y.UPDATE_DRAW_PATH, (M) => {
      p(M);
    }).on(Y.END_DRAW_PATH, () => {
      at && at.hideFakeIndCurveCtrl(), s.commitUndo();
    }), s.eam.on(Y.START_DRAW_PATH_ON_VERTEX, (M, { modifier: L }) => {
      d(M, L);
    }).on(Y.UPDATE_DRAW_PATH_ON_VERTEX, (M) => {
      E(M);
    }).on(Y.END_DRAW_PATH_ON_VERTEX, () => {
      at && at.hideFakeIndCurveCtrl(), a && (c && at && at.prepareVertexPropertyChanges(
        i.get("vertices")[0].id,
        "mirror",
        pe.INDEPENDENT,
        !0
      ), ke.dataStore.selection.selectVertices([], On)), s.commitUndo();
    });
    const g = (M, L, P, k, Q) => {
      if (P) {
        if (!Number.isFinite(P[0]) || !Number.isFinite(P[1])) {
          console.warn("_updateAffectedCurveControlsData get wrong control vertex posiotion druing action mode from interpolation");
          return;
        }
        if (L && L.x[0].id) {
          const b = s.interaction.getKeyFrame(M), X = Gb.cloneDeep(b.value);
          X.forEach((K) => {
            K.id === k && (K.pos[0] = P[0], K.pos[1] = P[1]);
          }), s.interaction.setKeyFrameValue(b.id, X, !1);
        } else
          Q[0] = P[0], Q[1] = P[1], jt.updateBaseVertex(k, /* @__PURE__ */ new Map([["pos", { after: P }]]));
      }
    }, T = (M, L, P) => {
      if (!M)
        return null;
      const k = s.transition.getStartValueWithCurrentValueAndInterval(M.x, L[0], P), Q = s.transition.getStartValueWithCurrentValueAndInterval(M.y, L[1], P);
      return [k, Q];
    }, A = (M) => {
      const L = jt.get("id"), P = s.selection.selectedActionId, k = s.interaction.getFirstResponseIdByActionId(P), Q = s.interaction.getPropertyTrackMapByElementId(k, L);
      if (!M.edge.isCurve || !Q || !Q.has("pathMorphing"))
        return;
      const b = Q.get("pathMorphing"), X = s.interaction.getPropertyTrackKeyFrameGroupByTime(b), V = Object.keys(X).sort((Ne, At) => Ne - At > 0 ? 1 : -1).filter((Ne) => Ne <= s.transition.currentTime), J = V.length > 0 ? V[V.length - 1] : null, ge = s.transition.getPropertyWorkingInterval(L, "pathMorphing"), ne = ge.get(M.originalCpV.id), ue = ge.get(M.originalCpW.id), te = s.transition.currentTime, ie = T(ne, M.leftEdgeCurveControlsPos[0], te), re = T(ue, M.rightEdgeCurveControlsPos[1], te), fe = X && X[J] ? X[J][0] : null;
      g(fe, ne, ie, M.originalCpV.id, M.leftEdgeCurveControlsPos[0]), g(fe, ue, re, M.originalCpW.id, M.rightEdgeCurveControlsPos[1]);
    }, m = new N();
    let O = null, S = null, y = null;
    const v = (M) => {
      c = null, l = null, a = null, O = null, S = null, y = null, vc(), u4(), Mg(!1);
      const L = ke.viewport.toWorld(M.mousePos);
      r.copy(L);
      const P = ke.dataStore.selection.get("snapTarget"), k = ke.dataStore.meshManager.prepareSplitEdgeData(at, P.edge.id, P.timeOnEdge);
      k && (s.isActionMode && A(k), ke.dataStore.meshManager.splitEdge(at, k), s.transition.cacheSpecificElementBaseValue(jt.get("id"), "pathMorphing"), i.selectVertices([k.midVertex], On), y = k.midVertex, m.copy(L));
    }, R = ({ mousePos: M }, { shift: L }, { snapToGrid: P, snapToObject: k }) => {
      const Q = n.toWorld(M);
      if (r.distance_to(Q) < o) return;
      O || (O = ff(jt, at, y)), S || (S = ke.getRenderItemOfElement(jt).transform.world), ro();
      const b = $d(ke.selection.first.element, Q);
      e("default"), IN(
        b,
        i,
        S,
        Q,
        y,
        O,
        P,
        k,
        m,
        L
      );
    };
    s.eam.on(Y.START_DRAW_PATH_ON_EDGE, (M) => {
      v(M);
    }).on(Y.UPDATE_DRAW_PATH_ON_EDGE, (M, { shift: L }, { snapToGrid: P = !0, snapToObject: k = !0 }) => {
      R(M, { shift: L }, { snapToGrid: P, snapToObject: k });
    }).on(Y.END_DRAW_PATH_ON_EDGE, () => {
      qo([]), ro(), ke.snapping.setEndSnapping(), s.commitUndo();
    });
  }
}
function hH(e) {
  const n = ke.dataStore.selection.get("vertices");
  SN(e, Nt), at.moveVertex(
    n,
    Nt.x,
    Nt.y
  ), ke.dataStore.debounceCommitUndo();
}
function Dc(e, n) {
  ke.getRenderItemOfElement(jt).transform.worldInv.xform(e, n);
  const i = jt.get("referencePoint");
  return n.subtract(i), n;
}
function SN(e, n) {
  return ke.getRenderItemOfElement(jt).transform.worldInv.basis_xform(e, n);
}
function ff(e, n, s) {
  const i = n.getVertPos(s.id), r = new N();
  return r.set(i[0], i[1]), ke.getRenderItemOfElement(e).transform.world.xform(r, r), r;
}
let yN = null, eh = null;
const uH = new N();
function dH(e, n, s) {
  const { dataStore: i, viewport: r } = e;
  yN = n, eh = e;
  let o = null;
  i.eam.on(Y.HOVER_ORIGIN, (a) => {
    i.data.hideOrigin || i.getFeature("editOrigin") && (o = fH(r.toWorld(a.mousePos)), dV(o), o && (s("arrowMove"), i.eam.changeHover(Gt.ORIGIN)));
  });
  {
    const a = new Ce();
    let c = null, l = null, h = null;
    const d = new N(), p = eh.snapping, E = new N(), g = (m, O) => {
      const S = {}, y = uH.copy(m).sub(E), v = pH(c, l), R = p.snapAxisAndDiagonal(y, O, "ORIGIN");
      y.copy(R), y.add(E).sub(d);
      const M = c.transform.worldInv.basis_xform(y), L = c.transform.scale;
      (L.x === 0 || L.y === 0) && (M.copy({
        x: L.x === 0 ? 0 : y.x,
        y: L.y === 0 ? 0 : y.y
      }), a.a = L.x === 0 ? 1 : a.a, a.d = L.y === 0 ? 1 : a.d);
      const P = v.x + M.x, k = v.y + M.y, Q = l.get("referencePoint");
      S.contentAnchorX = P - Q[0], S.contentAnchorY = k - Q[1];
      const b = i.drawInfo.getFixedPositionByChanges(l.get("id"), S);
      S.translateX = b.x, S.translateY = b.y, i.beginChangeGroup(), l.sets(S), i.endChangeGroup(), d.add(y);
    }, T = (m) => {
      o ? (c = e.getRenderItem(o), l = i.getById(o), d.copy(r.toWorld(m.mousePos)), c.transform.getInnerT(a), E.copy(d), p.setSnappingOriginalPos(c.transform.worldPivot), h = g) : m.handled = !1;
    }, A = () => {
      h = null, p.setEndSnapping(), i.commitUndo();
    };
    i.eam.on(Y.START_DRAG_ORIGIN, T).on(Y.UPDATE_DRAG_ORIGIN, (m, { shift: O }) => h(r.toWorld(m.mousePos), O)).on(Y.END_DRAG_ORIGIN, A);
  }
}
function fH(e) {
  const n = [];
  for (const i of eh.dataStore.selection.get("elements"))
    n.push(yN.state.scene.node_bank.get(i.get("id")));
  const s = VH(e, n);
  return s.length === 0 || (s.sort(
    (i, r) => i.item.transform.translate.distance_squared_to(e) - r.item.transform.translate.distance_squared_to(e)
  ), eh.dataStore.getById(s[0].id).isLocked() || eh.dataStore.getById(s[0].id).get("elementType") === Me.SCREEN) ? null : s[0].id;
}
function pH(e, n) {
  const { referencePoint: s, contentAnchor: i } = n.gets("referencePoint", "contentAnchor"), r = new N();
  r.copy(s).add(i);
  const { translate: o, rotation: a, scale: c, skew: l } = e.transform;
  return new Ce().copy(e.transform.parent).translate_right(o.x, o.y).rotate_right(a).skew_right(Rt(l.x), Rt(l.y)).scale_right(c.x, c.y).translate_right(-r.x, -r.y), r;
}
let Se, Ve, vl;
function EH(e, n) {
  const { dataStore: s, viewport: i } = e;
  Se = e, Ve = new bV(e), iH(Se, n), dH(Se, Ve, n), D4(n), s.eam.on(Y.INCREASE_CORNER_RADIUS, () => {
    const l = s.selection.get("elements");
    for (const h of l) {
      if (!h.get("geometry")) return;
      const p = s.selection.get("vertices");
      if (p.length > 0)
        for (const E of p) {
          let g = E.cornerRadius === null ? h.get("cornerRadius") : E.cornerRadius;
          g += 1, E.cornerRadius = g, console.log(`DEBUG: Increase corner radius: ${g}`);
        }
      else {
        const E = h.get("cornerRadius") + 1;
        h.set("cornerRadius", E), console.log(`DEBUG: Increase corner radius: ${E}`);
      }
    }
  }), s.eam.on(Y.DECREASE_CORNER_RADIUS, () => {
    const l = s.selection.get("elements");
    for (const h of l) {
      if (!h.get("geometry")) return;
      const p = s.selection.get("vertices");
      if (p.length > 0)
        for (const E of p) {
          let g = E.cornerRadius === null ? h.get("cornerRadius") : E.cornerRadius;
          g = Math.max(0, g - 1), E.cornerRadius = g, console.log(`DEBUG: Decrease corner radius: ${g}`);
        }
      else {
        const E = Math.max(0, h.get("cornerRadius") - 1);
        h.set("cornerRadius", E), console.log(`DEBUG: Decrease corner radius: ${E}`);
      }
    }
  }), s.eam.on(Y.SELECT_ALL_ELEMENTS, gH), s.eam.on(Y.SELECT_PARENT_ELEMENT, () => {
    TH();
  }), s.eam.on(Y.SELECT_CHILD_ELEMENT, () => {
    _H();
  }), s.eam.on(Y.SELECT_FIRST_ELEMENT, () => {
    const l = s.workspace.children;
    s.selection.selectElements([l[l.length - 1]]);
  }), s.eam.on(Y.SELECT_NEXT_ELEMENT, () => {
    o1("NEXT");
  }), s.eam.on(Y.SELECT_PREVIOUS_ELEMENT, () => {
    o1("PREVIOUS");
  }), s.eam.on(Y.EDIT_NEXT_TEXT_ELEMENT, (l = !1) => {
    if (WH(), s.selection.get("elements").length === 1) {
      const h = s.selection.get("elements")[0].get("id"), d = Se.view.getOrCreateDinoTree(h);
      nt().changeTextEditingNode(d.text_node_id, l);
    }
  }), s.eam.on(Y.EDIT_PREVIOUS_TEXT_ELEMENT, (l = !1) => {
    if (YH(), s.selection.get("elements").length === 1) {
      const h = s.selection.get("elements")[0].get("id"), d = Se.view.getOrCreateDinoTree(h);
      nt().changeTextEditingNode(d.text_node_id, l);
    }
  }), s.eam.on(Y.HOVER_RULER, ({ mousePos: l }) => {
    (l.x < ft.size && l.y >= ft.size || l.x >= ft.size && l.y < ft.size) && (n("ruler"), s.eam.changeHover(Gt.RULER), s.selection.set("hover", null));
  }), s.eam.on(Y.HOVER_GUIDELINE, ({ mousePos: l }) => {
    const h = Se.viewport.toWorld(l), [d, p] = ZV(Ve.state, h);
    let E = null;
    if (d.length > 0 && p.length > 0) {
      const g = s.guidelines.getGuideline(d), T = s.guidelines.getGuideline(p);
      E = g.index > T.index ? g : T;
    } else p.length > 0 ? E = s.guidelines.getGuideline(p) : d.length > 0 && (E = s.guidelines.getGuideline(d));
    E ? (n("ruler"), s.selection.set("hoverGuideline", E), s.eam.changeHover(Gt.GUIDELINE), s.selection.set("hover", null), s.selection.set("hoverMotionPoint", null)) : s.selection.set("hoverGuideline", null);
  }), s.eam.on(Y.HOVER_ELEMENT, ({ mousePos: l }, h) => {
    const d = i.toWorld(l), p = s.getById(e1(Ve.state, d, e.selection, !1));
    if (s.eam.changeHoverSelected(p), Se.dataStore.get("activeTool") === st.TEXT && !s.eam.states.hoverSelected) {
      Ve.state.hovered = null;
      return;
    }
    if (e.selection.anySelected)
      BV(
        Ve.state,
        d,
        e.selection,
        h.modifier
      );
    else if (s.workspace.isEmpty())
      Ve.state.hovered = null;
    else {
      let g = Ve.state.scene.node_bank.get(Ve.state.scene.root);
      g.item.isWorkspace() && (g = Ve.state.scene.node_bank.get(g.children[0].id)), JS(
        Ve.state,
        h.modifier,
        d,
        g.id,
        !1
      );
    }
    const E = s.getById(Ve.state.hovered);
    s.selection.set("hover", E), E ? s.eam.changeHover(Gt.ELEMENT) : s.eam.states.elementSelection === HE.MULTIPLE && Se.selection.bounds.has_point(d) && e.dataStore.get("activeTool") !== st.SCALE && s.eam.changeHover(Gt.MULTIPLE_SELECTION_BOUND), n("default"), h.alt && s.eam.hoverType === Gt.ELEMENT && E && !E.isScreen && s.get("editMode") === Dn.ELEMENT ? n("duplicate") : [
      st.RECTANGLE,
      st.ELLIPSE,
      st.CONTAINER,
      st.TEXT
    ].includes(s.eam.states.activeTool) && !E ? n("crosshair") : s.selection.get("textRange") !== null && (E != null && E.isText) ? n("text") : n("default");
  }), s.eam.on(Y.DRAG_OVER, ({ mousePos: l }) => {
    const h = i.toWorld(l);
    let d = Ve.state.scene.node_bank.get(Ve.state.scene.root);
    d.item.isWorkspace() && (d = Ve.state.scene.node_bank.get(d.children[0].id)), $S(Ve.state, h, d.id);
    const p = s.getById(Ve.state.hovered);
    s.selection.set("dragOver", p);
  }), s.eam.on(Y.DRAG_END, () => {
    Ve.state.hovered = null, s.selection.set("dragOver", null);
  }), s.eam.on(Y.DROP_WITH_FILES, ({ mousePos: l }) => {
    const h = i.toWorld(l);
    let d = Ve.state.scene.node_bank.get(Ve.state.scene.root);
    d.item.isWorkspace() && (d = Ve.state.scene.node_bank.get(d.children[0].id)), $S(Ve.state, h, d.id);
    const p = s.getById(Ve.state.hovered);
    s.selection.set("dragOver", p);
  }), s.eam.on(Y.DOUBLE_LEFT_CLICK, (l) => {
    if (s.eam.states.editMode === Dn.SHAPE) {
      s.eam.activateElementEditMode();
      return;
    }
    const h = s.selection.get("elements"), d = i.toWorld(l.mousePos);
    if (!e.selection.first) return;
    JS(
      Ve.state,
      l.modifier,
      d,
      e.selection.first.id,
      !0
    );
    const p = s.getById(Ve.state.hovered), E = s.selection.get("textRange") !== null, g = s.eam.states.activeTool;
    if (!p) return;
    switch (p.get("elementType")) {
      case Me.SCREEN:
      case Me.CONTAINER:
        s.selection.set("hover", p), s.selection.selectElements([p]);
        break;
      case Me.TEXT:
        (!E || g !== st.TEXT || !s.eam.states.hoverSelected) && (s.selection.set("hover", p), s.selection.selectElements([p]), s.eam.activateTextEditMode(!0));
        break;
      case Me.PATH:
        if (!h.includes(p)) {
          s.selection.set("hover", p), s.selection.selectElements([p]);
          return;
        }
        if (s.isEditingMode && s.isActionMode) {
          s.eam.activateShapeMode();
          return;
        }
        if (s.selection.selectElements([p], On), !s.isEditingMode)
          break;
        s.eam.states.isShapeMode ? s.eam.activateElementEditMode() : s.eam.activateShapeMode();
        break;
    }
    l.handled = !1;
  });
  const r = (l, h, d) => {
    h.shift ? yH(d) : IH(d);
    const p = s.getById(e1(Ve.state, i.toWorld(l.mousePos), e.selection, !1));
    s.eam.changeHoverSelected(p);
  };
  s.eam.on(Y.SELECT_ELEMENT, r), s.eam.on(Y.DESELECT_ELEMENT, (l) => {
    s.selection.get("hover") && (l.handled = !1), OH();
  });
  {
    const l = [], h = new N(), d = Se.snapping, p = new N(), E = 2, g = () => {
      o(l), a(d), Se.selection.single && l[0] ? p.copy(l[0].position) : p.set(Se.selection.bounds.x, Se.selection.bounds.y);
    }, T = () => {
      const k = s.selection.get("hover");
      k && s.selection.selectSelector(k, H1);
    };
    s.eam.on(Y.EDIT_SELECTOR, T);
    let A = null, m = !1, O = !1;
    const S = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map();
    window.initKfMap = v;
    let R = !1;
    const M = (k, Q) => {
      n(Q.alt ? "duplicate" : "default"), A = i.toWorld(k.mousePos.clone());
      const b = s.transition.currentTime;
      if (s.selection.get("elements").forEach((K) => {
        const { id: V, translateX: J, translateY: ge } = K.gets("id", "translateX", "translateY");
        y.set(V, [J, ge]);
        const ne = s.selection.selectedActionId, ue = s.interaction.getFirstResponseIdByActionId(ne), te = s.interaction.getCurrentElementKeyframeAtTime(ue, V, "motionPath", b);
        v.set(V, te ? { id: te.id, value: window.structuredClone(te.value) } : null);
      }), g(), !l.length) return;
      const X = l[0].element;
      IE(X.get("id")), s.selection.set("hover", null);
    }, L = (k, { alt: Q, shift: b }, { snapToGrid: X, snapToObject: K }) => {
      if (!l.length) return;
      const V = i.toWorld(k.mousePos.clone()), J = V.sub(A);
      d.updateMoved(J);
      const ge = V.distance_to(A);
      if (m = m || ge >= E, !m)
        return;
      if (s.beginChangeGroup(), O ^ Q) {
        if (n(Q ? "duplicate" : "default"), Q)
          O = !0, s.selection.get("elements").forEach((At) => {
            const Ke = At.get("id"), [St, rn] = y.get(Ke), gt = v.get(Ke);
            if (gt)
              At.sets({ translateX: St, translateY: rn }, {
                updateType: Gs.USER_EDITING
              }), s.interaction.setKeyFrameValue(gt.id, gt.value);
            else {
              const Wn = s.transition.currentTime;
              At.sets({ translateX: St, translateY: rn }, {
                updateType: Gs.USER_EDITING
              });
              const Xs = s.selection.selectedActionId, ls = s.interaction.getFirstResponseIdByActionId(Xs), Ci = s.interaction.getCurrentElementKeyframeAtTime(ls, Ke, "motionPath", Wn);
              Ci && s.interaction.deleteKeyFrame(Ci.id);
            }
          }), s.clipboard.duplicate(zP).forEach((At, Ke) => {
            S.set(At, Ke);
          });
        else {
          const Ne = s.selection.get("elements"), At = Array.from(y.keys()).map((Ke) => s.getElement(Ke));
          s.selection.selectElements(At, { commit: !1 }), s.selection.get("elements").forEach((Ke) => {
            const [St, rn] = y.get(Ke.get("id"));
            Ke.sets(
              { translateX: St + J.x, translateY: rn + J.y },
              { updateType: Gs.USER_EDITING }
            );
          }), s.deleteElements(Ne, {
            commit: !1,
            updateType: Gs.USER_EDITING
          }), O = !1, S.clear();
        }
        g(), IE(l[0].element.get("id"));
      }
      const ue = p.clone(), te = i.toWorld(k.mousePos);
      h.copy(A);
      const ie = te.clone().sub(h);
      X && (ie.x !== 0 && (h.x = Math.round(h.x), te.x = Math.round(te.x)), ie.y !== 0 && (h.y = Math.round(h.y), te.y = Math.round(te.y)));
      const re = te.clone().sub(h), fe = d.snapAxisAndDiagonal(re, b, "ELEMENT");
      if (re.copy(fe), X) {
        const Ne = d.snapElementsPosToGrid(ue, ie);
        re.add(Ne);
      }
      if (K) {
        d.updateSnapMovingData(!0);
        const Ne = d.comparingVertices(re, X);
        re.add(Ne);
      }
      s.selection.get("elements").forEach((Ne) => {
        const At = O ? S.get(Ne.get("id")) : Ne.get("id"), [Ke, St] = y.get(At);
        if (O) {
          const gt = s.getElement(At).getBaseValue("translate");
          Ne.setBaseProp("translate", { translateX: gt.translateX + re.x, translateY: gt.translateY + re.y }), s.isActionMode && (Ne.computedStyle.reload(), s.transition.prepareActionTransition(), s.transition.forceUpdateAnimation());
        } else
          Ne.sets({
            translateX: Ke + re.x,
            translateY: St + re.y
          }, {
            updateType: Gs.USER_EDITING
          });
      }), s.endChangeGroup(), R = !0;
    }, P = () => {
      m = !1, O = !1, IE(null), y.clear(), v.clear(), s.commitUndo(), d.setEndSnapping(), d.endSnapMovingElementToElement(), R && s.isDesignMode && s.drawInfo.vs.updateUpdateLevel(Is.UPDATE_ALL_NEED_BBOX_RECALC), R = !1;
    };
    s.eam.on(Y.START_DRAG_ELEMENT, M).on(Y.UPDATE_DRAG_ELEMENT, L).on(Y.END_DRAG_ELEMENT, P), s.eam.on(Y.START_DRAG_MULTI_ELEMENTS, M).on(Y.UPDATE_DRAG_MULTI_ELEMENTS, L).on(Y.END_DRAG_MULTI_ELEMENTS, P);
  }
  s.eam.on(Y.MOVE_ELEMENT_SELECTION_KEY, kH), s.eam.on(Y.MOVE_MOTION_POINTS_SELECTION_KEY, FH), vl = new XH(Se), s.eam.on(Y.SWITCH_TEXT_ELEMENT, vl.switchTextElement.bind(vl)), s.eam.on(Y.RESUME_TEXT_EDIT_MODE, vl.resumeTextEditMode.bind(vl));
  function o(l) {
    var h;
    l.splice(0);
    for (const { element: d } of Se.selection.iter()) {
      if (d.get("elementType") === Me.SCREEN)
        continue;
      const p = (h = P0(d)) == null ? void 0 : h.get("id"), E = new N(), g = new N();
      p ? (Se.drawInfo.toWorldPosition(p, d.get("position"), E), Se.drawInfo.toWorldPosition(p, d.get("translate"), g)) : (E.copy(d.get("position")), g.copy(d.get("translate"))), l.push({ translate: g, position: E, element: d, parentId: p });
    }
  }
  function a(l) {
    Se.selection.updateBounds(), l.setSnappingOriginalPos(Se.selection.bounds.center), l.setSelectedElementOAB();
  }
  (() => {
    const l = {
      hoveredGuideline: null,
      isShiftPressed: !1,
      hasChangedSelection: !1,
      initPositionScreen: new N(),
      lastPositionScreen: new N(),
      lastPosition: new N()
    }, h = (O, S) => {
      const { dataStore: y, viewport: v } = e, R = v.toWorld(O.mousePos);
      l.initPositionScreen.copy(O.mousePos), l.lastPositionScreen.copy(O.mousePos), l.hoveredGuideline = y.selection.get("hoverGuideline");
      const M = y.selection.get("guidelines");
      l.hasChangedSelection = !1, l.lastPosition.copy(R), l.hoveredGuideline.direction === dt.HORIZONTAL ? l.lastPosition.y = l.hoveredGuideline.position : l.lastPosition.x = l.hoveredGuideline.position, S.shift && (M.length > 0 || S.modifier) ? (y.selection.toggleGuidelines([l.hoveredGuideline]), l.hasChangedSelection = !0) : S.modifier && (y.selection.selectGuidelines([l.hoveredGuideline]), l.hasChangedSelection = !0), l.isShiftPressed = S.shift;
    }, d = (O, S, { snapToGrid: y = !0, snapToObject: v = !0 }) => {
      if (!l.hoveredGuideline) {
        console.warn("No guides hovered");
        return;
      }
      const { dataStore: R, viewport: M } = e;
      l.lastPositionScreen.copy(O.mousePos), l.lastPositionScreen.x < ft.size || l.lastPositionScreen.x > M.rect.width || l.lastPositionScreen.y < ft.size || l.lastPositionScreen.y > M.rect.height ? R.eam.setCursorOverlay({
        cursor: "not-allowed",
        behindCanvas: !1
      }) : (R.eam.setCursorOverlay(null), n("ruler"));
      const L = M.toWorld(O.mousePos);
      y && (l.hoveredGuideline.direction === dt.HORIZONTAL ? L.y = Math.round(L.y) : L.x = Math.round(L.x));
      const P = R.selection.get("guidelines"), k = L.clone();
      if (k.sub(l.lastPosition), v) {
        Se.snapping.updateSnapMovingDataForGuides();
        const Q = Se.snapping.compareVerticesWithGuides(
          l.hoveredGuideline,
          k,
          y
        );
        Number.isFinite(Q) && (l.hoveredGuideline.direction === dt.VERTICAL ? k.x += Q : k.y += Q);
      }
      P.length > 0 && P.indexOf(l.hoveredGuideline) !== -1 ? R.guidelines.moveMultiGuidelines(P, k) : R.guidelines.moveMultiGuidelines([l.hoveredGuideline], k), l.lastPosition.add(k), l.isShiftPressed = S.shift;
    }, p = () => {
      if (l.lastPositionScreen.distance_to(l.initPositionScreen) <= 4 && !l.hasChangedSelection) {
        const O = [l.hoveredGuideline];
        l.isShiftPressed ? s.selection.toggleGuidelines(O) : s.selection.selectGuidelines(O);
      } else if (l.hoveredGuideline && (l.lastPositionScreen.x < ft.size || l.lastPositionScreen.x > i.rect.width || l.lastPositionScreen.y < ft.size || l.lastPositionScreen.y > i.rect.height)) {
        const O = e.dataStore.selection.get("guidelines").map((S) => S.id);
        O.indexOf(l.hoveredGuideline.id) === -1 ? (e.dataStore.guidelines.deleteGuidelines([l.hoveredGuideline.id]), e.dataStore.selection.set("hoverGuideline", null), e.dataStore.eam.states.endHover()) : (e.dataStore.selection.clearGuidelines({ commit: !1 }), e.dataStore.guidelines.deleteGuidelines(O));
      }
      s.commitUndo();
    }, E = () => {
      const O = e.dataStore.selection.get("guidelines").map((S) => S.id);
      e.dataStore.selection.clearGuidelines({ commit: !1 }), e.dataStore.guidelines.deleteGuidelines(O), s.commitUndo();
    }, g = () => {
      const O = s.selection.get("hoverGuideline");
      O && (s.selection.selectGuidelines([O]), s.commitUndo());
    }, T = (O) => {
      const { dataStore: S, viewport: y } = e, v = y.toWorld(O.mousePos);
      l.initPositionScreen.copy(O.mousePos), l.lastPositionScreen.copy(O.mousePos), l.hoveredGuideline = S.selection.get("hoverGuideline"), l.hasChangedSelection = !1, l.lastPosition.copy(v), l.hoveredGuideline.direction === dt.HORIZONTAL ? l.lastPosition.y = l.hoveredGuideline.position : l.lastPosition.x = l.hoveredGuideline.position;
    }, A = (O, S, { snapToGrid: y = !0, snapToObject: v = !0 }) => {
      if (!l.hoveredGuideline) {
        console.warn("No guides hovered");
        return;
      }
      const { dataStore: R, viewport: M } = e;
      l.lastPositionScreen.copy(O.mousePos), l.lastPositionScreen.x < ft.size || l.lastPositionScreen.x > M.rect.width || l.lastPositionScreen.y < ft.size || l.lastPositionScreen.y > M.rect.height ? R.eam.setCursorOverlay({
        cursor: "not-allowed",
        behindCanvas: !1
      }) : (R.eam.setCursorOverlay(null), n("ruler"));
      const L = M.toWorld(O.mousePos);
      y && (l.hoveredGuideline.direction === dt.HORIZONTAL ? L.y = Math.round(L.y) : L.x = Math.round(L.x));
      const P = L.clone();
      if (P.sub(l.lastPosition), v) {
        Se.snapping.updateSnapMovingDataForGuides();
        const k = Se.snapping.compareVerticesWithGuides(
          l.hoveredGuideline,
          P,
          y
        );
        Number.isFinite(k) && (l.hoveredGuideline.direction === dt.VERTICAL ? P.x += k : P.y += k);
      }
      R.guidelines.moveMultiGuidelines([l.hoveredGuideline], P), l.lastPosition.add(P);
    }, m = () => {
      l.hoveredGuideline && (l.lastPositionScreen.x < ft.size || l.lastPositionScreen.x > i.rect.width || l.lastPositionScreen.y < ft.size || l.lastPositionScreen.y > i.rect.height) && (e.dataStore.guidelines.deleteGuidelines([l.hoveredGuideline.id]), e.dataStore.selection.set("hoverGuideline", null), e.dataStore.eam.states.endHover()), s.commitUndo();
    };
    return {
      init: () => {
        s.eam.on(Y.START_MOVE_GUIDE, h).on(Y.UPDATE_MOVE_GUIDE, d).on(Y.END_MOVE_GUIDE, p).on(Y.DELETE_GUIDELINES, E).on(Y.DIRECTLY_SELECT_GUIDE, g).on(Y.START_MOVE_GUIDE_WO_SELECT, T).on(Y.UPDATE_MOVE_GUIDE_WO_SELECT, A).on(Y.END_MOVE_GUIDE_WO_SELECT, m);
      }
    };
  })().init();
}
function vE(e) {
  return !e.get("locked");
}
function gH() {
  const e = Se.dataStore.selection, n = e.get("elements"), s = e.get("guidelines");
  if (n.length) {
    let i;
    for (const r of n) {
      const o = r.get("parent");
      if (!i)
        i = o;
      else {
        if (i === o)
          continue;
        e.selectElements(Se.dataStore.workspace.children.filter(vE));
        return;
      }
    }
    e.selectElements(i.children.filter(vE));
  } else s.length ? e.selectGuidelines(Se.dataStore.guidelines.getAllGuidelines()) : e.selectElements(Se.dataStore.workspace.children.filter(vE));
}
function _H() {
  const e = Se.dataStore.selection.get("elements");
  if (!e.length) return;
  const n = [];
  e.forEach((s) => {
    switch (s.get("elementType")) {
      case Me.CONTAINER:
      case Me.SCREEN:
        n.push(...s.children);
        break;
      default:
        n.push(s);
    }
  }), n.length && Se.dataStore.selection.selectElements(n);
}
function TH() {
  const e = Se.dataStore.selection.get("elements");
  if (!e.length) return;
  const n = [];
  e.forEach((s) => {
    const i = P0(s);
    i.get("type") !== ks.WORKSPACE && n.push(i);
  }), n.length && Se.dataStore.selection.selectElements(n);
}
function o1(e) {
  const n = Se.dataStore.selection.get("elements"), s = e === "NEXT" ? AH : mH;
  if (n.length === 0) {
    const i = Se.dataStore.workspace.children;
    Se.dataStore.selection.selectElements([s(i)]);
  } else {
    const i = n[0].get("parent");
    if (n.length === 1) {
      if (i.children.length > 1) {
        const r = i.children.indexOf(n[0]);
        Se.dataStore.selection.selectElements([s(i.children, r)]);
      }
    } else n.every((r) => r.get("parent") === i) && (e === "NEXT" ? Se.dataStore.selection.selectElements(n.slice(0, 1)) : Se.dataStore.selection.selectElements(n.slice(-1)));
  }
}
function AH(e, n = -1) {
  for (let s = n + 1; s < e.length; s++)
    if (e[s].get("visible")) return e[s];
  for (let s = 0; s < n; s++)
    if (e[s].get("visible")) return e[s];
}
function mH(e, n = e.length) {
  for (let s = n - 1; s >= 0; s--)
    if (e[s].get("visible")) return e[s];
  for (let s = e.length - 1; s > n; s--)
    if (e[s].get("visible")) return e[s];
}
function OH() {
  Se.dataStore.selection.clearAllExceptAction();
}
function IH(e) {
  const n = Se.dataStore.selection, s = n.get("hover");
  (n.get("elements").length > 1 || !(s != null && s.isText)) && Se.dataStore.eam.activateTextEditMode(!1), n.selectElements(s ? [s] : [], e), SH();
}
function SH() {
  const e = Se.dataStore.eam;
  (Se.dataStore.getFeature("editGradient") || e.states.isTextMode) && e.activateElementEditMode();
}
function yH(e) {
  const n = Se.dataStore.selection.get("hover");
  n && Se.dataStore.selection.toggleElements([n], e);
}
function CH(e) {
  RH(e);
}
function NH(e) {
  let n = Ve.state.scene.node_bank.get(Ve.state.scene.root);
  n.item.isWorkspace() && (n = Ve.state.scene.node_bank.get(n.children[0].id));
  const s = _N(Ve.state, e, n.id);
  return Se.dataStore.getById(s);
}
function xH(e) {
  Ve.state.scene.root = e.id;
}
function vH(e) {
  Ve.state.scene.addNewNode(Ve.state.compute, e);
}
function RH(e) {
  const n = Se.dataStore.getById(e.id), s = n.get("visible") && !n.get("locked"), i = Se.dataStore.workspace.get("scale"), r = Se.overlay.panes[0], o = { fontSize: 12, h_align: "left", v_align: "top" }, a = r.measureTextImage(n.get("name"), o.fontSize, o.h_align, o.v_align);
  Ve.state.scene.addScreenNode(Ve.state.compute, e, s, i, a);
}
function wH() {
  Se.indexer.root && Ve.updateScreenNameBounds();
}
function DH() {
  Se.indexer.root && Ve.updateGuidelines();
}
function LH() {
  Se.indexer.root && Ve.update();
}
function MH(e) {
  Ve.state.compute.bounds.delete(e), Ve.state.compute.transform.delete(e), Ve.state.scene.node_bank.delete(e);
}
function PH(e, n) {
  return EN(Ve.state.compute, Ve.state.scene.node_bank, n, e);
}
function bH(e) {
  const n = Ve.state.compute, s = Ve.state.scene.node_bank, i = [];
  let r = s.get(Ve.state.scene.root);
  if (r.item.isWorkspace() && (r = s.get(r.children[0].id)), e.containsRect(n.bounds.get(r.id).world))
    i.push(r.id);
  else {
    const c = s.get(r.id);
    for (let l = 0; l < c.children.length; l++)
      i.push(c.children[l].id);
  }
  const o = mN(n, s, i, e, !0), a = /* @__PURE__ */ new Set();
  for (const c of o)
    a.add(Se.dataStore.getById(c));
  return a;
}
function Rl(e) {
  const n = Ve.state.compute, s = Ve.state.scene.node_bank, i = [];
  for (const [a, c] of s)
    i.push(a);
  const r = mN(n, s, i, e), o = /* @__PURE__ */ new Set();
  for (const a of r)
    o.add(Se.dataStore.getById(a));
  return o;
}
function RE(e) {
  KV(Ve.state, e);
}
function UH(e) {
  QV(Ve.state, e);
}
function GH(e) {
  return qV(Ve.state, e);
}
function P0(e) {
  const n = e.get("parent");
  return n.get("type") === ks.DATA_STORE ? null : n.get("elementType") === Me.GROUP ? n.get("parent") : n;
}
function FH(e) {
  Se.dataStore.editor.setMotionPathProps(e, null, {
    delta: !0,
    commit: !1
  }), Se.dataStore.debounceCommitUndo();
}
function kH(e) {
  var r;
  const n = Se.dataStore.selection.get("elements"), s = Se.dataStore.selection.get("guidelines");
  if (n.includes(Se.dataStore.workspace.children[0]))
    return;
  Se.dataStore.beginChangeGroup();
  const i = new N();
  if (s.length)
    Se.dataStore.guidelines.moveMultiGuidelines(s, e);
  else if (n.length)
    for (const o of n) {
      if (o.isLocked()) continue;
      const a = (r = P0(o)) == null ? void 0 : r.get("id"), c = new N(...o.get("computedStyle").data.translate);
      a ? Se.drawInfo.toWorldPosition(a, c, i) : i.copy(c);
      const l = new N().copy(c).add(e);
      o.sets({
        translateX: l.x,
        translateY: l.y
      }, {
        updateType: Gs.USER_EDITING
      });
    }
  Se.dataStore.endChangeGroup(), Se.dataStore.debounceCommitUndo();
}
function a1(e, n) {
  return WV(Ve.state.compute, e, n);
}
function BH(e, n, s, i) {
  return YV(Ve.state.compute, e, n, s, i);
}
function VH(e, n) {
  return XV(Ve.state.compute, e, n);
}
function HH(e, n, s, i, r = !1) {
  return zV(Ve.state.compute, e, n, s, i, r);
}
function WH() {
  const e = Se.dataStore.selection.get("elements"), n = (s, i = -1) => {
    for (let r = i + 1; r < s.length; r++)
      if (s[r].get("visible") && s[r].isText) return s[r];
    for (let r = 0; r < i; r++)
      if (s[r].get("visible") && s[r].isText) return s[r];
    return null;
  };
  if (e.length === 0) {
    const s = Se.dataStore.workspace.children, i = n(s);
    if (i)
      return Se.dataStore.selection.selectElements([i]), i.get("id");
  } else {
    const s = e[0].get("parent");
    if (e.length === 1) {
      if (s.children.length > 1) {
        const i = s.children.indexOf(e[0]), r = n(s.children, i);
        if (r)
          return Se.dataStore.selection.selectElements([r]), r.get("id");
      }
    } else if (e.every((i) => i.get("parent") === s))
      return Se.dataStore.selection.selectElements(e.slice(0, 1)), e[0].get("id");
  }
  return null;
}
function YH() {
  const e = Se.dataStore.selection.get("elements"), n = (s, i = s.length) => {
    for (let r = i - 1; r >= 0; r--)
      if (s[r].get("visible") && s[r].isText) return s[r];
    for (let r = s.length - 1; r > i; r--)
      if (s[r].get("visible") && s[r].isText) return s[r];
    return null;
  };
  if (e.length === 0) {
    const s = Se.dataStore.workspace.children, i = n(s);
    i && Se.dataStore.selection.selectElements([i]);
  } else {
    const s = e[0].get("parent");
    if (e.length === 1) {
      if (s.children.length > 1) {
        const i = s.children.indexOf(e[0]), r = n(s.children, i);
        r && Se.dataStore.selection.selectElements([r]);
      }
    } else e.every((i) => i.get("parent") === s) && Se.dataStore.selection.selectElements(e.slice(-1));
  }
}
class XH {
  constructor(n) {
    this.visualServer = n;
  }
  switchTextElement() {
    var s;
    const n = this.visualServer.dataStore.selection.get("hover");
    if (n != null && n.isText) {
      const i = (s = this.visualServer.dataStore.selection.get("elements")) == null ? void 0 : s[0], r = i != null && i.isText ? i.get("id") : null, o = n != null && n.isText ? n.get("id") : null;
      o && r && o !== r && this.visualServer.dataStore.selection.selectElements([n]), document.activeElement.id !== "input" && document.getElementById("input").focus(), this.visualServer.dataStore.drawInfo.changeTextEditingNode(o, !1);
    } else
      this.visualServer.dataStore.eam.activateTextEditMode(!1), this.visualServer.dataStore.commitUndo();
  }
  resumeTextEditMode() {
    var s;
    this.visualServer.dataStore.eam.activateTextEditMode(!0);
    const n = (s = this.visualServer.dataStore.selection.get("elements")) == null ? void 0 : s[0];
    n != null && n.isText && (document.activeElement.id !== "input" && document.getElementById("input").focus(), this.visualServer.dataStore.drawInfo.changeTextEditingNode(n.get("id"), !1));
  }
}
const er = 0.01, Wu = 2, c1 = {
  ELEMENT: 100,
  ORIGIN: 40,
  POINT: 40
}, et = class et {
  /**
   * @param {VisualServer} visualServer
   */
  constructor(n) {
    this.vs = n, this.threshold = 5, this.startOrigin = new N(), this.startSnapping = !1, this.axisDiagonalVec = [new N(), new N()], this.axisDiagonalCount = 0, this.firstSnapXToGrid = !0, this.firstSnapYToGrid = !0, this.lastSnapToGridPos = new N(), this.moved = !1, this.otherElementsVertices = /* @__PURE__ */ new Map(), this.selectedVertices = /* @__PURE__ */ new Map(), this.snapToElementXUI = /* @__PURE__ */ new Map(), this.snapToElementYUI = /* @__PURE__ */ new Map(), this.isXSnapping = !1, this.isYSnapping = !1, this.snapAreaOnXLeftLUT = /* @__PURE__ */ new Map(), this.snapAreaOnXRightLUT = /* @__PURE__ */ new Map(), this.snapAreaOnYTopLUT = /* @__PURE__ */ new Map(), this.snapAreaOnYBottomLUT = /* @__PURE__ */ new Map(), this.spaceOnXLUT = /* @__PURE__ */ new Map(), this.spaceOnYLUT = /* @__PURE__ */ new Map(), this.spacingAreaUIMap = /* @__PURE__ */ new Map(), this.spacingLength = new N(-1, -1), this.selectedBoundsWorld = new ye(), this.boundsForResize = new ye(), this.hoverNodeTransform = null, this.spacingVerticalVec = new N(), this.spacingVertical = 0, this.spacingHorizontalVec = new N(), this.spacingHorizontal = 0, this.xOfAllVertices = [], this.yOfAllVertices = [], this.xHighlightGuide = [], this.yHighlightGuide = [];
  }
  updateThreshold(n) {
    const s = Math.floor(n * 100);
    s <= 2 ? this.threshold = 200 : s <= 5 ? this.threshold = 100 : s <= 10 ? this.threshold = 66 : s <= 25 ? this.threshold = 21 : s <= 50 ? this.threshold = 9 : s <= 75 ? this.threshold = 7 : s <= 100 ? this.threshold = 4 : s <= 200 ? this.threshold = 2 : s <= 400 ? this.threshold = 1 : s <= 25600 && (this.threshold = 0.5);
  }
  updateMoved(n) {
    !n.is_zero() && !this.moved && (this.moved = !0);
  }
  resetInterfaceData() {
    this.axisDiagonalCount = 0;
  }
  /**
   * @param {Vector2} startOrigin
   */
  setSnappingOriginalPos(n) {
    this.startOrigin.copy(n), this.startSnapping = !0;
  }
  setEndSnapping() {
    this.startSnapping = !1, this.axisDiagonalCount = 0, this.firstSnapXToGrid = !0, this.firstSnapYToGrid = !0, this.moved = !1, this.xHighlightGuide.length = 0, this.yHighlightGuide.length = 0;
  }
  /**
   * check whether draw snapping UI
   * @returns {bool}
   */
  isSnappingUIDataDirty() {
    return this.axisDiagonalCount > 0 || this.snapToElementXUI.size || this.snapToElementYUI.size || this.spacingAreaUIMap.size;
  }
  /**
   * @param {Vector2} delta
   * @param {boolean} isPressShift
   * @param {string} type
   * @returns {Vector2} // warn: need to free the return variable after used
   */
  snapAxisAndDiagonal(n, s, i = "ELEMENT") {
    const r = n.clone();
    if (s) {
      const o = n.clone().abs();
      o.x <= c1[i] || o.y <= c1[i] ? o.x <= nE && o.y <= nE ? this._setAxisDiagonalAngle(0, 90) : o.y - o.x > nE ? (r.set_x(0), this._setAxisDiagonalAngle(90)) : (r.set_y(0), this._setAxisDiagonalAngle(0)) : n.x > 0 && n.y > 0 ? (this._setAxisDiagonalAngle(-45), o.x >= o.y ? r.set(o.x, o.x) : r.set(o.y, o.y)) : n.x < 0 && n.y > 0 ? (this._setAxisDiagonalAngle(45), o.x >= o.y ? r.set(-o.x, o.x) : r.set(-o.y, o.y)) : n.x < 0 && n.y < 0 ? (this._setAxisDiagonalAngle(-45), o.x >= o.y ? r.set(-o.x, -o.x) : r.set(-o.y, -o.y)) : n.x > 0 && n.y < 0 && (this._setAxisDiagonalAngle(45), o.x >= o.y ? r.set(o.x, -o.x) : r.set(o.y, -o.y));
    } else
      this._setAxisDiagonalAngle(null, null);
    return r;
  }
  /**
   * @param {Vector2} pos
   * @param {Vector2} moveDelta
   * @returns {Vector2}
   */
  snapElementsPosToGrid(n, s = new N()) {
    const i = new N();
    return s.x !== 0 && n.x !== Math.round(n.x) && (i.x = Math.round(n.x) - n.x), s.y !== 0 && n.y !== Math.round(n.y) && (i.y = Math.round(n.y) - n.y), i;
  }
  /**
   * @param {Vector2} currMousePos
   * @param {Vector2} initMousePos
   * @param {Vector2} selectedVertPos
   * @param {boolean} isClickEdge
   * @param {boolean} isAlignAxis
   * @returns {Vector2}
   */
  snapResizeElementToPixelGrid(n, s, i, r, o) {
    if (r && !o) return n.clone();
    const a = n.clone().sub(s), c = n.clone(), l = s.clone().sub(i);
    let h = Math.round(n.x);
    return this.firstSnapXToGrid ? (a.x !== 0 && (c.x = Math.round(i.x) + l.x), this.firstSnapXToGrid = !1) : c.x = h + l.x, h = Math.round(n.y), this.firstSnapYToGrid ? (a.y !== 0 && (c.y = Math.round(i.y) + l.y), this.firstSnapYToGrid = !1) : c.y = h + l.y, this.lastSnapToGridPos.copy(c), this.lastSnapToGridPos;
  }
  /**
   * @param {Vector2} currMousePos
   * @param {Vector2} initMousePos
   * @param {Vector2} selectedVertPos
   * @param {boolean} isClickEdge
   * @param {boolean} isAlignAxis
   * @returns {Vector2}
   */
  snapScaleElementToPixelGrid(n, s, i, r, o) {
    if (!this.moved) return s.clone();
    if (r && !o) return n.clone();
    const a = n.clone().sub(s), c = n.clone(), l = s.clone().sub(i);
    let h = Math.round(n.x);
    return this.firstSnapXToGrid ? (a.x !== 0 && (c.x = Math.round(i.x) + l.x), this.firstSnapXToGrid = !1) : c.x = h + l.x, h = Math.round(n.y), this.firstSnapYToGrid ? (a.y !== 0 && (c.y = Math.round(i.y) + l.y), this.firstSnapYToGrid = !1) : c.y = h + l.y, c;
  }
  /**
   * @deprecated This function has been no longer called
   * @param {Vertex} hoverVert
   * @param {Vector2} delta
   * @param {Transform} nodeTransform
   * @param {Size} elemSize
   * @param {Mesh} mesh
   * @returns {Vector2}
   */
  getClosestDistanceToGrid(n, s, i, r, o) {
    const a = s.clone(), c = new N(), l = new N(), h = o.getVertPos(n.id);
    return l.set(h[0], h[1]), i.world.xform(l, l), c.copy(l).round().sub(l), a.sub(c).round(), c.x !== 0 && (a.x += c.x), c.y !== 0 && (a.y += c.y), a;
  }
  /**
   * Set resizing element snapping points, the points would be the two vertices of
   * dragging edge or the one of dragging handler
   * @param {Vector2} anchor
   * @param {import('../../visual_server/RenderItem').RenderItem } hoverNode
   */
  setResizeSelectedElementOAB(n, s) {
    this.selectedVertices.clear();
    const i = this.vs.selection, r = i.single ? i.single.id : null, o = r ? this.vs.indexer.getNode(r).boundsLocal_zero : i.bounds, a = r ? this.vs.indexer.getNode(r).item.transform.world : Ce.IDENTITY, c = r && this.vs.indexer.getNode(r).item.isComputedGroup();
    this._getResizeDraggingSideData(this.selectedVertices, i.single, o, a, n, c), s ? (this.boundsForResize.copy(s.boundsLocal_zero), this.hoverNodeTransform = s.item.transform) : (this.selectedBoundsWorld.copy(o), i.single && (this.boundsForResize.copy(o), this.hoverNodeTransform = this.vs.indexer.getNode(r).item.transform, this.selectedBoundsWorld = a.xform_rect(this.selectedBoundsWorld)));
  }
  /**
   * Set moving element snapping points, if it is single selection , the points will be
   * the vertices of OAB. If it is multi-selection, the points will be the vertices of AAB.
   */
  setSelectedElementOAB() {
    var o, a;
    this.selectedVertices.clear();
    const n = this.vs.selection, s = n.single ? n.single.id : null, i = n.single ? (o = this.vs.indexer.getNode(s)) == null ? void 0 : o.boundsLocal_zero : n.bounds, r = n.single ? (a = this.vs.indexer.getNode(s)) == null ? void 0 : a.item.transform.world : Ce.IDENTITY;
    this._getElementOABAndCenterData(this.selectedVertices, n.single, i, r), this.selectedBoundsWorld.copy(i), n.single && (this.selectedBoundsWorld = r.xform_rect(this.selectedBoundsWorld));
  }
  /**
   * Set not selected elements snapping points. The elements are in the same column or row area
   * of selected element. The data will be their AAB vertices.
   * @param {boolean} isMovingEle
   */
  updateSnapMovingData(n = !1) {
    this.otherElementsVertices.clear(), this.snapAreaOnXLeftLUT.clear(), this.snapAreaOnXRightLUT.clear(), this.snapAreaOnYTopLUT.clear(), this.snapAreaOnYBottomLUT.clear();
    const s = this.vs.selection, i = this.vs.viewport.rectW.clone(), r = 18 / this.vs.viewport.scale, o = s.bounds.x - this.threshold * 2 < i.x + r ? i.x + r : s.bounds.x - this.threshold * 2, a = i.y + r, c = o + s.bounds.width + this.threshold * 4 > i.right ? i.right - o : s.bounds.width + this.threshold * 4, l = i.height - r, h = new ye(o, a, c, l), d = i.x + r, p = s.bounds.y - this.threshold * 2 < i.y + r ? i.y + r : s.bounds.y - this.threshold * 2, E = i.width - r, g = p + s.bounds.height + this.threshold * 4 > i.bottom ? i.bottom - p : s.bounds.height + this.threshold * 4, T = new ye(d, p, E, g), A = s.bounds.x < i.x + r ? i.x + r : s.bounds.x, m = i.y + r, O = o + s.bounds.width > i.right ? i.right - o : s.bounds.width, S = i.height - r, y = new ye(A, m, O, S), v = i.x + r, R = s.bounds.y < i.y + r ? i.y + r : s.bounds.y, M = i.width - r, L = p + s.bounds.height > i.bottom ? i.bottom - p : s.bounds.height, P = new ye(v, R, M, L), k = s._selected, Q = /* @__PURE__ */ new Set();
    for (const J of k) {
      const ge = this.vs.indexer.getNode(J);
      ge.parent && Q.add(ge.parent.id);
    }
    const b = Rl(h), X = Rl(y);
    this._getElementsCornerAndCenterData(k, b, this.otherElementsVertices, n, !1, Q, X, s.bounds);
    const K = Rl(T), V = Rl(P);
    this._getElementsCornerAndCenterData(k, K, this.otherElementsVertices, n, !0, Q, V, s.bounds);
  }
  /**
   * @param {Vector2} delta
   * @param {bool} isSnapToGrid
   * @returns {Vector2}
   */
  comparingVertices(n, s = !0) {
    const i = new N(), r = new N(), o = new N(), a = new N();
    this.snapToElementXUI.clear(), this.xHighlightGuide.length = 0, this.snapToElementYUI.clear(), this.yHighlightGuide.length = 0, this.isXSnapping = !1, this.isYSnapping = !1;
    for (const [l, h] of this.selectedVertices.entries())
      for (const d of h.entries()) {
        const p = d[0];
        i.set(l, p);
        const E = this._convertPosToUIPanelVersion(i), g = E.clone().add(n);
        this._searchGuides(g, a, !1, !1);
        const T = Number.isInteger(E.x) || !s, A = Number.isInteger(E.y) || !s;
        for (const [m, O] of this.otherElementsVertices.entries())
          for (const S of O.entries()) {
            const y = S[0];
            r.set(m, y);
            const v = this._convertPosToUIPanelVersion(r), R = Number.isInteger(v.x) || !s, M = Number.isInteger(v.y) || !s;
            o.copy(v).sub(E).sub(n), T && R && Math.abs(o.x) <= this.threshold && (this.isXSnapping ? Math.abs(a.x) > Math.abs(o.x) && (this.snapToElementXUI.clear(), this.xHighlightGuide.length = 0, a.x = o.x) : (a.x = o.x, this.isXSnapping = !0)), A && M && Math.abs(o.y) <= this.threshold && (this.isYSnapping ? Math.abs(a.y) > Math.abs(o.y) && (this.snapToElementYUI.clear(), this.yHighlightGuide.length = 0, a.y = o.y) : (a.y = o.y, this.isYSnapping = !0)), this.isXSnapping && a.x === o.x && this._addSnapXUIData(v.x, v.y, this.snapToElementXUI), this.isYSnapping && a.y === o.y && this._addSnapYUIData(v.x, v.y, this.snapToElementYUI);
          }
      }
    this.spacingAreaUIMap.clear(), this.spacingHorizontal = 0, this.spacingVertical = 0;
    const c = this.selectedBoundsWorld.clone();
    return c.x += n.x, c.x += a.x, c.y += n.y, c.y += a.y, this._moveSnapSpacing(c, a, s), this._updateMoveSnappingUI(a, n), a;
  }
  _updateMoveSnappingUI(n, s) {
    this.isXSnapping || this.snapToElementXUI.clear(), this.isYSnapping || this.snapToElementYUI.clear();
    const i = new N();
    for (const [r, o] of this.selectedVertices.entries())
      for (const a of o.entries()) {
        const c = a[0];
        i.set(r, c);
        const l = this._convertPosToUIPanelVersion(i);
        i.copy(l), i.add(n).add(s);
        const h = this._convertPosToUIPanelVersion(i);
        i.copy(h), this.snapToElementXUI.has(i.x) && this.snapToElementXUI.get(i.x).set(i.y, 0), this.snapToElementYUI.has(i.y) && this.snapToElementYUI.get(i.y).set(i.x, 0);
      }
  }
  /**
   * @param {Vector2} mousePos
   * @param {Vector2} initMousePos
   * selectedVertPos is the click point position
   * if dragging an edge, the position value will be the center point position of two vertices of the edge
   * if dragging an vertex the position value will be same as the vertex's
   * @param {Vector2} selectedVertPos
   * @param {Vector2} anchor
   * @param {boolean} [isSnapToGrid]
   * @param {{isMultipleOf90: boolean, isMultipleOf180: boolean}} rotationStatus prevent an edge of a rotated element from snapping
   * @param {number} resizeType
   * @param {boolean} keepAspect
   * @returns {Vector2}
   */
  comparingVerticesWithResize(n, s, i, r, o = !0, a = { isMultipleOf90: !1, isMultipleOf180: !1 }, c, l = !1) {
    const h = new N(0.5, 0.5).sub(r);
    if ((h.x === 0 || h.y === 0) && !a.isMultipleOf90)
      return this.snapToElementXUI.clear(), this.snapToElementYUI.clear(), this.xHighlightGuide.length = 0, this.yHighlightGuide.length = 0, this.isXSnapping = !1, this.isYSnapping = !1, n.clone();
    const p = new N(), E = new N(), g = new N(), T = new N(), A = s.clone().sub(i), m = this._convertPosToUIPanelVersion(n.clone().sub(A));
    this.snapToElementXUI.clear(), this.snapToElementYUI.clear(), this.xHighlightGuide.length = 0, this.yHighlightGuide.length = 0, this.isXSnapping = !1, this.isYSnapping = !1;
    let O = r.y === 0.5, S = r.x === 0.5;
    a.isMultipleOf90 && !a.isMultipleOf180 && ([O, S] = [S, O]);
    for (const [y, v] of this.selectedVertices.entries())
      for (const R of v.entries()) {
        const M = R[0];
        p.set(y, M);
        const L = this._convertPosToUIPanelVersion(p), P = Number.isInteger(L.x) || !o, k = Number.isInteger(L.y) || !o;
        this._searchGuides(m, T, S, O);
        for (const [Q, b] of this.otherElementsVertices.entries())
          for (const X of b.entries()) {
            const K = X[0];
            E.set(Q, K);
            const V = this._convertPosToUIPanelVersion(E), J = Number.isInteger(V.x) || !o, ge = Number.isInteger(V.y) || !o;
            O || S ? (L.x = this.selectedVertices.size === 1 ? m.x : L.x, L.y = this.selectedVertices.size === 1 ? L.y : m.y, g.copy(V).sub(L)) : g.copy(V).sub(m), P && J && Math.abs(g.x) <= this.threshold && !S && (this.isXSnapping ? Math.abs(T.x) - Math.abs(g.x) > ms && (T.x = g.x, this.snapToElementXUI.clear(), this.xHighlightGuide.length = 0) : T.x = g.x, this.isXSnapping = !0), k && ge && Math.abs(g.y) <= this.threshold && !O && (this.isYSnapping ? Math.abs(T.y) - Math.abs(g.y) > ms && (T.y = g.y, this.snapToElementYUI.clear(), this.yHighlightGuide.length = 0) : T.y = g.y, this.isYSnapping = !0), this.isXSnapping && T.x === g.x && this._addSnapXUIData(V.x, V.y, this.snapToElementXUI), this.isYSnapping && T.y === g.y && this._addSnapYUIData(V.x, V.y, this.snapToElementYUI);
          }
      }
    if (m.add(T), this.spacingAreaUIMap.clear(), this.spacingHorizontal = 0, this.spacingVertical = 0, !l) {
      const y = et.getGripPointFromVector(h), v = this._updateCompareBoundsInGeneral(c, y, m);
      this._resizeSnapSpacing(h, v, T, o), this._updateSnappingUIResize(S, O, m), m.copy(n).add(T);
    }
    return m;
  }
  _searchGuides(n, s, i, r) {
    const { closestHorizontal: o, closestVertical: a } = GH(n);
    if (!i && a !== null) {
      const c = a[1] - n.x;
      Math.abs(c) <= this.threshold && (this.isXSnapping ? Math.abs(s.x) > Math.abs(c) && (this.snapToElementXUI.clear(), this.xHighlightGuide.length = 0, s.x = c, this.xHighlightGuide.push(a[0])) : (s.x = c, this.isXSnapping = !0, this.xHighlightGuide.push(a[0])));
    }
    if (!r && o !== null) {
      const c = o[1] - n.y;
      Math.abs(c) <= this.threshold && (this.isYSnapping ? Math.abs(s.y) > Math.abs(c) && (this.snapToElementYUI.clear(), this.yHighlightGuide.length = 0, s.y = c, this.yHighlightGuide.push(o[0])) : (s.y = c, this.isYSnapping = !0, this.yHighlightGuide.push(o[0])));
    }
  }
  _updateSnappingUIResize(n, s, i) {
    this.isXSnapping || this.snapToElementXUI.clear(), this.isYSnapping || this.snapToElementYUI.clear();
    const r = new N();
    for (const [o, a] of this.selectedVertices.entries())
      for (const c of a.entries()) {
        const l = c[0];
        r.set(o, l);
        const h = this._convertPosToUIPanelVersion(r);
        r.copy(h), n || s ? (this.snapToElementXUI.has(i.x) && this.snapToElementXUI.get(i.x).set(r.y, 0), this.snapToElementYUI.has(i.y) && this.snapToElementYUI.get(i.y).set(r.x, 0)) : (this.snapToElementXUI.has(i.x) && this.snapToElementXUI.get(i.x).set(i.y, 0), this.snapToElementYUI.has(i.y) && this.snapToElementYUI.get(i.y).set(i.x, 0));
      }
  }
  _updateCompareBoundsInGeneral(n, s, i) {
    let r;
    if (n === et.ResizeTypes.RESIZE_ELEMENTS)
      r = et.resizeRect(this.selectedBoundsWorld, s, i);
    else if (n === et.ResizeTypes.RESIZE_ONE_ELEMENT)
      if (!this.hoverNodeTransform || !this.hoverNodeTransform.rotation)
        r = et.resizeRect(this.selectedBoundsWorld, s, i);
      else {
        const o = this.hoverNodeTransform.worldInv.xform(i), a = et.resizeRect(this.boundsForResize, s, o);
        r = this.hoverNodeTransform.world.xform_rect(a);
      }
    else if (this.hoverNodeTransform) {
      const o = this.hoverNodeTransform.worldInv.xform(i), a = et.scaleRect(this.boundsForResize, s, o, this.hoverNodeTransform.getPivotOffset());
      r = this.hoverNodeTransform.world.xform_rect(a);
    } else
      console.warn("Invalid in comparingVerticesWithResize");
    return r;
  }
  _resizeSnapSpacing(n, s, i, r) {
    if (n.x >= er || n.x <= -0.01) {
      this._generateAllSpacing(!0, s);
      const o = Array.from(this.spaceOnXLUT.keys()).sort((h, d) => h - d), a = n.x >= er ? et.IgnoreNonContactDir.LEFT : et.IgnoreNonContactDir.RIGHT, c = this.isXSnapping ? ms : Wu, l = et._compareSpacing(s.left, s.right, this.snapAreaOnXLeftLUT, this.snapAreaOnXRightLUT, o, c, c, a);
      if (l) {
        const h = this._updateResizeExtraDeltaBySpacing(n, l, i, s, !0, r);
        h > 0 && this._snapSpacingUpdateUIXaxis(s, l, h);
      }
    }
    if (n.y >= er || n.y <= -0.01) {
      this._generateAllSpacing(!1, s);
      const o = Array.from(this.spaceOnYLUT.keys()).sort((h, d) => h - d), a = (n.y >= er, et.IgnoreNonContactDir.RIGHT), c = this.isYSnapping ? ms : Wu, l = et._compareSpacing(s.top, s.bottom, this.snapAreaOnYTopLUT, this.snapAreaOnYBottomLUT, o, c, c, a);
      if (l) {
        const h = this._updateResizeExtraDeltaBySpacing(n, l, i, s, !1, r);
        h > 0 && this._snapSpacingUpdateUIYaxis(s, l, h);
      }
    }
  }
  /**
   * @param {Vector2} resizeDir
   * @param {object} possibleSpacing
   * @param {Vector2} extraDelta
   * @param {Rect2} compareBounds
   * @param {boolean} isHorizontal
   * @param {boolean} isSnapToGrid
   * @returns {number}
   */
  _updateResizeExtraDeltaBySpacing(n, s, i, r, o, a) {
    let c = 0;
    const l = (o ? n.x : n.y) >= er;
    if (s.leftBounds && s.rightBounds) {
      if (c = et.roundToUIPanelVersion(l ? s.leftSpace : s.rightSpace), a && !Number.isInteger(c))
        return -1;
      o ? i.x += l ? s.rightSpace - c : c - s.leftSpace : i.y += l ? s.rightSpace - c : c - s.leftSpace;
    } else
      c = this._updateEtractDeltaByNonContactedSpacing(s, o, i, r, a);
    return c;
  }
  _moveSnapSpacing(n, s, i) {
    const r = this.isXSnapping ? ms : Wu;
    this._generateAllSpacing(!0, n);
    const o = Array.from(this.spaceOnXLUT.keys()).sort((h, d) => h - d);
    let a = et._compareSpacing(n.left, n.right, this.snapAreaOnXLeftLUT, this.snapAreaOnXRightLUT, o, r * 2, r);
    if (a) {
      const h = this._updateMoveExtraDeltaBySpacing(a, s, n, !0, i);
      h > 0 && this._snapSpacingUpdateUIXaxis(n, a, h);
    }
    const c = this.isYSnapping ? ms : Wu;
    this._generateAllSpacing(!1, n);
    const l = Array.from(this.spaceOnYLUT.keys()).sort((h, d) => h - d);
    if (a = et._compareSpacing(n.top, n.bottom, this.snapAreaOnYTopLUT, this.snapAreaOnYBottomLUT, l, c * 2, c), a) {
      const h = this._updateMoveExtraDeltaBySpacing(a, s, n, !1, i);
      h > 0 && this._snapSpacingUpdateUIYaxis(n, a, h);
    }
  }
  /**
   * @param {object} possibleSpacing
   * @param {Vector2} extraDelta This will be modifed
   * @param {Rect2} compareBounds
   * @param {boolean} isHorizontal
   * @param {boolean} isSnapToGrid
   * @returns {number}
   */
  _updateMoveExtraDeltaBySpacing(n, s, i, r, o) {
    let a = 0;
    if (n.leftBounds && n.rightBounds) {
      if (a = et.roundToUIPanelVersion((n.leftSpace + n.rightSpace) * 0.5), o && !Number.isInteger(a))
        return -1;
      r ? s.x += a - n.leftSpace : s.y += a - n.leftSpace;
    } else
      a = this._updateEtractDeltaByNonContactedSpacing(n, r, s, i, o);
    return a;
  }
  _updateEtractDeltaByNonContactedSpacing(n, s, i, r, o) {
    if (o && !Number.isInteger(n.nonContactSpacing))
      return -1;
    const a = n.nonContactSpacing;
    return n.leftBounds ? s ? i.x += a - (r.left - n.leftBounds.right) : i.y += a - (r.top - n.leftBounds.bottom) : s ? i.x += n.rightBounds.left - r.right - a : i.y += n.rightBounds.top - r.bottom - a, a;
  }
  _snapSpacingUpdateUIXaxis(n, s, i) {
    let r = null, o = null;
    if (s.leftBounds && (r = et.createHorizontalRect(s.leftBounds, !0, i, n), et.addToDisplay(this.spacingAreaUIMap, r), this.spacingHorizontalVec.x = s.leftBounds.right, this.spacingHorizontalVec.y = n.y + n.height * 0.5, this.spacingHorizontal = i), s.rightBounds && (o = et.createHorizontalRect(s.rightBounds, !1, i, n), et.addToDisplay(this.spacingAreaUIMap, o), s.leftBounds || (this.spacingHorizontalVec.x = s.rightBounds.left - i, this.spacingHorizontalVec.y = n.y + n.height * 0.5, this.spacingHorizontal = i)), this.spaceOnXLUT.has(i)) {
      const a = this.spaceOnXLUT.get(i);
      for (const c of a) {
        const l = et.createHorizontalRect(c[0], !0, i, c[1]);
        r && r.overlaps(l) || o && o.overlaps(l) || et.addToDisplay(this.spacingAreaUIMap, l);
      }
    }
  }
  _snapSpacingUpdateUIYaxis(n, s, i) {
    if (this.spaceOnYLUT.has(i)) {
      const r = this.spaceOnYLUT.get(i);
      for (const o of r) {
        const a = et.createVerticalRect(o[0], !0, i, o[1]);
        s.leftBounds && s.leftBounds.overlaps(a) || s.rightBounds && s.rightBounds.overlaps(a) || et.addToDisplay(this.spacingAreaUIMap, a);
      }
    }
    s.leftBounds && (et.addToDisplay(this.spacingAreaUIMap, et.createVerticalRect(s.leftBounds, !0, i, n)), this.spacingVerticalVec.x = n.x + n.width * 0.5, this.spacingVerticalVec.y = s.leftBounds.bottom, this.spacingVertical = i), s.rightBounds && (et.addToDisplay(this.spacingAreaUIMap, et.createVerticalRect(s.rightBounds, !1, i, n)), s.leftBounds || (this.spacingVerticalVec.x = n.x + n.width * 0.5, this.spacingVerticalVec.y = s.rightBounds.top - i, this.spacingVertical = i));
  }
  // Function to translate Vector2 grip to GripPoint
  static getGripPointFromVector(n) {
    const { x: s, y: i } = n;
    return Math.abs(s) < er && Math.abs(i) < er ? null : i <= -0.01 ? s <= -0.01 ? _n.TOP_LEFT : s >= er ? _n.TOP_RIGHT : _n.TOP : i >= er ? s <= -0.01 ? _n.BOTTOM_LEFT : s >= er ? _n.BOTTOM_RIGHT : _n.BOTTOM : s <= -0.01 ? _n.LEFT : s >= er ? _n.RIGHT : null;
  }
  /**
   * Resize a Rect2 based on grip position and current mouse position
   * @param {Rect2} rect - The initial state created by createResizeState
   * @param {number} gripPosition - The position where the mouse is gripping (use GripPosition enum)
   * @param {Vector2} mousePos - The current mouse position
   * @returns {Rect2} The resized rectangle
   */
  static resizeRect(n, s, i) {
    const r = n.clone();
    switch (s) {
      case _n.TOP_LEFT:
        r.width = n.right - i.x, r.height = n.bottom - i.y, r.x = i.x, r.y = i.y;
        break;
      case _n.TOP:
        r.height = n.bottom - i.y, r.y = i.y;
        break;
      case _n.TOP_RIGHT:
        r.width = i.x - n.x, r.height = n.bottom - i.y, r.y = i.y;
        break;
      case _n.RIGHT:
        r.width = i.x - n.x;
        break;
      case _n.BOTTOM_RIGHT:
        r.width = i.x - n.x, r.height = i.y - n.y;
        break;
      case _n.BOTTOM:
        r.height = i.y - n.y;
        break;
      case _n.BOTTOM_LEFT:
        r.width = n.right - i.x, r.height = i.y - n.y, r.x = i.x;
        break;
      case _n.LEFT:
        r.width = n.right - i.x, r.x = i.x;
        break;
    }
    return r;
  }
  /**
   * Resize a Rect2 based on grip position and current mouse position
   * @param {Rect2} rect - The initial state created by createResizeState
   * @param {number} gripPosition - The position where the mouse is gripping (use GripPosition enum)
   * @param {Vector2} mousePos - The current mouse position
   * @param {Vector2} origin
   * @returns {Rect2} The resized rectangle
   */
  static scaleRect(n, s, i, r) {
    const o = n.clone();
    let a = 1, c = 1;
    switch (s) {
      case _n.TOP_LEFT:
        a = (r.x - i.x) / (r.x - n.x), c = (r.y - i.y) / (r.y - n.y);
        break;
      case _n.TOP:
        c = (r.y - i.y) / (r.y - n.y);
        break;
      case _n.TOP_RIGHT:
        a = (i.x - r.x) / (n.x + n.width - r.x), c = (r.y - i.y) / (r.y - n.y);
        break;
      case _n.RIGHT:
        a = (i.x - r.x) / (n.x + n.width - r.x);
        break;
      case _n.BOTTOM_RIGHT:
        a = (i.x - r.x) / (n.x + n.width - r.x), c = (i.y - r.y) / (n.y + n.height - r.y);
        break;
      case _n.BOTTOM:
        c = (i.x - r.x) / (n.x + n.width - r.x);
        break;
      case _n.BOTTOM_LEFT:
        a = (r.x - i.x) / (r.x - n.x), c = (i.y - r.y) / (n.y + n.height - r.y);
        break;
      case _n.LEFT:
        a = (r.x - i.x) / (r.x - n.x);
        break;
    }
    return Number.isFinite(a) && (o.width *= a, o.x = r.x + (o.x - r.x) * a), Number.isFinite(c) && (o.height *= c, o.y = r.y + (o.y - r.y) * c), o;
  }
  static createHorizontalRect(n, s, i, r) {
    const o = s ? n.right : n.left - i, a = Math.min(r.top, n.top), c = Math.max(r.bottom, n.bottom) - a;
    return new ye(o, a, i, c);
  }
  static createVerticalRect(n, s, i, r) {
    const o = Math.min(r.left, n.left), a = s ? n.bottom : n.top - i, c = Math.max(r.right, n.right) - o;
    return new ye(o, a, c, i);
  }
  static addToDisplay(n, s) {
    const i = s.hash();
    n.has(i) || n.set(i, s);
  }
  endSnapMovingElementToElement() {
    this.otherElementsVertices.clear(), this.selectedVertices.clear(), this.snapToElementXUI.clear(), this.snapToElementYUI.clear(), this.spacingAreaUIMap.clear(), this.spacingHorizontal = 0, this.spacingVertical = 0;
  }
  /**
   * check if the selection aabb vert/hori with x/y axis when it is single selection
   * if it is multi-selection return true
   * @param {Selection} selection
   * @returns {bool}
   */
  isBoundingBoxAlignAxis(n) {
    return !n.single || this.isMultipleOf90Degree(n.first.node.item.transform.rotation);
  }
  /**
   * Check if following scaling conditions fit to snap to pixel when dragging handler
   * In the multi-selection the rotated element cannot snap scaling to all of
   * pixel grid when dragging handler
   * Condition not to snap scaling to pixel grid:
   * 1. It is multi-selection
   * 2. It has rotated element in selection
   * 3. It is dragging handler
   * @param {Element} hoveredNode
   * @param {bool} isClickEdge
   * @returns {bool}
   */
  isScalingSnapToPixelGrid(n, s) {
    const i = this.isMultipleOf90Degree(n.item.transform.world.get_rotation());
    return !s || s && i;
  }
  /**
   * Get the point at the center of edge as the click point
   * @param {Vector2} scaleDir
   * @param {SceneNode} hoverNode
   * @returns {Vector2} (warn: need to free after used)
   */
  getScalingClickPoint(n, s) {
    const i = s.item.transform.size.clone().abs(), r = zH.set(n.x * i.x, n.y * i.y).add(s.boundsLocal.center);
    return s.item.transform.world.xform(r, r), r;
  }
  /**
   * snap each element to pixel grid in the selection
   * @param {Vector2} delta
   * @param {Selection} selection
   * @param {number} rotation
   * @param {Vector2} ratio
   * @param {Vector2} parentScale
   * @param {bool} isSnapScalingToPixelGrid
   * @returns {Vector2}
   */
  snapScalingToPixelGrid(n, s, i, r, o, a) {
    const c = n.clone(), l = Math.cos(i);
    return c.divide(o), !s.single && !this.isMultipleOf90Degree(i) && c.divide(Math.abs(l), Math.abs(l)), a && c.multiply(r), c;
  }
  /**
   * When changing sign of scaling value, this will keep outside edge snapping to pixel grid
   * @param {Vector2} scaleDir
   * @param {Vector2} scale
   * @param {Vector2} origin
   * @param {number} scaleX
   * @param {number} scaleY
   * @returns {Vector2}
   */
  flipSnapEdge(n, s, i, r, o) {
    const a = s.clone(), c = n.x > 0 ? (100 - i.x) / i.x : i.x / (100 - i.x), l = n.y > 0 ? (100 - i.y) / i.y : i.y / (100 - i.y), h = new N(r, o).sign(), d = s.clone().sign();
    return h.x !== d.x && (a.x = s.x * c), h.y !== d.y && (a.y = s.y * l), a;
  }
  /**
   * return last position of snapping to pixel grid
   * @returns {Vector2}
   */
  getSnapGridPos() {
    return this.lastSnapToGridPos;
  }
  /**
   * check whether the angle is multiple of 90 degree
   * @param {number} radian
   * @returns {bool}
   */
  isMultipleOf90Degree(n) {
    const s = n % (Math.PI * 0.5) < wn ? 0 : n;
    return Number.isInteger(s % (Math.PI * 0.5));
  }
  /**
   * check whether the angle is multiple of 180 degree
   * @param {number} radian
   * @returns {bool}
   */
  isMultipleOf180Degree(n) {
    const s = n % Math.PI < wn ? 0 : n;
    return Number.isInteger(s % Math.PI);
  }
  /**
   * @param {number} angle1
   * @param {number} angle2
   */
  _setAxisDiagonalAngle(n, s = null) {
    this.axisDiagonalCount = s ? 2 : 1, this._setAxisDiagonalVec(n, 0), this._setAxisDiagonalVec(s, 1);
  }
  /**
   * @param {number} angle
   * @param {number} vecIndex
   */
  _setAxisDiagonalVec(n, s) {
    switch (n) {
      case 0:
        this.axisDiagonalVec[s].set(1, 0);
        break;
      case 45:
        this.axisDiagonalVec[s].set(-1, 1);
        break;
      case 90:
        this.axisDiagonalVec[s].set(0, 1);
        break;
      case -45:
        this.axisDiagonalVec[s].set(1, 1);
        break;
      default:
        this.axisDiagonalVec[s].set(0, 0);
        break;
    }
  }
  /**
   * get elements to snap to
   * @param {Set<string>} selectedIdList
   * @param {Element[]} elements
   * @param {Map<number, number[]>} dataList
   * @param {boolean} isMovingEle
   * @param {boolean} isRowArea
   * @param {Set<string>} selectedParent
   * @param {Element[]} spacingElements
   * @param {Rect2} selectionBounds
   */
  _getElementsCornerAndCenterData(n, s, i, r, o, a, c, l) {
    var h;
    for (const d of s) {
      const p = this._checkParentIdNotInclude(d, n, r), E = !this._isComputedGroupAncestorOfAnyInList(d, n), g = d.get("id"), T = this.vs.indexer.getNode(g);
      if (!d.isHidden() && p && E && !n.has(g)) {
        const A = T.boundsWorldAABB_zero;
        this._addPointDataToMap(A.center.x, A.center.y, i), this._addPointDataToMap(A.left, A.top, i), this._addPointDataToMap(A.right, A.top, i), this._addPointDataToMap(A.left, A.bottom, i), this._addPointDataToMap(A.right, A.bottom, i), a.has((h = this.vs.indexer.getNode(d.get("id")).parent) == null ? void 0 : h.id) && c.has(d) && !l.overlaps(A) && (o ? (this.snapAreaOnXLeftLUT.set(A.left, A), this.snapAreaOnXRightLUT.set(A.right, A)) : (this.snapAreaOnYTopLUT.set(A.top, A), this.snapAreaOnYBottomLUT.set(A.bottom, A)));
      }
    }
  }
  /**
   * exclude to snap to children element
   * @param {Element} hitElement
   * @param {Set<string>} checkIdList
   * @param {boolean} isMovingEle
   * @returns {bool}
   */
  _checkParentIdNotInclude(n, s, i) {
    let o = this.vs.indexer.getNode(n.get("id"));
    for (; !o.item.isScreen() && o.parent; ) {
      if (s.has(o.id) && (o.item.type !== "container" || i)) return !1;
      o = o.parent;
    }
    return !0;
  }
  /**
   * check whether the hitElement is a "normal group type" ancestor element
   * of the selected elements
   * @param {Element} hitElement
   * @param {Set<string>} selectedIdList
   * @returns {bool}
   */
  _isComputedGroupAncestorOfAnyInList(n, s) {
    const i = this.vs.indexer.getNode(n.get("id"));
    if (!n.isComputedGroup) return !1;
    for (const r of s) {
      let a = this.vs.indexer.getNode(r);
      for (; i.item.depth < a.item.depth; ) {
        if (a.parent === i) return !0;
        a = a.parent;
      }
    }
    return !1;
  }
  /**
   * @param {Map<number, Map<number,number>>} map
   * @param {bool} isSingleSelected
   * @param {Rect2} bound
   * @param {Transform2D} worldTrans
   */
  _getElementOABAndCenterData(n, s, i, r) {
    const o = new N(i.x + i.width, i.y), a = new N(i.x + i.width, i.y + i.height), c = new N(i.x, i.y + i.height), l = new N(i.x, i.y), h = new N(i.x + i.width * 0.5, i.y + i.height * 0.5);
    if (s) {
      const d = r.xform_rect(i);
      o.copy(d.topRight), a.copy(d.bottomRight), c.copy(d.bottomLeft), l.copy(d.topLeft), h.copy(d.center);
    }
    this._addPointDataToMap(h.x, h.y, n), this._addPointDataToMap(o.x, o.y, n), this._addPointDataToMap(a.x, a.y, n), this._addPointDataToMap(c.x, c.y, n), this._addPointDataToMap(l.x, l.y, n);
  }
  /**
   * @param {Map<number, Map<number,number>>} map
   * @param {bool} isSingleSelected
   * @param {Rect2} bound
   * @param {Transform2D} worldTrans
   * @param {Vector2} anchor
   * @param {boolean} isComputedGroup
   */
  _getResizeDraggingSideData(n, s, i, r, o, a) {
    const c = new N(0.5, 0.5).sub(o), l = new N(i.width, i.height), h = c.x === 0 ? new N(i.width * 0.5, 0) : new N(0, i.height * 0.5), d = c.x === 0 || c.y === 0, p = new N(), E = new N();
    if (l.multiply(c), d) {
      const g = i.center.clone().add(l);
      if (s)
        if (a) {
          const T = s.element.get("referencePoint"), A = c.x === 0 ? new N(T.x, 0) : new N(0, T.y);
          p.set(0, 0).add(l).add(A), E.set(0, 0).add(l).sub(A);
        } else
          p.set(i.width * 0.5, i.height * 0.5).add(l).add(h), E.set(i.width * 0.5, i.height * 0.5).add(l).sub(h);
      else
        p.copy(g).add(h), E.copy(g).sub(h);
      r.xform(p, p), r.xform(E, E), this._addPointDataToMap(p.x, p.y, n), this._addPointDataToMap(E.x, E.y, n);
    } else
      s ? p.set(i.width * 0.5 + l.x, i.height * 0.5 + l.y) : p.copy(i.center).add(l), r.xform(p, p), this._addPointDataToMap(p.x, p.y, n);
  }
  /**
   * @param {number} x
   * @param {number} y
   * @param {Map<number, Map<number,number>>} map
   */
  _addPointDataToMap(n, s, i) {
    if (i.has(n))
      i.get(n).set(s, 0);
    else {
      const r = /* @__PURE__ */ new Map();
      r.set(s, 0), i.set(n, r);
    }
  }
  _addSnapXUIData(n, s, i) {
    this._addPointDataToMap(n, s, i);
  }
  _addSnapYUIData(n, s, i) {
    this._addPointDataToMap(s, n, i);
  }
  _removePointDelta(n, s) {
    const i = [];
    for (const [, r] of n.entries()) {
      for (const [o, a] of r.entries())
        r.get(o) !== 0 && (r.has(o - a + s) || i.push(o), r.set(o - a + s, s));
      for (const o of i)
        r.delete(o);
      i.length = 0;
    }
  }
  /**
   * convert system data to UI panel data
   * UI panel only shows number with rounding system data to the two decimal places
   * @param {Vector2} pos
   * @returns {Vector2} (warning: need to free after used)
   */
  _convertPosToUIPanelVersion(n) {
    const s = n.clone();
    return s.scale(100), s.round(), s.scale(0.01), s;
  }
  /**
   *
   * @param {number} value
   * @returns {number}
   */
  static roundToUIPanelVersion(n) {
    return Math.round(n * 100) / 100;
  }
  /**
   * This function should be called before calling _removeOverlappingIntervals
   * @param {boolean} isRow
   * @param {Rect2} overlapBounds
   */
  _generateAllSpacing(n, s) {
    const i = n ? this.spaceOnXLUT : this.spaceOnYLUT;
    i.clear();
    const r = Array.from((n ? this.snapAreaOnXLeftLUT : this.snapAreaOnYTopLUT).entries()).sort((a, c) => a[0] - c[0]), o = r.length;
    for (let a = 0; a < o; a++) {
      let c = a + 1;
      for (; c < o && r[c][0] <= (n ? r[a][1].right : r[a][1].bottom); )
        c++;
      for (; c < o; ) {
        if (!s.overlaps(r[a][1], ms) && !s.overlaps(r[c][1], ms)) {
          const l = et.roundToUIPanelVersion(r[c][0] - (n ? r[a][1].right : r[a][1].bottom));
          i.has(l) ? i.get(l).push([r[a][1], r[c][1]]) : i.set(l, [[r[a][1], r[c][1]]]);
        }
        c++;
      }
    }
  }
  /**
   * @param {number} left
   * @param {number} right
   * @param {Map<number, Rect2>} snapLeftLUT
   * @param {Map<number, Rect2>} snapRightLUT
   * @param {number[]} nonContactSpacingArr
   * @param {number} tolerance
   * @param {number} nonContactTOL
   * @param {number} ignoreNonContactDir
   * @returns {{ leftSpace: number, rightSpace:number, leftBounds:Rect2, rightBounds:Rect2, nonContactSpacing:number}}
   */
  static _compareSpacing(n, s, i, r, o, a, c, l) {
    if (!i.size && !r.size)
      return null;
    const h = Array.from(i.keys()).sort((m, O) => m - O), d = Array.from(r.keys()).sort((m, O) => m - O);
    let p = et._searchInsertPosition(d, n, !0), E = et._searchInsertPosition(h, s, !1);
    for (; p > -1 && d[p] >= n; )
      p--;
    for (; E < h.length && h[E] <= s; )
      E++;
    let g = null, T = null, A = -1;
    if (p >= 0 && E < h.length) {
      const m = n - d[p], O = h[E] - s;
      if (Math.abs(m - O) <= a)
        return { leftSpace: m, rightSpace: O, leftBounds: r.get(d[p]), rightBounds: i.get(h[E]) };
    }
    if (p >= 0 && l !== et.IgnoreNonContactDir.LEFT) {
      const m = n - d[p], O = et._binarySearchWithTolerance(o, m, c);
      O > -1 && (g = r.get(d[p]), A = o[O]);
    }
    if (E < h.length && l !== et.IgnoreNonContactDir.RIGHT) {
      const m = h[E] - s, O = et._binarySearchWithTolerance(o, m, c);
      if (O > -1) {
        const S = o[O];
        (A < 0 || S < A) && (T = i.get(h[E]), g = null, A = S);
      }
    }
    return A !== -1 ? { leftBounds: g, rightBounds: T, nonContactSpacing: A } : null;
  }
  static _binarySearchWithTolerance(n, s, i) {
    let r = 0, o = n.length - 1;
    for (; r <= o; ) {
      const a = Math.floor((r + o) / 2), c = n[a];
      if (Math.abs(c - s) <= i)
        return a;
      c < s ? r = a + 1 : o = a - 1;
    }
    return -1;
  }
  static _searchInsertPosition(n, s, i) {
    let r = 0, o = n.length - 1, a = -1;
    for (; r <= o; ) {
      const c = r + Math.floor((o - r) * 0.5);
      i ? n[c] < s ? (a = c, r = c + 1) : o = c - 1 : n[c] > s ? (a = c, o = c - 1) : r = c + 1;
    }
    return a;
  }
  /**
   *
   */
  updateSnapMovingDataForGuides() {
    this.xOfAllVertices.length = 0, this.yOfAllVertices.length = 0;
    const n = this.vs.viewport.rectW.clone(), s = 18 / this.vs.viewport.scale;
    n.x += s, n.y += s, n.width -= s, n.height -= s;
    const i = Rl(n);
    for (const r of i) {
      const o = r.get("id"), a = this.vs.indexer.getNode(o);
      if (!r.isHidden() && !r.isScreen) {
        const c = a.boundsWorldAABB_zero;
        this.xOfAllVertices.push(et.roundToUIPanelVersion(c.center.x)), this.xOfAllVertices.push(et.roundToUIPanelVersion(c.left)), this.xOfAllVertices.push(et.roundToUIPanelVersion(c.right)), this.yOfAllVertices.push(et.roundToUIPanelVersion(c.center.y)), this.yOfAllVertices.push(et.roundToUIPanelVersion(c.top)), this.yOfAllVertices.push(et.roundToUIPanelVersion(c.bottom));
      }
    }
  }
  /**
   *
   * @param {import('@phase-software/data-store/src/Guidelines').Guideline} hoverGuide
   * @param {Vector2} delta
   * @param {boolean} isSnapToGrid
   * @returns {number}
   */
  compareVerticesWithGuides(n, s, i = !0) {
    if (!n) return 1 / 0;
    const r = n.direction === dt.VERTICAL ? this.xOfAllVertices : this.yOfAllVertices, o = n.direction === dt.VERTICAL ? s.x : s.y;
    let a = 1 / 0;
    for (const c of r) {
      if (i && !Number.isInteger(c))
        continue;
      const l = c - n.position - o;
      Math.abs(l) <= this.threshold && (a = Math.min(a, l));
    }
    return a;
  }
};
je(et, "ResizeTypes", Object.freeze({
  RESIZE_ONE_ELEMENT: 1,
  RESIZE_ELEMENTS: 2,
  SCALE_ONE_ELEMENT: 3
})), je(et, "IgnoreNonContactDir", Object.freeze({ NONE: -1, LEFT: 1, RIGHT: 2 }));
let Hc = et;
const zH = new N(), _n = Object.freeze({
  TOP_LEFT: 0,
  TOP: 1,
  TOP_RIGHT: 2,
  RIGHT: 3,
  BOTTOM_RIGHT: 4,
  BOTTOM: 5,
  BOTTOM_LEFT: 6,
  LEFT: 7
});
class KH extends Oh.EventEmitter {
  /**
   * @param {HTMLCanvasElement} canvas
   */
  constructor(n) {
    super(), this.x = 0, this.y = 0, this.width = 256, this.height = 256, this.scale = 1, this.pixelRatio = window.devicePixelRatio, this.canvas = n, this.projectionTransform = new Ce(), this.invProjectionTransform = new Ce(), this.reset();
  }
  reset() {
    return this.x = 0, this.y = 0, this.width = 256, this.height = 256, this.scale = 1, this.pixelRatio = window.devicePixelRatio, this.projectionTransform.identity(), this.invProjectionTransform.identity(), !0;
  }
  setTransform(n) {
    this.x = n.x, this.y = n.y, this.scale = n.scale, this.updateTransforms();
  }
  get rect() {
    return new ye(0, 0, this.width, this.height);
  }
  get rectW() {
    return this.toWorldRect(this.rect);
  }
  get realWidth() {
    return Math.floor(this.width * this.pixelRatio);
  }
  get realHeight() {
    return Math.floor(this.height * this.pixelRatio);
  }
  /** @private */
  updateTransforms() {
    this.projectionTransform.set(this.scale, 0, 0, this.scale, this.x, this.y), this.invProjectionTransform.copy(this.projectionTransform).affine_inverse(), this.emit("update");
  }
  resize() {
    const n = this.canvas.parentElement;
    if (!n) return;
    const s = n.getBoundingClientRect(), i = Math.ceil(s.width), r = Math.ceil(s.height);
    this.width === i && this.height === r && this.pixelRatio === window.devicePixelRatio || (this.width = i, this.height = r, this.pixelRatio = window.devicePixelRatio, this.canvas.style.width = `${this.width}px`, this.canvas.style.height = `${this.height}px`, this.width * this.height !== 0 && (this.canvas.width = this.realWidth, this.canvas.height = this.realHeight, this.emit(Oe.VIEWPORT_RESIZE), this.emit("update"), window.dispatchEvent(new Event("resize"))));
  }
  /**
   * converts a vector from world space to screen space coordinates
   * @param {Vector2} v
   * @returns {Vector2}
   */
  toScreen(n) {
    return this.projectionTransform.xform(n);
  }
  /**
   * converts a vector from screen space to world space coordinates
   * @param {Vector2} v
   * @returns {Vector2}
   */
  toWorld(n) {
    return this.invProjectionTransform.xform(n);
  }
  /**
   * converts a rect from world space to screen space coordinates
   * @param {Rect2} rect
   * @returns {Rect2}
   */
  toScreenRect(n) {
    return this.projectionTransform.xform_rect(n);
  }
  /**
   * converts a rect from screen space to world space coordinates
   * @param {Rect2} rect
   * @returns {Rect2}
   */
  toWorldRect(n) {
    return this.invProjectionTransform.xform_rect(n);
  }
  /** @returns {number} */
  getZoom() {
    return this.scale;
  }
  /** @param {number} zoom */
  setZoom(n) {
    const s = this.rectW;
    this.scale = Ss.clamp(n, GF, FF), this.moveTo(s), this.emit(Oe.VIEWPORT_ZOOM_CHANGE, n);
  }
  /** @param {Vector2} offset */
  offsetPos(n) {
    this.x += n.x, this.y += n.y, this.updateTransforms();
  }
  /**
   * zoom viewport around given point
   * @param {Vector2} pos - in screen space
   * @param {number} mult
   */
  zoomAroundPos(n, s) {
    const i = this.toWorld(n);
    this.setZoom(this.scale * s);
    const r = this.toScreen(i), o = n.clone().sub(r);
    this.offsetPos(o);
  }
  /**
   * Checks if the viewport is contained by the given rect
   * @param {Rect2} rect - in world space
   * @returns {boolean}
   */
  isContainedBy(n) {
    return n.containsRect(this.rectW);
  }
  /**
   * Checks if the viewport contains the given rect
   * @param {Rect2} rect - in world space
   * @returns {boolean}
   */
  containsRect(n) {
    return this.rectW.containsRect(n);
  }
  /**
   * @param {Rect2} rect - in world space
   * @param {number|{left: number, top: number, right: number, bottom: number}} [padding] - in screen space (pixels)
   * @param {number} [u] - in UV space [0, 1]
   * @param {number} [v] - in UV space [0, 1]
   */
  focus(n, s = 25, i = 0.5, r = 0.5) {
    let o, a, c, l;
    typeof s == "number" ? (o = s, a = s, c = s, l = s) : (o = s.left ?? 25, a = s.top ?? 25, c = s.right ?? 25, l = s.bottom ?? 25);
    const h = this.width - (o + c), d = this.height - (a + l);
    this.scale = Math.min(h / n.width, d / n.height);
    const p = n.clone();
    this.moveTo(p, i, r, {
      left: o,
      top: a,
      right: c,
      bottom: l
    });
  }
  /**
   * move at a point on the given rect taking into account u, v coords
   * @param {Rect2} rect - in world space
   * @param {number} [u] - in UV space [0, 1]
   * @param {number} [v] - in UV space [0, 1]
   * @param {{left: number, top: number, right: number, bottom: number}} [padding] - custom padding values
   */
  moveTo(n, s = 0.5, i = 0.5, r) {
    const o = this.rect;
    if (r) {
      const l = (r.left - r.right) / 2, h = (r.top - r.bottom) / 2;
      o.x += l, o.y += h;
    }
    const a = l1(o, s, i), c = l1(n, s, i).scale(this.scale);
    this.x = a.x - c.x, this.y = a.y - c.y, this.updateTransforms();
  }
}
function l1(e, n, s) {
  return new N(e.x + n * e.width, e.y + s * e.height);
}
const QH = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAYAAABUdSs8AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAANASURBVHgB7VdLSxtRFJ5X3g9qHo0J1kabFoLFCimFQhcGt7XQhYuCW1fuXYmPlSsX/gZ3LgT7J9y3BLpMS2nRQlXEpDHJ3H6f3qnjYGqSGbtpPrjcx0zmfPec75x7oygDDDDAAAP871CV3qEKIa4mqqpwjl4ofUBTeoQ0ppbLZf3w8HC8VCoZ6+vrJNXPZvqCCqO+XC4XNk2zur+/X5yYmPBjXfsnJKSRYDweT2As2u325729vcl8Ph9cW1u7exI0kslkIhhmSQBz0Wq1vuzs7EyRxNzcnH7XJPRUKhVD/1BcqvEaCcyDSh/a6hr0QCKRiAeDwbxFwEliZGQk1G04DMUjwCC7B8vLy+/Rv1laWvpUqVSaGJuSpDdgjOkBDMfsHlAcnqAwMb8QptJfvbkZ/CA1gBDcSMBOYnd39xmFiTXdXrzcwhJhRwIWifPz848bGxv5QqEQoOcUj6Df5gEnia2trVEWK0/SU8Y05syC1dVV0QnNZvPD9vZ21hMv8CNOD9B4rVb7Pj8//84wjFdoL30+3wu0qUAg8DgSiQyn0+moJODOC04RWsYXFhbe4vEkDeLZOMZjoVBoNBwO5+4BlhhdE5C7iPHjJFCv178tLi6+xtoTtCxaGi0VjUbTsVgsyZRlYcKaIcPnDiTAswA7yzYaja8rKysz9AYN0hh3a48/fhKnADvVg54Z4WPi4OCgjTg3UO1mNjc3K3D7MeJc0zSNggvwPV5UCBALoiIaaCpIXNwbXGUDf8z7AIYhCot6oEc4hstTIPPIEidBTWCclieozxMCdKfUgo/ionFn6lkE7OB7JC/c1gNrFyTCKkex3VaU5PO0zAbPjmtNKvx+Nx7A2rB1VCseQbU8gFgXMC9BnGU7AfRltOdofJ5yesDVfUBc3pDbiG0D02OMTdwRrx17qIanuq7/BLFTZEo9mUy2q9Xqn3dcuUKmmonU/AUv1GDsBGl4YpG7MKBpR1zHJfasWCw2Zmdn20J4dDbb1Mxe51Udu8zIcDyV50CG69Y54MwAtx4QV1yEmc1mm6iQZ36//xhrP9AfcT40NNRiAeN7/f6D6ooP1T09PW1QaDI7KDifJ6dgD9CsJtPtr7fj35vpJCsip8dCAAAAAElFTkSuQmCC", ZH = "data:image/png;base64,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", qH = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAuCAYAAABJcBuEAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAQXSURBVHgB7VhNTBNBFJ6lP2yhrRYLCBSoWCVKAo0YExIPoBw4KAkHDiZcOQAhhBi4iPyciMYEiEc1HLgQSEAMRwjcOAISEk+gRisQCOXCX6Hr+5aZUiogbLde7JdMdma3O+9737z3ZraMxRFHHHHE8b9DYpeHpCjK8UCSGMZ0VZgGJLBLghuTysrKDGtra3nFxcXGrq4ukNLijCZIZNSUmZmZFAwGv87MzNwpKCgw0/2Ef0KCG5HtdnsK9ZXDw8NvY2NjhW63W+7s7Iw9CRhJT09Ppm4GCNBYOTg4+D40NOQFierqakOsSRicTqeNrrnKUTSeIEFjmWmIrQsDCqSkpNhlWXYLApEkXC6X5aLLYWQ6gQzikt3W1vaJrpWtra1fFhcXA9QPcpL6AGsMBah7I1wBFqEEApPGamAybfXmdGBCxAAtwakEwkmMjIwUITDpniG8eEULEYRnEhAk9vf3F7q7u90ejycRyjGdYPibApEk+vr6clCsdElPvqZ/ZEFHR4dyFgKBwOeBgYEMXVTAJJEKwPj29vavmpqaZ0aj8SG1EpPJ9ICaNzEx8VZycvL11NRUKycQnQqRQSiM19bWVtHjQhjEM+q7LRZLTlJSUobD4bgigjFqAtwLEMgFgZ2dHV9DQ8MTunebWha1NJL7ns1mu3aVgLLNjRv58kUHEMCk8Gxvb+9He3v7YyKTB5lhdGJioox2Sf/GxsZrEKBX5NLSUiMPQN2CUN0Nm5qa8kGEDDthfHx8vHx9fX2LDCqzs7PK6urqG8hPvzfrVpDgCc4D1LUgFmCA4BDGvV6vGpjkfIgEja+EnRlYVAABeANZaSijLE9OTj6ic8FWf3+/GpRQoKenR70CQgmQiFoJeAASIAAFsObwvLe3N5T3MDw1NaX2l5eXTyjB1QsFo5aoxJEwYXp62jw4OHifJP9YXl5u39zcPPXHfr+fVVVVMZ/P95xIvCRCFiKh/dCCFyElajxkh7dYb1xFwxixIMaUhuo9qLGysvKCprFEk5ISz+u0paWlt5AXk2PNITsajIvx6Oio+hyxsbu7+5Pul9C7VnZUlLQRgAJIO+rnLywsvAMJEXCRMSACEwWrpaWlgqpjFk7UmvcFEYCo7TSZi24Vzs3NfQgPOBCA5yIwYbyxsfEp/fYm6gdPSc2ZIIlagCwgEtm06RTNz8+/h3Gst1hz4XldXV0l7REeFCx2fEqKDnySEAnqh0gI49ikhHF67hTfDkwniM8xEz8jugQJSknV8/r6esju4fEi63kqUiGKEpaDk8gym813KSZeNTc3V9A4j5oqO9NjKz4HCbzC2axWayqCkzapTBo7xNdSLI0DksgO6svIEKSaOIyetwHpyUr93wCf6vRBos47PDwcfkiNPUR95x5fyLnftYHDLHbe9hgAAAAASUVORK5CYII=", jH = "data:image/png;base64,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", JH = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAiCAYAAAA+stv/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAKfSURBVHgB7VY7ixpRFL7j+BifiChmxWSNCEGUZMHKUgKBEEznP0hvpYWIjzSCjb1gZWchmO3SaGcpJIgBJWwSE4ISYbMSXV+Tc8xoHLFYr/sodj643HOv45zvfOfcc4cQCRIkSJBw38GQ/cHwPP9/wTAE1zDzhAIysicEZ0wgEGB7vZ7T5/PJ0+k0kqIJhgoMOFXYbDbNYrE4q9frbo/Ho4R92a2QEJxwBoPBBDY/n8+/VCqVpw6Hg0ulUjdPAp1YrVYtmEdIANb8bDb7WiqVTpBEKBRib5oEazab9TAf8/+qUUQC1hyhqK0rAxUwmUwGjuMcKwLbJOx2u/qq6ZCTa0AulyNwEtB8GI/H38H8OhqNfmo2m1OwFwLJ6wHmGBUA8/FKgWq1yjcaDd5oNK6VwMKE35aFSej6zW7gC7EGIAUiAoPB4PM2iXK5/AwLE55hN5vXoVgVoYhANpuNttvt95skJpPJx0wm43C5XCpUbtfLqGsAFBCtdTrdyO12v+10OjMg9BI6JW57Y7HYqUajeZXP538C3wVty15DyKl+8xSgAsVi8Q3YHoVCcdLtdk/5DUyn0w+FQsG2S4W9FYDKZiAFZDgcigoLOuNYrVafgylzOp1R8JtEchDxSC6X/wYVLrxeL/4Hx1qFvRsG9H2RhMlkkvj9/h+tVutsNBr9AWXOVSpVH6Lug+NfLMtewDxWKpXzWq1GDi5GQUY9RPsI5R2Px98jkcgL2LPB0MDAi0mF7dpisehwYGPCfSF9hxPAl4OkRxDlt0Qi8RyiPobKN+KtuDr3+JxAlt3oiof3A8HB8jYMh8NPtFrtA3R+WxfR8jrG7wEw1SgvqoGR0zqnykkwGJyDw0m/37+Es38J9gwuIaozTiXXdqQHN5e7xF/f0Gr1SjENsAAAAABJRU5ErkJggg==", $H = "data:image/png;base64,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", e8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAARJSURBVHgB7VdbS1xXFN7nOBdHa3W8dDp2vEahrVBnGGgf4oOKP0AEaSgt1V4SWkLxuemD/0BaaMW2RDG1U9QHpY0gCvqoefCKeAPvJIq2jlXHUZM5/b7D2e1BrNGTyZsLFmfP2mvv/a3r3iPENV2TBdI0jaxgqJi+wgopwhqptbW1ytLSkhqNRpWZmZlnABDTN1QUa0guS42NjWowGLRnZ2cnnZycPDg6OvrF4/EkY8rBOWHdqIuJriaXl5fbMjMzUyKRyK9tbW0aeX9/P5QGKioqcor/whJ/ALQ8PT391YODgxAPppjM8d7e3m8Yp4EdMi9EvIgbIuYJtFweDoO16upqnTmWniBAAo0LAGkJY5ufn5+4uLj4EWSa3+/XxsfHNch15piy3d1dbXZ29mOscYETxIuGQ8bc5/O51tfXP3C5XDkLCws/EAQ8sSUBcEzZ3Nxcc2JiYj6q40OCoCcsJ6Y8PCsr6xUkXAetW11d/RZTpc3NzXdHR0fbJYCRkZEHLS0td+12e+nKysp3BMM1DEdJSYnDAHBpELoy0ZtjTheTQqHQJ5gPwu33TSG4j8ODHR0dn8oQycR0u92p0CcI9bxw2M5DAMsTpqamXGtray3d3d23GhoaxNDQkDg+Pn6Mzd9F43kPte+X+jk5Of6JiYnbHKMxPWltbfVWVFTw5/vYQ8vLy7vj9Xqj+H36XADIdrWrq8sJy/XD6+rqBDJd9Pb2krOhckfqDg8Py2HAYLMRgmtBtxA6gR7xGUCxWz4166lnztfbK9xmg7V2q/3dTNwDHdMOtm1vb6vPqwrFqOE0p9NZtLGx8Tvcqdc5S+3w8HCTCUfe3NyckjmwtbU1KeWsCOpyDddyD+x3g50SX/tZAOoZtFphYWEM8T1VVTVaUFDwTWVlZV9TU5Oor68XSUlJnrGxsUdlZWU/YuMxuQ4lOk4Z8uBRcnLya9TlmqqqqofY72usi4TD4VOEN3aZy0phTzeyNw8cwAF/ENz09PRPyPYAMvz25OTkz9IDHLe3t38O3SB1WLJcA10mai74St2RSqpRv2loPtzg7b6+vgbWObrh90adP5EAcCM+poxNyuFwvNPf3/8Vvm9inc8w5H8PV8+R0UUxuOspQEQAIAy3/llTU9MzMDBwE73hy0AgIObn51+XC9ABvZQVFxd/MTg4eBNV0wMAf2FqDyGI4PvM2PfK9O/dn5KSksE2i+TrkYlpvowo4xw9lpqa6mb7Zid90atZXiYJBAFPeDAuQV0/5IGGVfrhjDmsfgu/s8Au3gFxexcYG9kYTyMnAhIEmWPISsE+3h1Xsdx2GSWjdGIZGRnRnZ0d3SuolHvLy8t6WaFc72E+jMvn79zc3GMAoFzEldjR6FZWh+EJH5sV+Aam35DZ/lKeY2Yy7ncHb0p83exwdLu4oNQuIito+ULiU1y/Nyhg9+zs7Iy99Cf5WSDC9MdEXJNF+gcCK6IVrtlQQQAAAABJRU5ErkJggg==", t8 = "data:image/png;base64,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", n8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAQxSURBVHgB7VfbS1RdFN9nnIvjfH7OeMEvv8lbgpVoM2hEPSnUuwhCTEY++BB0wZ570D9BEjSbQGG6oT4olSDio+KDKKLiDbygmKHlmDpeqDn9fqezaxCddJreXLA4e9bee+3fuu49QpzSKUVAqqqSFQyVkK+IhBQRGRnKy8uV2dlZw+7urjI+Pv4NAIKaQkWJDMlxqba21lBYWGhKS0uL29/f9+3s7LxITU21YcrMORG5UeGJriYXFxcbk5OT4wOBwKuWlhaVvLm5+doOysnJsYhfYYk+AFqemJj479bW1mseTDGZ442NjTcY28FmmRciWkSFiHkMLZeHw2C1tLRUY46lJwiQQKMCQFrC2GZmZsbOzMzchkx1uVzq8PCwCrnGHFO2vr6uTkxM3MEeKzhG/Gk4ZMydTqd1cXHRY7Vaz05OTjYSBDzxUQLgmDIc/jQ2NjYT1VFBEPRExIkpD09JSfkHCfeS1s3Pzz/BlKuhoeHBwMCATwLguLGx8aHJZHLj8HqC4R6GIy8vz6wDOBSE4RCZtrioqMg4NjZmnZub87a2tnpKSkpERkbGA5/PVwSXL+Xn59/w+/3ahoKCgutDQ0OLXq/3clZW1n232y24B3ufLS8vMxxaThw3HJrlodnOJGOcUfPLo6OjXn5pOeV0Fsehc1x7MDHpicMAGA8KkO2GtrY2Cw5vam9vv1lZWSmQ6aKzs5N8BkuquA6HClio7aHF8MYZHFol9cAIwb2gmwsLCwI9ogpeZLf8KsKEQGuvDofDuLe3Zzqqv9P1OOzI36FEHeiYJrBxdXXV8LswKHoN2y0WS87S0tLb5ubmnyFgtvf19b3it6amRnM/5zimrL+//yW/MgTcSx1Yd87+A6EpLACiZcNhb0fJOZHVl+C+91TEOifV1dU98ng8t7e3t1cY++rqamb8h4qKilv19fWPZJ/gHpTuO7PZnB8XF8fQ2ahbHIMU9nSEIQHjDLCbiqh4ZGTkOUBdYRkODg62yDLkuKmp6R7WXmEismS5B2tdkKWDT9Qducig168dnqCCi11dXdWsc9mIpAfI9ABlnKPXuru7H8Ly89jn1A058vDD+gBjG4S7vgJEAAD8NpvtU1lZWUdPT89VhOcus356ejpVbpiamvqPstzc3Lu9vb3XUDUdAPAZUxvZ2dkBfL/pek9MP+/++Pj4JLbZlZWVDpmYoZcRZZyjxxISEhxs3+wnf3o1y+4VQxDwBK3Ok4mpWxWacBfwOwVs5R0QtXeBrsjIeOo54ZYgyBxDdgns5N1xEsuNx1mkv/OCSUlJu2tra5pXUCmP0QmDnEP/f4x5P1rul/T09D0AoFxEldgj6FZWh+4JJ5sV+Bym/5fZ/leeY6Gk3+9mvo7wdbDD0e0iTKmFo0jQ8oXEp7h2b1CAUgvi+g3+9Sf5QSAi5I+JOKUI6Ttf070TaUngygAAAABJRU5ErkJggg==", s8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAmySURBVHgB7VpbbBTJFa3pGc/4BQZjL6zX2GC87CY22IZdRHajXaxsyGpjZ5OV4AMhwQcPCcTjC/Fl+OADRYCCsskmcUJAkIAAwRdCCAkMCBAgBIineJrgQCRAgMTD9oync067bm95mIdtZsYGzZVKXdNVXV3n1r23Tt0epTKSkYxkJCMZyUhGBkBs2/ZEq6dTfCpNQoAQXGz+dMDit1sfKPGqNMnq1aupAOvIkSMelvr6emvatGlWa2srFcA2hd+elpYW9U6JNm2nzJgxwwuQvqqqKj/L1atXx7OwPnny5Cz08bEPnxkol0iqGEAsFC9BjhkzJhv13KNHj/40HA63srCOezmVlZUB9nlnlGCAoKv5S0pKcnEdsn///oldXV13bS2s79u3bwLa8ktLS3NwpTW8vUrQE6ffW1xNriqBFRYWDt27d2+tgL9z545TRAl79uypweNDaCViCUq7j3rLxCPg6d/4nTt8+PCCHTt2TAqFQv8R8ADqFFEC27Zv315HRVFhpjuot0UJnKy58jR7gt+9e3ddJHh2Z4mmhKKioiFoozv4DEsY3GIGPBTH7Al+69atk2KBV4mV0MMdBnVM4ORk5enHNOVYK19bW+uCl3oiJeBqDVp3kNXnPo9rgBOPB/7JkyeuAliPpQQGxuLi4nyOqa2AFja4FCCrIquPeu7GjRvL4oHXnNjuftx+TQnSh7vD2rVry/QW6lrBoNgihdfrlXH8HiWbqw8pun///gbZ6+fMmdMDfKQCTCWwrwjHwFgj0I9WkE0LY5BlGWgFeCTia7N3/L65ubm0oKBgeG5u7vvZ2dkVN27c+JMJ0BQVoYDIPnwW7WNRRg0dOrRwy5YtHwhHwD2voQiVVhHzM0w+QBM9fPhwNU328ePHv8/JyRkdCAQ+RFv15cuX/yqgjh8//u9YCjDbLl269De0kR1WoozmmBz70KFDVXyX0GYqQC+GSrkYfmcZ4HNo8qSyJr29d+/eH6CAj/x+/4SsrKxPL1y48PczZ85s8Xq938RSgM/n+5p92BfPfMJnOQbHkj58x8GDByfowOi4RNrODrZBcoThoTj0VgKeacK3bt36HiAmAsxkgPsZypfoPz2OAr5C+QL9p6JMogJu3779R2mPRpvJNbQLppY22xHcnmYYa5+fO3euC+ratWs/AEwdrQDDfM4VjqWAs2fP/hMK+Bz3PuUz169f/7O0ccxYtBn9I2lzasCj2oPbx2J4ZrTHef8vXE2CevDgwREBZPIAAUVhH62ASXxW+sbiCZwDlWAeoJLqDnYUbp+I4Ql4+jLuTeHqM6gJyOXLl79GhXlP5OLFi818BmUKx0ikBLEEnWtwj9IqCe7gbnVKc3u+qDcrH0tM8Hxu2LBhUZUQTeIpYefOnbW47yhBuEJSrECDd+gtI68Z8PoKnv0F7KpVq9z7rCuDFvdXCUKbuUVyznYSXMFjRnxmchKd6npTuOqR0t+xTCVwdzhw4EC10kFROEI8gJZKILt27XL7tre3J8WsoIDX7j19+lS9qXBuz549840cOZJz9eh7qt+iwTrmjzIkPz+/eN26dT/H4P/tjwuYkR+r495nXUXZEfriAh0dHW3r16//DPeLOVelT4/9XjBqTj/spU/Rt6gA8PvylStXTu+vEswgSFcwTX/ZsmX9As+5YE5fcW6cI9rz6ba9cYFESnAzujCrPJ7wUC8DQ/vJokWLGl+9enU/nhKOHTu2HdT3NygNJ06c+Fc0JUQDz76414DnGjlGPPCcw5IlS36NOX2M80cp2nlyzJMEinrTrdDc/4d1O28J+HklKe78+fN/9/LlywfxlHDy5MltYHfTUX519+7dEwLS3BFMq2Ef3Pua/XE42pYI/MKFC7/FXKp58szLyxtFgsa5GkEwriTsAFOysfI2XhIGMQmh3mlZVgc+ZbVv3ry5denSpYsxkf9hYgqnQcVrTU2NG+jwXBCXDpby8vKmU6dObeN99hORvmwbN25cE8CzfztABaWdY5rv4Dv57k2bNrV2dnZyPh0vXrwI4n0hHMW7KioqwioJ4rApIUIoDhGin8HcynhSI2fHKnxnWoLIuXPnNpHbo3ymr19gjF9Iu4p+GPrSfOb8+fP/MGOArDytD++uxRzGY4zRnJPkD/XhKGmpM6GUwgeYqi7AC9/DVZRQu2DBgt9KTKBoGjxVdfN6HoebCQagpsVRQD37kDZrKswD1FShw6bZ4z5Pgx/S7wW8UGGDBSbvPKB0DgBXv6S7DSVwFSYwGDEi62TGJ/oQVMcToQA4ffr05lgKMNuQROEhqo7PcywmVTi2DnjVTLZEgu8t+emvEnjxRH7w0O5QigmNQ/tHjY2NU3mOZ8HviSb4vqbErly58oMexykNDQ1TaHGoj4Wfl+BaZIJXqc4Y2z8ejHp87+NEmAPEtQyBayxXh9sScnrfCxie53ubFDXzCUyq0MK0gpkfLEW0H8lEqWSF0vlFWV4gmWAnMHIi3CI1CRnFADlr1qxasjMB1te0uATTYDB4b/bs2TXMMXKbI3BaHnmJ+DznktYssaFpxxLIFCVPwOwtV4gTbmpqqo/HGFWCDyNU4Jo1a7hzkOC8x2wzTZ6WpwOykwpLasDriwK0O7iZIq4IrYFKwD36aMWKFSt+GUsJooAE9HYMV57g0SePytbg3VVP28rHEDdFriK4guqmzR8vXry4IZoSVIxjLbc6kJxvGPAMeuvs8ap71S0DvBpwMS1CPo0xJnDlGLwYyaGEb6PRZhWD3uJ+FYpLb+X/Ainb5t5UzB1CTo8MWHoFx5MszZs377tIJUSCJ8PjOYPnDTz3AUohAx7N3vg4OmjFpc3yeRz1HrQ5UgkCnvcIXnUzvPFacUWa3gaSTW9TJvK9LhptRolKm8Xs0VbDPZ87CPoWR/5BYqCDXa/ENr4b4qejBKHNYgk0cQmMBM+6/gxGejuaeYfIXL9K0VeflGhUVmrmzJkW6KwXeTpvW1ubH0oIPH/+3A+gAfTxIzFSiqO1vWHDhjYcZ4Oot0MhHVj5DvQNQgEhxBIbKe8w/2ar3iaxe/5H0N0edVaphNbAPR71cm3y7zNo6rhhcvuUMryU+pRMnP8RBiALn7i9SFr4Hj58mAWwBGbBItglDDcJ4TjchW0vNGLEiC4cqrrYwG8GqVz9lAcVu/tf4owJHnzpteAO1s2bN73Y2jzI4ztb2qNHj5i9CWP7DGO/72ppaSFgyeik1PTTtac6fsw0FQHidxB+HgRX6oQimP4KwkJCbMN2F9Ypc+c59a6IyRblY6vSf4IUgjNYuH1KxQDniSgZyUhGMpKRdMv/ATwzHEmIDgvPAAAAAElFTkSuQmCC", i8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAMISURBVHgB7VZNaxpRFH1vZnRiovkkDSSBlhCyCV2kKS1k0SRtaHeBLJLf0KyyKl0m2RT6D/IfsnRdVGhLUYRSEBVBQUEQqdDo6Oh89dypI0GcJiOYlQcu83y+N/e8+865ytgYY4wxBCzL4n1TnA0JiXkEJb+8vKSEAsX29jZbW1szNzc3rfPzc4tzbrFR4uLiQkAyf7lcftdoND5RVCqVtyDi65IaOaTFxcVgrVb7HIlELAoaLy0tTbF/FfV0HZ4Z46S8Wq1KzWbTH4vFGEW73ZZarZbMhtCCZwKqqlIS0TCM3t5OpyNBG8KDEEilUiwYDAq3CZAwKaAN5hWuLnCsBlULe3t7vF6v82QyyXHXPojOd5sAjU3TlEBOXl9f5zMzM2YoFLKwz7zLGa4EyGrhcFgslUpv5ubmXiGBTUjTNJHuHwleOGsXFhZeZrPZj5OTkx1RFE1BECwKRVFi+/v7X3AYw42EGwFOdoPaZbz0dSKR+EBi60c0GnWGz7vRw+7uLtva2hLS6fRXJFepUIMS/U8DHKeVSOFsSNBeEihdodsa15dTh8vn81Ymk/mxvLx8dXR05HPERne+urr6DMue0trT09NfxWLxJ8pul1+SJEOWZQ174/Q9KuWZgEUiCgQC2uHhYQTdLoE52e/304vIcoF4PP7eIYCumNzZ2blCqVv4aCIMEFFBRJmentbOzs4MXOn9CSABPUg4Gp7K/Px8G91OxKlsteu6HpqYmOg462mMhL9RcgXEdTjGhHANOgDIaUju6oKBGkBiZ6hjs4rkTVxJY2Nj4wY9oAGlK6iG7iyiclNyWLSONX8wdXNwcNBAchWHoXXebejYpsveRA+w50kbsNwgWxnoDxrCTnh9fd1/GG8E3EDNCGW2xUZWI5D3KSl1QuqUXjCMxSwk1AuFwreVlRV7fy6X+z47O6uzh8Dx8bGIxxS08Ajie4zxExrTHEJkHuG5AvTPBz/HbXQ4hvumDsdgNR1W1SA4864774fnn8+uRfnJyUnPQSS4bvLR/h0bY4xR4C+vmoRqLg1k2wAAAABJRU5ErkJggg==", r8 = "data:image/png;base64,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", o8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAjCAYAAAD8BaggAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAALFSURBVHgB7ZbLihpBFIbL8TqjjqNojMFkzMTchEkMQsIQAobsQhaBIBKQ7HQjKLh0oS7cim/hwoXgwmdwKSQPYO6JD+D90jm/XS2tyThMaycE/OFQF7q7vjp16pxmbKeddtppp53+b2mYMq2+J7AtaY9dXoDRRCKRvU6nc0J9Lf+ORmZMEASlm1UEpCc7mM1mH5vN5n3qGwBWKBQApiPQW2j5WF3xnZtsNpud+sJ0Ov3UaDROaW6fzOjxeBaggUBgDsqUh8bF4rs2k10DEI2FyWTyuVKpPDoiWa1WpxzU5/OZ6HhVhdpzOp1Wam9gYWoXUOVy+YzGJ3LQarUaZKL31Dk+eMjhcBxS1ycBSVDD4fBrKpV6uQpaq9Ue0njuKTWCHe4/NJlMS0ASQL/f/y7N03H9BsVUiKk5ENnNVSAJCgJMu91eguLHt10oHtTW84AkKMBAq1DwlN/vN7ItxtSFQEzmqT9B1ev1B/TMHEr8xIZAuGUUQ2uB1kGNRqMPxWLxGFAI8k2hJA8tBXU+nxfOU6vVEihFLYECqlQqXWdi1lceT1IMyT0EmG63+zMajb7TarWLax8MBteCjsfj93R8brZhPC0BYUFc9Xg8/obmH+t0uqdy0F6v9yMWi72l8TOyM71e/4Ra3Da/xWK5glKzUSbnL1sYz9SDweBbMpl8ReN7ZCiqp3LQRCLx2mAwoNbdxiaoRezgqOCZIzLjRkWYA6GWeZCZs9nsCyRJ7JbmXIyXDoAia8MTWNxut9uYmL+sfEMHTLxpuk2z97zak9nT6fRds9l8FUWVL4DFPBQbX3K53HPqH+OvgD+vY+Jxw1b/oZQLuwmFQrgZ+y6Xy+J2u+EtA+ZQ2al/lMlk7jDxSOAVI1Pz94N/XNolwOY7RxyEw2H0AWX2er2o8PrLxodicp7MNCRh5VvSMciT5D/XX/ufVl2/AMMW8m/DjDj6AAAAAElFTkSuQmCC", a8 = "data:image/png;base64,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", c8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAANwSURBVHgB7VY9SFtRFL7vJ///PxoSLCQxhZZQKhiQbIJdpS7SrThVoYNOXdWhXToodCilBXGpg4PZSmmLgu3UwUXpJELEDBYbo0Ki+bn9TnqfvEYTk6hbPjjcm/fuPfd83znnvjDWQQcdtAHOuVTzSGJtQm52IR2qmW6vMjo6qszMzNS+uzkIpxIOkQcHB9X+/n5DPB434pkVNg57ArOIZyoFpe1h1wUcVQMQzoOwF7AJh8Phx7g0OTnJ5+bmOOavYc8pIKvVGqQgbyoAcqKEQiFi+3FlZYVPT0/TgW98Pt8vLkBLdcGswxwwCkIm5dpODfkmNi6Xy4Ofn7PZbPXAoaGh42g0eqwFEA6HufYuFovtYu192ITRaLwn1JDrKdKwCCVJYoVCQcrlcrTu5+LiYvX58PCwvVKp2PVr3W73uU+v1/t1YWHhLQJ/n06nTayddOiq2mS327sMBsMAmB8RS2JLrDX09fVxvRo4XFMjjXrxkY96ZOsqMDs7KyUSCarqrpOTk4lisTiwurr6aW1tTc+2ln0V6BZ2eHjItre3M1BKRVDURawVEHM1EAjYMH6n4qMiw/x4amqqym5nZ+ec9cbGxoV5KpWi9a9sNlsAo7nVQqTFBqfTiXR6dzXnJK1e7kYAY64oylNKH7VxywHQJpG/l+RMA9JwPtfUGBsb+28kjIyMcNRNgkiwfy3ZGqh9kFu3yWSK4efS/Pz8BZbI9aWjKMA9s9kchYJOuq5bOhz7GV0gmFINhMDkIRxltF6/KgBSCftSFovljvDR9DdHg9aCBmKAMYx8PtNLXC8AKs7e3t6MqqqPsK8bSrR3DwglJHJAtYBU3JVl+d1l9aAfKUisG4f8Ebhw0geMXee7QKno6emxoJq7cbXSFfuhVgmqDy0wYo91cWo/9L9ZpLJ9iFQodCfQlw7zB0jLHrUkGR2MZ19gP2hO7zAPU+oE+4ZoShoKAlDg1JrP512wx5C5C69k3HQc+V4vlUpH+J1ErexD/m8ej+comUyeLS8vl68dgLYOd4Mhk8lYTk9PbeVymUZqrwoOLOOjVUHVVxDYGeolHwwGC5ubm0UEzhs5bjY/lF6Gfi7hv0EeRZnDYQe4JvbB9DcOP/D7/X+gTJaYRyKR/NbWVpndAiRRVIrIr0qXjJgrOqv+CeGcsw46uAp/AfTlkTMRc7nzAAAAAElFTkSuQmCC", l8 = "data:image/png;base64,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", h8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAL3SURBVHgB7VY7SFthFL65N4+bxCRGkgghDcG4FNMq2Ap2Urq1uPkYCsXBpZPupRDH0kGXznZwsoNI6Sx06CY4xKEuGgqBLk3Sax423vv7fSF/UMGQ1yT54HDO/Z/nnP87J1GUAQYYYICHAiGE1LZO9tnbXXjzYBswNzenGoZRH/P5fGJ+fr6+bHNzU8gtSr/QuFydnp52JBIJHbbX6XSmoHch32A/hX4NWYlGo57x8XEXbC2dTqudZuQ+qBAn5AWcKMzMzPyGnTk7OxMU2MX19XWxtbVF+xPkHeTxxMSEc2lpSVN6hI2Rh0IhH+zvvDCfz4vh4WEhgaw0bawRdAZOZt1ud4xO8AylC9h4HtMYi8XcQ0NDEVVVv9ABYmdnp3np/v5+02YWCOwTDofjGZ+EZyjdgO/H6GGmwuHwT0a6sbEh2gHX2e322Ubm7iV7S8+Wl5fVo6MjJyJ/u7e3N4voFaS+OX9+fl7Xx8fHtzRRKBRYLWXLsmzgQecVwfSj1Oi5H5K+mWaJ1dXVusa6W1rauq4nRkZGuF/rOAOsdepgMEh9enBwoHSCXC73C0eY4IFJPihdgp77GAn07uHhYVsZ2N7eFni29x6PJ4p9bqVFFbTiADexxGpVAIT6vLi4eCrfncBcXU9OTjY150HAH4j8a7lcroLEV0q3XVFWAZmMmo5rmvYqmUzmZClKsC/IMbIf61aw/hGO8PbciFjDbCaBQCDocrmSGHojUy8vh1N/KLQ5h2y9RN8IsyWLfrViHoYfnRDs52NjY0W+N2Vqaorp/Yg3/0AbpC3i+wnZ36iilmjLO0YBqKOjo/rFxYWvVCoF8MZeTGm1Ws2CfUWNbwtZquLbQL8w1tbWLpFBq2cH5DrwwZ7NZnVwUjdN01WpVDhuer1eC04JpJ2emqiay0gk8j+TydTw3ZKA7fZoPreysLBgplKpCkhp+P3+PDLyF78TeVxeREUUkZ1/8XjcAGeqJycntXYO7oYgtjtaNOy7kfbvD8kADxrXPOLlPgoRGlwAAAAASUVORK5CYII=", u8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAgHSURBVHgB7VpNaFRHHJ/39mWzm++kSZU0tkEDhVqsrdBbUc9FMVClYMHYU2kvtYcW2oNKC6Un9VIqFKIHvYRihF56kEhtCz2IgghFRE2JkZCQD7P52o83/f1mZ7Yvb9c02X27ETo/+DPvzXs7b/6f8//PrBAWFhYWFhYWFhYWFhYWFhYWFhb/KziixpBSFr7pOA7vpZ6HzHepPvVM91UVnqgunAAzCqdPn1Y3d+/edQ4fPqyesd25c6dkHx5JvBMUjAgIpeoCiQJk2tGadk6dOuWidcFkDK23Z8+eOhKu46S+vr56EgQQJ7GPz/ft2+eRcB8zY+mxV1lRxZMVEcJMjFqmNicnJ535+XlneXnZWVhYcB89eiS2bNlCQYiJiYk2NEdBraDfOzs7b0xNTVHDSsvd3d3SdV05Njbmsw/C8Lu6uiQt5eTJk9JYhWLiebCMgNap8Ri12Nvbm8B1EhNvQrutvb29taWlpQPXn4Bm29raJEnkmf4O9CLoK9DPoBugL0DNoAY9Vj1IWQYtixSwjk2HYp6mTlPu6elJ4v410K+gWZFn8k4sFnuP18eOHZMzMzN0dXnmzBkjhF/YHjp0SJHu+w1EobVqQSY5vnajmBG8sYbNhGOYh/k2dHR0tKBvFJpTDJJ4jb45kLx165YMQuSZVeZtMDIyYvo/BJ0HXQZ9pAVBi4jTGp4HKzDBzqOpwp9ptgdFiFFeC83ow4cPVwlAC6dgFeF+ugqYNb+/xG/QyoKWIDYD/LBmnsGNUZza6UAA+zT/eDUME2EB7N69W1EYRgBGkFeuXFH3nuftRdtMgVMIgRi0IbiiAgT9DpNwoZEYAp0ShO/7KtrPzs6u+g18W7XQ6Kp+MK+oFAYGBgrPIEDVYvw3WltbvXQ67d68edMx+UVNYaROP6Tv0yybmpq6ksnkNjx+G/QU1lGk1bD/rwW+G3QLWg4/DQv7rLm5uZPxgHmEzjNqawHEkSNHXKz3LibpZTIZb2lp6V3QH3j0J5+fPXu2yAqepelS4LthayGw9j+BFXi5XK7Ag5QbXwrKFgA1Tzx48MBlkoNkx5ubmzuKCQ3CInoQ9QX8s5nMX7x4UVQBzAHc6elpN5vNqqRL1ApSp6PG9JHdNaL7BdAd+Osqc2UQY+CLCoGl8QO42kto27ka6LR5w0Ioqxhy8tWN+hgDH9JajsPl6HUTpAgwLzBhcf369aIxLly4oEzbBMX/ui+Bcbiag0BY6JChwms9qMQFVLUGP+QkXGiDQehp2N8pBEbxMOgWV69eXfe9AesJIh6Pj+ObFad/ZQuAVoClT4yPjzt6ySM9vn37tqgmRkdH2czj8z6LIKwGfuBxzYKgxPImuP4WOiTn4l4bHh4uivpRQgv4L35ycXHRx+ojkBRJVoqiVsug1BkXAqC6R8krsAr4KHQukflz586JaoDmr+PJyMrKCjXvI/fw0a/K5I36P1GWAEz9Dan7CII+Slwf/kiTnIUVXObab3w1SjAuUMDQ+DXc5pB0ST0XNZ8y0oDyYwCrNmqD5gfN5xCRs5hMFgL4HpMc7+/vj9QVKFC6HXAe3/gbbTaVSuXq6up8xCKzSVKzGKBsDROi+fkQQo4TgllmMLkZXH8OX00dP35cRAEyv3//fl4+Af0ARjONjY1ZlNwUuNy+fbsvag2p6wDm4ExE2vL56tb6+vodWKJ2YWIf87VgYhTE4OCgquzWc88xNPMHMTY3WV5GHcDEq4mJWGBnqPZC0EVIIRtELOiBEF6Fab6F+2/WEsJ6wEJI5Iufr9G+CeqD9rdS4HrXqexSmKhoW9wEIG5YYvMyizogjY1NN5FIxPDMhRCG0ecgq/uS70Ora47HJZQIZn+BOPIY2k9DEBmMTd/P4jtqJQjMZcOouBpkYKIAkA36mFAW+wFpBMUVTHQZ1eEyrpnOfcvUdq0k6cSJE4KBk1QqdiDZIuOkLGJOBlaWu3//PmNPYRXYLKi6gK7AnRnuB0IY7ejrBu0A7QL1g1QhUwpmqwxC+5EUfNfU/xDkANpe7jfo/Ua1B1Cp70dxMsR58ixADg0N0RxzyA8yCFIuEiQXmvKwOqzwReb2pfIDnfNPQLs/wWV4/T6SqUa+a1wA/Vmhlz62ELbP5EdssvYLCK4KuE1QS9QW3OIV+Ct3hx6Lf821FA2B9moaCj0bg9m/w+DHswXcM/iVVf6GEfnJEIGY4N67dy+OXD2OOJDAhkkCASyJ/TsVtcGMOvLiT7CZoQIZhETNqlMgMx5+q7QNK1pmTMHPlmBVtKYM+/E9v9JToUgPR81pLycF8+Sq4MCE3YaGBlU2gxEf3lCH50Z7EoIxkVwRhKTGQj8bn8EOv0nDmtJgnm7AzM8/cOBAWbl/GBWvAiGYnJwrgsRGCTWYgeZWUCwtgZEU+lPQ7Dw0GqQUgtw8KIU8grQAQagWv1kA81xNMogtHC+H+FJ27h9G5Mfj1D4nxvQU5bLqY6HEegHmzlOcNHw5Brdw0BoTlqa+N+PAJdRYtATW/EiIaPZK+yx9y839i+YrqgCzNHHHmJumPB3GabGHiXMH2UGAVM+xoSlQzhYYYWGDDRaeIKvnEJrqp5uw5CXzEGoh+RERrABVy5+NEAL7h9xBcrBz7CKBEdjLV+/xWv85gocriiFaDnebjAXx2hQ8gePxSJa/qhcQMr9RyeOzwrd4zX+FEMgd1Gu61C0C/2dApvUBi+qL8v8Ata6gnvU9w1DRX2pCzy0sLCwsLCwsIsM/PRbdF7dnNggAAAAASUVORK5CYII=", d8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAiCAYAAAA+stv/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJHSURBVHgB7VZNj9JQFH2dltKChdhAkIpjdYgjIXFM2BkTIW7FxAUbWbNiwY4V4WPFmh/AH2BBgn+CvYbEpRqjCewh5aP1HiwRm5k4UzoTk+lJXt59j9J73rn33VvGfPjw4cPHbQfHrg7Osqw/C45jWNNsMRc4YleE7YwrFAr8dDp9nMvlhE6nA1JuDuMKHDkNaJoWMk3zy3g8zmSzWZH2j26EhO1EikQiKtnWZrP5OhqNnum6LrXb7esnASeJRCJMZhIEaG2t1+tvg8HgOUiUSiX+uknwsVhMofmh9Tsb/yJBa4m5yK1LAwqoqhqRJEnfEXCSSKVS8mXDITCPQA4xPWg0Gh9ofluv1z9PJpMV2aZN0hsgxlCAzEf7CjCHEkhMWm8Tk7mrN+cDL0QOUAjOJbBPYjgcniExaY/fL16HYpeEFxLYkVgul5+63a6eTqeDUI55BP5fCjhJ9Hq9YxQrT66nHVPFeQtarZZ1EVar1cd+v695ogJe4lQAzufz+c9yufxeEIRXNF7SeBEIBHKiKD4NhUIa/pPP53HrDlPBmYQ755VK5R39fBYMBk9pnJB9gmdkWb6Pso3eQXvCwWGwZVToxccgsFgsflSr1Te094RGkoZKI4qrCqLxePwOChPtiXb4DgMIoBeQrEnDML43m83XOKmiKDGcEp2SHuMhty05v1cVPUvCbTes1Wqn4XD4XjQavXtTjWjbju1TypAXauCKuXXuKibFYnFDDpez2czIZDIG2WtqQqabzzJXcjlP6vZ78L/AL+lpU4KejmnsAAAAAElFTkSuQmCC", f8 = "data:image/png;base64,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", p8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAArCAYAAAAOnxr+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAASOSURBVHgB7ZjLSxxJHMd7nPdTHUfdjGZ1d02WXWGZ4K7Xlbh7WgTBFZa9OP4BCx72KOpxwYu3PeyCSkgEI6ghJEdByCkHwSCCgaj4iM84k+DEMXZXvt9OVWg678SeeJgfFNVVXd31qd+rqlvTilKUohSlKEUpSlHOgLi0DxQhhAuiDQwMvHy2v79fmC9zuYR2hsTV2dnpXltbu4DSjHawvr4+gNrLfiyghIth0T6nSAD/0tLSb7gWuq6v5nK5q4D+c3R0tCaZTIZw39fS0uKxAH8y9EeZvqamJri5uRkB5P3W1tYYNKp1dXVpgNPy+fydg4ODa/Pz87Pd3d0PfD6fUVFRobe1tel8vpBu4pJaO7e+vj7a09PDCQVgRVlZmWhvbxcjIyNieXlZHB8f38tms/9S+5WVlRGMCzQ1NXkL4hqcgD4ZDoerx8fH0zMzMyYgQScnJ8Xw8LAJy75UKiXgs4JjDMPIHB0d3RwbG0sSVjsFd3gnaGNjoy8Wi8U7Ojp+3N3dfUwowhB2bm5OKGEfNU5gtZDV1dW/aBEGnea0MLpRRQOBwFeZTOauMjch7bBKhoaGTGgs7H8srEy5gOakcILa2tpgKBRKImj+IUQ6nTaB3gRL7SLYBIJtnW6D1zClOQ+Kyh+NRhO9vb2/IMpNn1RCSOW3BFTCPo6dnZ39ncElLeOsME+Wl5eX+v3+BgTJBrVlh+KaGExKaHq2kXOH6OO473Hc/AyG6urqMC7PI0CuEIAgShg47KMGrebnAvb29rLT09O/8nkZVM7BKvOjVE1MTHSpqH+bEJyPMgsQFi7wMzOIo3mVL6b5GcFofntycmKmKWrV6gJ2SFWo8f39/f+YqqSvOuoCJQwKpKm6ra2tKXveZCbgDmWH5KawsbFxA9d1KBHHQYXcpSKRSCVgLk9NTf29uLh4HYeUhwQkEIHtkCsrK7dwBvgB6e0c+kK0DBetTl7aaYsyP7WK3PgFMsAFr9ebQmnGpGnA3mYwUcNWSNy/hHYd3UaeGwLMyw0NDfR5ryO7Fl/KXYYTcWIm82AweB7QF3H7Ul9fX/fOzs4T+qSETNFVOJZRn0gkolZf5qKlhk9Xsypi6WfysEGthEtLS8u5c8HE3w0ODv4B7V6lubGIL2UABqlNuE0VAV+8Sgi6ERddiABzUctSK2FOTDhosR7tpISkucPY2SrQ/7UVlG32cyF8h+O7F+fmJNLvIvF4PMaaWrSb2wpq6+MZ9vTd4DWwnICB4ZbFQ7OiTii4NxUKzxK4DtBCjp4J+bkhgXRUBjTMAzThPXIhL8vr2hjrxsJMbTp+eFXfRqyxXQp+Q8FvdfjiRVz/hCzQah2P9mWMbeb9w8ND3ePxcMNwHtQq3KH4oYcUlsO5NOt2ux8BKmMdg3YWqe0RgLNIX085nlbxaAUUmhQgOqI5v729bQBGVzuRMjfgM4REesshEJ9hrPE5f2yYKYyBxfQFDX4DN/ieNdvyh4bjefR9xaVyrTxEV6HE5Zb6SkoqqOntQrOiyuOD79nCwkIJgs1AbcANdP7fOmti/vIR7/j18xwhEWTtASnMcgAAAABJRU5ErkJggg==", E8 = "data:image/png;base64,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", g8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAApCAYAAABHomvIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAR3SURBVHgB7ZjLS1xXHMfPHZ33OD6m1mY01YJJUKFMsGRbre2qCIIVSjeOf0DBRZei7triQjelpQmohERQQQ0hWQpCVlkIRhAMRsVHxPcYfIzjnZPv93qOGYY8SOKNWcwPDudx7zn3c3+vc+4VIiMZyUhGMpKRjGTkLWKI9xQppQERnZ2dZ3M7OjqktZhhSPEZiNHU1JS1tLR0BeUG+t6ysjIPaifHAe7gS7CIixD1YPfs7OzPaEvTNBcPDg7uAPa3/v7+4nA47MN1V01NTXYK6AfDfpCJi4uLvaurqwHAPa2rqwtCg6K5uVkASsTj8Uc7Ozt3p6amJlpaWp65XK5kKBQy6+vrTc7/FO5gKC1dAmRfa2srHyQBKfPy8mRDQ4Ps6+uT8/Pz8vj4+EksFvuX2i4sLAzgPk91dbXTVhfgwvQ5v99fNDg4GB0fH7fACDgyMiJ7e3stSI5FIhEJn5S8J5lM7h4dHd0fGBgIE1J8hNnfCVhVVeUKBoMFjY2N321sbOwRhhCEnJyclFo4Rg0TVL/A4uLi77QAg0nYJYxWVDkej+eb3d3dx9qshEuH1NLT02PB4oVu4YXytKmFHcKFS0pKvD6fL4xg+IsPj0ajFsibIKlNBJFEEC3TPbAMU5N9gKjcOTk5X7S1tf2IqLV8TgvhtF8STAvHeO/ExMQvDBplCXuEeS4/Pz/X7XaXw/lXqJ10GL4Lg0QLTcw+cmYPfRjXs20zM528qKjIj+ZlOP5tPpgAWhgQHKPGUs1M8M3NzdjY2NhPnK+C5fwhtZlRvhweHm7WUfw2ITCnMqoJCVN/z4xgS17kgjQzIxLdaycnJ1a6oRZTTZ0Opws1vLW1dZMpR/miLaZ20NmRbkrX1tZG0/MeI5s7Sjock/nKyso9tEtRArYBSrWrBAKBQkD8MDo6+sfMzMwQDg/PCUYQgqbDLSwsPMAe/S3S1CWMeW1L2trM1CJy21eI6CtOpzOCcgMPjQLyIYOEGk2Fw/Xr6JcyC5SXl9OPz45paJ+vP3Jh7gpM3PRHJmGv13sZsFdx+Xp7e3vL+vr6C/qcgovQJXJzc/M5hxbQNe530dwqaMS5iI5ALqwOAdSInwDcaWDKiq6url+hzTs0K+C/5jXc46Pm9/b2/uRBggWu8Q9TD9exc682uDhNT1D6J6GgtTL0wzQrai8K4f7jHq53Hba3t7f/Vvk1W9gpNBG1qnwsUFBQEETtY96jObFNhnDgjaUGEUE5hnZIzTNso+SHFSCTqBPonkAz1nhlZaUYGhrKgq/SHQROQ2dzTlMq3sLnc2H7tExs35nsFNJK0miahGWBBi3v39/fFwia293d3YKfDITD54DAKX0MviiXl5cv5gtRqgMvTcxIn5ubu5tIJF6wTE9P/4+xa+KViS8GUAeQyp1XmXrQjxCOyZtBotKNzZHyGlFmN1HHEeHi8PDwGIHhRAoyHA5HAtEer6ioiCtXMC7m41qcarK2tjYLvpaFg4bBgvxoIjcmsaebn8VfCrVb6A97R0r7TF4CC4FGHxlDeiUAAAAASUVORK5CYII=", _8 = "data:image/png;base64,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", T8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAkCAYAAAAD3IPhAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAN2SURBVHgB7VbfS1NhGD4r93vul63lprlgFiHExPA2yboKQTAhutn2BwRedCnqZeDN7rqI0BEmmOCMqEth0FUXgl0IBulwM/EHbgWi4vb1PKfzyRpp5Y51swc+zjnfOd95n/M+z/t+R1FqqKGGGmqooYZjYVD+EkIIA6CMjIwcrR0eHhbqywwGofxjGPr7+8+vrq62YnTi2hoKhSw4GjkPkudImEM5a2hBzEtLS/dwLorFYmZ3d3cCxB4mk8lgIBCw4b6pq6urrozUHxE7lUzBYNC6trbmAJFP3d3dTmRGiUajCggo+/v773d2dl4uLCyk4/H4Z5PJVGpoaCj29PQUuV5vSQ3a1zdms9nkwMAAXypASLjdbtHb2yvGx8fF8vKyODg4+FgoFJ4yiz6fz4HnLB0dHUbdZORL6BG73e6fmpqKzc3NqSRIZmZmRoyNjamEOBeJRAQ8JPhMqVTK7+3tvZmcnAyQkHIKVX5Jpq2tzeR0Or19fX03Nzc3vzIwA5LQ/Py8kOAcM0dSkmwmk3nEzNLoih5g1eBQb7FYruTz+Q9SGhKpJCSRSCRUYhsbG89dLpdHyqVUC76kqanJarPZAjDqEwaKxWJq0OMIMUswuIDBs5QYr2E70IcMDub6+voLg4ODd1A9qkckSET6iCQkOMdn0+n0fRpay3D1YB/xeDwus9kchjFz/OrKwORNA0tQJl6jJyXoOdyv00UqGtDv99tx2gxTvmAQBpOgWTnHTJRLRZJbW1uF2dnZu1yvGbk6QlIqjIvT09NRWU0ngeS4lNVFQpDrFiuz6r7DxZQKX+rG5bXDw0O1xJmdcrkqicjBzG1vbz9jmWveqVquczQiSrxlfX09VdlXWGHsxJVE2BhzudxrnLdgOHQhI7Ru7HA4fAh4O5VKPV5cXHyFjfMLSTAoSVUSWVlZeYs96wZaQyPmrLo0QCkVs4PecQmV1Wo0GiMYnQgQA6F3NDAzVU4E99tx3eL1ep30DM712av4Veym1J6dlQ3NarU2g9hV3G4fGhqKo+t+o0c0IhHKSq+RiC7VJCErgbprGyArzE5i7NCQ4/ro6OgDZGmC0oDoZc30Jt32pxNgYBDKR1L0EwkgGyFcByiNRvjMiRwB2VI31HA4zMAOjYSN2ZO/ppVrzvQ/Vfz4ef/ptxNzpf/x435ESB5/VzHfAUyDqbXE82JSAAAAAElFTkSuQmCC", A8 = "data:image/png;base64,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", m8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAApCAYAAABHomvIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAARjSURBVHgB7VjLS1RRHD53dN7j+JjMGi0NrFAhJoy2adYqBMGEaOP4BwQuWoq6q3DjoigqUIsSVFAjaikIrVoIJgiGqfhIfI+BOo4zp++73WPD0IPMqy7mg8N53HPO/e7v8Z0zI0QSSSSRRBJJJJHEH6CJf4SUUgNEc3Pz7tqmpiapb6ZpUhwBaDU1NSnT09NnUS6j7ywoKHCgtnIcxC38CBZxGDBebB8bG7uBtoxGo1MbGxuvQPZ2R0dHrt/vd+G5raysLDWO6J7J7snFubm5zrm5OQ/Ifa6oqPDCgqK2tlaAlAiHwx9WV1dfDw8PD9bV1X2x2Wwxn88XraysjHL9QYSDZljpJEi219fX80USJGVGRoasqqqS7e3tcmJiQm5vb38KhUKPae3s7GwP5jlKS0utpoYAN2bMud3unK6uruDAwIBOjAR7e3tlW1ubTpJjgUBAIiYl58RisbWtra23nZ2dfpIU/+H2vxIsKSmxeb3erOrq6kuLi4vrJEMSJDk0NCQVOEYLk6j6gKmpqTv0AJNJmAVmK6o0h8NxZm1t7aNyK8klklRobW3VyeKDnuODMpSrhRngxnl5eU6Xy+VHMtzny4PBoE7kdyRpTSSRRBLNMDywDaXJPIKo7GlpaccaGhquIWv1mFMgORWXJKbAMc4dHBy8yaQxPGEOqHOZmZnpdru9EME/S+skkuG3MEkU6GL2oZmtjGE8TzXNzQzynJwcN5qnEPgv+WISUGBCcIwWi3cziS8tLYX6+/uvc72RLPtPUrkZ5XhPT0+tyuI/gYS5lFlNknD1FSqCKbrIDelmZiS653d2dnS5oRXjXZ1IThVaeHl5+Rklx4hFU1xtYbBDbvLn5+f7EnWPmc0TJZEcxXx2dvYN2vkoHtMISuNU8Xg82SBxta+v7+7o6Gg3Lg9fSYxESDSR3OTk5Duc0RcgUycx5jRNtJWbaUVo2wlk9Fmr1RpAuYyXBkHyPZOEFo0nh+cX0c+nChQWFjKOd69paO9vPHJjngoUbsYjRdjpdJ4C2XN4fLGxsbFuYWHhG2POIBdgSKSnp2dyDT2gasy30d1G0oh9gcpAbmxcAmgRNwnwpIEri1paWm7Bmq/oVpA/zWeY46Ll19fX7/EiwYLQeETp4T5mntUaN6frSZTxSVKwWgH6froVtROF5J7wDFenDtsrKysPDH1NFWaCLqJVjRjzZGVleVG7qHt0J45JHy68IRJjQrGQKMcwz2es00xjyR9WIBlDHUF3B5bRx4uLi0V3d3cKYpXhIHAb2l3zQ1LxFS6XDcenedexeKiMVLFqxBZdfGJ8fPyhkiJaj22c0y/4TJh52/kbYbqZLmamg+TrSCTyjWVkZOQpxs6Lny4+eCjtRNNtaOc5Sg/6AZKjeDNJDLkxOVN+Af6aA6Kow8hwsbm5uY3EsEKCNIvFEkG2h4uKisKwstSni0MCLVleXp4yMzOTgouGxgJ9jEIbYzjTo0fiXwrjtFA/7C1x7V18B1UTQJWXHh7YAAAAAElFTkSuQmCC", O8 = "data:image/png;base64,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", I8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAMTSURBVHgB7VVLSxtRFL4zyeSdNMaobQipizQtxtKI2y60YFeFWmiwSxddtEJL/Ae6aZfZ1irooqUF3Qh2lYVuXYigiAsf4INCkeAzRk0m0++LEwlpogldlebAYWbO/e53zj2PO0LUpS51qcu/IJqmSbVga8HLN5HhIRUTVyLX7fLw8LBE0blrCqYsaVdXl7G1tdVyfHz8MhgMmvldSsz3oaEhOlSIPTg4iOLd0tnZqej22oMoOPd6vc50Ov1lf39fOzk5+YAlO+2lAdDW0tJiPzo6+ohv7fT09KvH43GFw2GTHkDVQeTBjJ7O4fTbxMSEFolEyKstLi4+x7qD2SA5n9SmpibH/Pz8C2KI5Z7Dw8PvDQ0Nt4BnEHK5chjLRYDTGJaWlqxbW1ufp6am+mKxmJidnRXn5+c/caone3t7jxVFUYmVZVnL5XJSJpMxpFIpMzHj4+O+7u5uLvdtb29rgUDgjc/nS+M7c2MA0WhUnpycNOPkI3Te398vent7xfT0NNUHyHtRheAQgnshrxCEQJZeI6gcvrPFuNIpkDY3N2WkzYiTKEiZ+Fshx8XFhQI1InN/lKG0Jqy9cWFhwW42m70bGxvxRCLxbHBwMF+CUCj0a3l5OYH0Z5l6TBtLzqnTVFWVUQZje3v707W1tWaWIB6Pi56enhm/3x9zu91JTEcK+CzxFaNFCQzsZqvV6oejR+iDH6jpVROOjo6+hT1iMpnC0DYqtoZh6xgbGxsoNCH37OzszGD9oc1muwOMjdyiCpHY1Xr33oV2kIjEKysrI8hMCIQ+p9PpdblcHqw3Qr204flgdXX1E0eWexgobAGoi1MlqhzF/C2mz68bmSBBG0rxDs7vORyOZmYINpNOquhYO9eACc7NzQ3geR82v36Qqp1fCW8wEvMyIbHdbr+NUzdinPKpLL2IxOVE2aAe4pkhvDv1IOXrTnudyCAwJJNJQzablSwWS259fV2FQ/XyuhfFzcTb0LC7u2s4OzuTiUXzqWhetWLTVSGFO19mRgo/pwo/GKno5yXV+lesS13q8v/Kbx4phRKwTn8GAAAAAElFTkSuQmCC", S8 = "data:image/png;base64,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", y8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAQlSURBVHgB7VZNS1xXGD4zc2fGGZ0PP1KKmVCbTlro0EZqaGt0oavQCtWNuCgUQYqr5i+oK7sRXWhjsMUPGChR3A1ZxY+9QY0YDCpqFF2I3x+jjjMnz3O9R+4iCc7NZBHwhcs995xz3/d5n/Oe5xwhru3aPmWTUtr4iA8wu0jTVNDm5ma7DdbS0qK3MWQJzJV/UM4rKysda2trjoWFBT1oYWGhcLlcKU3TZCgUSo6NjaUkJ9tsUmTCjMC2iooKDcG8y8vLvxwdHf1zfn7+WhqWSCReHB8fR0dGRiKYm1VbW+vA244h8UGm6A6Hw+6enp7Q/v5+987OjgTlsqioiN71p7i4WNbX18ulpSW5t7f3qL+//yb6nVwayyDUOtNRV1fXLWbZ19enB25qapKjo6OKADk5OakDCAaDsqOjQ56dnc20tbXdwr8uw4cl02kvKCjw7e7uPqZjBmeWm5ubk52dnQ9LS0sfYF5Zd3f3X+h/yjHOIdDt7e3H/Jc+RBq1dmlEjqLyDAwM3KNjZsf31NTUf06n8x4K71u32x3G1Dtso6+EYwoEl2p6evo3+hAWdpsgcgQNwtET0ssHBRhDoLsYLsrJybkRNMzn8xVkZWV9gf67yPw5a4TP1tZWT25ubgD9abOgFx6DxOPxlywyrjPY+JPB6ZTjBr0a23gHCIJzWB9kAXWzSh+RSMSVrkZwssfr9RbKizLWi41UM1t8u40Kt5l3Csdqamp+NP9DH2h70y1GTvZ6PJ6Q2VldXd0PpNzI/NKM7Bx5eXl+sPClNBkBUD/excA7UVHh6Pv09HQddAoonGhoaPgGO8LMkl1lxjVHsMTJyckRVPBrPBGACdvt9sT6+npKvCfTt5nEj5TTFLbcMxSgGB8fF2VlZQ+xpk4Uo1ZSUqItLi5+NTg4qGGeBoD2QCCQxNaLY85udnb2Ngp2HyzGMTeJOeLKptYUzRvDw8N/cEspDdjY2Gjz+/15pBvK2JpMJldisdh3xnZzG/95SLvR5xQXspxeERp6zjW9jcDR3t7eSxDcmsi4dnV1tYPfNCzN3wRlAHCazgNrx7USItD5WXV19U8HBwev2tvbdUGiJnBb0tS5QCCKDYIwAFgLbrpo6FLM3VBVVXV/fn7+fwYiAGqDMA4j9ShQMzMz97HuTsvZm1mgiKAZIAjoQKSxsbF6ZWUlBsoXFANKqA4PD+ei0eivmB/MCACYzQTCh8r+nDWB9veo8J8nJib6VNbQ/X/ZD6A3yVqmAOimloM1QRkmEBxEd+bm5h4x69bW1t8xHiFLFCrUhH4pyRgABYJsUAUJhLI7NDT0wDgRbxMU3j6ype6I4iOZLrvMEm8/NcE48bzi4tRLS/MdwoLxeMDVK4WtmczPzz8DgER5efn57OxsCrfkzFxGrwDCZj4RxbVZtDdwnJDZRD9PwAAAAABJRU5ErkJggg==", C8 = "data:image/png;base64,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", N8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAMwSURBVHgB7VXPSxRhGJ6Zndnf2SrK1rrUQhtBVu5ml2566yjUktBFKIiEwL/AH5fsLBZ5EBUyBb1IdfKgF72JJxEU1HW3lkVERdFdd2em55lmZBE33W7RvPDxfvPO+z3v870/ZgTBFltsseVfEF3XxUp8K/GXLgKDEkuBy4Gbdqm3t1ekmNgVkTkXtLm5WY5EIu6Dg4Nn0WjUxWeC9/T0MICDK5FIGAt7hb57e3sJ7N1NTU2K6Vc5CSt4bW3tlePj48+7u7v64eHhO7zyh8NhTygU8q6srDxOpVJPgsGgj7a6ujo/gr/HWf3o6GispqamqqGhwWkSuDQJw5nsGRxBx0dGRvRYLEZcfX5+/unQ0NAjVVWTGxsbOolxT9vc3FyCPvTlmf39/Ynq6uqrwCMJ6bLlMG5O9kj7BIECgYC+tLSk53K5H2trax/y+XwaqTXsTBb3hUIhtbq6+hHZ+klfvuNZYIyTBDNxHgH5rAG1lCYnJ124+eDU1NTz9vZ2obW1VZienuYKwaWDfggqIAPGmXg8LiD1YQR9Y+HgEgLPQtq2trYE9M+rlpYWDc/F0nhnp0BcX1+XwFjGLRUwFs4TBBMQrOxzqRDj5OREwZK3t7cvLINRe+iAy+WKptPpr8PDw6clQFay6IEv1N3d3Ub6+Y572hYWFsaorRLwLDHgdyvwm6HyRwJky3FiV3s8nrCiKI3JZPI7gawm7O/v70Rq29DlGTYgG5H7rq6ulwMDA51WE/IMJuSb0+m87/V6rwPeZ47qhSJy3s3uvYkVJxCBl5eXBwH4gKAgFx8dHX3d19f3Aj4PYbsH3YjR/ERiPAOfGGw3sKrMzF5uCrAkc34DyAQB7s7MzLxFWW7jud7n812Drd7tdkegI7RBB6lZOoxjB/Qd2MLmRcoGL8uIXzBMg5zJZNxoIDcSIEEKCJoHuKppmojRk9BYIkqmZbNZdjhT7PL7/Q58jTWMYB43zy0uLqqwaxURMEUCgGNnZ8dRLBZFWZb1zc3NIshpWCJqeuoIsjpGT8J7mb4gquHrqM7Ozqogowt/KdbPxPj2Wz+nMp0slvy8xEr/irbYYsv/K78ADLbk2M0TFOAAAAAASUVORK5CYII=", x8 = "data:image/png;base64,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", v8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAgCAYAAACcuBHKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAANESURBVHgB7VY/SFtBHL73Yp75R00Qk5RmkFaXmhZBFzc72KF0cFFwcy1C1LWLunV1dXEoUsQWXIJDEIV2EUQkRUpLqG0sgkMwSaPGJO9dvy++J6FFyUucSj447t7d737vu9+/OyHuDoqUstrm5+dV65u9Ob5xY5toAuZPhKIoYnh42BGNRtWDgwMSUK+mFaO7u1t2dnbq4+PjBubYpLhLmCT4Q62rq8t3cnLyqlQqfTQMI4s1yZ7fnIeMl3KWlUSzsMxOAjipKx6PPymXy8mtrS05Ojoq/X4/T1vt+c15Xdd/Uo7yJvHmiNC/5olcGxsbTyuVSnpmZqb645sa1ylHeRIZGxtzWO5sFOrAwICzo6MjUA+BWiJwz2dYyN/X16c1RYKnCIVC3sPDwxhNXQ8Bq1Ge+zD2Ug/12c4Osh8cHFQvLi7ag8HgxOzs7PVaf3+/QAz8s2d9fV3s7+9Xx4uLi2JlZWUCVny7trZWwpSuigaQyWQc+Xxec7lcj7e3t+1sFZTnvlwup/X09DQcoCpd4Xa7I/KqAtluBPY/wNhDfY24Q6IIUYmKOpBHjN3LZrPVtb/dUesGC5AXSNffcOe1FWy7Y2FhwTKfUSgUvqJSCjug/Pn5+Rccwqqg9kFDMM89Hs/9ZDL5Bqe1nR07OzuvMQ4hJtrRK7bdQVdQmc/n02HS/Onpad17p6enxdDQ0DEy4wNaKZVKGfK2m+0m0BI8AUgEQSAxOTlZlwVAQIL0cSwWe8GgxpzXrLr2QRKRSMTt9XrDl5eXv+BjSSLLy8vytrsDKf1tamrqJdLzISsm1q8rpm13MDCRFcrq6mpU07QHiUSicHR09CmdTn9H7p8tLS09DwQCj9ra2nwo6QVkTmpvby+O6/y9w+HIO53OHDgUR0ZGdNO1jb0nVFWVm5ubP3Z3d5/BpBkoVi2FON073KjUq2Ce0V+GfBGkCnDHWTgcLsJypbm5OaZ6VZ/takUT9vb2aqiaLvysHVap1n8+YEiE35DhHEu7gSzSQaYIK5VwaZVxX1RMAvYDspYELx7egowNcVX13Ga6uZi+rKh85LDnGpqz5jHT/IOGSiyFZq+ytx461hvTWjPnRAsttNBCC/8N/gDQTw4VRAv8rQAAAABJRU5ErkJggg==", R8 = "data:image/png;base64,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", w8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAuCAYAAABAm7v+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAARNSURBVHgB7VhNSJRBGJ51f9x1f3RF8YdNV9PKzFwSAsODEkRBRB0kAg8ekggPetGT+HOIvQQmdEpwDyKEB8OgQxf/Ar0oQil1EbeIdlHBdkFFV3d6n3VGvzal3P1WCfaFYWa+Wb/3med95n3nk7GkJS1pSUta0v5v07CTm4ZzfjjRaBjm1HOmgqWwE5pwrqmrq9OurKwUV1VV6Xp6egAyls2pYhoCoc/Pz08Lh8PemZmZsvLycgM9TzkTUMKp0WazZdKY7+3tfR0dHb3qdDqN3d3dpw8KTnNycsw0zAMgmvPd3d1vw8PDLoCqr6/XnjYobVZWlpX6Qr6v7t9A0dzIYtBmzAaGMjMzbUaj0SkBRYNyOBymWMOnYyoZAUB3rqOj4y3199rb278sLi6GaBwWoBNj0AgYomGRkiEWxRSETvOI0Fls+e7fDA6gIQrZkYCUoEZGRiohdHqmVSZTtU2K+lhAEtTOzs4nt9vtLCkpSQWzLEGm/RtD0aD6+voKkDwTkg6EJqzRp6yrq4sfZ6FQ6OPg4GBeQljCS6MZApjNzU1fQ0PDI51OV0OtWq/XX6fmSk1NLTWbzbnZ2dkWAUhdlhSijjAkwTQ1NT2g5QoCUII1GheaTKZzaWlpeXa7PV2KW3VAYpdWclYAQFtbWz+am5vv0rNSarnUMrAO0GAFRViA0Ylwq2sAhFqGnW9vb3/v7Oy8ifBZrdYsOMdNgO0zIVskDwlBa+RYNhaviV1Gqn1LS8tF6CM9Pd2uLKzSOX4rfp+CNbTa2lodGhOMxQ0KLxAsmBASsCXzjAQDh+KOZML61NTU5f7+fgfNbV6v987GxsYzutw9lJsQwFhMBod4gdCSHs7lTgUbAGteW1t7SjnoA13ifi4vL3NxdwpgjPyEPhgMulGIBWOxM6XUgIJygDGMjY2VA8j4+DgnRzwjI4MTE5H0gB5zjNEDIEKPv+MqJ028zEAgrqCGgQE47+3t5evr65xC5AdD8/Pz3OVyHYCDQYPiFKpzAqVmcAMIBAKvJRgAmZub81RXV9+mn92gVoO5DBnALS0tvQQgdngriNvATAqO+9DQUBWcIRTop6enX9DaNYPBcImS5XlqF2hcMTAw8GRhYeEVlZLHSKIImTgAqoQsohtUdGLnvcfj4Y2NjZxO0jsqG5VInnCITI2e2MihnFUIgOhl7lKlximOvw0VHSJGqNBPTk520fMiAMHuFbnHiFRBLCKb2+QJUy1BQoyzs7P3AYIprhx+v/8NjXOVd2tFWtDKxKjqF4qg2TIxMVGvBNTa2sp9Pp/HYrFk0/xYbchEqCog0E/DQqr2n6EfHPPV1dUgMVFLz+0ipKdjoB8hgVDp9JRBNxS+521tbbdIzA4BNmHX1j9M5h/hOBcVn/piugXkQ8yobyyRXxtHAWL7x14PpnD/EZ9HkWIb6+dP3DuQGZbEHemJMU5HHTfJMP53dBZ24FWNk/ML4OG1G0C2Rt4AAAAASUVORK5CYII=", D8 = "data:image/png;base64,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", L8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACUAAAAvCAYAAABkBQNlAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAT7SURBVHgB7VhfSGRVHL7jnXFmnMZ/KbO6M+u0aLVY27hGEG2oRYi1BCVCL4YQvmSg+GAv4j8WhEL8AyY+iA9ihIJgD4Eg6EPki6EUYuiDGZWgqIOC/8bx9n3Xc+o27LLu3Dv4sPODyzn33HvP+c73+87vd85VlKQlLWlJS1rSni2zKU9vNk3T/rux2RTeo9QUiyxFeUoTAGwVFRXq9vb27dLSUntnZyeBxjNBy8wGII78/Py0i4uL3xcWFu4UFxenoj3l2oCJgV3p6enZqGvRaHRzenr6bjAYdHV0dFwPMA7s8/k8qOYRFO618/PzPyYmJkIEVlNTo14HMDUnJ8eLskC7VPz/gOHepcShVVNGprKzs9NdLldQgooF5vf73WZcaVcsMoBgEWhtbf0e5YctLS2/raysRFC/UC6BJ86oGTKF6gtGppQYxqampl7DvS5+Jb54eHXjINQU3PdIUEZgclWiTTUG3ESYFPpjQUlgZ2dnv3Z3dwcLCwudZFhJoKlPYioWWH9//y0G2ISFCqERb+zqa29v1x5nkUjkl7GxsbyEscWOY5kioKOjo63a2tpP7Hb7fVxvOhyON3CFnE5nkcfjuZGbm/ucAKWzJVizhrlYoUtA9fX1H+HxqwBRSBZRL3C73YG0tLS8rKysDCF4uwCmyjhmiUtFp14MeIugjo+P/25oaHiAtiJcN3Bl8jmBkx0mbgZTtDkJbGRkJB/fPJydnfWhzaFYkcgJirmPDJyenv7Z1tb2Llnzer05BMAdBF5T+V55eTmDs4OrjyC3trY+ZwJfWlrSDg8Phwgaz+2mQQmh67uExsbGl6iXjIyMLGMyFoOkcMWRpbW1tQ9OTk5+nJub0wBUy8zM1Pb39zWI/55g0Rxb/Fiw4eZMyRoHl4AImgwRZE9PTwB6+5YAmpqa9EUxOjqq13nh2U+cEPszDYoDC205CID3EgzanAMDA/6Dg4Pu3d3dMGMVAOoLgiXZIkiytbGxoWGT+DEnZlyZcQOT4GSJZu4+Paurqw+oGw5OEBy8r69Pj1dsC4VCer23t1d3JdMRvsuRwdUMYzLGpAhXpi0uLt6nbihiDiZZ4SU1RKPbWOd7nB+fg9Gv2IdiZh/G2Qi6nYODgwGuJKkbApCukkA4sDTje2QLTB1sbm62c3XS/XEzJdzlDIfDX+LwEKZ7OIicudwmU9RGk+9h1erg1tfXv6uqqnoLMe8mvmV4iHs3YZOxamdn52uCIBi6Q+ok1qSW+Izv4bulrq6uT1NTU+8ixhUAKAOuUzHjPkP+C0JHf3EwKWYOzoFpXF1GfTEdDQ0NfYGceA/dFDEAc8PI4CpYin/1yRMNaR8fH/+Mg0sxy8sYCnBoPVxeXh55B4bP7+A7P8osZgCpI82CHGgTs3seLnh5b2/vZxkQqSMCrKur08EB8A9lZWXv4d1XyCzTEeoerlpDUlassH91hfrN5ubm92VApLvoKupmeHi4Ac9DAHMbpU/sWOUu1Pqjvkw3FCm3K2BknFqibmZmZh5CN6V47UVc+crlzsEtIn7iDxEiofqqq6tfR+L9prKy8m24lLoJoD1b6kYRK+sq7JhFze9VJGYX9khupBcnSg26OYXLTpBsIyUlJec4oEYV/a/R1X4XmaaSbM3Pz6eApVSAsqmqqmGpRwlmcnIyroOoFf7V+4B4uX/SDGDloSK+Di0wYz+m1/c/7W6jSV2/UuYAAAAASUVORK5CYII=", M8 = "data:image/png;base64,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", P8 = "data:image/png;base64,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", b8 = "data:image/png;base64,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", U8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAiCAYAAAA+stv/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAKPSURBVHgB7VZPi1JRFL9PX+NT5ymJYppT1kAiSgV+gJRWoSYN6MqtizBGQnAp+gGaRUtBcNFGF4IVFX0B94GQrSqqEd01pr5R3+sce06NjDHeN38W835wuPfdd333d37n3HMkRIUKFSpUXHQwZHUwkiT9fWAYgs8wSoQCGrIi5MOYUCik7Xa7NwOBAFssFpEUjTNUYODQS06n0yCK4udms+n1+XxrsK45ExLyIZzJZLLAXJpOp18ajcZtt9vNFQqF0yeBh9jtdiNMHUhg501fmkwmX2u12l0kEY/HtadNQmu1WnkYryMB13bnEAlY5whFbh0bqIDFYjFxHOeeE1gk4XK59McNB0tOCDvv+jhsbG9tvYTxYS6X+9hqtcYwF8GkEyMAH515NRqNmP+R0Ol0kVgs9gmU2Acjy0isHCu4cpJGo5EgBEe+RxLP3482wuHw63q97qlUKvMreuT+lRUAbxhIQlRg6Z65Ek8ikRftdjtaLpd3E4kErk0VE5hjmQKHSaz7s9nsK4PBEC6VSh1QQaQt2QfA7IaBX7wFz97uScswHo8/gApOrBGL36NKQgxBv98/SMKnD4zk8T1tJ5lMZqvV6nfyR2r0VgD7xbLsT1Bhz+/342/Q6FVABbAQgQI30Dv0fDAY7KZSqUfw+g5kvwdsE+abuEev11/Fso29Ax1WXCVlGXn48DUkMBwOf6TT6Qis3QJzgFnAzFiskKjNZlvHwgRra3L4lAEJYC8ASR2CIHzL5/P30VOe563oJXZK2KYNBoMsGs7/qYrKe4TsxawbZjIZj9FovGI2my+fVSOatWPZSz3Ki2rg/wHaw6liEo1Gp3Dgfq/XE7xerwDzCTQhqjtOJdeip4qLy3niN23hSfilugeDAAAAAElFTkSuQmCC", G8 = "data:image/png;base64,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", th = {
  add: {
    "1x": QH,
    "2x": ZH
  },
  arrowMove: {
    "1x": qH,
    "2x": jH
  },
  convertPath: {
    "1x": JH,
    "2x": $H
  },
  crossMove: {
    "1x": e8,
    "2x": t8
  },
  crossScale: {
    "1x": n8,
    "2x": s8
  },
  crosshair: {
    "1x": i8,
    "2x": r8
  },
  default: {
    "1x": d8,
    "2x": f8
  },
  duplicate: {
    "1x": o8,
    "2x": a8
  },
  grab: {
    "1x": c8,
    "2x": l8
  },
  grabbing: {
    "1x": h8,
    "2x": u8
  },
  penAdd: {
    "1x": p8,
    "2x": E8
  },
  penClose: {
    "1x": g8,
    "2x": _8
  },
  penDefault: {
    "1x": T8,
    "2x": A8
  },
  penOpen: {
    "1x": m8,
    "2x": O8
  },
  resize: {
    "1x": I8,
    "2x": S8
  },
  rotate: {
    "1x": y8,
    "2x": C8
  },
  scale: {
    "1x": N8,
    "2x": x8
  },
  comment: {
    "1x": v8,
    "2x": R8
  },
  arrowCurve: {
    "1x": w8,
    "2x": D8
  },
  ruler: {
    "1x": L8,
    "2x": M8
  },
  rulerDelete: {
    "1x": P8,
    "2x": b8
  },
  selectorEdit: {
    "1x": U8,
    "2x": G8
  }
}, h1 = /* @__PURE__ */ new Set([
  "duplicate"
]), Bo = "cursor-";
function CN(e, n, s) {
  return `.${e} { cursor: image-set(url(${n})1x, url(${s})2x) 15 15, auto; }`;
}
function u1(e, n) {
  return new Promise((s, i) => {
    const r = new Image();
    r.src = e, r.onload = () => {
      const o = document.createElement("canvas");
      o.width = r.width, o.height = r.height;
      const a = o.getContext("2d");
      if (a) {
        a.translate(o.width / 2, o.height / 2), a.rotate(n), a.drawImage(r, -r.width / 2, -r.height / 2);
        const c = o.toDataURL();
        s(c);
      } else
        i("Failed to get canvas context");
    }, r.onerror = () => i("Failed to load cursor image");
  });
}
document.addEventListener("DOMContentLoaded", () => {
  const e = document.createElement("style"), n = Object.keys(th).map((s) => CN(`${Bo}${s}`, th[s]["1x"], th[s]["2x"])).join(" ");
  e.innerHTML = n, document.body.appendChild(e);
});
const d1 = new RegExp(`${Bo}(\\w+)`, "g");
class F8 {
  constructor() {
    this.currentClass = "", this.currentState = null, this.currentRotation = 0, this.secondState = null, this.nextRotateId = 0, this.existingRotatedCursors = /* @__PURE__ */ new Map(), H.get(H.Events.MOUSE_LEAVE).on("trigger", () => {
      this.updateCursorState(this.currentState);
    });
  }
  updateCanvasContainerClass(n, s, i) {
    n.classList.forEach((a) => {
      a.startsWith(Bo) && n.classList.remove(a);
    }), h1.forEach((a) => {
      n.classList.remove(`${Bo}${a}`);
    });
    const r = s.match(d1);
    let o = !0;
    i && (o = i.match(d1)), !(!r || !o) && (n.classList.add(s), i && n.classList.add(i));
  }
  /**
   * Sets the cursor state based on the given type and rotation.
   * @param {CursorState | null} state - The type of cursor state to set.
   * @param {number} [rotation=0] - The rotation value for the cursor state.
   */
  async updateCursorState(n, s = 0) {
    const i = document.getElementById("canvas-container");
    if (!i) return;
    const r = h1.has(n);
    if (!(!this.secondState && this.currentState === n && this.currentRotation === s) && (r ? this.secondState = n : (this.currentState = n, this.currentRotation = s, this.secondState = null), n !== null))
      if (r) {
        const o = `${Bo}${this.currentState}`, a = `${Bo}${n}`;
        this.updateCanvasContainerClass(i, o, a);
      } else n === "resize" || n === "scale" ? await this.setRotatedCursor(i, n, s) : (this.currentClass = `${Bo}${n}`, this.updateCanvasContainerClass(i, this.currentClass));
  }
  async setRotatedCursor(n, s, i) {
    try {
      const r = `${s}-${i}`;
      if (this.currentClass = this.existingRotatedCursors.get(r), !this.currentClass) {
        const [o, a] = await Promise.all([
          u1(th[s]["1x"], i),
          u1(th[s]["2x"], i)
        ]);
        this.currentClass = `${Bo}${s}-${this.nextRotateId++}`, this.secondState = null;
        const c = document.createElement("style");
        c.innerHTML = CN(this.currentClass, o, a), document.body.appendChild(c), this.existingRotatedCursors.set(r, this.currentClass);
      }
      this.updateCanvasContainerClass(n, this.currentClass);
    } catch (r) {
      console.error("Failed to create rotated cursor:", r);
    }
  }
}
function k8(e) {
  return e && e.getFeature("editSelector") ? "selectorEdit" : "default";
}
const B8 = (e, n = null) => {
  const s = new F8();
  return {
    setState: (i, r = 0) => {
      let o = i;
      i === "default" && (o = k8(n)), s.updateCursorState(o, r);
    },
    getCurrentState: () => ({
      firstState: s.currentState,
      secondState: s.secondState
    })
  };
};
class V8 {
  /**
   * @param {VisualServer} visualServer
   */
  constructor(n) {
    this.visualServer = n, this.dataStore = n.dataStore, this.viewport = n.viewport, this._zoom = !1, this._fullyInside = !1, this._remove = !1, this.insideContainer = !1, this._startPos = new N(), this._endPos = new N(), this._area = new ye(), this.start = this.start.bind(this), this.update = this.update.bind(this), this.end = this.end.bind(this), this.selectNodesInSelectionArea = this.selectNodesInSelectionArea.bind(this), this.updateSelectionWithViewportChange = this._updateSelectionWithViewportChange.bind(this);
  }
  /**
   * Viewport change handler
   * @private
   */
  _updateSelectionWithViewportChange() {
    const n = this._updateSelectionArea();
    this.dataStore.get("editMode") === Dn.ELEMENT ? this.selectNodesInSelectionArea(n) : this.dataStore.get("editMode") === Dn.SHAPE && this.selectVerticesInSelectionArea(n);
  }
  /**
   * Recursively search children and add found children to selection
   * @param {Set<Element>} elements
   */
  selectNodesInSelectionArea(n) {
    this.dataStore.selection.addElements([...n], On), this._removeElementsOutOfSelectionArea(n);
  }
  /**
   * Select vertices in selection area
   * @param {Set} vertices
   */
  selectVerticesInSelectionArea(n) {
    this._remove ? this.dataStore.selection.selectVertices([...n], On) : this.dataStore.selection.addVertices([...n], On);
  }
  /**
   * Start area selection
   * @param {ISEvent} e
   */
  start(n) {
    this._zoom = !1, this._startPos.copy(this.viewport.toWorld(n.mousePos)), this._endPos.copy(n.mousePos), this.viewport.on("update", this.updateSelectionWithViewportChange);
  }
  /**
   * Update area selection
   * @param {ISEvent} e
   * @param {object} keys
   * @param {bool} keys.shift
   * @param {bool} keys.alt
   * @param {bool} [zoom=false]
   * @param {bool} [hideArea=false]
   * @returns {Set<Element>}
   */
  update(n, s, i = !1, r = !1) {
    return this._updateConfigsWithModifiers(s, i), this._endPos.copy(n.mousePos), this._updateSelectionArea(r);
  }
  /**
   * Stop area selection
   * @param {bool} [commit=true]
   */
  end(n = !0) {
    this.viewport.off("update", this.updateSelectionWithViewportChange), hV(), this._zoom ? this._area.has_no_area() || this.viewport.focus(this._area) : n && this.dataStore.get("undo").commit();
  }
  /**
   * Update configs with modifiers
   * @private
   * @param {object} keys
   * @param {bool} [keys.shift=false]
   * @param {bool} [keys.alt=false]
   * @param {bool} zoom
   */
  _updateConfigsWithModifiers({ shift: n = !1, alt: s = !1 } = { sfift: !1, alt: !1 }, i) {
    this._zoom = i, n && s ? (this._fullyInside = !0, this._remove = !1) : !n && s ? (this._fullyInside = !0, this._remove = !0) : n && !s ? (this._fullyInside = !1, this._remove = !0) : (this._fullyInside = !1, this._remove = !0);
  }
  /**
   * Update hittest elements in selection area
   * @private
   * @param {bool} hideArea
   * @returns {Set<Element>}
   */
  _updateSelectionArea(n) {
    this._area.set(this._startPos.x, this._startPos.y, 0, 0), this._area.expand_to(this.viewport.toWorld(this._endPos)), lV(n ? null : this._area, !this._zoom);
    const s = this.dataStore.get("editMode");
    if (s === Dn.ELEMENT)
      return bH(this._area);
    if (s === Dn.SHAPE) {
      const i = /* @__PURE__ */ new Set(), r = this.visualServer.getRenderItemOfElement(this.visualServer.snappingPath.element), o = HH(this.visualServer.snappingPath.mesh, r, this.viewport, this._area, this._fullyInside);
      for (const a of o)
        a.isFlagged(Be.CURVE_VERT) || i.add(a);
      return i;
    }
  }
  _canBeSelect(n, s, i, r) {
    const o = s.get("type") === ks.WORKSPACE || s.get("elementType") === Me.SCREEN && i.has(s) && !r.has(s), a = s.get("elementType") === Me.CONTAINER && !r.has(s), c = this.insideContainer ? o || a : o, l = !this._fullyInside || this._fullyInside && n.isInside(this._area);
    return c && l;
  }
  /**
   * Remove elements which is out side of selection area
   * @private
   * @param {Element} elements
   */
  _removeElementsOutOfSelectionArea(n) {
    if (this._remove)
      if (n.size === 0)
        this.dataStore.selection.clearAllExceptAction(On);
      else {
        const i = this.dataStore.selection.get("elements").filter((r) => !n.has(r));
        this.dataStore.selection.removeElements(i, On);
      }
  }
}
const vr = {
  size: 20,
  alpha: 0.75,
  fade: {
    duration: 200,
    ease: "easeInOutSine",
    wait: 3e3
  },
  minSize: 30
};
let Ta = null, wE, Lc = 0;
const mh = new ye();
function H8(e, n = {}) {
  let s = -(n.x / n.scale + e.x) * n.width / e.width, i = -(n.y / n.scale + e.y) * n.height / e.height;
  const r = n.width * (n.width / (n.scale * e.width)), o = n.height * (n.height / (n.scale * e.height)), a = Math.max(r, vr.minSize), c = Math.max(o, vr.minSize);
  s -= Math.max(0, a - r) * 0.5, i -= Math.max(0, c - o) * 0.5, mh.set(s, i, a, c);
}
function f1(e) {
  return Math.round(mh.width) < e.width || Math.round(mh.height) < e.height;
}
function W8(e, n) {
  const { viewport: s, dataStore: i } = e;
  wE = n, zB(mh), i.eam.on(Y.HOVER_SCROLLBAR, (o) => {
    if (o.handled = !1, Ta = null, f1(s)) {
      const { x: a, y: c } = o.mousePos, { left: l, right: h, bottom: d, top: p } = mh, E = vr.size;
      s.width - E < a && a < s.width && p < c && c < d ? Ta = "y" : s.height - E < c && c < s.height && l < a && a < h && (Ta = "x"), p1();
    }
    Ta ? i.eam.changeHover(Gt.SCROLLBAR) : i.eam.changeHover(i.selection.get("hover") ? Gt.ELEMENT : Gt.NONE), XB(Ta);
  });
  const r = new N();
  i.eam.on(Y.START_MOVE_SCROLLBAR, (o) => {
    if (!Ta) {
      o.handled = !1;
      return;
    }
    r.copy(o.mousePos), wE("grabbing"), NN();
  }).on(Y.UPDATE_MOVE_SCROLLBAR, ({ mousePos: o }) => {
    const a = r.sub(o), c = e.root.bounds.world;
    Ta === "y" ? (a.x = 0, a.y = a.y * c.height * s.scale / s.height) : (a.x = a.x * c.width * s.scale / s.width, a.y = 0), s.offsetPos(a), r.copy(o);
  }).on(Y.END_MOVE_SCROLLBAR, () => {
    wE("default"), xN();
  }), s.on("update", () => {
    var a, c;
    const o = (c = (a = e == null ? void 0 : e.root) == null ? void 0 : a.bounds) == null ? void 0 : c.world;
    H8(o, s), f1(s) && p1();
  });
}
let Zg;
function NN() {
  Zg && window.clearTimeout(Zg);
}
function xN(e = 0) {
  NN(), Zg = window.setTimeout(z8, vr.fade.wait + e);
}
function p1() {
  X8(), xN(vr.fade.duration);
}
class vN {
  constructor() {
    this._easings = /* @__PURE__ */ new Map(), this._easings.set(
      "easeInOutSine",
      function(n) {
        return n < 0.5 ? (1 - Math.cos(n * Math.PI)) * 0.5 : Math.sin((n - 0.5) * Math.PI) * 0.5 + 0.5;
      }
    ), this._animating = !1, this._reverse = !1, this._doAnimationHandler = this._doAnimation.bind(this);
  }
  animate(n, s, i, r = !1) {
    this._duration = n, this._easing = this._easings.get(s), this._callback = i, this._reverse = r, this._startTime = -1, this._animating || (this._animating = !0, window.requestAnimationFrame(this._doAnimationHandler));
  }
  _doAnimation(n) {
    this._animating = !1, this._startTime < 0 && (this._startTime = n);
    let s = Math.min((n - this._startTime) / this._duration, 1);
    this._reverse && (s = 1 - s);
    const i = this._easing(s);
    this._reverse && (s = 1 - s);
    const r = this._callback(i, s, this._duration) && s < 1;
    !this._animating && r && (this._animating = !0, window.requestAnimationFrame(this._doAnimationHandler));
  }
}
const E1 = new vN(), Y8 = new vN();
function X8() {
  const e = Lc, n = vr.alpha;
  E1._animating || E1.animate(
    vr.fade.duration,
    vr.fade.ease,
    (s) => (Lc = n * s + e * (1 - s), QC(Lc), !0)
  );
}
function z8() {
  const e = Lc, n = 0;
  Y8.animate(
    vr.fade.duration,
    vr.fade.ease,
    (s) => (Lc = n * s + e * (1 - s), QC(Lc), !0)
  );
}
var Yt;
(function(e) {
  e.LOAD = "LOAD", e.EXEC = "EXEC", e.FFPROBE = "FFPROBE", e.WRITE_FILE = "WRITE_FILE", e.READ_FILE = "READ_FILE", e.DELETE_FILE = "DELETE_FILE", e.RENAME = "RENAME", e.CREATE_DIR = "CREATE_DIR", e.LIST_DIR = "LIST_DIR", e.DELETE_DIR = "DELETE_DIR", e.ERROR = "ERROR", e.DOWNLOAD = "DOWNLOAD", e.PROGRESS = "PROGRESS", e.LOG = "LOG", e.MOUNT = "MOUNT", e.UNMOUNT = "UNMOUNT";
})(Yt || (Yt = {}));
const K8 = /* @__PURE__ */ (() => {
  let e = 0;
  return () => e++;
})(), Q8 = new Error("ffmpeg is not loaded, call `await ffmpeg.load()` first"), Z8 = new Error("called FFmpeg.terminate()");
var pi, Ho, Jr, Ma, Pa, tf, bs;
class q8 {
  constructor() {
    yo(this, pi, null);
    /**
     * #resolves and #rejects tracks Promise resolves and rejects to
     * be called when we receive message from web worker.
     */
    yo(this, Ho, {});
    yo(this, Jr, {});
    yo(this, Ma, []);
    yo(this, Pa, []);
    je(this, "loaded", !1);
    /**
     * register worker message event handlers.
     */
    yo(this, tf, () => {
      Ot(this, pi) && (Ot(this, pi).onmessage = ({ data: { id: n, type: s, data: i } }) => {
        switch (s) {
          case Yt.LOAD:
            this.loaded = !0, Ot(this, Ho)[n](i);
            break;
          case Yt.MOUNT:
          case Yt.UNMOUNT:
          case Yt.EXEC:
          case Yt.FFPROBE:
          case Yt.WRITE_FILE:
          case Yt.READ_FILE:
          case Yt.DELETE_FILE:
          case Yt.RENAME:
          case Yt.CREATE_DIR:
          case Yt.LIST_DIR:
          case Yt.DELETE_DIR:
            Ot(this, Ho)[n](i);
            break;
          case Yt.LOG:
            Ot(this, Ma).forEach((r) => r(i));
            break;
          case Yt.PROGRESS:
            Ot(this, Pa).forEach((r) => r(i));
            break;
          case Yt.ERROR:
            Ot(this, Jr)[n](i);
            break;
        }
        delete Ot(this, Ho)[n], delete Ot(this, Jr)[n];
      });
    });
    /**
     * Generic function to send messages to web worker.
     */
    yo(this, bs, ({ type: n, data: s }, i = [], r) => Ot(this, pi) ? new Promise((o, a) => {
      const c = K8();
      Ot(this, pi) && Ot(this, pi).postMessage({ id: c, type: n, data: s }, i), Ot(this, Ho)[c] = o, Ot(this, Jr)[c] = a, r == null || r.addEventListener("abort", () => {
        a(new DOMException(`Message # ${c} was aborted`, "AbortError"));
      }, { once: !0 });
    }) : Promise.reject(Q8));
    /**
     * Loads ffmpeg-core inside web worker. It is required to call this method first
     * as it initializes WebAssembly and other essential variables.
     *
     * @category FFmpeg
     * @returns `true` if ffmpeg core is loaded for the first time.
     */
    je(this, "load", ({ classWorkerURL: n, ...s } = {}, { signal: i } = {}) => (Ot(this, pi) || (ll(this, pi, n ? new Worker(new URL(n, import.meta.url), {
      type: "module"
    }) : (
      // We need to duplicated the code here to enable webpack
      // to bundle worekr.js here.
      new Worker(new URL(
        /* @vite-ignore */
        "/assets/worker-BAOIWoxA.js",
        import.meta.url
      ), {
        type: "module"
      })
    )), Ot(this, tf).call(this)), Ot(this, bs).call(this, {
      type: Yt.LOAD,
      data: s
    }, void 0, i)));
    /**
     * Execute ffmpeg command.
     *
     * @remarks
     * To avoid common I/O issues, ["-nostdin", "-y"] are prepended to the args
     * by default.
     *
     * @example
     * ```ts
     * const ffmpeg = new FFmpeg();
     * await ffmpeg.load();
     * await ffmpeg.writeFile("video.avi", ...);
     * // ffmpeg -i video.avi video.mp4
     * await ffmpeg.exec(["-i", "video.avi", "video.mp4"]);
     * const data = ffmpeg.readFile("video.mp4");
     * ```
     *
     * @returns `0` if no error, `!= 0` if timeout (1) or error.
     * @category FFmpeg
     */
    je(this, "exec", (n, s = -1, { signal: i } = {}) => Ot(this, bs).call(this, {
      type: Yt.EXEC,
      data: { args: n, timeout: s }
    }, void 0, i));
    /**
     * Execute ffprobe command.
     *
     * @example
     * ```ts
     * const ffmpeg = new FFmpeg();
     * await ffmpeg.load();
     * await ffmpeg.writeFile("video.avi", ...);
     * // Getting duration of a video in seconds: ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 video.avi -o output.txt
     * await ffmpeg.ffprobe(["-v", "error", "-show_entries", "format=duration", "-of", "default=noprint_wrappers=1:nokey=1", "video.avi", "-o", "output.txt"]);
     * const data = ffmpeg.readFile("output.txt");
     * ```
     *
     * @returns `0` if no error, `!= 0` if timeout (1) or error.
     * @category FFmpeg
     */
    je(this, "ffprobe", (n, s = -1, { signal: i } = {}) => Ot(this, bs).call(this, {
      type: Yt.FFPROBE,
      data: { args: n, timeout: s }
    }, void 0, i));
    /**
     * Terminate all ongoing API calls and terminate web worker.
     * `FFmpeg.load()` must be called again before calling any other APIs.
     *
     * @category FFmpeg
     */
    je(this, "terminate", () => {
      const n = Object.keys(Ot(this, Jr));
      for (const s of n)
        Ot(this, Jr)[s](Z8), delete Ot(this, Jr)[s], delete Ot(this, Ho)[s];
      Ot(this, pi) && (Ot(this, pi).terminate(), ll(this, pi, null), this.loaded = !1);
    });
    /**
     * Write data to ffmpeg.wasm.
     *
     * @example
     * ```ts
     * const ffmpeg = new FFmpeg();
     * await ffmpeg.load();
     * await ffmpeg.writeFile("video.avi", await fetchFile("../video.avi"));
     * await ffmpeg.writeFile("text.txt", "hello world");
     * ```
     *
     * @category File System
     */
    je(this, "writeFile", (n, s, { signal: i } = {}) => {
      const r = [];
      return s instanceof Uint8Array && r.push(s.buffer), Ot(this, bs).call(this, {
        type: Yt.WRITE_FILE,
        data: { path: n, data: s }
      }, r, i);
    });
    je(this, "mount", (n, s, i) => {
      const r = [];
      return Ot(this, bs).call(this, {
        type: Yt.MOUNT,
        data: { fsType: n, options: s, mountPoint: i }
      }, r);
    });
    je(this, "unmount", (n) => {
      const s = [];
      return Ot(this, bs).call(this, {
        type: Yt.UNMOUNT,
        data: { mountPoint: n }
      }, s);
    });
    /**
     * Read data from ffmpeg.wasm.
     *
     * @example
     * ```ts
     * const ffmpeg = new FFmpeg();
     * await ffmpeg.load();
     * const data = await ffmpeg.readFile("video.mp4");
     * ```
     *
     * @category File System
     */
    je(this, "readFile", (n, s = "binary", { signal: i } = {}) => Ot(this, bs).call(this, {
      type: Yt.READ_FILE,
      data: { path: n, encoding: s }
    }, void 0, i));
    /**
     * Delete a file.
     *
     * @category File System
     */
    je(this, "deleteFile", (n, { signal: s } = {}) => Ot(this, bs).call(this, {
      type: Yt.DELETE_FILE,
      data: { path: n }
    }, void 0, s));
    /**
     * Rename a file or directory.
     *
     * @category File System
     */
    je(this, "rename", (n, s, { signal: i } = {}) => Ot(this, bs).call(this, {
      type: Yt.RENAME,
      data: { oldPath: n, newPath: s }
    }, void 0, i));
    /**
     * Create a directory.
     *
     * @category File System
     */
    je(this, "createDir", (n, { signal: s } = {}) => Ot(this, bs).call(this, {
      type: Yt.CREATE_DIR,
      data: { path: n }
    }, void 0, s));
    /**
     * List directory contents.
     *
     * @category File System
     */
    je(this, "listDir", (n, { signal: s } = {}) => Ot(this, bs).call(this, {
      type: Yt.LIST_DIR,
      data: { path: n }
    }, void 0, s));
    /**
     * Delete an empty directory.
     *
     * @category File System
     */
    je(this, "deleteDir", (n, { signal: s } = {}) => Ot(this, bs).call(this, {
      type: Yt.DELETE_DIR,
      data: { path: n }
    }, void 0, s));
  }
  on(n, s) {
    n === "log" ? Ot(this, Ma).push(s) : n === "progress" && Ot(this, Pa).push(s);
  }
  off(n, s) {
    n === "log" ? ll(this, Ma, Ot(this, Ma).filter((i) => i !== s)) : n === "progress" && ll(this, Pa, Ot(this, Pa).filter((i) => i !== s));
  }
}
pi = new WeakMap(), Ho = new WeakMap(), Jr = new WeakMap(), Ma = new WeakMap(), Pa = new WeakMap(), tf = new WeakMap(), bs = new WeakMap();
var g1;
(function(e) {
  e.MEMFS = "MEMFS", e.NODEFS = "NODEFS", e.NODERAWFS = "NODERAWFS", e.IDBFS = "IDBFS", e.WORKERFS = "WORKERFS", e.PROXYFS = "PROXYFS";
})(g1 || (g1 = {}));
const j8 = new Error("failed to get response body reader"), J8 = new Error("failed to complete download"), $8 = "Content-Length", e6 = (e) => new Promise((n, s) => {
  const i = new FileReader();
  i.onload = () => {
    const { result: r } = i;
    r instanceof ArrayBuffer ? n(new Uint8Array(r)) : n(new Uint8Array());
  }, i.onerror = (r) => {
    var o, a;
    s(Error(`File could not be read! Code=${((a = (o = r == null ? void 0 : r.target) == null ? void 0 : o.error) == null ? void 0 : a.code) || -1}`));
  }, i.readAsArrayBuffer(e);
}), RN = async (e) => {
  let n;
  if (typeof e == "string")
    /data:_data\/([a-zA-Z]*);base64,([^"]*)/.test(e) ? n = atob(e.split(",")[1]).split("").map((s) => s.charCodeAt(0)) : n = await (await fetch(e)).arrayBuffer();
  else if (e instanceof URL)
    n = await (await fetch(e)).arrayBuffer();
  else if (e instanceof File || e instanceof Blob)
    n = await e6(e);
  else
    return new Uint8Array();
  return new Uint8Array(n);
}, t6 = async (e, n) => {
  var r;
  const s = await fetch(e);
  let i;
  try {
    const o = parseInt(s.headers.get($8) || "-1"), a = (r = s.body) == null ? void 0 : r.getReader();
    if (!a)
      throw j8;
    const c = [];
    let l = 0;
    for (; ; ) {
      const { done: p, value: E } = await a.read(), g = E ? E.length : 0;
      if (p) {
        if (o != -1 && o !== l)
          throw J8;
        n && n({ url: e, total: o, received: l, delta: g, done: p });
        break;
      }
      c.push(E), l += g, n && n({ url: e, total: o, received: l, delta: g, done: p });
    }
    const h = new Uint8Array(l);
    let d = 0;
    for (const p of c)
      h.set(p, d), d += p.length;
    i = h.buffer;
  } catch (o) {
    console.log("failed to send download progress event: ", o), i = await s.arrayBuffer();
  }
  return i;
}, _1 = async (e, n, s = !1, i) => {
  const r = s ? await t6(e, i) : await (await fetch(e)).arrayBuffer(), o = new Blob([r], { type: n });
  return URL.createObjectURL(o);
};
class wN {
  constructor() {
  }
  /**
   * Get estimated size of the exported data
   * @abstract
   */
  static getEstimatedSize() {
  }
  /**
   * Add frame data to encoder
   * @abstract
   */
  addFrame() {
  }
  /**
   * Get encoder data
   * @abstract
   * @returns {Uint8Array} bytes
   */
  getData() {
  }
  /**
   * Start encoding
   * @abstract
   */
  encode() {
  }
  /**
   * End of the encoder
   * @abstract
   */
  end() {
  }
  /**
   * Cancel encoder
   * @abstract
   */
  cancel() {
  }
}
class n6 extends wN {
  /**
   * @param {FFmpeg} ffmpeg
   */
  constructor(n) {
    super(), this.ffmpeg = n, this._width = 0, this._height = 0, this._frameRate = 0, this._speed = 0, this._loop = !0, this._index = 0, this._onProgressHandler = null;
  }
  /**
   * @param {RecorderOption} options
   */
  init(n) {
    this._width = n.width, this._height = n.height, this._frameRate = n.fps, this._speed = n.speed, this._loop = n.loop, this._index = 0, this._onProgressHandler = null;
  }
  static getEstimatedSize({ width: n, height: s, fps: i, duration: r, transparency: o, loop: a, speed: c }) {
    const p = a ? 19 : 0, E = 256 * 3, g = 0.05, T = r / c, A = i * T;
    return (14 + (18 + n * s * (o ? 4 : 3) * g) * A + E + p) / 1024;
  }
  /**
   * Add frame data to encoder
   * @param {Uint8ClampedArray} pixels
   */
  async addFrame(n) {
    const s = await RN(n);
    await this.ffmpeg.writeFile(`${this._index}.png`, s), this._index++;
  }
  /**
   * Get encoder data
   */
  getData() {
    return this.ffmpeg.readFile("output.gif");
  }
  /**
   * Encode frames to gif
   */
  encode(n = () => {
  }) {
    let s = !0;
    return this._onProgressHandler = ({ progress: i }) => {
      s ? i === 1 && (s = !1) : n(Math.min(i, 1) * 100 * 0.5 + 50);
    }, this.ffmpeg.on("progress", this._onProgressHandler), this.ffmpeg.exec([
      "-i",
      "%d.png",
      "-vf",
      "palettegen",
      "palette.png"
    ]).then(() => this.ffmpeg.exec([
      "-framerate",
      `${this._frameRate}`,
      "-i",
      "%d.png",
      "-i",
      "palette.png",
      `${this._loop ? "-ignore_loop" : "-loop"}`,
      `${this._loop ? 0 : -1}`,
      "-filter_complex",
      `[0:v]setpts=${1 / this._speed}*PTS[v];[v][1:v]paletteuse`,
      "output.gif"
    ]));
  }
  /**
   * End of the encoder
   */
  end() {
    if (!this.ffmpeg.loaded) return;
    this._onProgressHandler && (this.ffmpeg.off("progress", this._onProgressHandler), this._onProgressHandler = null);
    const n = [
      this.ffmpeg.deleteFile("output.gif").catch(() => {
      }),
      // Ignore error if file doesn't exist
      this.ffmpeg.deleteFile("palette.png").catch(() => {
      })
      // Ignore error if file doesn't exist
    ];
    for (let s = 0; s <= this._index; s++)
      n.push(this.ffmpeg.deleteFile(`${s}.png`).catch(() => {
      }));
    Promise.all(n).then(() => {
      this.ffmpeg.terminate();
    }).catch((s) => {
      console.error("Error during cleanup:", s), this.ffmpeg.terminate();
    });
  }
  /**
   * Cancel encoder
   */
  cancel() {
    this.end();
  }
}
const T1 = {
  [wa.ULTRA]: 2,
  [wa.HIGH]: 23,
  [wa.MEDIUM]: 36,
  [wa.LOW]: 49
};
class s6 extends wN {
  /**
   * @param {FFmpeg} ffmpeg
   */
  constructor(n) {
    super(), this.ffmpeg = n, this._width = 0, this._height = 0, this._frameRate = 0, this._speed = 0, this._quality = 0, this._index = 0, this._onProgressHandler = null;
  }
  /**
   * @param {RecorderOption} options
   */
  init(n) {
    this._width = n.width, this._height = n.height, this._frameRate = n.fps, this._speed = n.speed, this._quality = T1[n.quality], this._index = 0, this._onProgressHandler = null;
  }
  static getEstimatedSize({ width: n, height: s, fps: i, duration: r, speed: o, videoQuality: a }) {
    const c = r / o, l = 8, h = 4, d = T1[a];
    return 0.05 * (n * s * h * l * i * c) / (8 * 1024 * d);
  }
  /**
   * Add frame data to encoder
   * @param {Uint8Array} pixels
   */
  async addFrame(n) {
    const s = await RN(n);
    await this.ffmpeg.writeFile(`${this._index}.png`, s), this._index++;
  }
  /**
   * Get encoder data
   */
  getData() {
    return this.ffmpeg.readFile("output.mp4");
  }
  /**
   * Encode frames to mp4 video
   */
  encode(n = () => {
  }) {
    return this._onProgressHandler = ({ progress: s }) => {
      n(Math.min(s, 1) * 100 * 0.5 + 50);
    }, this.ffmpeg.on("progress", this._onProgressHandler), this.ffmpeg.exec([
      "-framerate",
      `${this._frameRate}`,
      "-i",
      "%d.png",
      "-c:v",
      "libx264",
      "-crf",
      `${this._quality}`,
      "-filter:v",
      `pad=ceil(iw/2)*2:ceil(ih/2)*2,setpts=${1 / this._speed}*PTS,scale=out_color_matrix=bt709:out_range=tv`,
      // add pad
      "-pix_fmt",
      "yuv420p",
      "-bsf:v",
      "h264_metadata=video_full_range_flag=0:colour_primaries=1:transfer_characteristics=1:matrix_coefficients=1",
      "output.mp4"
    ]);
  }
  /**
   * End of the encoder
   */
  end() {
    if (!this.ffmpeg.loaded) return;
    this._onProgressHandler && (this.ffmpeg.off("progress", this._onProgressHandler), this._onProgressHandler = null);
    const n = [
      this.ffmpeg.deleteFile("output.mp4").catch(() => {
      })
    ];
    for (let s = 0; s <= this._index; s++)
      n.push(this.ffmpeg.deleteFile(`${s}.png`).catch(() => {
      }));
    Promise.all(n).then(() => {
      this.ffmpeg.terminate();
    }).catch((s) => {
      console.error("Error during cleanup:", s), this.ffmpeg.terminate();
    });
  }
  /**
   * Cancel encoder
   */
  cancel() {
    this.end();
  }
}
function DE(e) {
  return { width: 0, height: 0, pixels: null, error: new Error(e) };
}
const i6 = ei.hex(0);
async function r6(e, { pixels: n, width: s, height: i }) {
  const r = document.createElement("canvas");
  return r.width = s, r.height = i, r.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(n), s, i), 0, 0), new Promise((a) => r.toBlob(a, `image/${e}`));
}
function o6() {
  const e = G0.instance(), n = e.root.id;
  if (!e.indexer.getNode(n))
    throw console.warn(`Node with rootID ${n} not found.`), new Error(`Node with rootID ${n} not found.`);
  return e.updateNodes(), { VS: e, rootID: n };
}
async function a6(e = "png", n = null, s = i6, i = null) {
  const { rootID: r } = o6(), { pixels: o, width: a, height: c } = await c6(r, s, n, i);
  if (!o)
    throw console.warn(`Failed to render snapshot for rootID ${r}.`), new Error(`Failed to render snapshot for rootID ${r}.`);
  return r6(e, { pixels: o, width: a, height: c });
}
function c6(e, n, s = null, i = null, r = 1e4) {
  return new Promise((o) => {
    const a = G0.instance(), c = a.indexer.getNode(e);
    if (!c) {
      o(DE(`cannot take snapshot of non-exist element "${e}"`));
      return;
    }
    const l = nt();
    l.setCaptureBackgroundColor(n.r, n.g, n.b, n.a);
    const h = s ? s.x : i.w, d = s ? s.y : i.h, p = a.view.getOrCreateDinoTree(c.id);
    l.capture(p.root_id, i.x, i.y, i.w, i.h, h, d);
    const E = (/* @__PURE__ */ new Date()).getTime(), g = setTimeout(() => {
      console.warn("renderSnapshot timed out"), od.delete(E), o(DE("renderSnapshot timed out"));
    }, r);
    od.set(E, (T, A) => {
      if (clearTimeout(g), od.delete(E), T === null || A === 0)
        o(DE("Capture failed with null pointer or zero length"));
      else {
        const m = l.readU8Array(T, A);
        o({ pixels: m, width: h, height: d });
      }
    });
  });
}
const od = /* @__PURE__ */ new Map(), l6 = (e, n) => {
  for (const [, s] of od.entries())
    s && s(e, n);
}, Yu = {
  ROOT: "root",
  RESIZE: "resize"
};
class h6 {
  constructor() {
    this._paused = !1, this.dirty = {
      [Yu.ROOT]: !0,
      [Yu.RESIZE]: !1
    };
  }
  get paused() {
    return this._paused;
  }
  _updateDirty(n, s) {
    this.dirty[n] = s;
  }
  updateRootDirty(n) {
    this._updateDirty(Yu.ROOT, n);
  }
  updateResizeDirty(n) {
    this._updateDirty(Yu.RESIZE, n);
  }
  pause() {
    this._paused = !0;
  }
  resume() {
    this._paused = !1;
  }
}
const Oi = new h6(), u6 = () => {
  Oi.pause();
}, A1 = () => {
  Oi.resume();
}, DN = () => new Promise((e) => requestAnimationFrame(e)), d6 = (e, n = 0) => {
  const s = Math.pow(10, n);
  return Math.round(e * s) / s;
};
class f6 {
  /**
   * @param {VisualServer} visualServer
   * @param {DataStore} dataStore
   */
  constructor(n, s) {
    this.visualServer = n, this.dataStore = s, this._encoder = null, this.init();
  }
  init() {
    this.onProgress = () => {
    }, this.onComplete = () => {
    }, this._rafId = null, this._isEnabled = !1, this._ctx = null, this._imageData = null, this._imageSize = { width: 0, height: 0 }, this.type = null, this.settings = {
      startTime: 0,
      currTime: 0,
      endTime: 0,
      iterTime: 0,
      fps: 30,
      loop: !0,
      speed: 1,
      quality: wa.HIGH,
      transparent: !1,
      gifTransparentColor: NaN
    }, this.exportFile = null;
  }
  /**
   * Set media encoder to recorder
   * @param {Encoder} encoder
   */
  setEncoder(n) {
    this._encoder = n;
  }
  get width() {
    return this._imageSize.width;
  }
  get height() {
    return this._imageSize.height;
  }
  /**
   * Enable to record media
   */
  enable() {
    this._isEnabled = !0;
  }
  /**
   * Disable to record media
   */
  disable() {
    this._isEnabled = !1, this.end(), A1();
  }
  /**
   * Set media type
   * @param {MediaType} type
   */
  setMediaType(n) {
    this.type = n;
  }
  /**
   * Set output media viewport size
   * @param {number} width
   * @param {number} height
   */
  setOutputSize(n, s) {
    this._imageSize.width = n, this._imageSize.height = s;
  }
  /**
   * Update recorder settings
   * @param {object} newSettings
   */
  updateSetting(n) {
    this.settings = { ...this.settings, ...n }, this.settings.currTime = this.settings.startTime;
  }
  /**
   * Record canvas for exporting video
   * @param {Function} onProgress
   * @param {Function} onComplete
   * @param {Rect2} bounds
   */
  async start(n, s, i) {
    this.onProgress = n, this.onComplete = s, u6(), await this.processNextFrame(i), A1();
  }
  /**
   * Render next frame
   * @returns {Promise}
   * @param {Rect2} bounds
   */
  processNextFrame(n) {
    return new Promise((s) => {
      const i = async () => {
        await this.frameProcessingLoop(s, n);
      };
      this._rafId = window.requestAnimationFrame(i);
    });
  }
  /**
   * Render loop function for each frame
   * @param {Promise.resolve} resolve
   * @param {Rect2} bounds
   */
  async frameProcessingLoop(n, s) {
    if (!this._isEnabled) {
      this._encoder.cancel(), this.end(), n();
      return;
    }
    if (await this._captureScreen(this.settings.currTime, s), await this._encoder.addFrame(this._imageData), this.settings.currTime <= this.settings.endTime) {
      this.settings.currTime += this.settings.iterTime;
      let i = (this.settings.currTime - this.settings.startTime) / (this.settings.endTime - this.settings.startTime) * 100 * 0.5;
      i = Math.min(i, 100 * 0.5), this.onProgress(i), await this.processNextFrame(s);
    } else
      this._encoder.encode(this.onProgress).then(() => {
        this._encoder.getData().then((i) => {
          this.onComplete(i), this._encoder.end(), this.end();
        }).catch((i) => {
          console.error("Error during getData:", i), this.end();
        });
      }).catch((i) => {
        console.error("Error during encoding:", i), this.end();
      });
    n();
  }
  /**
   * Capture screen
   * @param {number} t
   * @param {Rect2} bounds
   */
  async _captureScreen(n, s) {
    this.dataStore.transition.setPlayheadTime(n, !0, !1), await DN();
    {
      const r = new ei(0, 0, 0, 0);
      this.type === Vo.GIF && !this.settings.transparent && r.set_with_array([0, 0, 0, 1]), this._imageData = await a6("png", void 0, r, s);
    }
  }
  /**
   * End record canvas
   */
  end() {
    H.resume(), this.dataStore.transition.resume(), this.dataStore.editor.reloadPropertiesAndStates(/* @__PURE__ */ new Map([["mode", ""]])), window.cancelAnimationFrame(this._rafId);
  }
  clear() {
    this.init();
  }
}
class p6 {
  /**
   *
   * @param {import('../../visual_server/VisualServer').VisualServer} visualServer
   * @param {*} dataStore
   */
  constructor(n, s) {
    je(this, "onRecordProgress", null);
    je(this, "loadFFmpeg", async () => {
      await this.ffmpeg.load({
        coreURL: await _1(`${window.location.origin}${hE.baseUrl}/ffmpeg/ffmpeg-core.js`, "text/javascript"),
        wasmURL: await _1(`${window.location.origin}${hE.baseUrl}/ffmpeg/ffmpeg-core.wasm`, "application/wasm"),
        classWorkerURL: `${window.location.origin}${hE.baseUrl}/ffmpeg/worker.js`
      });
    });
    this.visualServer = n, this.dataStore = s, this.ffmpeg = new q8(), this._encoder = null, this.recorder = new f6(n, s), this.init();
  }
  init() {
    this.type = null, this.exportFile = null, this.recorder.init();
  }
  /**
   * Enable to record media
   */
  enable() {
    this.recorder.enable(), this.dataStore.forceUpdateLayerListToRenderer(), this.loadFFmpeg();
  }
  /**
   * Disable tp record media
   */
  disable() {
    this.recorder.disable();
  }
  /**
   * Set output media viewport size
   */
  setOutputSize() {
    this.recorder.setOutputSize(
      this.dataStore.workspace.children[0].get("size").width,
      this.dataStore.workspace.children[0].get("size").height
    );
  }
  /**
   * Set media type
   * @param {MediaType} type
   */
  async setMediaType(n) {
    this.type = n, this.recorder.setMediaType(n), this.type === Vo.MP4 && this.updateRecordSetting({
      transparent: !1
    }), await this._initEncoder(), this.recorder.setEncoder(this._encoder);
  }
  /**
   * Update recorder settings
   * @param {object} newSettings
   */
  updateRecordSetting(n) {
    this.recorder.updateSetting(n);
  }
  /**
   * Init media encoder
   */
  async _initEncoder() {
    await this.loadFFmpeg();
    const n = {
      width: this.recorder.width,
      height: this.recorder.height,
      fps: this.recorder.settings.fps,
      speed: this.recorder.settings.speed,
      quality: this.recorder.settings.quality,
      loop: this.recorder.settings.loop
    };
    switch (this.type) {
      case Vo.GIF: {
        this._encoder = new n6(this.ffmpeg), this._encoder.init(n);
        break;
      }
      case Vo.MP4: {
        this._encoder = new s6(this.ffmpeg), this._encoder.init(n);
        break;
      }
    }
  }
  /**
   * Record canvas for exporting video
   * @param {Function} onRecordProgress
   * @param {Function} onRecordComplete
   * @param {string} actionId
   */
  async recordCanvas(n, s, i) {
    const r = RB(this.dataStore.drawInfo.vs, i, kF);
    await this.recorder.start(n, (o) => {
      this.handleExportCompletion(o), s();
    }, r.worldBoundsAABB);
  }
  /**
   * Create file blob
   * @param {Uint8Array} uint8Array
   * @returns {Blob}
   */
  createBlob(n) {
    let s;
    switch (this.type) {
      case Vo.GIF:
        s = { type: "image/gif" };
        break;
      case Vo.MP4:
        s = { type: "video/mp4" };
        break;
    }
    return new Blob([n], s);
  }
  /**
   * Handle finish recording
   * @param {Uint8Array} bytes
   */
  handleExportCompletion(n) {
    this.exportFile = URL.createObjectURL(this.createBlob(n));
  }
  clear() {
    this.init();
  }
}
let wt;
const Aa = 0.01;
function E6(e) {
  wt = e;
}
class Js {
  constructor() {
  }
  /**
   *
   * @param {Element[]} selection
   * @param {AlignType} direction
   */
  static _doAlignElement(n, s) {
    if (n.length === 1) {
      const i = n[0], r = wt.dataStore.getParentOf(i);
      if (!r)
        return;
      const o = wt.getRenderItemOfElement(i), a = o.transform.local.xform_rect(o.bounds.local), c = wt.getRenderItemOfElement(r).bounds.local.clone(), l = Js._alginBound(s, o.transform.translate, c, a);
      wt.dataStore.beginChangeGroup(), i.sets({ translateX: l.x, translateY: l.y }), wt.dataStore.commitUndo(), wt.dataStore.endChangeGroup();
    } else {
      const i = Js._snapToPixelGrid(s);
      wt.dataStore.beginChangeGroup();
      for (const r of n) {
        const o = wt.getRenderItemOfElement(r), a = o.transform.parent.xform(o.transform.translate), c = Js._alginBound(s, a, i, o.bounds.world);
        wt.dataStore.data.snapToPixelGrid && (s === Zt.MIDDLE ? c.y = Math.round(c.y) : s === Zt.CENTER && (c.x = Math.round(c.x)));
        const l = o.transform.parent.clone().affine_inverse().xform(c);
        l.x = this.roundToDecimal(l.x, 2), l.y = this.roundToDecimal(l.y, 2), r.sets({ translateX: l.x, translateY: l.y });
      }
      wt.dataStore.commitUndo(), wt.dataStore.endChangeGroup();
    }
  }
  /**
   *
   * @param {AlignType} direction
   * @param {Vector2} translate
   * @param {Bounds} targetBound
   * @param {Bounds} originBound
   * @returns {Vector2}
   */
  static _alginBound(n, s, i, r) {
    const o = s.clone();
    switch (n) {
      case Zt.LEFT:
        o.x += i.x - r.x;
        break;
      case Zt.RIGHT:
        o.x += i.right - r.right;
        break;
      case Zt.TOP:
        o.y += i.top - r.top;
        break;
      case Zt.BOTTOM:
        o.y += i.bottom - r.bottom;
        break;
      case Zt.MIDDLE:
        o.y += i.y + i.height * 0.5 - (r.y + r.height * 0.5);
        break;
      case Zt.CENTER:
        o.x += i.x + i.width * 0.5 - (r.x + r.width * 0.5);
        break;
    }
    return o;
  }
  static _snapToPixelGrid(n) {
    const s = wt.selection.bounds.clone();
    if (wt.dataStore.data.snapToPixelGrid)
      switch (n) {
        case Zt.LEFT:
          s.x = Math.ceil(s.x);
          break;
        case Zt.RIGHT:
          s.width = Math.floor(s.right) - s.x;
          break;
        case Zt.TOP:
          s.y = Math.ceil(s.y);
          break;
        case Zt.BOTTOM:
          s.height = Math.floor(s.bottom) - s.y;
          break;
        case Zt.MIDDLE:
        case Zt.CENTER:
          break;
      }
    return s;
  }
  /**
   *
   * @param {Element[]} selection
   * @param {AlignType} direction
   */
  static _doAlignVertices(n, s) {
    const i = wt.dataStore.selection.get("vertices");
    if (!i.length)
      return;
    const r = n[0].get("geometry").get("mesh"), { pathXform: o, pathXformInv: a } = Js._getPathTransform(n[0]), c = new ye();
    if (i.length === 1) {
      for (const p of r.getVertices())
        this._expandWorldBound(p, o, c);
      const l = i[0], h = o.xform(l.pos);
      Js._alignVertexByDirection(s, h, c);
      const d = a.xform(h);
      r.situateVertexToPos(l, d.x, d.y);
    } else {
      Js._setupPointShape(i, r), r.applyChanges(r.changes);
      const l = Js._getVerticesWorldPositionsAndUpdateBounds(i, o, c);
      for (const { vertex: h, worldPos: d } of l) {
        Js._alignVertexByDirection(s, d, c);
        const p = a.xform(d);
        r.situateVertexToPos(h, p.x, p.y);
      }
    }
    wt.dataStore.beginChangeGroup(), r.applyChanges(r.changes), r.fire(), wt.dataStore.commitUndo(), wt.dataStore.endChangeGroup();
  }
  /**
   *
   * @param {Vertex[]} selectedVertices
   * @param {Mesh} mesh
   * @returns {void}
   */
  static _setupPointShape(n, s) {
    if (!n[0].isFlagged(Be.CURVE_VERT))
      return;
    const i = /* @__PURE__ */ new Map();
    for (const r of n)
      if (r.isFlagged(Be.CURVE_VERT)) {
        if (!r.adjacentMainVertex) {
          console.warn("Please check file, a curve control does not attach a real vertex");
          continue;
        }
        const o = r.adjacentMainVertex.id;
        i.has(o.id) ? s.prepareVertexPropertyChanges(o, "mirror", pe.INDEPENDENT) : i.set(o.id);
      }
  }
  /**
   *
   * @param {Vertex[]} selectedVertices
   * @param {Transform2D} pathXform
   * @param {Rect2} bounds
   * @returns {VertexAndPosition[]}
   */
  static _getVerticesWorldPositionsAndUpdateBounds(n, s, i) {
    const r = [];
    for (const o of n) {
      const a = new N();
      new N().set(o.pos[0], o.pos[1]), s.xform(o.pos, a), r.push({ vertex: o, worldPos: a }), i.is_zero() ? (i.x = a.x, i.y = a.y) : i.expand_to(a);
    }
    return r;
  }
  /**
   *
   * @param {Element} element
   * @returns {{ pathXform:Transform2D, pathXformInv:Transform2D }}
   */
  static _getPathTransform(n) {
    const s = wt.getRenderItemOfElement(n), { translate: i, rotation: r, scale: o, skew: a, contentAnchor: c } = s.transform, l = s.transform.parent.clone().translate_right(i.x, i.y).rotate_right(r).skew_right(Rt(a.x), Rt(a.y)).scale_right(o.x, o.y).translate_right(-c.x, -c.y), h = l.clone().affine_inverse();
    return { pathXform: l, pathXformInv: h };
  }
  /**
   *
   * @param {AlignType} direction
   * @param {Vector2} worldPos
   * @param {Rect2} bounds
   */
  static _alignVertexByDirection(n, s, i) {
    switch (n) {
      case Zt.LEFT:
        s.x = i.left;
        break;
      case Zt.RIGHT:
        s.x = i.right;
        break;
      case Zt.TOP:
        s.y = i.top;
        break;
      case Zt.BOTTOM:
        s.y = i.bottom;
        break;
      case Zt.MIDDLE:
        s.y = i.center.y;
        break;
      case Zt.CENTER:
        s.x = i.center.x;
        break;
    }
  }
  /**
   *
   * @param {Element[]} selectionArr
   * @param {DistributeType} direction
   */
  static _doDistributeElement(n, s) {
    if (n.length < 3)
      return;
    const i = this._preorderTraversalWithIndex(wt.dataStore.workspace, n), r = s === Pc.HORIZONTAL, o = n.map((p, E) => ({
      element: p,
      bounds: wt.getRenderItemOfElement(p).bounds.world.clone(),
      index: i[E]
    })).sort(
      (p, E) => r ? Math.abs(p.bounds.left - E.bounds.left) < Aa ? p.index - E.index : p.bounds.left - E.bounds.left : Math.abs(p.bounds.top - E.bounds.top) < Aa ? p.index - E.index : p.bounds.top - E.bounds.top
    ), a = o.reduce((p, E) => Math.min(E.bounds.left, p), Number.MAX_VALUE), c = o.reduce((p, E) => Math.min(E.bounds.top, p), Number.MAX_VALUE);
    for (const p of o)
      p.bounds.offset(-a, -c);
    let l = 0;
    for (let p = 1; p < o.length; p++) {
      const E = o[p - 1], g = o[p];
      l += r ? g.bounds.left - E.bounds.right : g.bounds.top - E.bounds.bottom;
    }
    l /= n.length - 1, l = this.roundToDecimal(l, 2);
    const h = -o.reduce(
      (p, E) => Math.min(r ? E.bounds.width : E.bounds.height, p),
      Number.MAX_VALUE
    );
    if (l < h) {
      wt.dataStore.eam.showNotification("info", "file:alignment.distribute.error");
      return;
    }
    wt.dataStore.beginChangeGroup();
    const d = o[0].bounds;
    for (let p = 1; p < o.length; p++) {
      const E = o[p], g = wt.getRenderItemOfElement(E.element).transform, T = new N(0, 0);
      if (r ? T.x = l - (E.bounds.left - d.right) : T.y = l - (E.bounds.top - d.bottom), p === o.length - 1 && (r && T.x > 0 || !r && T.y > 0))
        break;
      const m = g.parent.clone().affine_inverse().basis_xform(T);
      E.element.sets({ translateX: g.translate.x + m.x, translateY: g.translate.y + m.y }), d.copy(E.bounds), d.offset(T.x, T.y);
    }
    wt.dataStore.commitUndo(), wt.dataStore.endChangeGroup();
  }
  /**
   *
   * @param {Element[]} selection
   * @param {DistributeType} direction
   */
  static _doDistributeVertices(n, s) {
    const i = s === Pc.HORIZONTAL, r = wt.dataStore.selection.get("vertices");
    if (r.length < 3)
      return;
    const o = n[0].get("geometry").get("mesh"), { pathXform: a, pathXformInv: c } = Js._getPathTransform(n[0]), l = new ye(), h = Js._getVerticesWorldPositionsAndUpdateBounds(r, a, l), d = this.roundToDecimal((i ? l.width : l.height) / (r.length - 1), 2);
    if (Math.abs(d) < Aa)
      return;
    const p = h.sort((E, g) => Math.abs(E.worldPos.x - g.worldPos.x) < Aa && Math.abs(E.worldPos.y - g.worldPos.y) < Aa ? E.vertex.index - g.vertex.index : i ? Math.abs(E.worldPos.x - g.worldPos.x) < Aa ? E.worldPos.y - g.worldPos.y : E.worldPos.x - g.worldPos.x : Math.abs(E.worldPos.y - g.worldPos.y) < Aa ? E.worldPos.x - g.worldPos.x : E.worldPos.y - g.worldPos.y);
    Js._setupPointShape(r, o), o.applyChanges(o.changes);
    for (let E = 1; E < p.length - 1; E++) {
      const { vertex: g, worldPos: T } = p[E];
      i ? T.x = p[0].worldPos.x + E * d : T.y = p[0].worldPos.y + E * d;
      const A = c.xform(T);
      o.situateVertexToPos(g, A.x, A.y);
    }
    wt.dataStore.beginChangeGroup(), o.applyChanges(o.changes), o.fire(), wt.dataStore.commitUndo(), wt.dataStore.endChangeGroup();
  }
  /**
   *
   * @param {AlignType} direction
   */
  static align(n) {
    const s = wt.dataStore, i = s.selection.get("elements");
    s.get("editMode") === Dn.ELEMENT ? this._doAlignElement(i, n) : s.get("editMode") === Dn.SHAPE && this._doAlignVertices(i, n), s.commitUndo();
  }
  /**
   *
   * @param {DistributeType} direction
   */
  static distribute(n) {
    const s = wt.dataStore, i = s.selection.get("elements");
    s.get("editMode") === Dn.ELEMENT ? this._doDistributeElement(i, n) : s.get("editMode") === Dn.SHAPE && this._doDistributeVertices(i, n), s.commitUndo();
  }
  /**
   *
   * @param {Element} root
   * @param {Element[]} elements
   * @returns {number[]}
   */
  static _preorderTraversalWithIndex(n, s) {
    const i = [];
    if (!n) return i;
    const r = [n];
    let o = 0;
    for (; r.length > 0; ) {
      const a = r.pop(), c = s.indexOf(a);
      if (c !== -1 && (i[c] = o++), !!a.children)
        for (let l = 0; l < a.children.length; l++)
          r.push(a.children[l]);
    }
    return i;
  }
  /**
   *
   * @param {number} value
   * @param {number} decimal
   * @returns {number}
   */
  static roundToDecimal(n, s) {
    const i = Math.pow(10, s);
    return Math.round(n * i) / i;
  }
  /**
   * @param {Vertex} vertex
   * @param {Transform2D} pathXform
   * @param {Rect2} bounds
   * @returns {Rect2}
   */
  static _expandWorldBound(n, s, i) {
    const r = new N();
    return new N().set(n.pos[0], n.pos[1]), s.xform(n.pos, r), i.is_zero() ? (i.x = r.x, i.y = r.y) : i.expand_to(r), i;
  }
}
const g6 = 30, _6 = 1;
let Ts, vn, G, An, ir, fi, nr;
function T6(e) {
  Ts = e, G = e.dataStore, An = e.viewport, vn = B8(Ts.canvas, G), EH(Ts, vn.setState), ir = LV(Ts, vn), fi = new V8(Ts), Xk(Ts, vn.setState), W8(Ts, vn.setState), eH(Ts, ir, fi, vn.setState), E6(Ts), nr = new p6(Ts, G), C6(), m6(), O6(), y6();
  const n = /* @__PURE__ */ new Set(), s = () => {
    const r = new Set(G.selection.get("elements"));
    for (const o of r)
      n.has(o) || n.add(o);
    for (const o of n)
      r.has(o) || n.delete(o);
  }, i = (r) => {
    switch (r) {
      case si.EDITING: {
        vn.setState("default"), s();
        break;
      }
      case si.VIEWING:
      case si.VERSIONING: {
        vn.setState("default");
        break;
      }
    }
  };
  G.on("state", i), i(G.get("state")), G.selection.on(Oe.SELECT, s);
}
function LN(e, n = {}) {
  const { padding: s = 25 } = n, i = e.clone();
  An.focus(i, {
    left: s + ft.size,
    top: s + ft.size,
    right: s,
    bottom: s
  });
}
const jo = {
  ALL: "ALL",
  WIDTH: "WIDTH",
  HEIGHT: "HEIGHT"
};
function nh(e = jo.ALL, n = {}) {
  const s = Ts.indexer.getActiveScreenNode();
  if (s) {
    const i = s.boundsWorldAABB.clone();
    e === jo.WIDTH ? (i.y += i.height / 2, i.height = 0) : e === jo.HEIGHT && (i.x += i.width / 2, i.width = 0), LN(i, n);
  }
}
function A6() {
  Ts.selection.size > 0 ? LN(Ts.selection.bounds) : nh(jo.ALL);
}
function MN() {
  An.moveTo(Ts.selection.bounds);
}
function m6() {
  const e = [0.02, 0.03, 0.06, 0.13, 0.25, 0.5, 1, 2, 4, 8, 16, 32, 64, 128, 256], n = (E) => e.find((g) => g > E), s = (E) => e.findLast((g) => g < E);
  G.eam.on(Y.ZOOM_IN, () => {
    const E = An.getZoom(), g = n(E);
    g !== void 0 && An.setZoom(g);
  }), G.eam.on(Y.ZOOM_OUT, () => {
    const E = An.getZoom(), g = s(E);
    g !== void 0 && An.setZoom(g);
  }), G.eam.on(Y.ZOOM_RESET, () => {
    An.setZoom(1);
  }), G.eam.on(Y.ZOOM_FIT_CONTENT, (E) => {
    nh(jo.ALL, E);
  }), G.eam.on(Y.ZOOM_FIT_WIDTH, (E) => {
    nh(jo.WIDTH, E);
  }), G.eam.on(Y.ZOOM_FIT_HEIGHT, (E) => {
    nh(jo.HEIGHT, E);
  }), G.eam.on(Y.ZOOM_FIT_SELECTION, () => {
    A6();
  }), G.eam.on(Y.ZOOM_CENTER_SELECTION, () => {
    MN();
  }), G.eam.on(Y.ZOOM_TO_VALUE, (E) => {
    G.workspace.watched.set("scale", E);
  }), G.eam.on(Y.ALIGN, (E) => {
    Js.align(E);
  }), G.eam.on(Y.DISTRIBUTE, (E) => {
    Js.distribute(E);
  }), G.eam.on(Y.COPY, (E) => {
    G.clipboard.copy(E);
  }), G.eam.on(Y.PASTE, (E) => {
    G.clipboard.paste(E);
  }), G.eam.on(Y.CUT, (E) => {
    G.clipboard.cut(E);
  }), G.eam.on(Y.DUPLICATE_ELEMENT, () => {
    G.clipboard.duplicate();
  }), G.eam.on(Y.UNDO, () => {
    G.get("undo").undo();
  }), G.eam.on(Y.REDO, () => {
    G.get("undo").redo();
  }), G.eam.on(Y.EXIT_EDITOR, () => {
    vn.setState(null);
  }), G.eam.on(Y.ACTIVATE_SELECT_TOOL, () => {
    vn.setState("default");
  }), G.eam.on(Y.ACTIVATE_SCALE_TOOL, () => {
    vn.setState("default");
  }), G.eam.on(Y.ACTIVATE_HAND_TOOL, () => {
    vn.setState("grab");
  }), G.eam.on(Y.ACTIVATE_RECTANGLE_TOOL, () => {
    vn.setState("crosshair");
  }), G.eam.on(Y.ACTIVATE_ELLIPSE_TOOL, () => {
    vn.setState("crosshair");
  }), G.eam.on(Y.ACTIVATE_CONTAINER_TOOL, () => {
    vn.setState("crosshair");
  }), G.eam.on(Y.ACTIVATE_PEN_TOOL, () => {
    vn.setState("penDefault");
  }), G.eam.on(Y.ACTIVATE_TEXT_TOOL, () => {
    vn.setState("crosshair");
  }), G.eam.on(Y.ACTIVATE_COMMENT_TOOL, () => {
    vn.setState("comment");
  });
  let i = G.get("mode");
  G.eam.on(Y.SWITCH_MODE, (E) => {
    i = E;
  }), G.eam.on(Y.EXPORT_MEDIA, async (E) => {
    const { fileName: g, mediaType: T, quality: A, transparent: m, loop: O, speed: S, fps: y, start: v, end: R, actionId: M } = E;
    G.set("mode", Rn.ACTION, Ku), nr.enable(), H.pause(), G.transition.hold(), G.transition.prepareActionTransition(), await DN();
    const L = (v === void 0 ? 0 : v) * 1e3, P = (R === void 0 ? 0 : R) * 1e3, k = y === void 0 ? g6 : y, Q = S === void 0 ? _6 : S, b = 1e3 / k * Q, X = G.interaction.getElementIdByActionId(M);
    nr.setOutputSize(), nr.updateRecordSetting({
      startTime: L,
      endTime: P,
      iterTime: b,
      speed: Q,
      fps: y,
      quality: A,
      transparent: m,
      loop: O
    }), await nr.setMediaType(T);
    const K = (ne) => {
      G.eam.exportProgress(d6(ne, 1));
    }, V = () => {
      nr.exportFile && G.eam.exportFinish(nr.exportFile, { fileName: g, type: T }), nr.clear();
    }, J = G.drawInfo.vs.root.id, ge = X;
    G.drawInfo.vs.view.cleanup(), G.drawInfo.vs.setRoot(ge), G.drawInfo.vs.view.setup(G, ge), await nr.recordCanvas(K, V, M), G.drawInfo.vs.setRoot(J), G.drawInfo.vs.view.setup(G, J), G.set("mode", i, Ku);
  }), G.eam.on(Y.CANCEL_EXPORT_MEDIA, () => {
    G.set("mode", i, Ku), nr.disable(), nr.clear();
  });
  let r = null;
  const o = /* @__PURE__ */ new Set(), a = new N(), c = (E) => {
    o.clear(), E.x < 0 && o.add("left"), E.y < 0 && o.add("top"), E.x > An.width && o.add("right"), E.y > An.height && o.add("bottom");
  }, l = () => {
    o.size && (o.has("left") && (a.x = 8), o.has("right") && (a.x = -8), o.has("top") && (a.y = 8), o.has("bottom") && (a.y = -8), An.offsetPos(a), a.x = 0, a.y = 0), r = requestAnimationFrame(l);
  };
  G.eam.on(Y.START_LEFT_CLICK_MOVE, () => {
    r = requestAnimationFrame(l);
  }), G.eam.on(Y.UPDATE_LEFT_CLICK_MOVE, (E) => {
    G.eam.states.hover !== "GUIDELINE" && c(E.mousePos);
  }), G.eam.on(Y.END_LEFT_CLICK_MOVE, () => {
    o.clear(), cancelAnimationFrame(r);
  });
  let h = 0;
  const d = 20;
  let p;
  G.eam.on(Y.START_RIGHT_CLICK_MOVE, (E) => {
    p = E.mousePos, h = 0;
  }), G.eam.on(Y.UPDATE_RIGHT_CLICK_MOVE, (E) => {
    p = E.mousePos, h++;
  }), G.eam.on(Y.END_RIGHT_CLICK_MOVE, () => {
    if (h < d) {
      const E = G.selection.get("elements"), g = Ts.viewport.toWorld(p), T = G.selection.get("hover"), A = Ts.selection.bounds.has_point(g);
      G.selection.get("hoverGuideline") ? G.eam.directlySelectGuide() : T || A ? (!E.includes(T) && !A && (G.selection.clearAllExceptAction(), G.selection.addElements([T])), G.eam.openElementContextMenu(p.clone())) : G.eam.openCanvasContextMenu(p.clone());
    }
  });
}
function O6() {
  G.eam.on(Y.START_RESIZE_ELEMENT, (r, o, { snapToGrid: a, snapToObject: c }) => ir.resizeStart(r, a, c)).on(Y.UPDATE_RESIZE_ELEMENT, (r, o, { snapToGrid: a, snapToObject: c }) => ir.resizeUpdate(r, o, a, c)).on(Y.END_RESIZE_ELEMENT, ir.resizeEnd), G.eam.on(Y.START_SCALE_ELEMENT, (r, o, { snapToGrid: a, snapToObject: c }) => ir.resizeStart(r, a, c)).on(Y.UPDATE_SCALE_ELEMENT, (r, o, { snapToGrid: a, snapToObject: c }) => ir.resizeUpdate(r, o, a, c)).on(Y.END_SCALE_ELEMENT, ir.resizeEnd), G.eam.on(Y.START_ROTATE_ELEMENT, (r, o) => ir.rotateStart(r, o)).on(Y.UPDATE_ROTATE_ELEMENT, (r, o) => ir.rotateUpdate(An.toWorld(r.mousePos), o)).on(Y.END_ROTATE_ELEMENT, ir.rotateEnd), G.eam.on(Y.START_ZOOM_TO_SELECTION, fi.start).on(Y.UPDATE_ZOOM_TO_SELECTION, (r, o) => fi.update(r, o, !0)).on(Y.END_ZOOM_TO_SELECTION, fi.end);
  let e = /* @__PURE__ */ new Set();
  const n = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set();
  G.eam.on(Y.START_AREA_SELECT_ELEMENT, (r) => {
    e = new Set(G.selection.get("elements")), fi.start(r);
  }).on(Y.UPDATE_AREA_SELECT_ELEMENT, (r, o) => {
    const a = fi.update(r, o, !1);
    n.forEach((c) => e.delete(c)), n.clear(), s.forEach((c) => e.add(c)), s.clear(), a.forEach((c) => {
      e.has(c) ? (s.add(c), e.delete(c)) : (n.add(c), e.add(c));
    }), fi.selectNodesInSelectionArea(e), e.size && G.eam.pauseAnimation();
  }).on(Y.END_AREA_SELECT_ELEMENT, () => {
    fi.end(), e.clear(), n.clear(), s.clear();
  });
  const i = /* @__PURE__ */ new Set();
  G.eam.on(Y.START_AREA_SELECT_CELL, (r) => {
    G.selection.get("vertices").forEach((a) => i.add(a)), fi.start(r);
  }).on(Y.UPDATE_AREA_SELECT_CELL, (r, o) => {
    const a = fi.update(r, o, !1);
    i.forEach((c) => {
      a.has(c) ? a.delete(c) : a.add(c);
    }), fi.selectVerticesInSelectionArea(a);
  }).on(Y.END_AREA_SELECT_CELL, () => {
    fi.end(), i.clear();
  });
}
function PN(e, n) {
  return e.containsRect(n.boundsWorldAABB);
}
function I6({
  mousePos: e,
  wheelDelta: n,
  deltaToMult: s,
  useViewportAwareZoomPos: i,
  viewport: r,
  screenNode: o
}) {
  const a = n.y < 0 ? s(n.y) : 1 / s(n.y);
  let c = e;
  if (i && r && o) {
    const l = r.toScreen(o.boundsWorldAABB.center);
    c = PN(r, o) ? l : e;
  }
  return { zoomMult: a, zoomPos: c };
}
let bo;
class S6 {
  /**
   * @param {DataStore} dataStore - Data store instance
   * @param {Viewport} viewport - Viewport instance
   * @param {object} cursorHandler - Cursor handler for visual feedback
   */
  constructor(n, s, i) {
    this.dataStore = n, this.viewport = s, this.cursorHandler = i, this.enabled = !0, this._hasLastMousePos = !1, this._lastMousePos = new N();
  }
  /**
   * Updates the enabled state based on current data store and viewport state.
   * In Prototype Mode, disable panning when the screen is fully inside the viewport.
   */
  updateEnabledState() {
    if (this.dataStore.isPrototypeMode) {
      const n = this.dataStore.drawInfo.vs.indexer.getActiveScreenNode(), s = PN(this.viewport, n);
      this.enabled = !s;
    } else
      this.enabled = !0;
  }
  /**
   * Starts viewport panning
   * @param {object} event - Event data containing mousePos
   */
  startPanning(n) {
    this.enabled && (this._hasLastMousePos = !0, this._lastMousePos.copy(n.mousePos), this.cursorHandler.setState("grabbing"));
  }
  /**
   * Updates viewport panning
   * @param {object} event - Event data containing mousePos
   */
  updatePanning(n) {
    if (this.enabled) {
      const { mousePos: s } = n;
      this._hasLastMousePos || this.startPanning(n);
      const i = s.clone().sub(this._lastMousePos);
      this.viewport.offsetPos(i), this._lastMousePos.copy(s);
    }
  }
  /**
   * Ends viewport panning
   */
  endPanning() {
    this.enabled && (this._hasLastMousePos = !1);
  }
  /**
   * Handles wheel panning
   * @param {object} event - Event data containing wheelDelta
   */
  wheelPan(n) {
    if (this.enabled) {
      const s = n.wheelDelta.clone().negate();
      this.viewport.offsetPos(s);
    }
  }
}
function y6() {
  G.eam.on(Y.ACTIVATE_PAN, () => {
    vn.setState("grab");
  }), G.eam.on(Y.DEACTIVATE_PAN, () => {
    vn.setState("default");
  }), G.eam.on(Y.COMMENT_DEACTIVATE_PAN, () => {
    vn.setState("comment");
  }), bo = new S6(G, An, vn), G.eam.on(Y.START_PANNING, (i) => bo.startPanning(i)).on(Y.UPDATE_PANNING, (i) => bo.updatePanning(i)).on(Y.END_PANNING, () => {
    bo.endPanning();
  }), G.eam.on(Y.MOVE_VIEWPORT_KEY, (i) => {
    An.offsetPos(i);
  }), G.eam.on(Y.WHEEL_PAN_VIEWPORT, (i) => {
    bo.wheelPan(i);
  });
  function e({ event: i, deltaToMult: r, isMobile: o = !1 }) {
    const a = G.isPrototypeMode, c = o ? i.pinchScale < 1 : i.wheelDelta.y > 0;
    if (a && c) {
      const l = o ? i.pinchScale : 1 / r(i.wheelDelta.y);
      s({
        zoomFactor: l
      });
    } else if (o) {
      const l = i.pinchScale;
      An.zoomAroundPos(i.mousePos, l);
    } else {
      const l = a ? G.drawInfo.vs.indexer.getActiveScreenNode() : null, { zoomMult: h, zoomPos: d } = I6({
        mousePos: i.mousePos,
        wheelDelta: i.wheelDelta,
        deltaToMult: r,
        useViewportAwareZoomPos: a,
        viewport: An,
        screenNode: l
      });
      An.zoomAroundPos(d, h);
    }
  }
  function n({
    offset: i,
    currentZoom: r,
    zoomFactor: o,
    options: a = {}
  }) {
    const {
      minBaseMovementInPx: c = 20,
      progressiveMovementSlowdownRatio: l = 0.25,
      maxProgressiveMovementInPx: h = 40
    } = a, d = i.length();
    if (d < 1)
      return new N(0, 0);
    const p = Math.abs(1 - o) * c, E = Math.max(0.1, Math.min(1, 1 / r)), g = d * E * l, T = h * E, A = Math.min(g, T), m = p + A, S = i.clone().normalize().scale(m);
    return S.x = Math.sign(i.x) * Math.min(Math.abs(i.x), Math.abs(S.x)), S.y = Math.sign(i.y) * Math.min(Math.abs(i.y), Math.abs(S.y)), S;
  }
  function s({
    viewPortTopLeftX: i = 0,
    viewPortTopLeftY: r = 0,
    zoomFactor: o
  }) {
    const a = G.drawInfo.vs.indexer.getActiveScreenNode(), c = An.toScreen(a.boundsVisualWorldAABB.center), l = An.rect.clone();
    l.x += i, l.y += r, l.width -= i, l.height -= r;
    const d = l.center.clone().sub(c), p = An.getZoom(), E = n({
      offset: d,
      currentZoom: p,
      zoomFactor: o
    });
    An.setZoom(p * o), An.offsetPos(E);
  }
  {
    const i = (r) => 1 + Math.abs(r) / 1e3;
    G.eam.on(Y.WHEEL_ZOOM_TO_POINTER, (r) => {
      e({
        event: r,
        deltaToMult: i,
        isMobile: !1
      });
    });
  }
  if (G.eam.on(Y.ACTIVATE_TEXT_EDIT_MODE, () => {
    const r = G.selection.get("elements")[0];
    r != null && r.isText && G.drawInfo.setTextEditingMode(r.get("id"), G.selection.get("textRange"));
  }), G.eam.on(Y.DEACTIVATE_TEXT_EDIT_MODE, () => {
    G.drawInfo.exitTextEditingMode();
  }), H.platform === "Mac") {
    const i = "quadratic", r = (o) => {
      switch (i) {
        case "cubic":
          return (1 + Math.abs(o) / 150) ** 3;
        case "quadratic":
          return (1 + Math.abs(o) / 100) ** 2;
        default:
          return 1 + Math.abs(o) / 75;
      }
    };
    G.eam.on(Y.TRACKPAD_ZOOM_TO_POINTER, (o) => {
      e({
        event: o,
        deltaToMult: r,
        isMobile: !1
      });
    });
  }
  G.eam.on(Y.MOBILE_PINCH_ZOOM_TO_POINTER, (i) => {
    i.pinchScale && i.pinchCenter && e({
      event: i,
      deltaToMult: (o) => 1 + Math.abs(o) / 1e3,
      isMobile: !0
    });
  }), An.on(Oe.VIEWPORT_ZOOM_CHANGE, () => {
    bo.updateEnabledState();
  }), An.on(Oe.VIEWPORT_RESIZE, () => {
    bo.updateEnabledState();
  }), G.eam.on(Y.SWITCH_DOCUMENT_MODE, () => {
    bo.updateEnabledState();
  });
}
function C6() {
  H.get(H.Events.MOUSE_MOVE).on("trigger", (e, n) => {
    G.eam.mouseMove(e, n);
  }), H.get(H.Events.DELETE).on("trigger", (e, n) => {
    G.eam.delete(e, n);
  }), H.get(H.Events.LEFT_CLICK_DOWN).on("trigger", (e, n) => {
    G.eam.leftClickDown(e, n);
  }), H.get(H.Events.LEFT_CLICK_UP).on("trigger", (e, n) => {
    G.eam.leftClickUp(e, n);
  }), H.get(H.Events.DOUBLE_LEFT_CLICK).on("trigger", (e) => {
    G.eam.doubleLeftClick(e);
  }), H.get(H.Events.DRAG_OVER).on("trigger", (e) => {
    G.eam.dragOver(e);
  }), H.get(H.Events.DRAG_END).on("trigger", (e) => {
    G.eam.dragEnd(e);
  }), H.get(H.Events.DROP).on("trigger", (e) => {
    G.eam.drop(e);
  }), H.get(H.Events.LEFT_CLICK_MOVE).on("start", (e, n) => {
    G.eam.fire(Y.START_LEFT_CLICK_MOVE, e), G.eam.leftClickMove(e, n);
  }).on("update", (e, n) => {
    G.eam.fire(Y.UPDATE_LEFT_CLICK_MOVE, e), G.eam.updateAction(e, n);
  }).on("end", () => {
    G.eam.fire(Y.END_LEFT_CLICK_MOVE), G.eam.endAction();
  }), H.get(H.Events.MIDDLE_CLICK_MOVE).on("start", (e) => {
    G.eam.middleClickMove(e);
  }).on("update", (e) => {
    G.eam.updateAction(e);
  }).on("end", () => {
    G.eam.endAction(), G.eam.spaceOff();
  }), H.get(H.Events.RIGHT_CLICK_MOVE).on("start", (e) => {
    G.eam.fire(Y.START_RIGHT_CLICK_MOVE, e), G.eam.rightClickMove(e);
  }).on("update", (e) => {
    G.eam.fire(Y.UPDATE_RIGHT_CLICK_MOVE, e), G.eam.updateAction(e);
  }).on("end", () => {
    G.eam.fire(Y.END_RIGHT_CLICK_MOVE), G.eam.endAction(), G.eam.spaceOff();
  }), H.get(H.Events.SPACE).on("start", (e) => {
    G.eam.spaceOn(e);
  }).on("end", () => {
    G.eam.spaceOff(), G.eam.toggleAnimation(), G.eam.endAction();
  }), H.get(H.Events.MOVE_RIGHT).on("trigger", (e, n) => {
    G.eam.arrowKey(dt.RIGHT, n);
  }), H.get(H.Events.MOVE_LEFT).on("trigger", (e, n) => {
    G.eam.arrowKey(dt.LEFT, n);
  }), H.get(H.Events.MOVE_UP).on("trigger", (e, n) => {
    G.eam.arrowKey(dt.UP, n);
  }), H.get(H.Events.MOVE_DOWN).on("trigger", (e, n) => {
    G.eam.arrowKey(dt.DOWN, n);
  }), H.get(H.Events.SELECT_PREVIOUS_ELEMENT).on("trigger", () => {
    G.eam.selectElementSibling(dt.UP);
  }), H.get(H.Events.SELECT_NEXT_ELEMENT).on("trigger", () => {
    G.eam.selectElementSibling(dt.DOWN);
  }), H.get(H.Events.TEXT_MOVE_CARET_TO_LINE_START).on("trigger", () => {
    G.eam.moveTextToEdge(dt.START);
  }), H.get(H.Events.TEXT_MOVE_CARET_TO_TEXT_START).on("trigger", () => {
    G.eam.moveTextToEdge(dt.START, { modifier: !0 });
  }), H.get(H.Events.TEXT_EXPAND_SELECTION_TO_LINE_START).on("trigger", () => {
    G.eam.moveTextToEdge(dt.START, { shift: !0 });
  }), H.get(H.Events.TEXT_EXPAND_SELECTION_TO_TEXT_START).on("trigger", () => {
    G.eam.moveTextToEdge(dt.START, { modifier: !0, shift: !0 });
  }), H.get(H.Events.TEXT_MOVE_CARET_TO_LINE_END).on("trigger", () => {
    G.eam.moveTextToEdge(dt.END);
  }), H.get(H.Events.TEXT_MOVE_CARET_TO_TEXT_END).on("trigger", () => {
    G.eam.moveTextToEdge(dt.END, { modifier: !0 });
  }), H.get(H.Events.TEXT_EXPAND_SELECTION_TO_LINE_END).on("trigger", () => {
    G.eam.moveTextToEdge(dt.END, { shift: !0 });
  }), H.get(H.Events.TEXT_EXPAND_SELECTION_TO_TEXT_END).on("trigger", () => {
    G.eam.moveTextToEdge(dt.END, { modifier: !0, shift: !0 });
  }), H.get(H.Events.ENTER).on("trigger", (e) => {
    G.eam.enter(e);
  }), H.get(H.Events.ENTER_SHIFT).on("trigger", (e) => {
    G.eam.enter(e, { shift: !0 });
  }), H.get(H.Events.ESCAPE).on("trigger", (e) => {
    G.eam.escape(e);
  }), H.get(H.Events.WHEEL_PAN_VIEWPORT).on("trigger", (e, n) => {
    G.eam.wheelPanAndZoom(e, n);
  }), H.get(H.Events.WHEEL_ZOOM_TO_POINTER).on("trigger", (e) => {
    G.eam.wheelPanAndZoom(e, { modifier: !0 });
  }), H.platform === "Mac" && H.get(H.Events.TRACKPAD_ZOOM_TO_POINTER).on("trigger", (e) => {
    G.eam.wheelPanAndZoom(e, { ctrl: !0 });
  }), H.get(H.Events.MOBILE_PINCH_ZOOM_TO_POINTER).on("trigger", (e) => {
    G.eam.wheelPanAndZoom(e, { pinch: !0 });
  }), H.get(H.Events.MOBILE_TOUCH_PAN).on("start", (e) => {
    G.eam.startAction(Y.START_PANNING, e);
  }).on("update", (e) => {
    G.eam.updateAction(e);
  }).on("end", () => {
    G.eam.endAction();
  }), H.get(H.Events.ZOOM_IN).on("trigger", (e) => {
    G.eam.zoomIn(e);
  }), H.get(H.Events.ZOOM_OUT).on("trigger", (e) => {
    G.eam.zoomOut(e);
  }), H.get(H.Events.ZOOM_RESET).on("trigger", () => {
    G.eam.zoomReset();
  }), H.get(H.Events.ZOOM_FIT_CONTENT).on("trigger", () => {
    G.eam.zoomFitContent();
  }), H.get(H.Events.ZOOM_FIT_SELECTION).on("trigger", () => {
    G.eam.zoomFitSelection();
  }), H.get(H.Events.ZOOM_CENTER_SELECTION).on("trigger", () => {
    G.eam.zoomCenterSelection();
  }), H.get(H.Events.ACTIVATE_SELECT_TOOL).on("trigger", () => {
    G.eam.activateSelectTool();
  }), H.get(H.Events.ACTIVATE_SCALE_TOOL).on("trigger", () => {
    G.eam.activateScaleTool();
  }), H.get(H.Events.ACTIVATE_HAND_TOOL).on("trigger", (e) => {
    G.eam.activateHandTool(e);
  }), H.get(H.Events.ACTIVATE_RECTANGLE_TOOL).on("trigger", () => {
    G.eam.activateRectangleTool();
  }), H.get(H.Events.ACTIVATE_CONTAINER_TOOL).on("trigger", () => {
    G.eam.activateContainerTool();
  }), H.get(H.Events.ACTIVATE_ELLIPSE_TOOL).on("trigger", () => {
    G.eam.activateEllipseTool();
  }), H.get(H.Events.ACTIVATE_PEN_TOOL).on("trigger", () => {
    G.eam.activatePenTool();
  }), H.get(H.Events.ACTIVATE_COMMENT_TOOL).on("trigger", () => {
    G.eam.activateCommentTool();
  }), H.get(H.Events.ACTIVATE_TEXT_TOOL).on("trigger", () => {
    G.eam.activateTextTool();
  }), H.get(H.Events.TOGGLE_EYE_DROPPER_TOOL).on("trigger", () => {
    G.eam.toggleEyeDropperTool();
  }), H.get(H.Events.GROUP_ELEMENTS).on("trigger", (e, n) => {
    G.eam.groupElements(n);
  }), H.get(H.Events.UNGROUP_ELEMENT).on("trigger", () => {
    G.eam.ungroupElements();
  }), H.get(H.Events.INCREASE_CORNER_RADIUS).on("trigger", () => {
    G.eam.increaseCornerRadius();
  }), H.get(H.Events.DECREASE_CORNER_RADIUS).on("trigger", () => {
    G.eam.decreaseCornerRadius();
  }), H.get(H.Events.SELECT_ALL).on("trigger", () => {
    G.eam.selectAllByContext();
  }), H.get(H.Events.COPY).on("trigger", () => {
    G.eam.copy();
  }), H.get(H.Events.PASTE).on("trigger", (e) => {
    G.eam.paste(e);
  }), H.get(H.Events.CUT).on("trigger", () => {
    G.eam.cut();
  }), H.get(H.Events.DUPLICATE).on("trigger", () => {
    G.eam.duplicate();
  }), H.get(H.Events.UNDO).on("trigger", () => {
    G.eam.undo();
  }), H.get(H.Events.REDO).on("trigger", () => {
    G.eam.redo();
  }), H.get(H.Events.TOGGLE_EXPAND).on("trigger", () => {
    G.eam.toggleExpand();
  }), H.get(H.Events.ALIGN_LEFT).on("trigger", () => {
    G.eam.align(Zt.LEFT);
  }), H.get(H.Events.ALIGN_CENTER).on("trigger", () => {
    G.eam.align(Zt.CENTER);
  }), H.get(H.Events.ALIGN_RIGHT).on("trigger", () => {
    G.eam.align(Zt.RIGHT);
  }), H.get(H.Events.ALIGN_TOP).on("trigger", () => {
    G.eam.align(Zt.TOP);
  }), H.get(H.Events.ALIGN_MIDDLE).on("trigger", () => {
    G.eam.align(Zt.MIDDLE);
  }), H.get(H.Events.ALIGN_BOTTOM).on("trigger", () => {
    G.eam.align(Zt.BOTTOM);
  }), H.get(H.Events.DISTRIBUTE_HORIZONTAL).on("trigger", () => {
    G.eam.distribute(Pc.HORIZONTAL);
  }), H.get(H.Events.DISTRIBUTE_VERTICAL).on("trigger", () => {
    G.eam.distribute(Pc.VERTICAL);
  }), H.get(H.Events.TOGGLE_ANIMATE_MODE).on("trigger", () => {
    const e = G.isActionMode ? Rn.DESIGN : Rn.ACTION, n = G.get("lastActiveAction");
    e === Rn.ACTION && n ? (G.isActionMode && (G.transition.stop(), G.drawInfo.vs.updateNodes()), G.eam.switchMode(n === null ? Rn.DESIGN : Rn.ACTION), G.selection.selectAction(n, { commit: !1 })) : e === Rn.DESIGN && (G.eam.switchMode(e), G.selection.selectAction(null, { commit: !1 })), G.commitUndo();
  }), H.get(H.Events.TOGGLE_ORIGIN).on("trigger", () => {
    G.eam.toggleOrigin();
  }), H.get(H.Events.TOGGLE_RULER).on("trigger", () => {
    G.eam.toggleRuler();
  }), H.get(H.Events.TOGGLE_ACTION_PANEL).on("trigger", () => {
    G.isActionMode && G.eam.toggleActionPanel();
  }), H.get(H.Events.TOGGLE_INTERFACE).on("trigger", () => {
    G.eam.toggleInterface();
  }), H.get(H.Events.ADD_ACTION).on("trigger", () => {
    G.eam.addAction();
  }), H.get(H.Events.TOGGLE_COMMENT_VISIBILITY).on("trigger", () => {
    G.eam.toggleCommentVisibility();
  }), H.get(H.Events.TOGGLE_VISIBLE).on("trigger", () => {
    G.eam.toggleVisible();
  }), H.get(H.Events.TOGGLE_LOCK).on("trigger", () => {
    G.eam.toggleLock();
  }), H.get(H.Events.BRING_TO_FRONT).on("trigger", () => {
    G.eam.bringToFront();
  }), H.get(H.Events.SEND_TO_BACK).on("trigger", () => {
    G.eam.sendToBack();
  }), H.get(H.Events.MOVE_FORWARD).on("trigger", () => {
    G.eam.moveForward();
  }), H.get(H.Events.MOVE_BACKWARD).on("trigger", () => {
    G.eam.moveBackward();
  }), H.get(H.Events.MASK_SELECTION).on("trigger", () => {
    G.eam.maskGroupElements(!0);
  }), H.get(H.Events.TOGGLE_PRESENCE).on("trigger", () => {
    G.eam.togglePresencePreference();
  }), H.get(H.Events.EDIT_ORIGIN).on("trigger", () => {
    const e = G.getFeature("editOrigin");
    G.setFeature("editOrigin", !e);
  }), H.get(H.Events.TOGGLE_INSPECTING).on("trigger", () => {
    G.eam.toggleInspecting();
  }), H.get(H.Events.RESTART_PROTOTYPE).on("trigger", () => {
    G.eam.restartPrototype();
  }), H.get(H.Events.TOGGLE_PROTOTYPE_MODE).on("trigger", () => {
    G.isPrototypeMode ? G.eam.exitPrototypeMode() : G.eam.enterPrototypeMode();
  }), H.get(H.Events.EXIT_PROTOTYPE_MODE).on("trigger", () => {
    G.eam.exitPrototypeMode();
  }), H.get(H.Events.ENTER_PROTOTYPE_MODE_FULL_SCREEN).on("trigger", () => {
    G.eam.enterPrototypeModeFullScreen();
  });
}
function N6() {
  switch (G.get("editMode")) {
    case Dn.SHAPE:
      Ts.snappingPath.update();
      break;
  }
}
function x6(e, n, s) {
  return Math.abs(e[0] - n) > ms || Math.abs(e[1] - s) > ms;
}
const b0 = (e, n) => {
  const s = e.view.getOrCreateDinoTree(n.id), i = n.fontFamily || "Noto Sans", r = n.fontSize, o = n.fontStyle, a = n.fontWeight, c = n.lineHeight, l = n.content || "", h = n.letterSpacing, d = 0, p = n.horizontalAlignment, E = n.verticalAlignment;
  if (n.updateFlags & Z.STYLE) {
    let b = e.dataStore.fontManager.getFontUrl(i, o, a);
    b || (console.warn(`cannot found the URL for ${i}-${o}-${a}`), b = e.dataStore.fontManager.getFontUrl(i, "Regular", 400)), nt().fetchFont(i, b, o, a);
  }
  let g = -1;
  n.resizingMode !== co[Ht.AUTO_WIDTH] && (g = n.transform.size.x);
  let T = -1;
  n.resizingMode === co[Ht.FIXED] && (T = n.transform.size.y);
  const A = s.text_node_id;
  let m = 0, O = 0, S = 0;
  const y = e.dataStore.selection.get("textRange");
  y ? (m = y.start, O = y.end, S = y.cursor) : (O = l.length, S = l.length);
  const { start_block: v, start_char: R, end_block: M, end_char: L, cursor_index: P, active_block_index: k } = qg(l, m, O, S);
  for (let b = 0; b < s.fills.children.length; b++)
    nt().setTextDoc(s.fills.children[b].text_doc_id, l, P, k), nt().setTextStyle(s.fills.children[b].text_doc_id, i, o, a, r, h, c, d, p, E), nt().buildLayoutAndPath(s.fills.children[b].id, s.fills.children[b].text_doc_id, g, T), nt().markNodeChanged(s.fills.children[b].id);
  for (let b = 0; b < s.strokes.children.length; b++)
    nt().setTextDoc(s.strokes.children[b].text_doc_id, l, P, k), nt().setTextStyle(
      s.strokes.children[b].text_doc_id,
      i,
      o,
      a,
      r,
      h,
      c,
      d,
      p,
      E
    ), nt().buildLayoutAndPath(s.strokes.children[b].id, s.strokes.children[b].text_doc_id, g, T), nt().markNodeChanged(s.strokes.children[b].id);
  nt().setTextDoc(s.text_doc_id, l, P, k), nt().setTextStyle(s.text_doc_id, i, o, a, r, h, c, d, p, E), nt().buildLayoutAndPath(A, s.text_doc_id, g, T), nt().markNodeChanged(A), nt().setTextSelection(s.text_doc_id, v, R, M, L, P, k);
  const Q = nt().getTextPathData(A, s.text_doc_id);
  s.path_id ? nt().setPath(s.path_id, Q) : s.path_id = nt().makePath(Q);
}, qg = (e, n, s, i) => {
  let r = 0, o = 0, a = 0, c = 0, l = 0, h = 0, d = 0, p = 0, E = -1;
  for (let g = 0; g <= e.length; g++) {
    if (g === i && (l = d, h = p), g === n && (r = d, a = p, E = s - n), E > 0)
      E--;
    else if (E === 0) {
      o = d, c = p;
      break;
    }
    g < e.length && e[g] == `
` ? (d++, p = 0) : p++;
  }
  return s > 0 && e[s - 1] === `
` && (c = 0), { start_block: r, start_char: a, end_block: o, end_char: c, cursor_index: h, active_block_index: l };
}, bN = (e, n, s, i, r) => {
  const o = n.get("resizingMode"), a = n.get("size"), c = n.get("horizontalAlignment"), l = n.get("verticalAlignment");
  o === Ht.AUTO_WIDTH ? v6(
    e,
    a,
    s,
    i,
    n,
    c,
    l,
    r
  ) : o === Ht.AUTO_HEIGHT && D6(
    e,
    a,
    i,
    n,
    c,
    l,
    r
  );
};
function v6(e, n, s, i, r, o, a, c) {
  const l = r.get("id");
  if (e.dataStore.isDesignMode && !e.dataStore.isPrototypeMode) {
    if (!x6(n, s, i))
      return;
    const h = {
      width: s,
      height: i,
      referencePointX: 0.5 * s,
      referencePointY: 0.5 * i
    }, d = r.get("contentAnchor");
    n.x >= Qt && (h.contentAnchorX = d.x * s / n.x), n.y >= Qt && (h.contentAnchorY = d.y * i / n.y);
    const p = UN(
      e,
      l,
      h,
      o,
      a
    );
    p && (h.translateX = p.x, h.translateY = p.y), r.sets(h, c);
  } else {
    const h = { width: s, height: i }, d = r.getBaseValue("referencePoint"), p = r.getBaseValue("dimensions");
    R6(
      o,
      a,
      h,
      s,
      i,
      d,
      p
    ), r.sets(h, s0);
  }
}
function R6(e, n, s, i, r, o, a) {
  const c = a.width - o.referencePointX, l = a.height - o.referencePointY;
  switch (e) {
    case Yi.CENTER:
      s.referencePointX = 0.5 * i;
      break;
    case Yi.RIGHT:
      s.referencePointX = i - c;
      break;
    case Yi.LEFT:
      s.referencePointX = o.referencePointX;
      break;
  }
  switch (n) {
    case Fs.MIDDLE:
      s.referencePointY = 0.5 * r;
      break;
    case Fs.BOTTOM:
      s.referencePointY = r - l;
      break;
    case Fs.TOP:
      s.referencePointY = o.referencePointY;
      break;
  }
}
function w6(e, n, s, i, r) {
  const o = r.height - i.referencePointY;
  switch (s) {
    case Fs.MIDDLE:
      e.referencePointY = 0.5 * n;
      break;
    case Fs.BOTTOM:
      e.referencePointY = n - o;
      break;
    case Fs.TOP:
      break;
  }
}
function D6(e, n, s, i, r, o, a) {
  const c = i.get("id");
  if (e.dataStore.isDesignMode && !e.dataStore.isPrototypeMode) {
    const l = {
      height: s,
      referencePointY: 0.5 * s
    }, h = i.get("contentAnchor");
    n.y >= Qt && (l.contentAnchorY = h.y * s / n.y);
    const d = UN(
      e,
      c,
      l,
      r,
      o
    );
    d && (l.translateX = d.x, l.translateY = d.y), i.sets(l, a);
  } else {
    const l = { height: s }, h = i.getBaseValue("referencePoint"), d = i.getBaseValue("dimensions");
    w6(
      l,
      s,
      o,
      h,
      d
    ), i.sets(l, s0);
  }
}
function UN(e, n, s, i, r, o = !1) {
  const a = L6(e, n, s);
  if (!a) return null;
  const c = o ? a.baseTransform : a.transform, { contentAnchor: l, referencePoint: h, size: d, translate: p, skew: E, scale: g, rotation: T } = M6(c), A = P6(s, l, h), m = b6(s, d), { newPivotOffset: O, originPivotOffset: S } = U6(
    A,
    l,
    h,
    d,
    s,
    i,
    r
  );
  return G6(
    p,
    T,
    E,
    g,
    O,
    S,
    m
  );
}
function L6(e, n, s) {
  const i = e.getRenderItem(n);
  return !i || !(s.contentAnchorX !== void 0 || s.contentAnchorY !== void 0 || s.width !== void 0 || s.height !== void 0) ? null : i;
}
function M6(e) {
  return {
    contentAnchor: e.contentAnchor,
    referencePoint: e.referencePoint,
    size: { x: e.size.x, y: e.size.y },
    translate: { x: e.translate.x, y: e.translate.y },
    skew: e.skew,
    scale: e.scale,
    rotation: e.rotation
  };
}
function P6(e, n, s) {
  return {
    contentAnchorX: e.contentAnchorX ?? n.x,
    contentAnchorY: e.contentAnchorY ?? n.y,
    referencePointX: e.referencePointX ?? s.x,
    referencePointY: e.referencePointY ?? s.y
  };
}
function b6(e, n) {
  let s = 0, i = 0;
  if (e.width !== void 0) {
    const r = e.width !== 0 && e.width < Qt, o = n.x !== 0 && n.x < Qt;
    r && !o ? s = -e.width * 0.5 : o && !r && (s = n.x * 0.5);
  }
  if (e.height !== void 0) {
    const r = e.height !== 0 && e.height < Qt, o = n.y !== 0 && n.y < Qt;
    r && !o ? i = -e.height * 0.5 : o && !r && (i = n.y * 0.5);
  }
  return { offsetX: s, offsetY: i };
}
function U6(e, n, s, i, r, o, a) {
  const { contentAnchorX: c, contentAnchorY: l, referencePointX: h, referencePointY: d } = e, p = new N(
    c + h,
    l + d
  ), E = new N(
    n.x + s.x,
    n.y + s.y
  );
  switch (o) {
    case Yi.CENTER:
      p.x = c + h - (r.width ? r.width : i.x) * 0.5, E.x -= i.x * 0.5;
      break;
    case Yi.RIGHT:
      p.x = c + h - (r.width ? r.width : i.x), E.x -= i.x;
      break;
  }
  switch (a) {
    case Fs.MIDDLE:
      p.y = l + d - (r.height ? r.height : i.y) * 0.5, E.y -= i.y * 0.5;
      break;
    case Fs.BOTTOM:
      p.y = l + d - (r.height ? r.height : i.y), E.y -= i.y;
      break;
  }
  return { newPivotOffset: p, originPivotOffset: E };
}
function G6(e, n, s, i, r, o, a) {
  const { offsetX: c, offsetY: l } = a, h = new N(e.x, e.y), d = new Ce().translate_right(h.x, h.y).rotate_right(n).skew_right(Rt(s.x), Rt(s.y)).scale_right(i.x, i.y).translate_right(-r.x, -r.y), p = new Ce().translate_right(e.x, e.y).rotate_right(n).skew_right(Rt(s.x), Rt(s.y)).scale_right(i.x, i.y).translate_right(-o.x, -o.y), E = d.get_origin(), g = p.get_origin();
  return {
    x: c + h.x + (g.x - E.x),
    y: l + h.y + (g.y - E.y)
  };
}
let Ue = null, jg = null;
const tt = nt();
function Jg() {
  this.id = null, this.item = null, this.boundsLocal = new ye(), this.boundsLocal_zero = new ye(), this.boundsWorldAABB = new ye(), this.boundsWorldAABB_zero = new ye(), this.boundsVisualLocal = new ye(), this.boundsVisualWorldAABB = new ye(), this.subtreeBounds = new ye(), this.subtreeBoundsVersion = 0, this.pos = -1, this.parent = null, this.children = [], this.version = 0, this.geometryVersion = 0;
}
Jg.prototype = {
  constructor: Jg,
  reset() {
    this.id = null, this.item = null, this.boundsLocal.set(0, 0, 0, 0), this.boundsLocal_zero.set(0, 0, 0, 0), this.boundsVisualLocal.set(0, 0, 0, 0), this.boundsVisualWorldAABB.set(0, 0, 0, 0), this.boundsWorldAABB.set(0, 0, 0, 0), this.boundsWorldAABB_zero.set(0, 0, 0, 0), this.subtreeBounds.set(0, 0, 0, 0), this.subtreeBoundsVersion = 0, this.pos = -1, this.parent = null, this.children.length = 0, this.version = 0, this.geometryVersion = 0;
  },
  get isRoot() {
    return this.parent === null || this.id === Ue.root.id;
  },
  /* hierarchy */
  /**
   * @returns {SceneNode | null}
   */
  getFirstChild() {
    return this.children.length > 0 ? this.children[0] : null;
  },
  /**
   * @returns {SceneNode | null}
   */
  getLastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  },
  /**
   * @returns {SceneNode | null}
   */
  getNextSibling() {
    return !this.parent || this.pos < 0 ? null : this.parent.getChild(this.pos + 1);
  },
  /**
   * @returns {SceneNode | null}
   */
  getPrevSibling() {
    return !this.parent || this.pos < 0 ? null : this.parent.getChild(this.pos - 1);
  },
  /**
   * @param {SceneNode} node
   */
  addChild(e) {
    e.pos = this.children.length, this.children.push(e), e.parent = this, ad(e, this.item.depth + 1);
  },
  /**
   * @param {SceneNode} node
   * @param {number} pos
   */
  addChildAt(e, n) {
    if (!(n < 0 || n > this.children.length)) {
      this.children.length += 1;
      for (let s = this.children.length - 1; s > n; s--)
        this.children[s] = this.children[s - 1], this.children[s].pos = s;
      this.children[n] = e, e.pos = n, e.parent = this, ad(e, this.item.depth + 1);
    }
  },
  /**
   * This method is already very similar to `addChildAt` in the commit 2a7731a6569c36bb9e1114afa75864539a44e398
   * but the commit has a bug that it might create holes in the children array.
   * This implementation ensures there will be no holes in the children array, and also keeps the same logic as `addChildAt`.
   * I have not time to figure out why we need two different methods to the same thing, so just keep them for now.
   * @param {SceneNode} node
   * @param {number} pos
   */
  insertChildAt(e, n) {
    const s = Math.min(n, this.children.length);
    if (s === this.children.length)
      e.pos = s, this.children.push(e);
    else {
      this.children.length += 1;
      for (let i = this.children.length - 1; i > s; i--)
        this.children[i] = this.children[i - 1], this.children[i].pos = i;
      this.children[s] = e, e.pos = s;
    }
    e.parent = this, ad(e, this.item.depth + 1);
  },
  /**
   * @param {SceneNode} node
   */
  removeChild(e) {
    const n = this.children.indexOf(e);
    n < 0 || this.removeChildAt(n);
  },
  /**
   * @param {number} index
   */
  removeChildAt(e) {
    if (e < 0 || e >= this.children.length) return;
    const n = this.children[e];
    n.parent = null, n.pos = -1;
    const s = this.children.length - 1;
    for (let i = e; i < s; i++) {
      const r = this.children[i + 1];
      r.pos = i, this.children[i] = r;
    }
    this.children.length = s;
  },
  /**
   * @param {number} index
   * @returns {SceneNode}
   */
  getChild(e) {
    return e < 0 || e >= this.children.length ? null : this.children[e];
  },
  hasChildren() {
    return this.children.length > 0;
  },
  reverseChildren() {
    this.children = this.children.slice().reverse();
    for (let e = 0, n = this.children.length; e < n; e++)
      this.children[e].pos = e;
  },
  /* geometry */
  /**
   * @param {PathData} pathData
   * @param {[number, number]} rect
   */
  setGeometry(e, n = null) {
    const s = this.item;
    if (s.freed || !s.base.vector)
      return;
    s.base.shape = qe.createFromPathData(e), s.base.shape.version = -1, s.base.vector.rect = n, s.base.setShape(0, Tt.BASE, s.base.shape), s.update(Z.GEOMETRY);
    let i = this.parent;
    for (; i; )
      i = i.parent;
  },
  /* calculation */
  calcBounds(e = !1) {
    const n = Ue.view.getOrCreateDinoTree(this.item.id);
    if (n.base_path_id === 0)
      this.boundsLocal.set(0, 0, 0, 0), this.boundsLocal_zero.set(0, 0, 0, 0), this.boundsWorldAABB.set(0, 0, 0, 0), this.boundsWorldAABB_zero.set(0, 0, 0, 0);
    else {
      const s = mC(n.base_path_id);
      if (this.boundsLocal.set(s.x, s.y, s.w, s.h), this.item.isMaskGroup()) {
        const r = this.children[this.children.length - 1], o = Ue.view.getOrCreateDinoTree(r.id), a = new ye();
        for (let c = 0; c < o.strokes.children.length; c++) {
          const l = o.strokes.children[c], h = IC(l.path_id, l.stroke_data_id);
          a.merge_with({ x: h.x, y: h.y, width: h.w, height: h.h });
        }
        if (o.strokes.children.length > 0) {
          const c = r.item.transform.local.xform_rect(a);
          this.boundsLocal.merge_with(c);
        }
      }
      let i = K6(this.item, this.boundsLocal.clone());
      this.boundsLocal_zero.copy(i), i = this.item.transform.world.xform_rect(this.boundsLocal), this.boundsWorldAABB.set(i.x, i.y, i.width, i.height), i = this.item.transform.world.xform_rect(this.boundsLocal_zero), this.boundsWorldAABB_zero.set(i.x, i.y, i.width, i.height), this.boundsVisualWorldAABB = this.item.transform.world.xform_rect(this.boundsVisualLocal);
    }
    if (this.item.bounds.rect.copy(this.boundsLocal), this.item.bounds.visual.copy(this.boundsVisualLocal), e)
      for (let s = 0, i = this.children, r = i.length; s < r; s++)
        i[s].calcBounds(!0);
  },
  /**
   * @param {boolean} skipClippedArea if content clipped by parent should be ignored?
   * @returns {Rect2}
   */
  calcSubtreeBounds(e = !1) {
    const n = Ue.currentVersion();
    if (n && this.subtreeBoundsVersion === n)
      return this.subtreeBounds;
    if (this.item.type === "text") {
      const s = Ue.view.getOrCreateDinoTree(this.item.id), i = tt.getTextLayoutBox(s.text_node_id), r = new ye().set(i.x, i.y, i.w, i.h), o = this.item.transform.world.xform_rect(r);
      this.subtreeBounds.copy(this.boundsVisualWorldAABB.merge(o));
    } else
      this.subtreeBounds.copy(this.boundsVisualWorldAABB);
    if (!this.item.clipping || !e)
      for (let s = 0, i = this.children, r = i.length; s < r; s++) {
        const o = i[s].calcSubtreeBounds(e);
        o.is_zero() || (this.subtreeBounds.is_zero() ? this.subtreeBounds.copy(o) : this.subtreeBounds.merge_with(o));
      }
    return this.item.bounds.local.copy(this.boundsLocal_zero), this.item.bounds.world.copy(this.boundsWorldAABB_zero), this.item.bounds.rect.copy(this.item.bounds.local), Ue.selection.markDirty(this.item.id), n && (this.subtreeBoundsVersion = n), this.subtreeBounds;
  }
};
class F6 {
  /**
   * @param {VisualServer} vs
   */
  constructor(n) {
    Ue || (Ue = n), jg || (jg = this), this.root = null, this.nodeMap = /* @__PURE__ */ new Map();
  }
  clear() {
    this.root && ($g(this.root), this.root = null), this.nodeMap.clear();
  }
  /**
   * @param {DataStore} ds
   */
  connectDataStore(n) {
    if (n.workspace.on(Oe.SCENE_TREE_CHANGES, (s, i = { undoable: !0 }) => {
      const { oldParents: r, newParents: o, removed: a, added: c, moved: l, reordered: h } = VP(s);
      for (const d of a)
        this.deleteNode(d, r.get(d), l.size > 0);
      for (const d of c) {
        const p = o.get(d), g = n.getElement(p).children.indexOf(n.getElement(d)), T = this.nodeMap.get(p), A = this.createNodeFromDataStore(d);
        this.insertNode(A, T, g), Ue.view.createDinoNode(A), Ue.view.insertDinoNode(A, T, g);
        const m = n.getElement(d);
        if ((m.get("elementType") === Me.CONTAINER || m.get("elementType") === Me.BOOLEAN_CONTAINER || m.get("elementType") === Me.MASK_CONTAINER) && l.size === 0 && !s.UPDATE.has(d))
          for (const O of n.traverseSubtree(d, !1, !0)) {
            const S = n.getElement(O), y = S.get("parent"), v = y.children.indexOf(S), R = this.nodeMap.get(y.get("id")), M = this.createNodeFromDataStore(O);
            this.insertNode(M, R, v), Ue.view.createDinoNode(M), Ue.view.insertDinoNode(M, R, v);
          }
        this.updateTransformRecursively(A);
      }
      for (const d of l) {
        const p = o.get(d), g = n.getElement(p).children.indexOf(n.getElement(d));
        this.moveNode(d, p, g);
        const T = r.get(d), A = Ue.getRenderItem(d);
        if (!A) {
          console.warn(`[SpatialCache] cannot add item (id="${A.id}") to non-exist parent (id="${d}")`);
          continue;
        }
        A.transform._dirty = !0, A.baseTransform._dirty = !0;
        const m = Ue.getRenderItem(p);
        if (m.transform._dirty = !0, m.baseTransform._dirty = !0, T) {
          const O = Ue.dataStore.getById(d);
          this._updateBaseValues(O, A, m, i.undoable), n.isActionMode && (n.transition.cacheSpecificElementBaseValue(d, "motionPath"), this._updateComputedValues(O, A, m));
        }
      }
      for (const d of h) {
        const p = o.get(d), E = n.getElement(p).children.indexOf(n.getElement(d));
        this.reorderNode(d, E);
      }
    }), n.on(Oe.LOAD_START, () => {
      this.clear();
    }), n.on(Oe.LOAD, () => {
      const s = n.workspace.watched;
      this.loadFromDataStore(n, s);
    }), n.workspace.watched) {
      const s = n.workspace.watched;
      this.loadFromDataStore(n, s);
    }
    n.guidelines.on(Oe.GUIDELINES_CHANGES, (s) => {
      s.CREATE.forEach((i) => {
        const r = n.guidelines.getGuideline(i);
        r && RE(r);
      }), s.UPDATE.forEach((i, r) => {
        const o = n.guidelines.getGuideline(r);
        o && RE(o);
      }), s.DELETE.forEach((i) => {
        UH(i);
      });
    });
  }
  /**
   * @param {DataStore} ds
   * @param {Element} root
   */
  loadFromDataStore(n, s) {
    const i = s.get("id"), r = this.createNodeFromDataStore(i);
    for (const a of n.traverseSubtree(i, !1, !0)) {
      const c = n.getElement(a), l = c.get("parent"), h = l.children.indexOf(c), d = this.createNodeFromDataStore(a), p = this.nodeMap.get(l.get("id"));
      this.insertNode(d, p, h);
    }
    Ue.view = new PC(Ue), Ue.setRoot(r.id), Ue.view.setup(Ue.dataStore, Ue.root.id);
    const o = [
      ...n.guidelines.getGuidelineListVertical(),
      ...n.guidelines.getGuidelineListHorizontal()
    ];
    for (const a of o) {
      const c = n.guidelines.getGuideline(a);
      c && RE(c);
    }
  }
  /**
   * @param {NodeID} id
   * @returns {SceneNode}
   */
  makeNode(n) {
    const s = new Jg();
    return s.id = n, s.item = Ue.makeRenderItem(n), this.nodeMap.set(n, s), s;
  }
  /**
   * @param {NodeID} id
   * @returns {boolean}
   */
  hasNode(n) {
    return this.nodeMap.has(n);
  }
  /**
   * @param {NodeID} id
   * @returns {SceneNode}
   */
  getNode(n) {
    return this.hasNode(n) ? this.nodeMap.get(n) : (console.warn(`[SpatialCache] cannot find node (id="${n}")`), null);
  }
  /** @returns {SceneNode} */
  getRootNode() {
    return this.root;
  }
  /** @returns {SceneNode} */
  getWorkspaceNode() {
    return this.nodeMap.get(Ue.dataStore.workspace.watched.get("id"));
  }
  /** @returns {SceneNode} */
  getActiveScreenNode() {
    return this.getWorkspaceNode().getFirstChild();
  }
  /**
   * @param {NodeID} id
   * @returns {boolean}
   */
  isRoot(n) {
    return n === this.root.id;
  }
  /**
   * @param {SceneNode} node
   * @param {SceneNode} parent
   * @param {number} index
   * @returns {SceneNode}
   */
  insertNode(n, s, i) {
    return s.insertChildAt(n, i), s.item.isComputedGroup() && s.item.update(Z.GEOMETRY), n.item.update(Z.GEOMETRY | Z.TRANSFORM | Z.STYLE), n.item.base.mods.length = 3, n;
  }
  /**
   * @param {NodeID} id
   * @returns {SceneNode}
   */
  createNodeFromDataStore(n) {
    const s = this.makeNode(n), i = Ue.dataStore.getElement(n);
    return _B(Ue, s, i), parent.version = Ue.currentVersion(), s.version = parent.version, s;
  }
  /**
   * @param {NodeID} id
   * @param {NodeID} parentID
   * @param {bool} ignoreChildren
   */
  deleteNode(n, s, i = !1) {
    const r = this.nodeMap.get(s);
    if (!r) {
      console.warn(`[SpatialCache] cannot remove item (id="${n}") from non-exist parent (id="${s}")`);
      return;
    }
    const o = this.nodeMap.get(n);
    if (!o) {
      console.warn(`[SpatialCache] cannot remove non-exist item (id="${n}")`);
      return;
    }
    CB(o);
    const a = r.item.isMaskGroup() && r.getLastChild().id === o.id;
    r.removeChild(o), r.version = Ue.currentVersion(), o.version = r.version, Ue.view.removeDinoNode(o, r, a), i ? FN(o) : $g(o), (r.item.trim.enabled || r.item.isComputedGroup()) && r.item.update(Z.GEOMETRY);
  }
  /**
   * @param {NodeID} id
   * @param {NodeID} parentID
   * @param {number} index
   */
  moveNode(n, s, i) {
    const r = this.nodeMap.get(s);
    if (!r) {
      console.warn(`[SpatialCache] cannot find new parent (id="${s}")`);
      return;
    }
    const o = this.nodeMap.get(n);
    if (!o) {
      console.warn(`[SpatialCache] cannot find node (id="${n}")`);
      return;
    }
    const a = o.parent, c = a.item.isMaskGroup() && a.getLastChild().id === o.id;
    a.removeChild(o), a.version = Ue.currentVersion(), a.item.update(Z.GEOMETRY), r.addChildAt(o, i), r.version = Ue.currentVersion(), r.item.isComputedGroup() && r.item.update(Z.GEOMETRY), o.version = a.version, o.item.update(Z.TRANSFORM | Z.GEOMETRY), o.item.base.mods.length = 3, Ue.view.removeDinoNode(o, a, c), Ue.view.insertDinoNode(o, r, i);
  }
  /**
   * Reorder node to new index under the same parent
   * @param {NodeID} id
   * @param {number} index
   */
  reorderNode(n, s) {
    const i = this.nodeMap.get(n);
    if (!i) {
      console.warn(`[SpatialCache] cannot find item (id="${n}")`);
      return;
    }
    if (i.pos === s) return;
    i.parent.version = Ue.currentVersion(), i.parent.item.update(Z.GEOMETRY);
    const r = i.parent.children, o = s < i.pos ? -1 : 1;
    for (let a = i.pos; a !== s; a += o)
      r[a] = r[a + o], r[a].pos = a, r[a].version = i.parent.version;
    r[s] = i, i.pos = s, i.version = i.parent.version, i.item.update(Z.TRANSFORM | Z.GEOMETRY), Ue.view.reorderDinoNode(i, i.parent, s);
  }
  /** @param {SceneNode} node */
  updateTransformRecursively(n) {
    var r;
    const s = (r = n.parent) == null ? void 0 : r.item, i = n.id === this.root.id;
    if (s && !i ? (s.updateFlags & Z.TRANSFORM && n.item.update(Z.TRANSFORM), n.item.updateFlags & Z.TRANSFORM && (n.item.transform.update(), n.item.transform.updateWorld(s.transform), n.item.bounds.updateLocal(n.item.transform.local), n.item.bounds.updateWorld(n.item.transform.world)), n.item.transform.parent.copy(s.transform.world)) : (n.item.updateFlags & Z.TRANSFORM && (n.item.transform.update(), n.item.transform.updateWorld(new Ud()), n.item.bounds.updateLocal(n.item.transform.local), n.item.bounds.updateWorld(n.item.transform.world)), n.item.transform.parent.identity(), n.item.transform.world.copy(n.item.transform.local)), n.item.transform.worldInv.copy(n.item.transform.world).affine_inverse(), n.item.updateFlags & Z.TRANSFORM && (n.item.baseTransform.update(), s ? n.item.baseTransform.updateWorld(s.baseTransform) : n.item.baseTransform.updateWorld(new Ud()), AB(Ue, n), n.item.version = Ue.currentVersion()), n.children.length > 0)
      for (let o = 0, a = n.children, c = a.length; o < c; o++)
        this.updateTransformRecursively(a[o]);
  }
  /**
   * @param {RenderItem[]} nodeList
   */
  updateNodes(n) {
    var a;
    if (!this.root) return;
    const s = this.root.getFirstChild();
    let i = n.map((c) => this.nodeMap.get(c.id)).filter(Y6).sort(Xu);
    zt.log("max depth of the scene tree", i.length >= 1 ? i[0].item.depth : "no scene node updates"), zt.begin("node update/transform");
    const r = /* @__PURE__ */ new Set();
    for (const c of i)
      r.add(c), zt.beginSub("node update/transform"), this.updateTransformRecursively(c), zt.endSub("node update/transform"), c.item.trim.enabled && c.hasChildren() && kN(r, c), z6(r, c);
    zt.end("node update/transform"), i = [...r].sort(Xu);
    for (let c = i.length - 1; c >= 0; c--) {
      let l = i[c];
      r.add(l);
      let h = l, d = l.parent;
      for (; d && d !== s; )
        d.item.isBooleanGroup() && (r.add(d), d.item.update(Z.GEOMETRY)), d.item.isMaskGroup() && h === d.getLastChild() && (r.add(d), d.item.update(Z.GEOMETRY)), d.item.isNormalGroup() && (r.add(d), d.item.update(Z.GEOMETRY)), h = l, l = d, d = d.parent;
    }
    i = [...r].sort(Xu);
    for (let c = i.length - 1; c >= 0; c--) {
      const l = i[c], h = l.item;
      if (h.updateFlags & Z.STYLE && (mB(Ue, l), IB(Ue, l)), h.updateFlags & Z.GEOMETRY) {
        if (h.type === "text") {
          const d = Ue.view.getOrCreateDinoTree(h.id);
          tt.setNodeLineHeight(d.root_id, h.lineHeight), tt.setNodeLetterSpacing(d.root_id, h.letterSpacing), tt.setNodeFontSize(d.root_id, h.fontSize), tt.setNodeTextContent(d.root_id, h.content), tt.setNodeVerticalAlignment(d.root_id, h.verticalAlignment), tt.setNodeHorizontalAlignment(d.root_id, h.horizontalAlignment), h.base.shape = qe.createFromPathData(ki([h.transform.size.x, h.transform.size.y])), h.base.setShape(0, Tt.BASE, h.base.shape), h.base.vector.clear(), h.base.modVector = null, h.base.shape.version = -1, b0(Ue, h);
        }
        if (h.base.shape && (h.base.shape.version = -1, h.trim.enabled && !l.item.isContainerNormalGroup())) {
          const p = h.base.getFinalShape(0, Tt.SELF_TRIM).trimmed(
            h.trim.begin,
            h.trim.end,
            h.trim.offset,
            h.trim.mode
          );
          h.base.setShape(0, Tt.SELF_TRIM, p), p.version = -1;
        }
      }
      if (h.updateFlags & Z.NODE_SETTING) {
        const d = Ue.view.getOrCreateDinoTree(h.id);
        tt.setNodeBlend(d.root_id, yB(h.blendMode)), tt.setNodeVisible(d.root_id, h.visible), tt.setNodeOpacity(d.root_id, h.opacity);
      }
      h.version = Ue.currentVersion(), l.version = h.version;
    }
    zt.begin("node update/geometry modifier"), zt.begin("boolean"), zt.begin("trim");
    const o = [];
    for (let c = i.length - 1; c >= 0; c--) {
      const l = i[c];
      GN(l, o);
    }
    i = i.concat(o.filter((c) => {
      for (let l = 0; l < i.length; l++)
        if (c === i[l]) return !1;
      return !0;
    }).sort(Xu)), zt.end("node update/geometry modifier"), zt.end("boolean"), zt.end("trim"), zt.begin("node update/stroke"), zt.begin("node update/element hit test");
    for (let c = i.length - 1; c >= 0; c--) {
      const l = i[c], h = l.item;
      if (h.isNormalGroup()) {
        let A = null;
        for (let m = 0; m < l.children.length; m++) {
          const O = l.children[m];
          if (!O.item.visible || !O.item.base.shape || O.item.base.shape.isEmpty()) continue;
          const S = O.item.transform.local.xform_rect(O.boundsLocal);
          A ? A.merge_with(S) : A = S.clone();
        }
        A ? (h.base.shape = qe.createFromPathData(ki([A.width, A.height])), h.base.shape = h.base.shape.transform(new Ce().translate(A.x, A.y))) : h.base.shape = qe.create(), h.base.setShape(0, Tt.BASE, h.base.shape), h.base.vector.clear(), h.base.modVector = null, h.base.shape.version = -1;
      }
      if (h.isMaskGroup() && l.hasChildren()) {
        const A = l.getLastChild(), m = A.item;
        if (m.fillLayers.length) {
          let O = m.base.getFinalShape();
          if (h.type === "text") {
            const S = tt.getPathCmd(T.path_id), y = tt.getPathVtx(T.path_id);
            O = qe.createFromPathData(new Vs(y, S));
          }
          O && (h.base.shape = O.clone().transform(m.transform.local));
        } else if (m.strokes.length) {
          h.base.shape = new qe();
          for (let O = 0; O < m.strokes.length; O++) {
            const S = m.strokes[O].shape.clone().transform(m.transform.local);
            h.base.shape = h.base.shape.union(S);
          }
        } else if (m.isContainerNormalGroup()) {
          const O = A.item.transform.local.xform_rect(A.boundsLocal);
          O && (h.base.shape = qe.createFromPathData(ki([O.width, O.height])), h.base.shape = h.base.shape.transform(new Ce().translate(O.x, O.y)));
        }
        h.base.shape || (h.base.shape = new qe()), h.base.setShape(0, Tt.BASE, h.base.shape), h.base.shape.version = -1;
      }
      const d = ((a = h.base.shape) == null ? void 0 : a.version) < 0;
      if (d) {
        h.base.shape.version = Ue.currentVersion(), h.changed = !0, h.isEmpty = !1, (h.isBooleanGroup() || h.isMaskGroup()) && (h.base.vector.rect = null);
        const A = h.base.shape.toPathData();
        h.base.vector.path = A;
      }
      const p = h.base.getFinalShape(), E = (p == null ? void 0 : p.version) < 0, g = h.base.getFinalVector();
      if (d || E) {
        p.version = Ue.currentVersion(), h.changed = !0;
        const A = p.toPathData();
        g.path = A;
      }
      (!h.base.shape || h.base.shape.isEmpty()) && (h.isEmpty = !0);
      const T = Ue.view.getOrCreateDinoTree(h.id);
      {
        if (d) {
          const A = h.base.shape.toPathData();
          T.base_path_id === 0 && (T.base_path_id = tt.makePath(A)), tt.setPath(T.base_path_id, A);
        }
        if ((d || E || h.updateFlags & Z.STYLE) && VN(h), !h.clipping && T.children.compose[0] !== null && (tt.destroyNodeCompose(T.children.id, 0), T.children.compose[0] = null, tt.reorderNode(T.children.id, 2)), h.clipping && T.children.compose[0] === null) {
          T.children.compose[0] = new Xi(), T.children.compose[0].id = tt.makeNode(tt.GROUP), T.children.compose[0].children[0] = new Xi(), T.children.compose[0].children[0].id = tt.makeNode(tt.PATH), tt.addNodeChild(T.children.compose[0].id, T.children.compose[0].children[0].id);
          const A = tt.makeColor(0, 0, 0, 1);
          tt.setNodeFillPaint(T.children.compose[0].children[0].id, tt.COLOR, A), T.children.compose[0].children[0].path_id = T.path_id, tt.setNodePath(T.children.compose[0].children[0].id, T.path_id);
          const { scale: m, skew: O, rotation: S, translation: y } = h.transform.world.decompose();
          tt.setNodeTransform(
            T.children.compose[0].id,
            y.x,
            y.y,
            S,
            m.x,
            m.y,
            O.x,
            O.y
          );
          const v = 1;
          T.children.compose[0].comp_id = tt.makeCompose(v, T.children.compose[0].id), tt.setNodeCompose(T.children.id, 0, T.children.compose[0].comp_id), tt.reorderNode(T.children.id, 1);
        }
        T.children.compose[0] !== null && (d || E) && (tt.setPath(T.children.compose[0].children[0].path_id, g.path), tt.markNodeChanged(T.children.compose[0].children[0].id));
      }
      if (h.updateFlags & Z.GEOMETRY) {
        zt.beginSub("node update/stroke"), BN(h), h.meshChanged = !0, zt.endSub("node update/stroke");
        const A = mC(T.path_id), m = new ye(A.x, A.y, A.w, A.h);
        g.bounds.copy(m);
        for (let O = 0; O < T.strokes.children.length; O++) {
          const S = T.strokes.children[O], y = IC(S.path_id, S.stroke_data_id);
          m.merge_with(new ye(y.x, y.y, y.w, y.h));
        }
        l.boundsVisualLocal.copy(m), h.bbox.copy(l.boundsVisualLocal);
      }
      l.calcBounds(!!(h.updateFlags & Z.TRANSFORM)), h.updateFlags = 0;
    }
    zt.end("node update/stroke"), zt.end("node update/element hit test"), this.root.calcSubtreeBounds(), i.length > 0 && (Ue._dirty = !0);
  }
  /**
   * @param {Element} element
   * @param {RenderItem} node
   * @param {RenderItem} newParentNode
   * @param {boolean} undoable
   */
  _updateBaseValues(n, s, i, r) {
    const o = i.baseTransform, a = s.baseTransform;
    if (o.world.basis_determinant() === 0)
      return;
    const c = o.worldInv.clone();
    c.append(a.world);
    const l = a.getPivotOffset(), { rotation: h, scale: d, skew: p, position: E } = qS(c, l);
    E.add(l), n.setBaseProps(k6, [
      W6(E),
      B6(d),
      V6(p),
      H6(h)
    ], r);
  }
  /**
   * @param {Element} element
   * @param {RenderItem} item
   * @param {RenderItem} newParentItem
   */
  _updateComputedValues(n, s, i) {
    const r = i.transform, o = s.transform;
    if (r.world.basis_determinant() === 0)
      return;
    const a = r.worldInv.clone();
    a.append(o.world);
    const c = o.getPivotOffset(), { rotation: l, scale: h, skew: d, position: p } = qS(a, c), E = p.clone().add(c);
    n.sets({
      scale: h,
      skew: d,
      rotation: s.autoOrient ? l - s.orientRotation : l,
      translateX: E.x,
      translateY: E.y
    }, YP);
  }
}
const $g = (e) => {
  for (let n = 0, s = e.children, i = s.length; n < i; n++)
    $g(s[n]);
  FN(e);
}, GN = (e, n) => {
  const s = e.item;
  if (s.isBooleanGroup())
    zt.beginSub("boolean"), X6(e), zt.endSub("boolean"), n.push(e);
  else if (s.isContainerNormalGroup()) {
    const i = [];
    for (let r = 0, o = e.children, a = o.length; r < a; r++)
      GN(o[r], i);
    if (i.reverse(), s.trim.version < 0) {
      if (s.trim.enabled) {
        switch (zt.beginSub("trim"), e.item.trim.mode) {
          case ar.INDIVIDUALLY: {
            const r = qe.trimMultiple(
              e.item.trim.begin,
              e.item.trim.end,
              e.item.trim.offset,
              i.map((o) => o.item.base.getFinalShape(e.item.depth - o.item.depth + 1, Tt.PARENT_TRIM))
            );
            for (let o = 0; o < i.length; o++) {
              s.base.mods.length = 2 - e.item.depth + i[o].item.depth;
              const a = r[o].clone();
              a.version = -1, i[o].item.base.setShape(
                e.item.depth - i[o].item.depth,
                Tt.PARENT_TRIM,
                a
              ), i[o].item.update(Z.GEOMETRY);
            }
            break;
          }
          case ar.SIMULTANEOUSLY:
            for (let r = 0, o = i.length; r < o; r++) {
              const a = i[r], c = a.item.base.getFinalShape(
                e.item.depth - a.item.depth + 1,
                Tt.PARENT_TRIM
              ).trimmed(
                e.item.trim.begin,
                e.item.trim.end,
                e.item.trim.offset,
                e.item.trim.mode
              );
              a.item.base.setShape(
                e.item.depth - a.item.depth,
                Tt.PARENT_TRIM,
                c
              ), a.item.update(Z.GEOMETRY);
            }
            break;
        }
        zt.endSub("trim");
      } else {
        for (let r = 0, o = i.length; r < o; r++) {
          const a = i[r];
          a.item.base.deleteShape(Tt.PARENT_TRIM, s.depth - a.item.depth), a.item.update(Z.GEOMETRY), a.item.base.shape.version = -1;
        }
        s.base.deleteShape(Tt.SELF_TRIM), s.base.mods.length = 2, s.update(Z.GEOMETRY), s.base.shape && (s.base.shape.version = -1);
      }
      n.push(e), s.trim.version = Ue.currentVersion();
    }
    for (let r = 0, o = i.length; r < o; r++)
      n.push(i[r]);
  } else if (!s.isMaskGroup()) {
    if (s.trim.version < 0) {
      if (s.trim.enabled) {
        const i = s.base.getFinalShape(0, Tt.SELF_TRIM).trimmed(
          s.trim.begin,
          s.trim.end,
          s.trim.offset,
          s.trim.mode
        );
        i.version = -1, s.base.setShape(0, Tt.SELF_TRIM, i);
      } else
        s.base.deleteShape(Tt.SELF_TRIM), s.base.mods.length = 2;
      s.trim.version = Ue.currentVersion(), s.update(Z.GEOMETRY);
    }
    n.push(e);
  }
}, FN = (e) => {
  MH(e.id), Ue.destroyRenderItem(e.id), jg.nodeMap.delete(e.id), uB(e.id), Ue.view.destroyDinoNode(e);
}, k6 = ["translate", "scale", "skew", "rotation"], LE = { scaleX: 0, scaleY: 0 }, ME = { skewX: 0, skewY: 0 }, m1 = { rotation: 0 }, PE = { translateX: 0, translateY: 0 };
function B6(e) {
  return LE.scaleX = e.x, LE.scaleY = e.y, LE;
}
function V6(e) {
  return ME.skewX = e.x, ME.skewY = e.y, ME;
}
function H6(e) {
  return m1.rotation = e, m1;
}
function W6(e) {
  return PE.translateX = e.x, PE.translateY = e.y, PE;
}
const Xu = (e, n) => e.item.depth - n.item.depth, Y6 = (e) => !!e;
function U0(e, n) {
  if (!e.item.visible) return;
  const s = e.item;
  if (s.isContainerNormalGroup() || s.isMaskGroup()) {
    const i = e.children;
    for (let r = 0, o = i.length; r < o; r++)
      U0(i[r], n);
  } else {
    let i = null;
    if (!s.fillLayers.length && s.strokeLayers.length)
      BN(s), i = s.strokes[0].shape;
    else if (e.item.type === "text") {
      const o = Ue.view.getOrCreateDinoTree(e.id), a = tt.getPathCmd(o.path_id), c = tt.getPathVtx(o.path_id);
      i = qe.createFromPathData(new Vs(c, a));
    } else
      i = s.base.getFinalShape();
    const r = i.clone().transform(s.transform.world);
    n.push(r);
  }
}
function X6(e) {
  const n = e.children, s = [];
  for (let o = 0; o < n.length; o++)
    U0(n[o], s);
  e.geometryVersion = Ue.currentVersion();
  const i = e.item;
  let r = null;
  for (let o = 0; o < s.length; o++)
    r = r ? r[Jy[i.booleanType]](s[o]) : s[o];
  if ((!r || s.length === 0 || r.isEmpty()) && (r = qe.create()), r.transform(i.transform.world.clone().affine_inverse()), i.base.shape = r, i.base.shape.version = -1, i.base.setShape(0, Tt.BASE, r.clone()), e.item.cornerRadius > 0) {
    const o = Sg(r.toPathData(), e.item.cornerRadius);
    i.base.setShape(0, Tt.CORNER, qe.createFromPathData(o));
  }
  if (i.base.vector.clear(), i.base.modVector = null, i.trim.enabled) {
    const o = i.base.shape.trimmed(
      i.trim.begin,
      i.trim.end,
      i.trim.offset,
      // according to the spec, always use individual mode when trimming a boolean group
      ar.INDIVIDUALLY
    );
    i.base.setShape(0, Tt.SELF_TRIM, o), o.version = -1;
  } else
    i.base.deleteShape(Tt.SELF_TRIM);
  i.update(Z.GEOMETRY);
}
function kN(e, n) {
  if (!(n.item.isBooleanGroup() || n.item.isMaskGroup()))
    for (let s = 0, i = n.children, r = i.length; s < r; s++) {
      const o = i[s];
      e.add(o), o.item.update(Z.GEOMETRY), kN(e, o);
    }
}
function z6(e, n) {
  if (n.item.isBooleanGroup() || n.item.isMaskGroup()) {
    n.item.update(Z.GEOMETRY);
    return;
  }
  let s = n.parent ? n.parent.parent : null;
  for (; s; )
    s.item.trim.enabled && (e.add(s), s.item.update(Z.GEOMETRY), n.item.trim.version < 0 && (s.item.trim.version = -1)), s = s.parent;
}
function BN(e) {
  for (let n = 0; n < e.strokes.length; n++) {
    const s = e.strokes[n];
    if (!s)
      break;
    let i = 0;
    switch (s.style.startCap) {
      case cn.NONE: {
        i = 0;
        break;
      }
      case cn.ROUND: {
        i = 1;
        break;
      }
      case cn.SQUARE_SOLID: {
        i = 2;
        break;
      }
    }
    let r = 0;
    switch (s.style.join) {
      case Us.MITER: {
        r = 0;
        break;
      }
      case Us.BEVEL: {
        r = 1;
        break;
      }
      case Us.ROUND: {
        r = 2;
        break;
      }
    }
    {
      VN(e), e.type === "text" && b0(Ue, e);
      const o = Ue.view.getOrCreateDinoTree(e.id);
      if (o.strokes.children[n]) {
        o.strokes.children[n].stroke_data_id === 0 ? (o.strokes.children[n].stroke_data_id = tt.makeStroke(s.style.width, i, r, s.style.miterLimit, s.style.dashPattern[0], s.style.dashPattern[1]), tt.setNodeStrokeData(o.strokes.children[n].id, o.strokes.children[n].stroke_data_id)) : (tt.destroyStrokePathCache(o.strokes.children[n].id, o.strokes.children[n].stroke_data_id), tt.setStroke(o.strokes.children[n].stroke_data_id, s.style.width, i, r, s.style.miterLimit, s.style.dashPattern[0], s.style.dashPattern[1]), tt.markNodeChanged(o.strokes.children[n].id));
        const a = tt.getStrokePathCmd(o.path_id, o.strokes.children[n].stroke_data_id), c = tt.getStrokePathVtx(o.path_id, o.strokes.children[n].stroke_data_id);
        s.shape = qe.createFromPathData(new Vs(c, a));
      }
    }
  }
}
const Uo = new N(0, 0), K6 = (e, n) => {
  if (Uo.set(0, 0), e.isComputedGroup()) {
    const a = Ue.dataStore.getElement(e.id).get("referencePoint");
    Uo.set(a[0], a[1]);
  }
  const s = e.sizeFlag, i = e.transform.size.x, r = e.transform.size.y;
  if (s.w === "f0" && s.h === "f0" || s.w === "t0" && s.h === "f0" || s.w === "f0" && s.h === "t0") {
    const o = i * 0.5 - Uo.x, a = r * 0.5 - Uo.y, c = 0, l = 0;
    return new ye(o, a, c, l);
  }
  if (s.w === "f0") {
    const o = i * 0.5 - Uo.x, a = -Uo.y, c = 0, l = r;
    return new ye(o, a, c, l);
  }
  if (s.h === "f0") {
    const o = -Uo.x, a = r * 0.5 - Uo.y, c = i, l = 0;
    return new ye(o, a, c, l);
  }
  return n;
}, ad = (e, n) => {
  e.item.depth = n;
  for (let s = 0, i = e.children, r = i.length; s < r; s++)
    ad(i[s], n + 1);
}, VN = (e) => {
  const n = Ue.view.getOrCreateDinoTree(e.id);
  if (e.type !== "text") {
    const s = e.base.getFinalShape().toPathData();
    n.path_id === 0 && (n.path_id = tt.makePath(s)), tt.setPath(n.path_id, s);
  }
  for (let s = 0; s < n.fills.children.length; s++)
    n.fills.children[s].path_id === 0 ? (n.fills.children[s].path_id = n.path_id, tt.setNodePath(n.fills.children[s].id, n.path_id)) : tt.markNodeChanged(n.fills.children[s].id);
  for (let s = 0; s < n.strokes.children.length; s++)
    n.strokes.children[s].path_id === 0 ? (n.strokes.children[s].path_id = n.path_id, tt.setNodePath(n.strokes.children[s].id, n.path_id)) : tt.markNodeChanged(n.strokes.children[s].id);
}, es = nt();
class Q6 {
  /**
   * Creates a new clipboard
   * @param {VisualServer} visualServer
   */
  constructor(n) {
    this.vs = n, this.pathCommands = ve;
  }
  inject() {
    this.vs.dataStore.injectDrawInfo(this);
  }
  /**
   * Gets reference to canvas element
   * @returns {HTMLCanvasElement}
   */
  getCanvas() {
    return this.vs.canvas;
  }
  /**
   * Convert mouse position to world position
   * @param {Vector2} mousePos
   * @returns {Vector2} output position
   */
  convertMousePosToWorldPosition(n) {
    return this.vs.viewport.toWorld(n);
  }
  toBaseWorldPosition(n, s, i = new N()) {
    const r = this.vs.getRenderItem(n);
    if (!r)
      throw new Error(`Invalid element ID provided ${n}`);
    if (this.vs.dataStore.isWorkspace(n))
      return i.x = s.x, i.y = s.y, i;
    const o = r.baseTransform.world, a = this._applyMatrix(s, o);
    return i instanceof N ? (i.x = a.x, i.y = a.y) : (i[0] = a.x, i[1] = a.y), i;
  }
  /**
   * Converts object space position into world space position
   * @param {string} elementId  element in which space input position is defined.
   *                             for mesh point positions, it's the element itself
   *                             for element position, it is that element's parent
   * @param {Vector2} pos input position
   * @param {Vector2} [out] output position
   * @returns {[number, number]}  output position (in world space)
   */
  toWorldPosition(n, s, i = new N()) {
    const r = this.vs.getRenderItem(n);
    if (!r)
      throw new Error(`Invalid element ID provided ${n}`);
    if (this.vs.dataStore.isWorkspace(n))
      return i.x = s.x, i.y = s.y, i;
    const o = r.transform.world, a = this._applyMatrix(s, o);
    return i instanceof N ? (i.x = a.x, i.y = a.y) : (i[0] = a.x, i[1] = a.y), i;
  }
  vertex2World(n, s, i = new N()) {
    const r = this.vs.getRenderItem(n);
    if (!r)
      throw new Error(`Invalid element ID provided ${n}`);
    const o = this._getPathTransform(r), a = this._applyMatrix(s, o);
    return i instanceof N ? (i.x = a.x, i.y = a.y) : (i[0] = a.x, i[1] = a.y), i;
  }
  getVerticesBoundWorld(n) {
    const s = new Fn(), i = this.vs.getRenderItemOfElement(n), r = this._getPathTransform(i), o = n.get("geometry").get("mesh"), a = new N(), c = new N();
    for (const l of o.getVertices())
      a.x = l.pos[0], a.y = l.pos[1], r.xform(a, c), s.minMax([c.x, c.y]);
    return s;
  }
  world2Vertex(n, s, i = new N()) {
    const r = this.vs.getRenderItem(n);
    if (!r)
      throw new Error(`Invalid element ID provided ${n}`);
    const o = this._getPathTransform(r);
    o.affine_inverse();
    const a = this._applyMatrix(s, o);
    return i instanceof N ? (i.x = a.x, i.y = a.y) : (i[0] = a.x, i[1] = a.y), i;
  }
  /**
   *
   * @param {RenderItem} node
   * @returns {Transform2D}
   */
  _getPathTransform(n) {
    const { translate: s, rotation: i, scale: r, skew: o, contentAnchor: a } = n.transform;
    return n.transform.parent.clone().translate_right(s.x, s.y).rotate_right(i).skew_right(Rt(o.x), Rt(o.y)).scale_right(r.x, r.y).translate_right(-a.x, -a.y);
  }
  /**
   * Converts world space position into object space position
   * @param {string} elementId  element to which space input position needs to be converted.
   *                             for mesh point positions, it's the element itself
   *                             for element position, it is that element's parent
   * @param {[number, number]} pos input position
   * @param {[number, number]} out output position
   * @param {Vector2} [offset]
   * @returns {[number, number]}  output position (in world space)
   */
  toObjectPosition(n, s, i = new N(), r) {
    const o = this.vs.getRenderItem(n);
    if (!o)
      throw new Error(`Invalid element ID provided ${n}`);
    const a = o.transform.worldInv, c = this._applyMatrix(s, a, void 0, r);
    return i.x = c.x, i.y = c.y, i;
  }
  /**
   * Returns bounds of the viewport
   * @param {AABB} vpBounds   if provided, will set viewport bounds into this AABB and return it
   * @returns {AABB}  vpBounds if provided, otherwise new instance of AABB with viewport bounds
   */
  getViewportBounds(n = new Fn()) {
    return n.copy(this.vs.viewport.rectW), n;
  }
  /**
   * Returns current selection bounds
   * @param {AABB} bounds   if provided, will set selection bounds into this AABB and return it
   * @param {boolean} onlyVisible if ture, the bound only includes visible elements
   * @returns {AABB}        if provided, otherwise new instance of AABB with selection bounds
   */
  getSelectionBoundsWorld(n = new Fn(), s = !1) {
    if (!s)
      return n.copy(this.vs.selection.bounds);
    const i = new ye();
    for (const { node: r } of this.vs.selection.iter())
      r.item.visible && (i.is_zero() ? i.copy(r.boundsWorldAABB) : i.merge_with(r.boundsWorldAABB));
    return n.copy(i);
  }
  /**
   * Generate current boolean result bounds of the given elements
   * Notice: this function will utlize boolean algorithm which might be a heavy calculation,
   * should be careful to use it.
   * @param {BooleanOperation} booleanType
   * @param {Element} parent
   * @param {[Element]} elements
   * @returns {AABB}
   */
  getBooleanlocalBounds(n, s, i) {
    const r = new Fn(), o = [];
    for (let l = 0; l < i.length; l++) {
      const h = this.vs.indexer.getNode(i[l].get("id"));
      U0(h, o);
    }
    let a = null;
    for (let l = 0; l < o.length; l++)
      a = a ? a[Jy[n]](o[l]) : o[l];
    if (!a || a.isEmpty()) {
      const h = this.getSelectionBoundsWorld(r).topLeft, d = new Vs();
      d.commands = [1], d.vertices = [h.x, h.y], a = qe.createFromPathData(d);
    }
    const c = a.getBounds();
    return r.copy(c);
  }
  /**
   * Generate current bounds of the element
   * @param {Element} element
   * @param {AABB} bounds
   * @param {boolean} including_stroke
   * @returns {AABB}
   */
  getElementBounds(n, s = new Fn(), i = !1) {
    const r = this.vs.indexer.getNode(n.get("id"));
    let o = r.item.base.getFinalShape();
    o = o.clone().transform(r.item.transform.local);
    const a = o.getBounds().clone();
    if (i)
      for (let c = 0; c < r.item.strokeLayers.length; c++) {
        const l = r.item.strokes[c].style, h = r.item.base.getFinalShape();
        let d = gk(h, l);
        d = d.clone().transform(r.item.transform.local), a.merge_with(d.getBounds());
      }
    return s.copy(a);
  }
  /**
   * @typedef {object} GradientHandles
   * @property {Vector2} center
   * @property {Vector2} bottom
   * @property {Vector2} left
   */
  /**
   * getGradientHandlesPosition
   * @param {number} width
   * @param {number} height
   * @param {boolean} isLinear
   * @param {number[]} gradientTransform
   * @returns {GradientHandles}
   */
  getGradientHandlesPosition(n, s, i, r) {
    const o = new Ce();
    return o.set(...r).affine_inverse().scale(n, s), {
      center: o.xform(i ? yC : CC),
      bottom: o.xform(NC),
      left: o.xform(xC)
    };
  }
  centerSelection() {
    MN();
  }
  _applyMatrix(n, s, i = new N(), r = void 0) {
    return n instanceof N ? i.set(n.x, n.y) : i.set(n[0], n[1]), r && i.add(r), s.xform(i, i), i;
  }
  getMeshOutlinesForExport(n, s) {
    const i = /* @__PURE__ */ new Set();
    X1(n, i);
    const r = new Vs(), o = (a, c) => {
      const l = a.cellTable.get(c).pos;
      return [l[0] - s[0], l[1] - s[1]];
    };
    for (const a of i)
      Y1(n, a, r, o, !0);
    return r;
  }
  /**
   * Get position fixed by other properties changes, always call this function before apply changes, the change should only contain one type of property
   * @param {string} elementId
   * @param {object} changes
   * @param {Vector2} specifiedRefPoint
   * @returns {object|number|null} translate | translate.x | translate.y | null
   */
  getFixedPositionByChanges(n, s, i) {
    const r = this.vs.getRenderItem(n);
    if (!r)
      return null;
    const o = r.transform;
    if (s.contentAnchorX === void 0 && s.contentAnchorY === void 0 && s.width === void 0 && s.height === void 0)
      return null;
    let a, c, l;
    const h = o.contentAnchor;
    if (i === void 0) {
      a = o.local.get_origin();
      const b = o.referencePoint;
      c = b.x, l = b.y;
    } else {
      c = i.x, l = i.y;
      const { translate: b, rotation: X, scale: K, skew: V } = o, J = new Ce();
      J.translate_right(b.x, b.y).rotate_right(X).skew_right(Rt(V.x), Rt(V.y)).scale_right(K.x, K.y).translate_right(-h.x, -h.y).translate_right(-c, -l), a = J.get_origin();
    }
    let d = h.x, p = h.y;
    const E = o.size.x, g = o.size.y, T = o.translate.x, A = o.translate.y;
    s.contentAnchorX !== void 0 && (d = s.contentAnchorX), s.contentAnchorY !== void 0 && (p = s.contentAnchorY);
    let m = 0, O = 0;
    if (s.width !== void 0) {
      const b = s.width !== 0 && s.width < Wo, X = E !== 0 && E < Wo;
      b && !X ? m = -s.width * 0.5 : X && !b && (m = E * 0.5);
    }
    if (s.height !== void 0) {
      const b = s.height !== 0 && s.height < Wo, X = g !== 0 && g < Wo;
      b && !X ? O = -s.height * 0.5 : X && !b && (O = g * 0.5);
    }
    s.referencePointX !== void 0 && (c = s.referencePointX), s.referencePointY !== void 0 && (l = s.referencePointY);
    const S = new N(
      d + c,
      p + l
    ), y = new N(T, A), v = o.skew, R = o.scale, M = o.rotation, P = new Ce().translate_right(y.x, y.y).rotate_right(M).skew_right(Rt(v.x), Rt(v.y)).scale_right(R.x, R.y).translate_right(-S.x, -S.y).get_origin(), k = m + y.x + (a.x - P.x), Q = O + y.y + (a.y - P.y);
    return new N(k, Q);
  }
  /**
   * Get the properties of the children after resize
   * @param {Element} element
   * @param {number} originalWidth
   * @param {number} originalHeight
   * @param {number} newWidth
   * @param {number} newHeight
   * @returns {Map<string, object>}
   */
  getChildrenPropertiesAfterResize(n, s, i, r, o) {
    const a = /* @__PURE__ */ new Map();
    if (!this.vs.getRenderItem(n.get("id")))
      return a;
    let l = s, h = i;
    s === 0 && (l = Es), i === 0 && (h = Es);
    const d = new N(r / l, o / h);
    for (const p of n.children) {
      const E = p.get("id"), g = this.vs.getRenderItem(E), T = g.transform;
      if (!g) continue;
      const A = new Ce().scale_right(d.x, d.y).rotate_right(T.rotation).skew_right(T.skew.x, T.skew.y), { rotation: m, scale: O, skew: S } = A.decompose(), y = new N().copy(T.size).multiply(O), v = new N().copy(T.translate).multiply(d), R = new N().copy(T.contentAnchor).multiply(O), M = p.get("referencePoint"), L = new N(M[0], M[1]).multiply(O);
      if (p.isText) {
        const k = this.vs.indexer.getNode(E);
        k.item.resizingMode === co[Ht.AUTO_WIDTH] ? (Math.abs(y.x - T.size.x) > 0.01 && p.set("resizingMode", Ht.AUTO_HEIGHT), Math.abs(y.y - T.size.y) > 0.01 && p.set("resizingMode", Ht.FIXED)) : k.item.resizingMode === co[Ht.AUTO_HEIGHT] && Math.abs(y.y - T.size.y) > 0.01 && p.set("resizingMode", Ht.FIXED);
      }
      const P = {
        skew: new N(S.x, S.y),
        rotation: m
      };
      T.scale.x !== 0 && (P.width = y.x, P.translateX = v.x, P.contentAnchorX = R.x, P.referencePointX = L.x), T.scale.y !== 0 && (P.height = y.y, P.translateY = v.y, P.contentAnchorY = R.y, P.referencePointY = L.y), a.set(E, P);
    }
    return a;
  }
  /**
   * Update render data from dirty nodes at the moment
   */
  updateNodes() {
    const n = [...this.vs.updateList.values()];
    this.vs.indexer.updateNodes(n), this.vs.updateList.clear();
  }
  /**
   * Check whether the element is present in SpacialCache.nodeMap
   * @param {string} elementId
   * @returns {boolean}
   */
  isNodePresent(n) {
    return !!this.vs.indexer.getNode(n);
  }
  /**
   * Trigger updateNodes first then get the latest bounds of the element
   * @param {string} elementId
   * @returns {Rect2}
   */
  getLatestLocalBounds(n) {
    return this.vs.indexer.getNode(n).boundsLocal;
  }
  updateMotionPathPointShape(n, s) {
    N4(n, s);
  }
  /**
   * @param {PointShape} point
   * @param {string} type
   */
  updateMotionPointCurveControl(n, s) {
    const i = s === "in" ? "out" : "in", r = new N().fromArray(n[i]), o = new N(-n[s][0], -n[s][1]);
    switch (n.mirror) {
      case pe.ANGLE: {
        const a = r.length();
        o.normalize().scale(a), n[i] = [o.x, o.y];
        break;
      }
      case pe.ANGLE_AND_LENGTH: {
        n[i] = [o.x, o.y];
        break;
      }
      case pe.NONE:
      case pe.INDEPENDENT:
        break;
    }
  }
  /**
   * @param {CubicBez} curve
   * @param {number} percent
   * @returns {CubicBez}
   */
  subdivideMotionPath(n, s) {
    const i = new ae().initWithPointsAndHandlesN(...n), o = i.getLength() * s;
    return ae.subdivide(i.getValues(), i.getTimeAt(o));
  }
  /**
   * Update render data from dirty nodes at the moment
   * @param {string} id
   * @returns {PathData}
   */
  getTextPathDataWithPathID(n) {
    const i = this.vs.view.getOrCreateDinoTree(n).path_id, r = es.getPathCmd(i), o = es.getPathVtx(i);
    return new Vs(o, r);
  }
  /**
   * Generates a path representation of text with specified styling options
   *
   * This method creates a path that represents text with the given font size, line height,
   * and letter spacing. If any of these parameters are not provided, it falls back to
   * the element's default values.
   *
   * @param {string} elementId - The ID of the text element
   * @param {number} [fontSize] - Font size to use (defaults to element's fontSize if not provided)
   * @param {number} [lineHeight] - Line height to use (defaults to element's lineHeight if not provided)
   * @param {number} [letterSpacing] - Letter spacing to use (defaults to element's letterSpacing if not provided)
   * @returns {PathData} A PathData object containing the commands and vertices for the text path
   */
  getTextPathWithStyle(n, s, i, r) {
    const o = this.vs.indexer.nodeMap.get(n).item, a = this.vs.view.getOrCreateDinoTree(n), c = a.text_node_id, l = a.text_doc_id, h = {
      font_family: o.fontFamily,
      font_style: o.fontStyle,
      font_weight: o.fontWeight,
      font_size: s || o.fontSize,
      // Font size, minimum value is 1
      letter_spacing: r ?? o.letterSpacing,
      // Value can be 0
      line_spacing: i ?? o.lineHeight,
      // Value can be 0
      paragraph_spacing: o.paragraphSpacing || 0,
      text_horizontal_alignment: o.horizontalAlignment,
      text_vertical_alignment: o.verticalAlignment
    }, { commands: d, vertices: p } = nt().getTextPathWithStyle(c, l, h);
    return new Vs(p, d);
  }
  /**
   * @param {SceneNode} node
   * @param {PathData} pathData
   */
  handleTextPaintsLayer(n, s) {
    const i = this.vs.view.getOrCreateDinoTree(n.id);
    es.setPath(i.path_id, s), n.setGeometry(s);
    for (let r = 0; r < i.fills.children.length; r++) {
      const o = i.fills.children[r];
      es.destroyNode(o.id), o.id = es.makeNode(es.PATH), es.setNodePath(o.id, i.path_id), n.item.visualServer.view.setParent(o.id, n.item.id), es.addNodeChild(i.fills.id, o.id), es.setNodeFillPaint(o.id, o.fill_tag, o.fill_id), es.markNodeChanged(o.id);
    }
    for (let r = 0; r < i.strokes.children.length; r++) {
      const o = i.strokes.children[r];
      es.destroyNode(o.id), o.id = es.makeNode(es.PATH), es.setNodePath(o.id, i.path_id), n.item.visualServer.view.setParent(o.id, n.item.id), es.addNodeChild(i.strokes.id, o.id), es.setNodeStrokeData(o.id, o.stroke_data_id), es.setNodeStrokePaint(o.id, o.stroke_tag, o.stroke_id), es.markNodeChanged(o.id);
    }
  }
  /**
   * @param {PathData} pathData
   * @returns {Rect2}
   */
  getTextPathOffset(n) {
    return qe.createFromPathData(n).getBounds();
  }
  /**
   * @param {PathData} pathData
   * @param {number} x
   * @param {number} y
   * @returns {PathData}
   */
  translatePathData(n, s, i) {
    const r = new Ce().translate(s, i);
    return n.applyXorm(r);
  }
  setTextEditingMode(n, s = null) {
    const i = this.vs.view.getOrCreateDinoTree(n);
    if (s) {
      const r = this.vs.dataStore.getElement(n).get("content"), { start: o, end: a, cursor: c } = s, { start_block: l, start_char: h, end_block: d, end_char: p, cursor_index: E, active_block_index: g } = qg(r, o, a, c);
      nt().enterTextEditingMode(i.text_node_id, l, h, d, p, E, g);
    } else
      nt().enterTextEditingMode(i.text_node_id, -1, 0, 0, 0, 0, 0);
    document.getElementById("input").focus();
  }
  changeTextEditingNode(n, s) {
    const i = this.vs.view.getOrCreateDinoTree(n);
    nt().changeTextEditingNode(i.text_node_id, s);
  }
  exitTextEditingMode() {
    nt().exitTextEditingMode(), document.getElementById("input").blur(), setTimeout(() => {
      document.activeElement.id === "input" && document.getElementById("input").blur();
    }, 100);
  }
  setForceDefaultCursor(n) {
    nt().setForceDefaultCursor(n);
  }
  getUpdatedTextPathBBox(n) {
    const s = this.vs.view.getOrCreateDinoTree(n), i = this.vs.indexer.getNode(n);
    return b0(this.vs, i.item), nt().getTextPathBBox(s.text_doc_id);
  }
  /**
   * Updates text element properties based on text content and style
   * Used for both interpolatable and non-interpolatable changes in design mode
   *
   * @param {Element} element - The text element to update
   * @param {object} options - Additional options for the update
   * @returns {void}
   */
  updateTextProperties(n, s) {
    const i = n.get("id");
    if (n.get("resizingMode") === Ht.FIXED || !this.vs.indexer.hasNode(i))
      return;
    if (this.vs.view.getOrCreateDinoTree(i).text_doc_id) {
      const a = this.getUpdatedTextPathBBox(i);
      bN(this.vs, n, a.w, a.h, s), this.vs.indexer.getNode(i).item.update(Z.TRANSFORM), this.updateNodes();
    } else
      console.warn("No text document ID found for element:", i);
  }
  /**
   * Updates text element properties for non-interpolatable changes
   * Handles special cases like content changes, alignment changes, and resizing mode changes
   *
   * @param {Element} element - The text element to update
   * @param {Map<string, any>} changes - Map of property changes
   * @param {object} options - Additional options for the update
   */
  updateTextNonInterpolatableProps(n, s, i) {
    var r;
    if (s.has("content") || s.has("horizontalAlignment") || s.has("verticalAlignment"))
      this.updateTextProperties(n, i);
    else if (s.has("resizingMode")) {
      const o = s.get("resizingMode").value, a = s.get("resizingMode").original, c = (r = this.vs.dataStore.selection) == null ? void 0 : r.selectedActionId;
      switch (o) {
        case Ht.AUTO_WIDTH:
          this.updateTextProperties(n, i), this.vs.dataStore.interaction.deleteElementPropertyTrack(c, n.get("id"), "dimensions", !0);
          break;
        case Ht.AUTO_HEIGHT:
          a === Ht.FIXED && (this.vs.dataStore.interaction.deleteElementPropertyTrack(c, n.get("id"), "dimensions", !0), this.updateTextProperties(n, i));
          break;
      }
    } else (s.has("width") || s.has("height") || s.has("size")) && this.updateTextProperties(n, i);
  }
  getAutoHeightValue() {
    const n = this.vs.dataStore.selection.get("elements")[0].get("id"), s = this.vs.view.getOrCreateDinoTree(n);
    return Math.round(100 * nt().getTextAutoLineHeightValue(s.text_node_id));
  }
  updateTextRange(n, s, i) {
    const r = this.vs.dataStore.selection.get("elements")[0].get("id"), o = this.vs.view.getOrCreateDinoTree(r), a = this.vs.dataStore.getElement(r).get("content"), { start_block: c, start_char: l, end_block: h, end_char: d, cursor_index: p, active_block_index: E } = qg(a, n, s, i);
    nt().setTextSelection(o.text_doc_id, c, l, h, d, p, E);
  }
}
let zu = null;
const bE = nt(), Z6 = () => ({
  id: null,
  img: null,
  node_ids: /* @__PURE__ */ new Set(),
  texture_id: null,
  _dirty: !1,
  dino_image_id: 0,
  pixels: []
});
class q6 {
  constructor() {
    this.id = `@res[${j6++}]`, this.colorStops = [];
  }
  /**
   * @param {Array<{ position: number, color: RGBA }>} stops
   */
  setColorStops(n) {
    this.colorStops.length = 0;
    const s = [];
    for (const { position: i, color: r } of n) {
      const o = [
        r[0],
        r[1],
        r[2],
        r[3]
      ];
      s.push({
        pos: i,
        color: o
      });
    }
    this.colorStops = s.sort((i, r) => i.pos - r.pos);
  }
}
let j6 = 1;
class J6 {
  static instance() {
    return O1;
  }
  /**
   * @param {VisualServer} vs
   */
  constructor(n) {
    zu || (zu = n), this.images = /* @__PURE__ */ new Map(), this.gradients = /* @__PURE__ */ Object.create(null), O1 = this;
  }
  /**
   * @param {string} id
   * @returns {ImageResource}
   */
  createImageResource(n) {
    const s = Z6();
    return s.id = n, this.images.set(n, s), s;
  }
  /**
   * @param {string} id
   * @returns {ImageResource}
   */
  getImageResource(n) {
    return this.images.get(n);
  }
  /**
   * @param {string} id
   */
  destroyImageResource(n) {
    this.images.get(n) && this.images.set(n, null);
  }
  /**
   * load image from src string
   * @param {string} id
   * @param {string} src - any src string that `HTMLImageElement` supports
   */
  loadImage(n, s) {
    const i = this.images.get(n), r = new Image();
    r.onload = () => {
      i.img = r, i._dirty = !0;
      const o = document.createElement("canvas"), a = o.getContext("2d");
      o.width = r.width, o.height = r.height, a.drawImage(r, 0, 0), i.pixels = a.getImageData(0, 0, r.width, r.height).data;
    }, r.onerror = () => {
    }, r.crossOrigin = "anonymous", r.src = s;
  }
  /**
   * update image resource if it's dirty, and update all nodes that use this image
   * @param {string} id
   */
  updateImageResource(n) {
    const s = this.images.get(n);
    if (s._dirty) {
      s._dirty = !1, bE.setImageWithPixels(s.dino_image_id, s.pixels, s.img.width, s.img.height);
      for (const i of s.node_ids) {
        zu.indexer.getNode(i).item.styleUpdated();
        const o = zu.view.getOrCreateDinoTree(i);
        bE.markNodeChanged(o.fills.id), bE.markNodeChanged(o.strokes.id);
      }
    }
  }
  /**
   * @param {string} [id]
   * @returns {GradientResource}
   */
  createGradientResource(n) {
    const s = new q6(this.gfx);
    return n && (s.id = n), this.gradients[s.id] = s, s;
  }
  /**
   * @param {string} id
   */
  destroyGradientResource(n) {
    if (!this.gradients[n]) {
      delete this.gradients[n];
      return;
    }
    delete this.gradients[n];
  }
  /**
   * @param {string} id
   * @returns {GradientResource}
   */
  getGradientResource(n) {
    return this.gradients[n];
  }
  update() {
    for (const [n] of this.images)
      this.updateImageResource(n);
  }
  clear() {
    for (const n in this.images)
      this.destroyImageResource(n);
    this.images = /* @__PURE__ */ new Map();
    for (const n in this.gradients)
      this.destroyGradientResource(n);
    return this.gradients = /* @__PURE__ */ Object.create(null), !0;
  }
}
let O1 = null;
const pc = {};
class $6 {
  /**
   * @param {VisualServer} vs
   */
  constructor(n) {
    this.vs = n, this._selected = /* @__PURE__ */ new Set(), this.bounds = new ye(), this._dirtyBounds = !0;
  }
  get anySelected() {
    return this._selected.size > 0;
  }
  /**
   * @returns {number} number of nodes in selection
   */
  get size() {
    return this._selected.size;
  }
  get containsMultiple() {
    return this._selected.size > 1;
  }
  /**
   * Returns selected node/element only if it is single. Otherwise returns null
   * @returns {SelectedItem|null}
   */
  get single() {
    if (this._selected.size === 1) {
      const n = this._selected.values().next().value;
      return this._assignToTmp(n), pc;
    }
    return null;
  }
  /**
   * @returns {SelectedItem|null} Returns first element in selection. Or null if no elements are selected
   */
  get first() {
    if (this._selected.size > 0) {
      const n = this._selected.values().next().value;
      return this._assignToTmp(n), pc;
    }
    return null;
  }
  /**
   * @param {(item: SelectedItem) => boolean} fn
   * @returns {boolean}
   */
  all(n) {
    for (const s of this.iter())
      if (!n(s))
        return !1;
    return !0;
  }
  *iter() {
    for (const n of this._selected)
      this._assignToTmp(n), yield pc;
  }
  /**
   * @param {string} nodeId
   */
  markDirty(n) {
    this._selected.has(n) && (this._dirtyBounds = !0);
  }
  updateBounds() {
    this._dirtyBounds && (this._dirtyBounds = !1, this.bounds.setFrom(this.vs._getWorldBoundsOf(this._selected)));
  }
  /** @param {string} id */
  _assignToTmp(n) {
    pc.id = n, pc.element = this.vs.dataStore.getById(n), pc.node = this.vs.indexer.getNode(n);
  }
  watchDSSelection() {
    this.vs.dataStore.selection.on(Oe.SELECT, () => {
      this._selected.clear();
      for (const n of this.vs.dataStore.selection.get("elements"))
        this._selected.add(n.get("id"));
      this._dirtyBounds = !0;
    });
  }
  reset() {
    return this._selected = /* @__PURE__ */ new Set(), this.bounds.set(0, 0, 0, 0), this._dirtyBounds = !0, !0;
  }
}
let I1 = null;
class G0 {
  static instance() {
    return I1;
  }
  /**
   * @param {HTMLCanvasElement} canvas
   * @param {DataStore} dataStore
   */
  constructor(n, s) {
    this.canvas = n, this.dataStore = s, this.viewport = new KH(n), this.selection = new $6(this), this.snapping = new Hc(this), this.snappingPath = new nH(this), this.drawInfo = new Q6(this), this.drawInfo.inject(), this.storage = new J6(this), this.overlay = new Bk(this, this.viewport), this.indexer = new F6(this), this.root = null, this.updateList = /* @__PURE__ */ new Set(), this.nodeFlagsList = /* @__PURE__ */ new Map(), this._updateLevel = Is.NONE, this.itemMap = /* @__PURE__ */ Object.create(null), this.view = null, I1 = this, this.viewModeChangeHandler = this.handleViewModeChange.bind(this), this.dataStore.on("viewMode", this.viewModeChangeHandler);
  }
  /* RenderItem API */
  clear() {
    this.indexer.clear(), this.overlay.clearPanes(), this.storage.clear(), this.selection.reset(), this.viewport.reset();
    for (const n in this.itemMap)
      this.itemMap[n].clear();
    return this.itemMap = /* @__PURE__ */ Object.create(null), this.updateList = /* @__PURE__ */ new Set(), this.nodeFlagsList = /* @__PURE__ */ new Map(), this.root = null, this.view.cleanup(), this.viewModeChangeHandler && (this.dataStore.off("viewMode", this.viewModeChangeHandler), this.viewModeChangeHandler = null), !0;
  }
  /**
   * @param {ViewMode} viewMode
   */
  handleViewModeChange(n) {
    var s;
    switch (this.view.cleanup(), n) {
      case fd.TABLE: {
        const i = this.dataStore.selection.get("elements"), r = this.dataStore.workspace.watched, o = ((s = i == null ? void 0 : i[0]) == null ? void 0 : s.get("id")) || r.get("id"), a = this.dataStore.getById(o);
        this.view = new I0(this), this.setRoot(a.get("id")), this.view.setup(this.dataStore, o);
        break;
      }
      case fd.SINGLE:
      default: {
        const i = this.dataStore.workspace.watched;
        this.view = new PC(this), this.setRoot(i.get("id")), this.view.setup(this.dataStore, i.get("id"));
        break;
      }
    }
  }
  /**
   * @param {UpdateLevel} updateLevel
   */
  updateUpdateLevel(n) {
    n > this._updateLevel && (this._updateLevel = n);
  }
  currentVersion() {
  }
  /**
   * @param {string} id
   */
  setRoot(n) {
    const s = this.indexer.getNode(n);
    if (!s) {
      console.error("Cannot set root to null!");
      return;
    }
    this.root = s.item, this.indexer.root = s, xH(s);
  }
  /**
   * @param {string} id
   * @returns {RenderItem}
   */
  makeRenderItem(n) {
    const s = new Ag(n);
    return s.visualServer = this, this.itemMap[n] = s, s;
  }
  /**
   * @param {string} id
   */
  destroyRenderItem(n) {
    const s = this.itemMap[n];
    s && (s.clear(), s.freed = !0, delete this.itemMap[n]);
  }
  /**
   * @param {string} id
   * @returns {RenderItem}
   */
  getRenderItem(n) {
    return this.itemMap[n] || null;
  }
  /**
   * @param {Element} element
   * @returns {RenderItem}
   */
  getRenderItemOfElement(n) {
    return n ? this.getRenderItem(n.get("id")) : null;
  }
  /**
   * @param {string} id
   * @returns {boolean}
   */
  updateTransformRecursively(n) {
    const s = this.indexer.getNode(n);
    return s ? (this.indexer.updateTransformRecursively(s), this.selection.updateBounds(), !0) : !1;
  }
  /**
   * Iterates over world bounds of nodes specified by list of IDs
   * @param {Iterable<string>} ids
   */
  *_getWorldBoundsOf(n) {
    for (const s of n)
      yield this.indexer.getNode(s).boundsWorldAABB_zero;
  }
  /**
   * Update nodes based on updateList at the moment
   */
  updateNodes() {
    const n = [...this.updateList.values()];
    this.indexer.updateNodes(n), this.updateList.clear();
    for (const s of this.nodeFlagsList)
      if (this.indexer.nodeMap.has(s[0])) {
        const i = this.indexer.nodeMap.get(s[0]).item;
        i.updateFlags |= s[1], this.updateList.add(i);
      }
    this.nodeFlagsList.clear(), this.storage.update();
  }
}
let HN = 0, e0 = !1, Gn = null, UE = null;
const cd = nt();
let Je = null;
function e7() {
  Oi.pause();
}
async function t0() {
  Oi.updateRootDirty(!0), Oi.resume(), e0 = !0, window.dispatchEvent(new Event("resize")), cd.resumeApp();
}
const co = Object.freeze({
  [Ht.AUTO_WIDTH]: "auto_width",
  [Ht.AUTO_HEIGHT]: "auto_height",
  [Ht.FIXED]: "fixed"
});
Object.freeze({
  auto_width: Ht.AUTO_WIDTH,
  auto_height: Ht.AUTO_HEIGHT,
  fixed: Ht.FIXED
});
window.__ph__ = {
  // Dino might not be ready yet, so add a onInited callback
  onReady: () => {
    cd.initialized = !0, Je = new G0(UE, Gn), cd.setBackgroundColor(12 / 255, 12 / 255, 12 / 255, 1), b4(Je), H.watch(UE), T6(Je), n7(), Je.indexer.connectDataStore(Gn), Je.selection.watchDSSelection(), Gn.isLoaded ? t0() : Gn.once(Oe.LOAD, t0);
  },
  onFrameBegin: () => {
    UE.style.cursor = "inherit", t7(), HN++;
  },
  onUpdateSceneTree: () => {
    if (Oi.paused) return null;
    const e = s7();
    switch (zt.begin("node update"), Je.updateNodes(), Je._updateLevel) {
      case Is.UPDATE_NEED_BBOX_RECALC:
        Je.view.update();
        break;
      case Is.UPDATE_ALL_NEED_BBOX_RECALC:
        Je.view.updateAll(!0);
        break;
      case Is.UPDATE_ALL:
        Je.view.updateAll(!1);
        break;
      case Is.UPDATE:
      case Is.NONE:
        break;
    }
    Je._updateLevel = Is.NONE, zt.end("node update"), zt.begin("hit test"), LH(), zt.end("hit test"), Je.view.layout(), zt.begin("misc update"), Je.selection.updateBounds(), e && e();
  },
  /**
   * @param {DinoID} node_id
   * @param {number} flag
   */
  onNodeUpdate: (e, n) => {
    if (Je.view.hasParent(e)) {
      const s = Je.view.getParent(e);
      Je.indexer.getNode(s).item.update(n), Je.nodeFlagsList.set(s, n);
    } else
      console.log(`cannot get phase node by dino rid ${e}`);
  },
  onTextUpdate: (e, n, s, i, r, o) => {
    if (!Je.selection.single) {
      console.log("no selection during text update");
      return;
    }
    let c = "";
    if (n !== 0) {
      const l = new Uint8Array(uE().HEAPU8.buffer, e, n);
      c = new TextDecoder("utf-8").decode(l);
    }
    c === "\0" && (c = ""), Gn.selection.updateTextRange(i, r, o, { commit: !1 }), Gn.editor.setProps({
      content: c
    }, { commit: !1 }), s || Gn.debounceCommitUndo();
  },
  // * Mouse events already handled by IS at renderer/src/actions/index.js
  onExitTextEditingMode: () => {
  },
  onCopyText: (e, n) => {
    let s = "";
    if (n !== 0) {
      const i = new Uint8Array(uE().HEAPU8.buffer, e, n);
      s = new TextDecoder("utf-8").decode(i);
    }
    Gn.clipboard.copy(wk.TEXT, { text: s });
  },
  onPasteText: () => {
    Gn.clipboard.paste();
  },
  onUndoComb: () => {
    Gn.eam.undo();
  },
  onRedoComb: () => {
    Gn.eam.redo();
  },
  onSelectionUpdate: (e, n, s, i, r, o, a) => {
    const c = Je.view.getParent(e), h = Je.indexer.getNode(c).item.content, { start: d, end: p, cursor_idx: E } = i7(h, n, s, i, r, o, a);
    Gn.selection.updateTextRange(d, p, E, { commit: !1 }), Gn.debounceCommitUndo();
  },
  onUpdatePageOffset: (e) => {
    const n = Je.view.getParent(e), s = Je.indexer.getNode(n).boundsWorldAABB, i = Je.viewport.toScreenRect(s);
    nt().updatePageOffset(i.x, i.y);
  },
  // we call this function when we have font file is loaded and the text node needs to be updated its size
  onUpdateElementSize: (e, n, s) => {
    const i = Je.view.getParent(e), r = Je.dataStore.getById(i);
    bN(Je, r, n, s, { flags: or.FROM_TEXT_EDIT, commit: !1 });
  },
  onGetTextPathId: (e) => {
    const n = Je.view.getParent(e);
    return Je.view.getOrCreateDinoTree(n).path_id;
  },
  onESC: () => {
    Gn.eam.escape();
  },
  onTab: () => {
    Gn.eam.editSiblingTextElement(dt.UP);
  },
  onShiftTab: () => {
    Gn.eam.editSiblingTextElement(dt.DOWN);
  },
  onGetTotalCount: (e) => {
    const n = Je.view.getParent(e);
    return Je.indexer.getNode(n).item.content.length;
  },
  onIsPointInTextElement: (e, n, s) => {
    const i = Je.view.getParent(e);
    if (!i) return !1;
    const r = Je.indexer.getNode(i), o = r.boundsWorldAABB, a = r.item.transform.world.xform(new N(n, s));
    return o.contains(a.x, a.y);
  },
  onPrepareCamera: () => {
    if (!Oi.paused && e0) {
      Je.viewport.resize();
      const { x: e, y: n, scale: s } = Je.viewport;
      return cd.setCamera(-e, -n, s), N6(), Je.storage.update(), zt.end("misc update"), !0;
    } else
      return zt.end("misc update"), !1;
  },
  onOverlay: () => {
    if (Oi.paused || !e0) return null;
    if (Je.dataStore.isEditingMode && !Je.dataStore.isTableView) {
      const s = Je.indexer.getActiveScreenNode();
      CH(s), wH(), DH();
    }
    const e = Je.dataStore.get("state");
    (e === si.EDITING || e === si.VIEWING || e === si.INSPECTING || e === si.VERSIONING) && Y4();
  },
  onFrameEnd: () => {
  },
  onCapture: (e, n) => {
    l6(e, n);
  },
  onFontRequest: (e, n, s, i) => {
    const r = new Uint8Array(uE().HEAPU8.buffer, e, n), o = new TextDecoder("utf-8").decode(r), c = {
      0: "Regular",
      1: "Italic",
      2: "Oblique"
    }[s] || "Regular";
    let l = Je.dataStore.fontManager.getFontUrl(o, c, i);
    l || (console.warn(`cannot found the URL for ${o}-${s}-${i}`), l = Je.dataStore.fontManager.getFontUrl(o, "Regular", 400)), nt().fetchFont(o, l, c, i);
  },
  onZoom: (e) => {
    Gn.eam.changeZoom(e);
  },
  onZoomToFit: () => {
    Gn.eam.zoomFitContent();
  },
  onZoomToSelection: () => {
    Gn.eam.zoomFitSelection();
  },
  onZoomOut: () => {
    Gn.eam.zoomOut();
  },
  onZoomIn: () => {
    Gn.eam.zoomIn();
  }
};
function t7() {
  if (HN === 10) {
    const e = document.createElement("div");
    e.setAttribute("data-test-id", "rendererReady"), document.getElementById("modal").appendChild(e);
  }
}
function n7() {
  const { dataStore: e, viewport: n } = Je;
  e.on(Oe.LOAD_START, e7), e.on(Oe.LOAD, t0), e.eam.on(Y.SWITCH_DOCUMENT_MODE, () => {
    Je.view.reload(), e.isPrototypeMode && Oi.updateRootDirty(!0);
  }), e.workspace.on(Oe.WORKSPACE_CHANGE_WATCH, () => {
    Oi.updateRootDirty(!0);
  }), e.workspace.on("scale", (s) => {
    n.setZoom(s);
  }), n.on("update", () => {
    e.workspace.sets({
      scale: n.scale,
      panX: n.x,
      panY: n.y
    });
  });
}
function s7() {
  if (!Oi.dirty.root || !Je.dataStore.isLoaded) return;
  switch (Oi.updateRootDirty(!1), Oi.updateResizeDirty(!0), Je.dataStore.get("state")) {
    case si.EDITING:
    case si.VIEWING:
    case si.VERSIONING:
      return Je.viewport.resize(), () => nh(jo.ALL);
    case si.PROTOTYPING: {
      Je.viewport.resize();
      return;
    }
  }
}
function i7(e, n, s, i, r, o, a) {
  let c = 0, l = 0, h = null, d = null, p = null;
  for (let E = 0; E <= e.length && (p === null && l === a && (p = c + o), l === n && h === null && (h = c + s), l === i && d === null && (d = c + r), E < e.length && e[E] === `
` && l++, c++, !(h !== null && d !== null)); E++)
    ;
  return h === null || d === null ? (console.warn("Start or end index not found in the content."), null) : {
    start: h,
    end: d,
    cursor_idx: p
  };
}
const r7 = {
  FLOAT: (e, n, s) => n + (s - n) * e,
  ARRAY: (e, n, s) => n.map((i, r) => i + (s[r] - i) * e),
  VERTICES: (e, n, s) => n.map((i) => {
    const r = s.find((o) => o.id === i.id);
    return r ? {
      id: i.id,
      pos: [i.pos[0] + (r.pos[0] - i.pos[0]) * e, i.pos[1] + (r.pos[1] - i.pos[1]) * e]
    } : (console.warn(`Vertex ${i.id} not found in interpolate vertices`), i);
  }),
  MOTION_PATH: (e, n, s, i) => {
    const r = [n.pos[0], n.pos[1]], o = [s.pos[0], s.pos[1]], a = n.out.slice(0, 2), c = s.in.slice(0, 2), l = a.every((p) => !p) ? null : [r[0] + a[0], r[1] + a[1]], h = c.every((p) => !p) ? null : [o[0] + c[0], o[1] + c[1]];
    if (!l && !h) {
      const p = o[0] - r[0], E = o[1] - r[1], [g, T] = D1(e, r[0], r[1], o[0], o[1]);
      if (p || E) {
        const A = Math.atan2(E, p);
        return {
          pos: [g, T],
          in: [0, 0],
          out: [0, 0],
          orientRotation: A
        };
      }
      return {
        pos: [g, T],
        in: [0, 0],
        out: [0, 0],
        orientRotation: 0
      };
    } else {
      const p = [...r, ...a, ...c, ...o], E = new ae().initWithPointsAndHandlesN(
        p[0],
        p[1],
        p[2],
        p[3],
        p[4],
        p[5],
        p[6],
        p[7]
      ), g = E.getLength(), T = g * e;
      if (e < 0) {
        const A = E.getPointAtTime(0);
        if (!A)
          throw new Error("pos is null");
        const m = g * Math.abs(i[1]), O = E.getTangentAtTime(0);
        if (!O)
          throw new Error("tangent is null");
        const S = Math.atan2(O.y, O.x);
        return A.add(O.scale(m * e)), {
          pos: [A.x, A.y],
          in: [0, 0],
          out: [0, 0],
          orientRotation: S
        };
      } else if (e > 1) {
        const A = E.getPointAtTime(1);
        if (!A)
          throw new Error("pos is null");
        if (!i[3])
          throw new Error("easing[3] is undefined");
        const m = g * (i[3] - 1), O = E.getTangentAtTime(1);
        if (!O)
          throw new Error("tangent is null");
        const S = Math.atan2(O.y, O.x);
        return A.add(O.scale(m * (e - 1))), {
          pos: [A.x, A.y],
          in: [0, 0],
          out: [0, 0],
          orientRotation: S
        };
      } else {
        const A = E.getTimeAt(T);
        if (A === null)
          throw new Error("t is null");
        const m = E.getPointAtTime(A);
        if (!m)
          throw new Error("pos is null");
        const O = E.getTangentAtTime(A);
        if (!O)
          throw new Error("tangent is null");
        const S = Math.atan2(O.y, O.x);
        return {
          pos: [m.x, m.y],
          in: [0, 0],
          out: [0, 0],
          orientRotation: S
        };
      }
    }
  },
  CONTENT_ANCHOR: (e, n, s) => ({
    contentAnchorX: n.contentAnchorX + (s.contentAnchorX - n.contentAnchorX) * e,
    contentAnchorY: n.contentAnchorY + (s.contentAnchorY - n.contentAnchorY) * e
  }),
  PAINT: (e, n, s) => {
    const i = {
      type: n.type,
      color: [...n.color],
      gradient: {
        stops: [],
        transform: [...n.gradient.transform]
      },
      image: {
        id: n.image.id,
        mode: n.image.mode
      }
    };
    switch (n.type) {
      case Ie.SOLID: {
        i.color = [
          n.color[0] + (s.color[0] - n.color[0]) * e,
          n.color[1] + (s.color[1] - n.color[1]) * e,
          n.color[2] + (s.color[2] - n.color[2]) * e,
          n.color[3] + (s.color[3] - n.color[3]) * e
        ];
        break;
      }
      case Ie.GRADIENT_LINEAR:
      case Ie.GRADIENT_RADIAL:
      case Ie.GRADIENT_ANGULAR:
      case Ie.GRADIENT_DIAMOND: {
        const r = [...n.gradient.stops], o = [...s.gradient.stops], a = r.length, c = o.length;
        a > c ? S1(r, o) : c > a && S1(o, r);
        const l = r.length;
        for (let p = 0; p < l; p++)
          i.gradient.stops.push({
            position: r[p].position + (o[p].position - r[p].position) * e,
            color: [
              r[p].color[0] + (o[p].color[0] - r[p].color[0]) * e,
              r[p].color[1] + (o[p].color[1] - r[p].color[1]) * e,
              r[p].color[2] + (o[p].color[2] - r[p].color[2]) * e,
              r[p].color[3] + (o[p].color[3] - r[p].color[3]) * e
            ]
          }), i.gradient.stops[p].position = r[p].position + (o[p].position - r[p].position) * e;
        const h = n.gradient.transform.length ? [...n.gradient.transform] : [0, -1, 1, 0, 0, 1], d = [...s.gradient.transform];
        i.gradient.transform = [
          h[0] + (d[0] - h[0]) * e,
          h[1] + (d[1] - h[1]) * e,
          h[2] + (d[2] - h[2]) * e,
          h[3] + (d[3] - h[3]) * e,
          h[4] + (d[4] - h[4]) * e,
          h[5] + (d[5] - h[5]) * e
        ];
        break;
      }
      case Ie.IMAGE: {
        n.image.id ? i.image.id = n.image.id : i.image.id = s.image.id, n.image.mode ? i.image.mode = n.image.mode : i.image.mode = s.image.mode;
        break;
      }
    }
    return i;
  }
}, o7 = () => {
  const e = new W2();
  return Object.entries(r7).forEach(
    ([n, s]) => {
      const i = R1({
        name: n,
        interpolate: s
      });
      e.register(i);
    }
  ), e;
}, S1 = (e, n) => {
  const s = n.slice().sort((i, r) => i.position - r.position);
  for (let i = s.length; i < e.length; i++) {
    const r = e[i].position;
    let o = null;
    if (r <= s[0].position)
      o = s[0];
    else if (r >= s[s.length - 1].position)
      o = s[s.length - 1];
    else
      for (let a = 0; a < s.length - 1; a++) {
        const c = s[a], l = s[a + 1], h = r - c.position, d = l.position - r;
        if (h >= 0 && d > 0) {
          h <= d ? o = c : o = l;
          break;
        }
      }
    n[i] = o;
  }
}, a7 = o7();
class c7 extends z2 {
  constructor() {
    super(a7);
  }
}
window.AnimationComposer = c7;
